<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CnosDB</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="content/cnosdb/latest/about.html"><strong aria-hidden="true">1.</strong> 关于本项目</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/index.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/download.html"><strong aria-hidden="true">2.1.</strong> 下载</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/install.html"><strong aria-hidden="true">2.2.</strong> 安装</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/get-start.html"><strong aria-hidden="true">2.3.</strong> 入门指南 TODO</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/concept.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/concept/cnosql_vs_sql.html"><strong aria-hidden="true">3.1.</strong> CnosDB VS SQL</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/concept/design_insights.html"><strong aria-hidden="true">3.2.</strong> 设计原则</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/concept/storage_engine.html"><strong aria-hidden="true">3.3.</strong> 存储引擎</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/concept/tsi_design.html"><strong aria-hidden="true">3.4.</strong> TSI的设计</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/concept/file_system_layout.html"><strong aria-hidden="true">3.5.</strong> 文件系统布局</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/guide/index.html"><strong aria-hidden="true">4.</strong> 指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/guide/cnosdb-cli.html"><strong aria-hidden="true">4.1.</strong> cnosdb-cli</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/index.html"><strong aria-hidden="true">5.</strong> 运维管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/export_import.html"><strong aria-hidden="true">5.1.</strong> 导入和导出</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/backup_restore.html"><strong aria-hidden="true">5.2.</strong> 备份和还原</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/configuration.html"><strong aria-hidden="true">5.3.</strong> CnosDB配置</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/index.html"><strong aria-hidden="true">6.</strong> CnosDB工具</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/cnosdb.html"><strong aria-hidden="true">6.1.</strong> cnosdb</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-cli.html"><strong aria-hidden="true">6.2.</strong> cnosdb-cli</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html"><strong aria-hidden="true">6.3.</strong> cnosdb-inspect</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> CnosQL</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_sample.html"><strong aria-hidden="true">7.1.</strong> CnosQL入门 TODO</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_syntax.html"><strong aria-hidden="true">7.2.</strong> CnosQL语法 TODO</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_queries.html"><strong aria-hidden="true">7.3.</strong> CnosQL查询 TODO</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/management_database.html"><strong aria-hidden="true">7.4.</strong> 管理数据库</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_schema.html"><strong aria-hidden="true">7.5.</strong> Schema查询</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/continuous_queries.html"><strong aria-hidden="true">7.6.</strong> 连续查询</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_function.html"><strong aria-hidden="true">7.7.</strong> CnosQL函数</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/math_operators.html"><strong aria-hidden="true">7.8.</strong> CnosQL数学运算符</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_spect.html"><strong aria-hidden="true">7.9.</strong> CnosQL参考</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> 数据协议</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/line_protocol.html"><strong aria-hidden="true">8.1.</strong> CnosDB Line Protocol</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/write_api.html"><strong aria-hidden="true">8.2.</strong> CnosDB Write API</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/query_api.html"><strong aria-hidden="true">8.3.</strong> CnosDB Query API</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/prometheus.html"><strong aria-hidden="true">8.4.</strong> Prometheus</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/telegraf.html"><strong aria-hidden="true">8.5.</strong> Telegraf</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/sandboxmanagement.html"><strong aria-hidden="true">9.</strong> 集群管理</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/frequently_asked_questions.html"><strong aria-hidden="true">10.</strong> 常见问题</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CnosDB</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cnosdb"><a class="header" href="#cnosdb">CnosDB</a></h1>
<p>CnosDB是一个由社区驱动的开源时间序列数据库。</p>
<h2 id="产品特性"><a class="header" href="#产品特性">产品特性</a></h2>
<ul>
<li>全面与InfluxDB 1.X 稳定版兼容。</li>
<li>开源分布式集群，产品永久免费。</li>
<li>24*7全球开源社区支持。</li>
<li>实时时序数据库：可将您的离线监控平台，提升为一个实时决策系统</li>
<li>支持海量时间序列线：在海量标签、海量时间序列线的情况下，依然能够高效实现分布式迭代器及查询优化</li>
<li>低成本/碳中和：高效的存储引擎可充分发挥硬件性能，并在高效压缩存储的同时保障查询效率</li>
<li>强大完整的生态：可集成市面上主流的采集、存储、分析、可视化等工具</li>
</ul>
<h2 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h2>
<blockquote>
<p>CnosDB是一个专注于时序数据场景的时序型数据库，适用于各种时序场景，如服务器指标、应用程序指标、性能指标、函数接口调用指标、网络流量数据、探测器数据、日志、市场交易记录等。</p>
</blockquote>
<h3 id="devops监控"><a class="header" href="#devops监控">DevOps监控</a></h3>
<p>通过监控基础设施（服务器、容器、数据库、微服务、云服务等）的核心指标来及时发现问题并在影响关键业务之前解决问题，尽管一些新兴技术提升了基础设施的DevOps监控的复杂性，但CnosDB都能很好的适应。CnosDB通过灵活的插件的形式，采集指标或者从第三方服务（如StatsD或Kafka）拉取数据，并通过自定义配置按需上报给外部存储系统。</p>
<h3 id="iot监控"><a class="header" href="#iot监控">IoT监控</a></h3>
<p>主要用于接收和处理来自IoT设备的海量数据，并进行实时分析，在无人工干预的情况下，执行预定义操作，IoT设备无处不在，公路摄像头，智能网联车、手机、冰箱都有它的身影，不过IoT设备的硬件性能和缓存能力有限，数据往往是以流式方式实时上报，所以需要一个弹性、扩展性强的高性能时序后台来应对突发流量的挑战。CnosDB的水平扩展、实时分析等能力，是专门针对这类场景来设计的，具有足够的读写性能和容量弹性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="下载"><a class="header" href="#下载">下载</a></h2>
<ul>
<li>
<h3 id="ubuntu--debian"><a class="header" href="#ubuntu--debian">Ubuntu &amp; Debian</a></h3>
<blockquote>
<p>MD5: 3aa8049d784487f6aeeab21a4e8f7c1c</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb_0.10.3_amd64.deb
sudo dpkg -i cnosdb_0.10.3_amd64.deb
</code></pre>
</li>
<li>
<h3 id="docker-image"><a class="header" href="#docker-image">Docker Image</a></h3>
<pre><code class="language-shell">docker pull cnosdb:0.10.3
</code></pre>
</li>
<li>
<h3 id="redhat--centos"><a class="header" href="#redhat--centos">RedHat &amp; CentOS</a></h3>
<blockquote>
<p>MD5: 0d3c00abdb34764dcbd79eee33ea1c0f</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3.x86_64.rpm
sudo yum localinstall cnosdb-0.10.3.x86_64.rpm
</code></pre>
</li>
<li>
<h3 id="macos"><a class="header" href="#macos">macOS</a></h3>
<blockquote>
<p>MD5: 7711a3167255ee015f1f62f53d0e38cd</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_darwin_amd64.tar.gz
tar zxvf cnosdb-0.10.3_darwin_amd64.tar.gz
</code></pre>
</li>
<li>
<h3 id="windows-binaries64-bit---using-powershell"><a class="header" href="#windows-binaries64-bit---using-powershell">Windows Binaries(64-bit) - using PowerShell</a></h3>
<blockquote>
<p>MD5: 62ea309b3edd8fe9c4b98d10f9bc7dcf</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_windows_amd64.zip -UseBasicParsing -OutFile cnosdb-0.10.3_windows_amd64.zip
Expand-Archive .\cnosdb-0.10.3_windows_amd64.zip -DestinationPath 'C:\Program Files\CnosDB\cnosdb\'
</code></pre>
</li>
<li>
<h3 id="linux-binaries64-bit"><a class="header" href="#linux-binaries64-bit">Linux Binaries(64-bit)</a></h3>
<blockquote>
<p>MD5: 64c763c917030134971d21e54c21a59d</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_amd64.tar.gz
tar xvfz cnosdb-0.10.3_linux_amd64.tar.gz
</code></pre>
</li>
<li>
<h3 id="linux-binaries64-bit-static"><a class="header" href="#linux-binaries64-bit-static">Linux Binaries(64-bit, static)</a></h3>
<blockquote>
<p>MD5: eebb5665fcc4f540de488567caec187d</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3-static_linux_amd64.tar.gz
tar xvfz cnosdb-0.10.3-static_linux_amd64.tar.gz
</code></pre>
</li>
<li>
<h3 id="linux-binaries32-bit"><a class="header" href="#linux-binaries32-bit">Linux Binaries(32-bit)</a></h3>
<p>MD5: 3ed72382eb79d664baeac3b71d744b4b</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_i386.tar.gz
tar xvfz cnosdb-0.10.3_linux_i386.tar.gz
</code></pre>
</li>
<li>
<h3 id="linux-binariesarmv7"><a class="header" href="#linux-binariesarmv7">Linux Binaries(ARMv7)</a></h3>
<p>MD5: 90b2b8c72404e1835988325b3ea05f3d</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_armhf.tar.gz
tar xvfz cnosdb-0.10.3_linux_armhf.tar.gz
</code></pre>
</li>
<li>
<h3 id="linux-binariesarmv8"><a class="header" href="#linux-binariesarmv8">Linux Binaries(ARMv8)</a></h3>
<p>MD5: 631ef2e05b2d0f5a310422d1871bb003</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_arm64.tar.gz
tar xvfz cnosdb-0.10.3_linux_arm64.tar.gz
</code></pre>
</li>
<li>
<h3 id="验证下载二进制文件的真实性可选"><a class="header" href="#验证下载二进制文件的真实性可选">验证下载二进制文件的真实性（可选）</a></h3>
<p>为了验证安全性，请按照以下步骤验证您下载的CnosDB的<code>gpg</code>签名（大多数系统默认包含<code>gpg</code>命令，如果<code>gpg</code>不可用，请参阅<a href="https://gnupg.org/download">Gun主页</a>获取安装说明。</p>
<ol>
<li>下载并导入CnosDB公钥</li>
</ol>
<pre><code>curl -s https://www.cnosdb.com/cnosdb.key | gpg --import
</code></pre>
<ol start="2">
<li>通过在URL上添加<code>.asc</code>来下载指定版本的签名文件</li>
</ol>
<pre><code class="language-shell"> wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_amd64.tar.gz
</code></pre>
<ol start="3">
<li>验证签名 <code>gpg --verify</code></li>
</ol>
<pre><code class="language-shell"> gpg --verify cnosdb-0.10.3_linux_amd64.tar.gz.asc cnosdb-0.10.3_linux_amd64.tar.gz
</code></pre>
<p>此命令应该输出：</p>
<pre><code class="language-shell">gpg: Good signature from &quot;CnosDB &lt;contact@cnosdb.com&gt;&quot; [unknown]
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<ol>
<li>
<p>拉取镜像</p>
<pre><code class="language-shell">docker pull cnosdb/cnosdb:latest
</code></pre>
</li>
<li>
<p>启动容器</p>
<pre><code class="language-shell">docker run -itd -p 8086:8086 cnosdb/cnosdb:latest
</code></pre>
</li>
</ol>
<h2 id="ubuntu--debian-1"><a class="header" href="#ubuntu--debian-1">Ubuntu &amp; Debian</a></h2>
<ol>
<li>
<p>下载</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb_0.10.3_amd64.deb
sudo dpkg -i cnosdb_0.10.3_amd64.deb
</code></pre>
</li>
<li>
<p>启动</p>
<pre><code class="language-shell">sudo systemctl start cnosdb
</code></pre>
</li>
</ol>
<h2 id="red-hat--centos"><a class="header" href="#red-hat--centos">Red Hat &amp; CentOS</a></h2>
<ol>
<li>下载
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3.x86_64.rpm
sudo yum localinstall cnosdb-0.10.3.x86_64.rpm
</code></pre>
</li>
<li>启动
<pre><code class="language-shell">sudo systemctl start cnosdb
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="入门指南-这个重新来"><a class="header" href="#入门指南-这个重新来">入门指南: 这个重新来</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念"><a class="header" href="#概念">概念</a></h1>
<h2 id="cnosdb-vs-sql"><a class="header" href="#cnosdb-vs-sql">CnosDB VS SQL</a></h2>
<ul>
<li>
<h3 id="概念-1"><a class="header" href="#概念-1">概念</a></h3>
<p>CnosDB类似于SQL数据库，但在许多方面有所不同。CnosDB是专门为时间序列数据构建的。关系数据库可以处理时间序列数据，但对常见的时间序列工作负载没有进行优化。CnosDB旨在存储大量时间序列数据，并快速对这些数据执行实时分析。</p>
<p>在CnosDB中，时间戳标识任何给定数据系列中的单个点。这就像一个SQL数据库表，其中的主键是由系统预先设置的，并且总是时间。</p>
<p>CnosDB还认识到，您的模式首选项可能会随着时间而改变。在CnosDB中，您不必预先定义模式。数据点可以具有measurements上的一个字段、measurements上的所有字段或中间的任何数字。只需为新字段编写一个点，就可以向measurements添加新字段。如果您需要了解相关术语，如measurement、tag和field等，请阅读本节内容，了解SQL数据库到CnosDB术语交叉。</p>
</li>
<li>
<h3 id="术语"><a class="header" href="#术语">术语</a></h3>
<p>下面的表是一个(非常)简单的例子，它是一个SQL数据库中名为<code>wind_speed</code>的表，其中没有索引的列是<code>#wind_speed</code>，索引的列是<code>station_id</code>、<code>station</code>和<code>time</code>。</p>
<pre><code>+------------+---------------+---------------------+--------------+
| station_id |   station     |       time          |  #wind_speed |
+------------+---------------+---------------------+--------------+
|       1    | LianYunGang   | 1429185600000000000 |       63     |
|       1    | LianYunGang   | 1429185601000000000 |       74     |
|       1    | LianYunGang   | 1429185602000000000 |       51     |
|       1    | LianYunGang   | 1429185603000000000 |       15     |
|       2    | XiaoMaiDao    | 1429185600000000000 |       104    |
|       2    | XiaoMaiDao    | 1429185601000000000 |       20     |
|       2    | XiaoMaiDao    | 1429185602000000000 |       21     |
|       2    | XiaoMaiDao    | 1429185603000000000 |       34     |
+------------+---------------+---------------------+--------------+
</code></pre>
<p>同样的数据在 CnosDB 中看起来是这样的：</p>
<pre><code>name: wind_speed
tags: station_id=1, station=LianYunGang
time			               #wind_speed
----			               ------------
2015-04-16T12:00:00Z	 63
2015-04-16T12:00:01Z	 74
2015-04-16T12:00:02Z	 51
2015-04-16T12:00:03Z	 15

name: wind_speed
tags: station_id=2, station=XiaoMaiDao
time			               #wind_speed
----			               ------------
2015-04-16T12:00:00Z	 104
2015-04-16T12:00:01Z	 20
2015-04-16T12:00:02Z	 21
2015-04-16T12:00:03Z	 34
</code></pre>
<ul>
<li>时间序列数据在聚合场景中最有用</li>
<li>CnosDB 中的<code>measurement</code>类似于SQL数据库<code>table</code>。</li>
<li>CnosDB 中的<code>tags</code>类似于SQL数据库中的有索引的列。</li>
<li>CnosDB 中的<code>fields</code>就像SQL数据库中没有索引的列。</li>
<li>CnosDB 中的<code>points</code>类似于SQL行。</li>
<li>CnosDB 中不需要预定义<code>schema</code></li>
</ul>
<p>基于对数据库术语的这种比较，CnosDB连续查询和保留策略类似于SQL数据库中的存储过程。它们只指定一次，然后定期自动执行。</p>
<p>当然，SQL数据库和CnosDB之间存在一些主要差异。SQL join不能用于CnosDB的<code>measurements</code>; 您的模式设计应该反映这种差异。而且，正如我们上面提到的，<code>measurements</code>就像一个SQL表，其中的主索引总是预先设置为time。CnosDB时间戳必须在U<code>NIX epoch (GMT)</code>或格式化为<code>RFC3339</code>下有效的日期-时间字符串。</p>
</li>
<li>
<h3 id="cnosql"><a class="header" href="#cnosql">CnosQL</a></h3>
<p>CnosDB支持的查询语言主要是CnosQL。</p>
<p>CnosQL是一种类似sql的查询语言，用于与CnosDB交互。它经过精心设计，使之与其他SQL或类似SQL的环境中的SQL相似，同时还提供了特定于存储和分析时间序列数据的特性。然而，CnosQL不是SQL，缺乏对SQL高级用户习惯的更高级操作，如UNION、JOIN和HAVING的支持。</p>
<p>CnosQL的SELECT语句遵循SQL SELECT语句的形式:</p>
<p><code>SELECT &lt;stuff&gt; FROM &lt;measurement_name&gt; WHERE &lt;some_conditions&gt;</code></p>
<p><code>WHERE</code>是可选的</p>
<p>要获得上面部分的CnosDB输出，您需要输入:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot;</code></p>
<p>如果你只想看到LianYunGang的数据，你可以输入:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot; WHERE &quot;station&quot; = 'LianYunGang'</code></p>
<p>如果你想查看2015年4月16日12:00:01 UTC之后LianYunGang的数据，你可以输入:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt; '2015-04-16 12:00:01'</code></p>
<p>如上例所示，CnosQL允许您在<code>WHERE</code>语句中指定查询的时间范围。可以使用单引号括起来的日期-时间字符串，格式为Y<code>YYY-MM-DD HH:MM:SS。MMM </code>(<code>MMM</code>是可选的毫秒数，您还可以指定微秒或纳秒)。你也可以在<code>now()</code>中使用相对时间，它指的是服务器的当前时间戳:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot; WHERE time &gt; now() - 1h</code></p>
<p>该查询输出wind_speed的measurements中的数据，其中时间戳比服务器当前时间早1小时。使用now()指定持续时间的选项有:ns(纳秒)、u或µ(微秒)、ms(毫秒)、s(秒)、m(分钟)、h(小时)、d(天)和w(周)。</p>
</li>
<li>
<h3 id="cnosdb-并非-crud"><a class="header" href="#cnosdb-并非-crud">CnosDB 并非 CRUD</a></h3>
<p>CnosDB是一个针对时间序列数据进行了优化的数据库。这些数据通常来自分布式传感器组、大型网站的点击数据或金融交易列表。</p>
<p>这些数据的一个共同之处是，它们在总体上更有用。有一篇文章说，你的电脑在UTC时间周二12:38:35的时候CPU利用率为12%，这很难从中得出结论。当与本序列的其他部分结合使用时，它将变得更加有用。这是随着时间的推移趋势开始显现的地方，可以从数据中得出可操作的见解。此外，时间序列数据通常只写入一次，很少更新。</p>
<p>其结果是，CnosDB不是一个完整的CRUD数据库，而是更像一个CR-ud，优先考虑创建和读取数据的性能，而不是更新和销毁，并防止一些更新和销毁行为，以使创建和读取性能更高:</p>
<ul>
<li>要更新一个点，请插入一个具有相同measurements、tag set和timestamp的点。</li>
<li>您可以删除或删除序列，但不能基于字段值删除单个点。作为一种解决方案，您可以搜索字段值，检索时间，然后基于时间字段进行DELETE操作。</li>
<li>您还不能更新或重命名tags。要修改一系列点的tags，请找到有问题标记值的点，将值更改为所需的值，将这些点写回，然后删除带有旧tag values的序列。</li>
<li>你不能通过tag keys来删除tags。</li>
</ul>
</li>
</ul>
<h2 id="设计原则"><a class="header" href="#设计原则">设计原则</a></h2>
<p>CnosDB应用时间序列数据的优化设计原则。其中一些设计原则可能与性能方面的权衡有关。主要设计原则包括：</p>
<ul>
<li>
<p>以时间为顺序的数据</p>
</li>
<li>
<p>严格的更新和删除权限</p>
</li>
<li>
<p>先处理读写查询</p>
</li>
<li>
<p>无模式设计</p>
</li>
<li>
<p>单个点上的数据集</p>
</li>
<li>
<p>重复数据</p>
</li>
<li>
<h3 id="以时间为顺序的数据"><a class="header" href="#以时间为顺序的数据">以时间为顺序的数据</a></h3>
<p>为了提高性能，数据按时间升序写入。</p>
</li>
<li>
<h3 id="严格的更新和删除权限"><a class="header" href="#严格的更新和删除权限">严格的更新和删除权限</a></h3>
<p>为了提高查询和写性能，CnosDB严格限制更新和删除权限。时间序列数据主要是从未更新的新数据。删除通常只会影响未写入的数据，不会发生有争议的更新。</p>
</li>
<li>
<h3 id="先处理读写查询"><a class="header" href="#先处理读写查询">先处理读写查询</a></h3>
<p>CnosDB优先考虑读和写请求，而不是强一致性。CnosDB在执行查询时返回结果。所有影响查询数据的事务随后都会被处理，以确保数据最终是一致的。因此，如果摄取速率很高(每毫秒多个写操作)，查询结果可能不包括最近的数据。</p>
</li>
<li>
<h3 id="无模式设计"><a class="header" href="#无模式设计">无模式设计</a></h3>
<p>CnosDB使用无模式设计来更好地管理不连续数据。时间序列数据通常是短暂的，这意味着数据出现几个小时，然后就消失了。</p>
</li>
<li>
<h3 id="单个点上的数据集"><a class="header" href="#单个点上的数据集">单个点上的数据集</a></h3>
<p>由于数据集比单个点更重要，因此CnosDB实现了强大的工具来聚合数据和处理大型数据集。点通过时间戳和序列来区分，所以没有传统意义上的ID。</p>
</li>
<li>
<h3 id="重复数据"><a class="header" href="#重复数据">重复数据</a></h3>
<p>为了简化冲突解决和提高写性能，CnosDB假设发送多次的数据是重复数据。相同的点不会存储两次。如果为某个点提交了新的字段值，则CnosDB使用最新的字段值更新该点。在极少数情况下，数据可能会被覆盖。</p>
</li>
</ul>
<h2 id="设计架构和tsm"><a class="header" href="#设计架构和tsm">设计架构和TSM</a></h2>
<ul>
<li>
<h3 id="设计架构"><a class="header" href="#设计架构">设计架构</a></h3>
<p>每个CnosDB用例都是唯一的，您的模式反映了这种唯一性。通常，为查询而设计的模式可以实现更简单、更高效的查询。对于大多数用例，我们推荐以下设计架构:</p>
<ul>
<li>在何处存储数据(标签或字段)</li>
<li>避免过多的series</li>
<li>使用推荐的命名约定</li>
<li>分片时长管理</li>
</ul>
</li>
<li>
<h4 id="在何处存储数据标签或字段"><a class="header" href="#在何处存储数据标签或字段">在何处存储数据(标签或字段)</a></h4>
<ul>
<li>将常用查询和分组元数据存储在标签中。</li>
<li>如果每个数据点包含不同的值，则将数据存储在字段中。</li>
<li>将数字值存储为fields(tag values只支持字符串值)。</li>
</ul>
</li>
<li>
<h4 id="避免过多的series"><a class="header" href="#避免过多的series">避免过多的series</a></h4>
<p>按tags查询比按fields查询性能更好。但是，当创建过多的索引时，写和读都可能开始变慢。</p>
<p>每一组索引数据元素形成一个series key。包含高度可变信息(如唯一id、哈希值和随机字符串)的标记将导致大量的series，也称为高series基数。对于许多数据库工作负载来说，高series基数是高内存使用量的主要驱动因素。因此，为了减少内存消耗，可以考虑将高基数值存储在field values中，而不是存储在tag keys或field keys中。</p>
</li>
<li>
<h4 id="使用推荐的命名约定"><a class="header" href="#使用推荐的命名约定">使用推荐的命名约定</a></h4>
<ul>
<li>避免在tag和field keys中保留关键字</li>
<li>如果每个数据点包含不同的值，则将数据存储在field中。</li>
<li>将数字值存储为fields(tag values只支持字符串值)。</li>
</ul>
</li>
<li>
<h3 id="tsm-树"><a class="header" href="#tsm-树">TSM 树</a></h3>
<p>时间结构合并树(TSM)引擎解决了获得最大吞吐量、压缩和原始时间序列数据查询速度的问题。在TSI之前，倒排索引是一种内存中的数据结构，是在基于TSM中的数据启动数据库时构建的。这意味着对于每个度量、标记键值对和字段名，内存中都有一个查询表来将这些元数据位映射到底层的时间序列。对于具有大量临时序列的用户，内存利用率随着新的时间序列的创建而不断增加。而且，启动时间增加了，因为所有的数据都必须在启动时加载到堆上。</p>
</li>
<li>
<h3 id="tsm-相关概念"><a class="header" href="#tsm-相关概念">TSM 相关概念</a></h3>
<p>CnosDB存储引擎看起来非常类似于LSM树。它有一个预写日志和一组只读数据文件，这些文件在概念上类似于LSM树中的sstable。TSM文件包含排序、压缩的系列数据。</p>
<p>CnosDB将为每个时间块创建一个分片（即shard）。例如，如果您有一个无限持续时间的保留策略，那么将为每7天的时间块创建分片。每个分片都映射到底层存储引擎数据库。每个数据库都有自己的WAL和TSM文件。</p>
</li>
<li>
<h3 id="存储引擎"><a class="header" href="#存储引擎">存储引擎</a></h3>
<p>存储引擎将多个组件捆绑在一起，提供存储和查询系列数据的外部接口。它由多个组件组成，每个组件都扮演一个特定的角色:</p>
<ul>
<li>
<p><code>内存索引</code>- 内存索引是跨分片的共享索引，提供对<code>measurement</code>、<code>tags</code>和<code>series</code>的快速访问。索引由引擎使用，但并不特定于存储引擎本身。</p>
</li>
<li>
<p><code>WAL</code> - <code>WAL</code>是一种写入优化的存储格式，它允许写入是持久的，但不容易查询。对<code>WAL</code>的写入附加到固定大小的段。</p>
</li>
<li>
<p><code>缓存</code> - 缓存是存储在<code>WAL</code>中的数据的内存表示。它在运行时被查询并与存储在<code>TSM</code>文件中的数据合并。</p>
</li>
<li>
<p><code>TSM 文件</code> - <code>TSM</code>文件以列格式存储压缩的系列数据。</p>
</li>
<li>
<p><code>FileStore</code>- <code>FileStore</code>调解对磁盘上所有<code>TSM</code>文件的访问。它确保在替换现有文件以及删除不再使用的<code>TSM</code>文件时自动安装<code>TSM</code>文件。</p>
</li>
<li>
<p><code>Compactor</code> - <code>Compactor</code>负责将优化程度较低的<code>Cache</code>和<code>TSM</code>数据转换为读取优化程度更高的格式。它通过压缩系列、删除已删除的数据、优化索引以及将较小的文件组合成较大的文件来实现这一点。</p>
</li>
<li>
<p><code>Compaction Planner</code> - <code>Compaction Planner</code>确定哪些<code>TSM</code>文件已准备好进行压缩，并确保多个并发压缩不会相互干扰。</p>
</li>
<li>
<p><code>Compression</code>- <code>Compression</code>由各种编码器和解码器处理特定数据类型。一些编码器是相当静态的，并且总是以相同的方式编码相同的类型；其他人根据数据的形状切换压缩策略。</p>
</li>
<li>
<p><code>Writers/Readers</code> - 每种文件类型（<code>WAL</code>段、<code>TSM</code>文件、<code>tombstones</code>等）都有用于处理格式的<code>Writers</code>和<code>Readers</code>。</p>
</li>
</ul>
</li>
<li>
<h3 id="预写日志-wal"><a class="header" href="#预写日志-wal">预写日志 WAL</a></h3>
<p>WAL被组织成一组类似于<code>_000001.wal</code>的文件。文件编号是单调递增的，称为WAL段。当一个段的大小达到10MB时，它被关闭并打开一个新的段。每个WAL段存储多个压缩的写和删除块。</p>
<p>当写入时，新的点被序列化，使用Snappy压缩，并写入WAL文件。在成功返回之前，文件被fsync并将数据添加到内存索引中。这意味着需要将点批处理在一起以实现高吞吐量性能。(对于许多用例来说，最佳批量大小似乎是每批5000 - 10000个点。)</p>
<p>WAL中的每个表项都遵循<code>TLV标准</code>，一个字节代表表项的类型(写或删除)，一个4字节的<code>uint32</code>压缩块的长度，然后是压缩块。</p>
</li>
<li>
<h3 id="缓存"><a class="header" href="#缓存">缓存</a></h3>
<p>缓存是当前存储在WAL中的所有数据点的内存副本。这些点由key组织，key是measurement、tag set和field。每个field保存为自己的时间顺序范围。缓存数据在内存中没有被压缩。</p>
<p>对存储引擎的查询将把来自缓存的数据与来自TSM文件的数据合并。在查询处理时，对从缓存中获取的数据的副本执行查询。这样，在查询运行时输入的写操作不会影响结果。</p>
<p>发送到缓存的删除操作将清除给定key或给定key的特定时间范围。</p>
<p>缓存为快照行为提供了一些控制。最重要的控制是内存限制。有一个下界，即<code>cache-snapshot-memory-size</code>，超过这个下界将触发对TSM文件的快照，并删除相应的WAL段。还有一个上限，<code>cache-max-memory-size</code>，超过这个上限会导致缓存拒绝新的写操作。这些配置对于防止内存不足的情况以及对客户机施加反压力非常有用，因为写入数据的速度比实例持久化数据的速度要快。每次写操作时都会检查内存阈值。</p>
<p>其他快照控制是基于时间的。空闲阈值<code>cache -snapshot-write-cold-duration</code>在制定时间间隔内没有收到写请求时，强制缓存快照TSM文件。</p>
<p>通过重新读取磁盘上的WAL文件，在重新启动时重新创建内存缓存。</p>
</li>
<li>
<h3 id="tsm-文件"><a class="header" href="#tsm-文件">TSM 文件</a></h3>
<p>TSM文件是内存映射的只读文件的集合。这些文件的结构看起来非常类似于LevelDB或其他LSM树变体中的SSTable。</p>
<p>TSM文件由四部分组成：header, blocks, index, footer.</p>
<h4 id="header"><a class="header" href="#header">Header</a></h4>
<pre><code>+--------+------------------------------------+-------------+--------------+
| Header |               Blocks               |    Index    |    Footer    |
|5 bytes |              N bytes               |   N bytes   |   4 bytes    |
+--------+------------------------------------+-------------+--------------+
</code></pre>
<p><code>Header</code>用于标识文件类型和版本号。</p>
<pre><code>  +-------------------+
  |      Header       |
  +-------------------+
  |  Magic  │ Version |
  | 4 bytes │ 1 byte  |
  +-------------------+
</code></pre>
<h4 id="blocks"><a class="header" href="#blocks">Blocks</a></h4>
<p><code>Blocks</code> 是成对的 CRC32 校验和和数据的序列。block数据对文件是不透明的。CRC32 用于block级错误检测。block的长度存储在索引中。</p>
<pre><code>  +--------------------------------------------------------------------+
  │                           Blocks                                   │
  +---------------------+-----------------------+----------------------+
  |       Block 1       |        Block 2        |       Block N        |
  +---------------------+-----------------------+----------------------+
  |   CRC    |  Data    |    CRC    |   Data    |   CRC    |   Data    |
  | 4 bytes  | N bytes  |  4 bytes  | N bytes   | 4 bytes  |  N bytes  |
  +---------------------+-----------------------+----------------------+
</code></pre>
<h4 id="index"><a class="header" href="#index">Index</a></h4>
<p>block之后是文件中block的Index。Index由一系列Index条目组成，这些条目按字典顺序按key排序，然后按时间排序。key包括measurement name、tag set和one field。每个点的多个字段在 TSM 文件中创建多个Index条目。每个Index条目以key长度和key开头，然后是block类型（float、int、bool、string）和key后面的block Index条目数。每个block Index条目由block的最小和最大时间、block所在文件的偏移量和block的大小组成。TSM 文件中包含密钥的每个block都有一个block Index条目。</p>
<p>Index结构可以提供对所有block的有效访问以及确定与访问给定key相关的成本的能力。给定一个key和timestamp，我们可以确定一个文件是否包含该时间戳的块。我们还可以确定该block所在的位置以及必须读取多少数据才能检索该block。知道block的大小，我们可以有效地配置我们的 IO 语句。</p>
<pre><code>  +-----------------------------------------------------------------------------+
  │                                   Index                                     │
  +-----------------------------------------------------------------------------+
  │ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │....│
  │ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │    │
  +-----------------------------------------------------------------------------+
</code></pre>
<h4 id="footer"><a class="header" href="#footer">Footer</a></h4>
<p>最后一部分是存储索引开始的偏移量的页脚。</p>
<pre><code>  +---------+
  │ Footer  │
  +---------+
  │Index Ofs│
  │ 8 bytes │
  +---------+
</code></pre>
</li>
<li>
<h3 id="压缩"><a class="header" href="#压缩">压缩</a></h3>
<p>压缩是将以写优化格式存储的数据迁移到读优化格式的循环过程。当写一个shard时，有几个压缩阶段:</p>
<p>1.快照 —— 必须将Cache和WAL中的值转换为TSM文件，以释放WAL段所使用的内存和磁盘空间。这些压缩是基于缓存内存和时间阈值进行的。</p>
<p>2.级别压缩 —— 级别压缩(级别1-4)发生在TSM文件生成时。TSM文件从快照文件压缩到一级文件。多个1级文件被压缩以生成2级文件。这个过程继续进行，直到文件达到TSM文件的最大大小4级(完全压缩)。除非需要运行删除、索引优化压缩或完全压缩，否则不会进一步压缩它们。较低级别的压缩使用的策略避免了cpu密集型活动，如解压缩和组合块。更高级别(因此更少频率)的压缩将重新组合块，以完全压缩它们，并增加压缩比。</p>
<p>3.索引优化 —— 当许多4级TSM文件累积时，内部索引将变得更大，访问成本也更高。索引优化压缩在一组新的TSM文件中分割序列和索引，将给定序列的所有点排序到一个TSM文件中。在进行索引优化之前，每个TSM文件包含大多数或所有系列的点，因此每个文件包含相同的系列索引。在索引优化之后，每个TSM文件包含来自最小序列的点，并且文件之间的序列重叠很少。因此，每个TSM文件都有一个较小的惟一系列索引，而不是完整系列列表的副本。此外，来自特定系列的所有点在TSM文件中是连续的，而不是分布在多个TSM文件中。</p>
<p>4.完全压缩(4级压缩) —— 当碎片长时间处于冷状态，或者碎片上发生删除时，就会发生完全压缩。完全压缩生成一组最优的TSM文件，并包括来自级别和索引优化压缩的所有优化。一旦碎片被完全压缩，除非存储了新的写或删除操作，否则不会在其上运行其他压缩操作。</p>
<p>每个块都被压缩，以减少查询时的存储空间和磁盘IO。一个块包含给定序列和字段的时间戳和值。每个块有一个字节头，后面是压缩时间戳和压缩值。</p>
<pre><code>  +--------------------------------------------------+
  | Type  |  Len  |   Timestamps    |      Values    |
  |1 Byte | VByte |     N Bytes     |    N Bytes     │
  +--------------------------------------------------+
</code></pre>
<p>根据数据类型及其形状，使用编码对时间戳和值进行压缩和单独存储。独立存储它们允许对所有时间戳使用时间戳编码，同时允许对不同的字段类型使用不同的编码。例如，有些点可以使用游程编码，而其他点则不能。</p>
<p>每个值类型还包含一个1字节的头，指示剩余字节的压缩类型。四个高位存储压缩类型，四个低位在需要时由编码器使用。</p>
<h4 id="时间戳"><a class="header" href="#时间戳">时间戳</a></h4>
<p>时间戳编码是自适应的，并基于所编码的时间戳的结构。它结合使用增量编码、缩放和使用simple8b游程编码的压缩，并在需要时退回到无压缩。</p>
<p>时间戳的分辨率是可变的，但可以是纳秒级的粒度，需要8个字节来存储未压缩的数据。在编码期间，值首先进行增量编码。第一个值是起始时间戳，随后的值是与前一个值的差值。这通常将值转换成更小的整数，更容易压缩。许多时间戳也是单调增加的，并落在时间的偶数边界上，例如每10秒。当时间戳具有这种结构时，它们的最大公约数也是10的倍数。这可以将非常大的整数delta转换为更小的整数delta，从而更好地压缩。</p>
<p>使用这些调整后的值，如果所有增量相同，则使用游程编码存储时间范围。如果不能进行游程编码，并且所有值都小于(1«60)- 1(在纳秒分辨率下~36.5年)，则使用simple8b编码对时间戳进行编码。Simple8b编码是一种64位字对齐整数编码，它将多个整数打包成一个64位字。如果任何值超过了最大值，增量将不压缩地存储，每个块使用8个字节。未来的编码可能使用补丁方案，如PFOR，以更有效地处理异常值。</p>
<h4 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h4>
<p>浮点是使用<code>Facebook Gorilla paper</code>的实现进行编码的。将XORS连续的值编码在一起，当这些值很接近时产生一个小结果。然后使用控制位存储增量，以指示异或值中有多少前导和尾零。我们的实现删除了论文中描述的时间戳编码，只对浮点值进行编码。</p>
<h4 id="整数"><a class="header" href="#整数">整数</a></h4>
<p>整数编码根据未压缩数据中的值范围使用两种不同的策略。编码后的值首先使用ZigZag编码。它使正整数和负整数在一个正整数范围内交叉。</p>
<p>如果所有ZigZag编码的值都小于(1«60)- 1，则使用simple8b编码对它们进行压缩。如果任何值大于最大值，那么所有的值都被不压缩地存储在块中。如果所有值都相同，则使用游程编码。对于经常是常量的值，这种方法非常有效。</p>
<h4 id="布尔值"><a class="header" href="#布尔值">布尔值</a></h4>
<p>布尔值使用简单的位打包策略进行编码，每个布尔值使用1位。编码的布尔值的数量使用可变字节编码存储在块的开头。</p>
<h4 id="字符串"><a class="header" href="#字符串">字符串</a></h4>
<p>字符串使用<code>Snappy</code>压缩进行编码。每个字符串都是连续打包的，它们被压缩为一个更大的块。</p>
</li>
<li>
<h3 id="写"><a class="header" href="#写">写</a></h3>
<p>写操作被添加到当前的WAL段，同时也被添加到缓存中。每个WAL段都有一个最大尺寸。当前文件写满时，写入滚动到新文件。缓存也是有大小限制的；当缓存太满时，会进行snapshot和WAL压缩。如果写速率在一段持续时间内超过WAL压缩速率，那么缓存可能会变得太满，在这种情况下，新的写操作将会失败，直到snapshot进程赶上。</p>
<p>当WAL段被填满并关闭时，Compactor会snapshot缓存并将数据写入一个新的TSM文件。当成功写入TSM文件并进行fsync时，文件存储就会加载并引用它。</p>
</li>
<li>
<h3 id="更新"><a class="header" href="#更新">更新</a></h3>
<p>更新(为一个已经存在的点写一个新的值)与正常写操作一样发生。因为缓存的值会覆盖现有的值，所以新的写操作优先。如果写入将覆盖以前的TSM文件中的一个点，那么这些点将在查询运行时合并，新的写入优先。</p>
</li>
<li>
<h3 id="删除"><a class="header" href="#删除">删除</a></h3>
<p>删除是通过向WAL写入一个删除条目来进行的，该条目用于测量或序列，然后更新Cache和FileStore。Cache将收回所有相关条目。FileStore为每个包含相关数据的TSM文件写一个tombstone文件。这些tombstone文件在启动时用于忽略块以及在压缩期间用于删除已删除的条目。</p>
<p>对部分删除的系列的查询在查询时进行处理，直到压缩从TSM文件中完全删除数据。</p>
</li>
<li>
<h3 id="查询"><a class="header" href="#查询">查询</a></h3>
<p>当存储引擎执行查询时，它本质上是对与特定series key和field相关的给定时间的搜索。首先，我们对数据文件进行搜索，以找到包含与查询匹配的时间范围以及包含匹配序列的文件。</p>
<p>选中数据文件后，接下来需要找到series key索引条目在文件中的位置。我们对每个TSM索引执行二进制搜索，以找到其索引块的位置。</p>
<p>在通常情况下，多个TSM文件之间的块不会重叠，我们可以线性搜索索引条目，以找到要读取的起始块。如果有重叠的时间块，则对索引项进行排序，以确保较新的写操作优先，并且在查询执行期间可以按顺序处理这些块。</p>
<p>当遍历索引项时，块顺序地从块部分读取。块被解压缩，我们寻找特定的点。</p>
</li>
</ul>
<h2 id="tsi的设计"><a class="header" href="#tsi的设计">TSI的设计</a></h2>
<ul>
<li>
<h3 id="概述"><a class="header" href="#概述">概述</a></h3>
<p>为了支持大量时间序列，即在数据库存储的惟一时间序列数量中具有非常高的基数，CnosDB添加了新的时间序列索引(TSI)。CnosDB支持客户使用具有数千万个时间序列的CnosDB。然而，CnosDB的目标是扩大到数亿，最终达到数十亿。使用CnosDB的TSI存储引擎，用户应该能够拥有数百万个唯一的时间序列。目标是系列的数量应该不受服务器硬件上的内存数量的限制。重要的是，数据库中存在的序列数量对数据库启动时间的影响可以忽略不计。</p>
</li>
<li>
<h3 id="时间序列指数"><a class="header" href="#时间序列指数">时间序列指数</a></h3>
<p>新的时间序列索引(TSI)将索引移动到我们内存映射的磁盘上的文件。这意味着我们让操作系统句柄成为最近最少使用(Least Recently Used, LRU)内存。与处理原始时间序列数据的TSM引擎非常类似，我们有一个预写日志，它具有一个内存结构，在查询时与内存映射索引合并。不断运行后台进程将索引压缩成越来越大的文件，以避免在查询时进行太多的索引合并。在后台，我们使用了像Robin Hood Hashing这样的技术来进行快速索引查找，并使用hyperloglog++来保存基数估计的草图。后者将使我们能够向查询语言中添加内容。</p>
</li>
<li>
<h3 id="启用-tsi"><a class="header" href="#启用-tsi">启用 TSI</a></h3>
<p>启用TSI时，需要在CnosDB配置文件(<code>CnosDB.conf</code>)中设置以下行:</p>
<p><code>index-version = &quot;tsi1&quot;</code></p>
</li>
<li>
<h3 id="工具"><a class="header" href="#工具">工具</a></h3>
<h4 id="cnosdb_inspect-dumptsi"><a class="header" href="#cnosdb_inspect-dumptsi"><code>cnosdb_inspect dumptsi</code></a></h4>
<p>如果正在对索引问题进行故障排除，可以使用<code>cnosdb_inspect dumptsi</code>命令。这个命令允许您打印索引、文件或一组文件的汇总统计信息。此命令一次只对一个索引起作用。</p>
<h4 id="cnosdb_inspect-buildtsi"><a class="header" href="#cnosdb_inspect-buildtsi"><code>cnosdb_inspect buildtsi</code></a></h4>
<p>如果希望将现有的<code>shard</code>从内存索引转换为TSI索引，或者如果现有的TSI索引已经损坏，可以使用c<code>nosdb_inspect buildtsi</code>命令从底层的TSM数据创建索引。如果您有一个现有的TSI索引，您想要重建，首先删除您的分片中的索引目录。</p>
<p>该命令在服务器级工作，但您可以选择添加数据库、保留策略和碎片过滤器，以仅应用于碎片的一个子集。</p>
</li>
<li>
<h3 id="理解-tsi"><a class="header" href="#理解-tsi">理解 TSI</a></h3>
<h4 id="文件组织"><a class="header" href="#文件组织">文件组织</a></h4>
<p>TSI 由如下几部分构成</p>
<ul>
<li>索引:包含单个分片的整个索引数据集。</li>
<li>分区:包含用于分片的数据的分片分区。</li>
<li>日志文件:以内存索引的形式包含新写入的series，并持久化为WAL。</li>
<li>索引文件:包含一个不可变的、内存映射的索引，由一个日志文件构建或由两个连续的索引文件合并而成。</li>
<li>序列文件：它包含整个数据库中所有series keys的集合。数据库中的每个分片共享相同的序列文件。</li>
</ul>
<h4 id="写-1"><a class="header" href="#写-1">写</a></h4>
<p>当写入操作系统时，会发生以下情况。</p>
<ol>
<li>Series被添加到Series文件中，如果Series文件已经存在，则查找它。这将返回一个自动递增的序列ID。</li>
<li>series被发送到索引。索引维护现有系列id的咆哮位图，并忽略已经创建的系列。</li>
<li>该序列被散列并发送到适当的分区。</li>
<li>分区将系列作为一个条目写入日志文件。</li>
<li>日志文件将该系列写入磁盘上的预写日志文件，并将该系列添加到一组内存索引中。</li>
</ol>
<h4 id="压实"><a class="header" href="#压实">压实</a></h4>
<p>一旦日志文件大小超过阈值(5MB)，就会创建一个新的活动日志文件，并将前一个日志文件压缩到一个索引文件中。第一个索引文件的级别是1 (L1)。日志文件被认为是级别0 (L0)。</p>
<p>索引文件也可以通过合并两个较小的索引文件来创建。例如，如果两个相邻的L1索引文件存在，则可以将它们合并到L2索引文件中。</p>
<h4 id="读"><a class="header" href="#读">读</a></h4>
<p>索引提供了几个API调用来检索数据集，例如:</p>
<p><code>MeasurementIterator ()</code>: 返回已排序的measurement名称列表。</p>
<p><code>TagKeyIterator() </code>: 返回measurements中已排序的标签键列表。</p>
<p><code>TagValueIterator()</code>: 返回tag keys的tag values的排序列表。</p>
<p><code>MeasurementSeriesIDIterator()</code>: 返回measurements的所有series id的排序列表。</p>
<p><code>TagKeySeriesIDIterator()</code>: 返回tag keys的所有series id的排序列表。</p>
<p><code>TagValueSeriesIDIterator() </code>: 返回一个tag values的所有series id的排序列表。</p>
<h4 id="日志文件结构"><a class="header" href="#日志文件结构">日志文件结构</a></h4>
<p>日志文件的结构很简单，它是按顺序写入磁盘的LogEntry对象列表。日志文件一直写到5MB，然后压缩成索引文件。日志中的条目对象可以是以下任何一种类型:</p>
<ul>
<li>AddSeries</li>
<li>DeleteSeries</li>
<li>DeleteMeasurement</li>
<li>DeleteTagKey</li>
<li>DeleteTagValue</li>
</ul>
<p>日志文件的内存索引跟踪以下内容:</p>
<ul>
<li>measurements的名字</li>
<li>measurements的tag keys</li>
<li>tag keys的tag values</li>
<li>series的measurements</li>
<li>series的tag values</li>
<li>series, measurements, tag keys和tag values的tombstones文件</li>
</ul>
<h4 id="索引文件结构"><a class="header" href="#索引文件结构">索引文件结构</a></h4>
<p>索引文件是一个不可变的文件，它跟踪与日志文件类似的信息，但所有数据都被索引并写入磁盘，以便可以直接从内存映射中访问它。</p>
<p>索引文件包含以下部分：</p>
<ul>
<li>TagBlocks: 为单个tag key维护tag value的索引。</li>
<li>MeasurementBlock: 维护measurements值及其tag keys的索引。</li>
<li>Trailer: 存储文件的偏移量信息，以及用于基数估计的HyperLogLog草图。</li>
</ul>
<h4 id="manifest文件"><a class="header" href="#manifest文件">MANIFEST文件</a></h4>
<p>MANIFEST文件存储在索引目录中，并列出属于该索引的所有文件以及访问它们的顺序。每次发生压缩时，都会更新此文件。目录中任何不在索引文件中的文件都是正在压缩过程中的索引文件。</p>
<h4 id="文件集"><a class="header" href="#文件集">文件集</a></h4>
<p>文件集是在CnosDB进程运行时获得的清单的内存快照。这需要提供索引在某个时间点的一致视图。该文件集还促进了对其所有文件的引用计数，以便在文件的所有读取器完成对文件的操作之前，不会通过压缩删除任何文件。</p>
</li>
</ul>
<h2 id="文件系统布局"><a class="header" href="#文件系统布局">文件系统布局</a></h2>
<ul>
<li>
<h3 id="cnosdb-文件结构"><a class="header" href="#cnosdb-文件结构">CnosDB 文件结构</a></h3>
<h4 id="data-目录"><a class="header" href="#data-目录">Data 目录</a></h4>
<p>CnosDB存储时间序列数据(TSM文件)的目录路径。要定制此路径，请使用<code>[data].dir</code>配置选项。</p>
<h4 id="wal-目录"><a class="header" href="#wal-目录">WAL 目录</a></h4>
<p>CnosDB存放WAL(Write Ahead Log 预写日志)文件的目录路径。要定制此路径，请使用<code>[data].wal-dir</code>配置选项。</p>
<h4 id="meta-目录"><a class="header" href="#meta-目录">Meta 目录</a></h4>
<p>CnosDB存放meta文件的目录路径，存储有关用户、数据库、保留策略、分片和连续查询的信息。要定制此路径，请使用<code>[meta].dir</code>配置选项。</p>
</li>
<li>
<h3 id="文件布局"><a class="header" href="#文件布局">文件布局</a></h3>
<ul>
<li><a href="content/cnosdb/latest/concept.html#macos">macOS</a></li>
<li><a href="content/cnosdb/latest/concept.html#linux">Linux</a></li>
<li><a href="content/cnosdb/latest/concept.html#windows">Windows</a></li>
<li><a href="content/cnosdb/latest/concept.html#docker">Docker</a></li>
<li><a href="content/cnosdb/latest/concept.html#kubernetes">Kubernetes</a></li>
</ul>
</li>
</ul>
<h4 id="macos-1"><a class="header" href="#macos-1">macOS</a></h4>
<p>macOs默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">~/.cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">~/.cnosdb/mata/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">~/.cnosdb/wal/</td></tr>
</tbody></table>
<p>macOS 文件系统概述</p>
<pre><code>          ~/.cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<h4 id="linux"><a class="header" href="#linux">Linux</a></h4>
<p>在Linux上安装CnosDB时，您可以下载并安装cnosdb二进制文件，也可以以包的形式安装。使用的安装方法决定了文件系统的布局。</p>
<p>Linux 默认目录 (以独立的二进制文件形式安装)</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">~/.cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">~/.cnosdb/mata/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">~/.cnosdb/wal/</td></tr>
</tbody></table>
<p>Linux 文件系统概述 (以独立的二进制文件形式安装)</p>
<pre><code>          ~/.cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<p>Linux 默认目录 (以包的形式安装)</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">/var/lib/cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">/var/lib/cnosdb/meta/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">/var/lib/cnosdb/wal/</td></tr>
<tr><td style="text-align: center">默认配置文件路径</td><td style="text-align: center">/etc/cnosdb/cnosdb.conf</td></tr>
</tbody></table>
<p>Linux 文件系统概述 (以包的形式安装)</p>
<pre><code>          /var/lib/cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db

          /etc/cnosdb/
            └──cnosdb.conf
</code></pre>
<h4 id="windows"><a class="header" href="#windows">Windows</a></h4>
<p>Windows 默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">%USERPROFILE% \ .cnosdb\data\</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">%USERPROFILE% \ .cnosdb\meta\</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">%USERPROFILE% \ .cnosdb\meta\</td></tr>
</tbody></table>
<p>Windows 文件系统概述</p>
<pre><code>          %USERPROFILE% \ .cnosdb\
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<h4 id="docker-1"><a class="header" href="#docker-1">Docker</a></h4>
<p>Docker 默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">/var/lib/cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">/var/lib/cnosdb/meta/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">/var/lib/cnosdb/wal/</td></tr>
</tbody></table>
<p>Docker 文件系统概述</p>
<pre><code>          /var/lib/cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<h4 id="kubernetes"><a class="header" href="#kubernetes">Kubernetes</a></h4>
<p>Kubernetes 默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">/var/lib/cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">/var/lib/cnosdb/meta/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">/var/lib/cnosdb/wal/</td></tr>
</tbody></table>
<p>Kubernetes 文件系统概述</p>
<pre><code>          /var/lib/cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosdb-vs-sql-1"><a class="header" href="#cnosdb-vs-sql-1">CnosDB VS SQL</a></h2>
<ul>
<li>
<h3 id="概念-2"><a class="header" href="#概念-2">概念</a></h3>
<p>CnosDB类似于SQL数据库，但在许多方面有所不同。CnosDB是专门为时间序列数据构建的。关系数据库可以处理时间序列数据，但对常见的时间序列工作负载没有进行优化。CnosDB旨在存储大量时间序列数据，并快速对这些数据执行实时分析。</p>
<p>在CnosDB中，时间戳标识任何给定数据系列中的单个点。这就像一个SQL数据库表，其中的主键是由系统预先设置的，并且总是时间。</p>
<p>CnosDB还认识到，您的模式首选项可能会随着时间而改变。在CnosDB中，您不必预先定义模式。数据点可以具有measurements上的一个字段、measurements上的所有字段或中间的任何数字。只需为新字段编写一个点，就可以向measurements添加新字段。如果您需要了解相关术语，如measurement、tag和field等，请阅读本节内容，了解SQL数据库到CnosDB术语交叉。</p>
</li>
<li>
<h3 id="术语-1"><a class="header" href="#术语-1">术语</a></h3>
<p>下面的表是一个(非常)简单的例子，它是一个SQL数据库中名为<code>wind_speed</code>的表，其中没有索引的列是<code>#wind_speed</code>，索引的列是<code>station_id</code>、<code>station</code>和<code>time</code>。</p>
<pre><code>+------------+---------------+---------------------+--------------+
| station_id |   station     |       time          |  #wind_speed |
+------------+---------------+---------------------+--------------+
|       1    | LianYunGang   | 1429185600000000000 |       63     |
|       1    | LianYunGang   | 1429185601000000000 |       74     |
|       1    | LianYunGang   | 1429185602000000000 |       51     |
|       1    | LianYunGang   | 1429185603000000000 |       15     |
|       2    | XiaoMaiDao    | 1429185600000000000 |       104    |
|       2    | XiaoMaiDao    | 1429185601000000000 |       20     |
|       2    | XiaoMaiDao    | 1429185602000000000 |       21     |
|       2    | XiaoMaiDao    | 1429185603000000000 |       34     |
+------------+---------------+---------------------+--------------+
</code></pre>
<p>同样的数据在 CnosDB 中看起来是这样的：</p>
<pre><code>name: wind_speed
tags: station_id=1, station=LianYunGang
time			               #wind_speed
----			               ------------
2015-04-16T12:00:00Z	 63
2015-04-16T12:00:01Z	 74
2015-04-16T12:00:02Z	 51
2015-04-16T12:00:03Z	 15

name: wind_speed
tags: station_id=2, station=XiaoMaiDao
time			               #wind_speed
----			               ------------
2015-04-16T12:00:00Z	 104
2015-04-16T12:00:01Z	 20
2015-04-16T12:00:02Z	 21
2015-04-16T12:00:03Z	 34
</code></pre>
<ul>
<li>时间序列数据在聚合场景中最有用</li>
<li>CnosDB 中的<code>measurement</code>类似于SQL数据库<code>table</code>。</li>
<li>CnosDB 中的<code>tags</code>类似于SQL数据库中的有索引的列。</li>
<li>CnosDB 中的<code>fields</code>类似SQL数据库中没有索引的列。</li>
<li>CnosDB 中的<code>points</code>类似于SQL行。</li>
<li>CnosDB 中不需要预定义<code>schema</code></li>
</ul>
<p>基于对数据库术语的这种比较，CnosDB连续查询和保留策略类似于SQL数据库中的存储过程。它们只指定一次，然后定期自动执行。</p>
<p>当然，SQL数据库和CnosDB之间存在一些主要差异。SQL join不能用于CnosDB的<code>measurements</code>; 您的模式设计应该反映这种差异。而且，正如我们上面提到的，<code>measurements</code>就像一个SQL表，其中的主索引总是预先设置为time。CnosDB时间戳必须在U<code>NIX epoch (GMT)</code>或格式化为<code>RFC3339</code>下有效的日期-时间字符串。</p>
</li>
<li>
<h3 id="cnosql-1"><a class="header" href="#cnosql-1">CnosQL</a></h3>
<p>CnosDB支持的查询语言主要是CnosQL。</p>
<p>CnosQL是一种类似sql的查询语言，用于与CnosDB交互。它经过精心设计，使之与其他SQL或类似SQL的环境中的SQL相似，同时还提供了特定于存储和分析时间序列数据的特性。然而，CnosQL不是SQL，缺乏对SQL高级用户习惯的更高级操作，如UNION、JOIN和HAVING的支持。</p>
<p>CnosQL的SELECT语句遵循SQL SELECT语句的形式:</p>
<p><code>SELECT &lt;stuff&gt; FROM &lt;measurement_name&gt; WHERE &lt;some_conditions&gt;</code></p>
<p><code>WHERE</code>是可选的</p>
<p>要获得上面部分的CnosDB输出，您需要输入:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot;</code></p>
<p>如果你只想看到LianYunGang的数据，你可以输入:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot; WHERE &quot;station&quot; = 'LianYunGang'</code></p>
<p>如果你想查看2015年4月16日12:00:01 UTC之后LianYunGang的数据，你可以输入:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt; '2015-04-16 12:00:01'</code></p>
<p>如上例所示，CnosQL允许您在<code>WHERE</code>语句中指定查询的时间范围。可以使用单引号括起来的日期-时间字符串，格式为Y<code>YYY-MM-DD HH:MM:SS.MMM </code>(<code>MMM</code>是可选的毫秒数，您还可以指定微秒或纳秒)。你也可以在<code>now()</code>中使用相对时间，它指的是服务器的当前时间戳:</p>
<p><code>SELECT * FROM &quot;wind_speed&quot; WHERE time &gt; now() - 1h</code></p>
<p>该查询输出wind_speed的measurements中的数据，其中时间戳比服务器当前时间早1小时。使用now()指定持续时间的选项有:ns(纳秒)、u或µ(微秒)、ms(毫秒)、s(秒)、m(分钟)、h(小时)、d(天)和w(周)。</p>
</li>
<li>
<h3 id="cnosdb-并非-crud-1"><a class="header" href="#cnosdb-并非-crud-1">CnosDB 并非 CRUD</a></h3>
<p>CnosDB是一个针对时间序列数据进行了优化的数据库。这些数据通常来自分布式传感器组、大型网站的点击数据或金融交易列表。</p>
<p>这些数据的一个共同之处是，它们在总体上更有用。有一篇文章说，你的电脑在UTC时间周二12:38:35的时候CPU利用率为12%，这很难从中得出结论。当与本序列的其他部分结合使用时，它将变得更加有用。这是随着时间的推移趋势开始显现的地方，可以从数据中得出可操作的见解。此外，时间序列数据通常只写入一次，很少更新。</p>
<p>其结果是，CnosDB不是一个完整的CRUD数据库，而是更像一个CR-ud，优先考虑创建和读取数据的性能，而不是更新和销毁，并防止一些更新和销毁行为，以使创建和读取性能更高:</p>
<ul>
<li>要更新一个点，请插入一个具有相同measurements、tag set和timestamp的点。</li>
<li>您可以删除或删除序列，但不能基于字段值删除单个点。作为一种解决方案，您可以搜索字段值，检索时间，然后基于时间字段进行DELETE操作。</li>
<li>您还不能更新或重命名tags。要修改一系列点的tags，请找到有问题标记值的点，将值更改为所需的值，将这些点写回，然后删除带有旧tag values的序列。</li>
<li>你不能通过tag keys来删除tags。</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="设计原则-1"><a class="header" href="#设计原则-1">设计原则</a></h1>
<p>CnosDB应用时间序列数据的优化设计原则。其中一些设计原则可能与性能方面的权衡有关。主要设计原则包括：</p>
<ul>
<li>以时间为顺序的数据</li>
<li>严格的更新和删除权限</li>
<li>预处理读写查询</li>
<li>无Schema设计</li>
<li>单个Point上的数据集</li>
<li>重复数据</li>
</ul>
<h3 id="以时间为顺序的数据-1"><a class="header" href="#以时间为顺序的数据-1">以时间为顺序的数据</a></h3>
<p>为了提高性能，数据按时间升序写入。</p>
<h3 id="严格的更新和删除权限-1"><a class="header" href="#严格的更新和删除权限-1">严格的更新和删除权限</a></h3>
<p>为了提高查询和写性能，CnosDB严格限制更新和删除权限。时间序列数据主要是从未更新的新数据。限制删除可以有效提高查询和写入性能。</p>
<h3 id="优先处理读写查询"><a class="header" href="#优先处理读写查询">优先处理读写查询</a></h3>
<p>CnosDB优先考虑读和写请求，而不是强一致性。CnosDB在执行查询时返回结果。所有影响查询数据的事务随后都会被处理，以确保数据最终是一致的。因此，如果摄取速率很高(每毫秒多个写操作)，查询结果可能不包括最近的数据。</p>
<h3 id="无schema设计"><a class="header" href="#无schema设计">无Schema设计</a></h3>
<p>CnosDB使用无Schema设计来更好地管理不连续数据。时间序列数据通常是短暂的，这意味着数据出现一段时间，然后就消失了。</p>
<h3 id="单个point是不重要的"><a class="header" href="#单个point是不重要的">单个Point是不重要的</a></h3>
<p>由于数据集比单个Point更重要，因此CnosDB实现了强大的工具来聚合数据和处理大型数据集。Point通过时间戳和序列来区分，所以没有传统意义上的ID。</p>
<h3 id="重复数据-1"><a class="header" href="#重复数据-1">重复数据</a></h3>
<p>为了简化冲突解决和提高写性能，CnosDB假设发送多次的数据是重复数据。相同的点不会存储两次。如果为某个点提交了新的字段值，则CnosDB使用最新的字段值更新该点。在极少数情况下，数据可能会被覆盖。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="tsm架构设计"><a class="header" href="#tsm架构设计">TSM架构设计</a></h2>
<ul>
<li>
<h3 id="设计架构-1"><a class="header" href="#设计架构-1">设计架构</a></h3>
<p>每个CnosDB用例都是唯一的，您的模式反映了这种唯一性。通常，为查询而设计的模式可以实现更简单、更高效的查询。对于大多数用例，我们推荐以下设计架构:</p>
<ul>
<li>在何处存储数据(标签或字段)</li>
<li>避免过多的series</li>
<li>使用推荐的命名约定</li>
<li>分片时长管理</li>
</ul>
</li>
<li>
<h4 id="在何处存储数据标签或字段-1"><a class="header" href="#在何处存储数据标签或字段-1">在何处存储数据(标签或字段)</a></h4>
<ul>
<li>将常用查询和分组元数据存储在标签中。</li>
<li>如果每个数据点包含不同的值，则将数据存储在字段中。</li>
<li>将数字值存储为fields(tag values只支持字符串值)。</li>
</ul>
</li>
<li>
<h4 id="避免过多的series-1"><a class="header" href="#避免过多的series-1">避免过多的series</a></h4>
<p>按tags查询比按fields查询性能更好。但是，当创建过多的索引时，写和读都可能开始变慢。</p>
<p>每一组索引数据元素形成一个series key。包含高度可变信息(如唯一id、哈希值和随机字符串)的标记将导致大量的series，也称为高series基数。对于许多数据库工作负载来说，高series基数是高内存使用量的主要驱动因素。因此，为了减少内存消耗，可以考虑将高基数值存储在field values中，而不是存储在tag keys或field keys中。</p>
</li>
<li>
<h4 id="使用推荐的命名约定-1"><a class="header" href="#使用推荐的命名约定-1">使用推荐的命名约定</a></h4>
<ul>
<li>避免在tag和field keys中保留关键字</li>
<li>如果每个数据点包含不同的值，则将数据存储在field中。</li>
<li>将数字值存储为fields(tag values只支持字符串值)。</li>
</ul>
</li>
<li>
<h3 id="tsm-树-1"><a class="header" href="#tsm-树-1">TSM 树</a></h3>
<p>时间结构合并树(TSM)引擎解决了获得最大吞吐量、压缩和原始时间序列数据查询速度的问题。在TSI之前，倒排索引是一种内存中的数据结构，是在基于TSM中的数据启动数据库时构建的。这意味着对于每个度量、标记键值对和字段名，内存中都有一个查询表来将这些元数据位映射到底层的时间序列。对于具有大量临时序列的用户，内存利用率随着新的时间序列的创建而不断增加。而且，启动时间增加了，因为所有的数据都必须在启动时加载到堆上。</p>
</li>
<li>
<h3 id="tsm-相关概念-1"><a class="header" href="#tsm-相关概念-1">TSM 相关概念</a></h3>
<p>CnosDB存储引擎看起来非常类似于LSM树。它有一个预写日志和一组只读数据文件，这些文件在概念上类似于LSM树中的sstable。TSM文件包含排序、压缩的系列数据。</p>
<p>CnosDB将为每个时间块创建一个分片（即shard）。例如，如果您有一个无限持续时间的保留策略，那么将为每7天的时间块创建分片。每个分片都映射到底层存储引擎数据库。每个数据库都有自己的WAL和TSM文件。</p>
</li>
<li>
<h3 id="存储引擎-1"><a class="header" href="#存储引擎-1">存储引擎</a></h3>
<p>存储引擎将多个组件捆绑在一起，提供存储和查询系列数据的外部接口。它由多个组件组成，每个组件都扮演一个特定的角色:</p>
<ul>
<li>
<p><code>内存索引</code>- 内存索引是跨分片的共享索引，提供对<code>measurement</code>、<code>tags</code>和<code>series</code>的快速访问。索引由引擎使用，但并不特定于存储引擎本身。</p>
</li>
<li>
<p><code>WAL</code> - <code>WAL</code>是一种写入优化的存储格式，它允许写入是持久的，但不容易查询。对<code>WAL</code>的写入附加到固定大小的段。</p>
</li>
<li>
<p><code>缓存</code> - 缓存是存储在<code>WAL</code>中的数据的内存表示。它在运行时被查询并与存储在<code>TSM</code>文件中的数据合并。</p>
</li>
<li>
<p><code>TSM 文件</code> - <code>TSM</code>文件以列格式存储压缩的系列数据。</p>
</li>
<li>
<p><code>FileStore</code>- <code>FileStore</code>调解对磁盘上所有<code>TSM</code>文件的访问。它确保在替换现有文件以及删除不再使用的<code>TSM</code>文件时自动安装<code>TSM</code>文件。</p>
</li>
<li>
<p><code>Compactor</code> - <code>Compactor</code>负责将优化程度较低的<code>Cache</code>和<code>TSM</code>数据转换为读取优化程度更高的格式。它通过压缩系列、删除已删除的数据、优化索引以及将较小的文件组合成较大的文件来实现这一点。</p>
</li>
<li>
<p><code>Compaction Planner</code> - <code>Compaction Planner</code>确定哪些<code>TSM</code>文件已准备好进行压缩，并确保多个并发压缩不会相互干扰。</p>
</li>
<li>
<p><code>Compression</code>- <code>Compression</code>由各种编码器和解码器处理特定数据类型。一些编码器是相当静态的，并且总是以相同的方式编码相同的类型；其他人根据数据的形状切换压缩策略。</p>
</li>
<li>
<p><code>Writers/Readers</code> - 每种文件类型（<code>WAL</code>段、<code>TSM</code>文件、<code>tombstones</code>等）都有用于处理格式的<code>Writers</code>和<code>Readers</code>。</p>
</li>
</ul>
</li>
<li>
<h3 id="预写日志-wal-1"><a class="header" href="#预写日志-wal-1">预写日志 WAL</a></h3>
<p>WAL被组织成一组类似于<code>_000001.wal</code>的文件。文件编号是单调递增的，称为WAL段。当一个段的大小达到10MB时，它被关闭并打开一个新的段。每个WAL段存储多个压缩的写和删除块。</p>
<p>当写入时，新的点被序列化，使用Snappy压缩，并写入WAL文件。在成功返回之前，文件被fsync并将数据添加到内存索引中。这意味着需要将点批处理在一起以实现高吞吐量性能。(对于许多用例来说，最佳批量大小似乎是每批5000 - 10000个点。)</p>
<p>WAL中的每个表项都遵循<code>TLV标准</code>，一个字节代表表项的类型(写或删除)，一个4字节的<code>uint32</code>压缩块的长度，然后是压缩块。</p>
</li>
<li>
<h3 id="缓存-1"><a class="header" href="#缓存-1">缓存</a></h3>
<p>缓存是当前存储在WAL中的所有数据点的内存副本。这些点由key组织，key是measurement、tag set和field。每个field保存为自己的时间顺序范围。缓存数据在内存中没有被压缩。</p>
<p>对存储引擎的查询将把来自缓存的数据与来自TSM文件的数据合并。在查询处理时，对从缓存中获取的数据的副本执行查询。这样，在查询运行时输入的写操作不会影响结果。</p>
<p>发送到缓存的删除操作将清除给定key或给定key的特定时间范围。</p>
<p>缓存为快照行为提供了一些控制。最重要的控制是内存限制。有一个下界，即<code>cache-snapshot-memory-size</code>，超过这个下界将触发对TSM文件的快照，并删除相应的WAL段。还有一个上限，<code>cache-max-memory-size</code>，超过这个上限会导致缓存拒绝新的写操作。这些配置对于防止内存不足的情况以及对客户机施加反压力非常有用，因为写入数据的速度比实例持久化数据的速度要快。每次写操作时都会检查内存阈值。</p>
<p>其他快照控制是基于时间的。空闲阈值<code>cache -snapshot-write-cold-duration</code>在制定时间间隔内没有收到写请求时，强制缓存快照TSM文件。</p>
<p>通过重新读取磁盘上的WAL文件，在重新启动时重新创建内存缓存。</p>
</li>
<li>
<h3 id="tsm-文件-1"><a class="header" href="#tsm-文件-1">TSM 文件</a></h3>
<p>TSM文件是内存映射的只读文件的集合。这些文件的结构看起来非常类似于LevelDB或其他LSM树变体中的SSTable。</p>
<p>TSM文件由四部分组成：header, blocks, index, footer.</p>
<h4 id="header-1"><a class="header" href="#header-1">Header</a></h4>
<pre><code>+--------+------------------------------------+-------------+--------------+
| Header |               Blocks               |    Index    |    Footer    |
|5 bytes |              N bytes               |   N bytes   |   4 bytes    |
+--------+------------------------------------+-------------+--------------+
</code></pre>
<p><code>Header</code>用于标识文件类型和版本号。</p>
<pre><code>  +-------------------+
  |      Header       |
  +-------------------+
  |  Magic  │ Version |
  | 4 bytes │ 1 byte  |
  +-------------------+
</code></pre>
<h4 id="blocks-1"><a class="header" href="#blocks-1">Blocks</a></h4>
<p><code>Blocks</code> 是成对的 CRC32 校验和和数据的序列。block数据对文件是不透明的。CRC32 用于block级错误检测。block的长度存储在索引中。</p>
<pre><code>  +--------------------------------------------------------------------+
  │                           Blocks                                   │
  +---------------------+-----------------------+----------------------+
  |       Block 1       |        Block 2        |       Block N        |
  +---------------------+-----------------------+----------------------+
  |   CRC    |  Data    |    CRC    |   Data    |   CRC    |   Data    |
  | 4 bytes  | N bytes  |  4 bytes  | N bytes   | 4 bytes  |  N bytes  |
  +---------------------+-----------------------+----------------------+
</code></pre>
<h4 id="index-1"><a class="header" href="#index-1">Index</a></h4>
<p>block之后是文件中block的Index。Index由一系列Index条目组成，这些条目按字典顺序按key排序，然后按时间排序。key包括measurement name、tag set和one field。每个点的多个字段在 TSM 文件中创建多个Index条目。每个Index条目以key长度和key开头，然后是block类型（float、int、bool、string）和key后面的block Index条目数。每个block Index条目由block的最小和最大时间、block所在文件的偏移量和block的大小组成。TSM 文件中包含密钥的每个block都有一个block Index条目。</p>
<p>Index结构可以提供对所有block的有效访问以及确定与访问给定key相关的成本的能力。给定一个key和timestamp，我们可以确定一个文件是否包含该时间戳的块。我们还可以确定该block所在的位置以及必须读取多少数据才能检索该block。知道block的大小，我们可以有效地配置我们的 IO 语句。</p>
<pre><code>  +-----------------------------------------------------------------------------+
  │                                   Index                                     │
  +-----------------------------------------------------------------------------+
  │ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │....│
  │ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │    │
  +-----------------------------------------------------------------------------+
</code></pre>
<h4 id="footer-1"><a class="header" href="#footer-1">Footer</a></h4>
<p>最后一部分是存储索引开始的偏移量的页脚。</p>
<pre><code>  +---------+
  │ Footer  │
  +---------+
  │Index Ofs│
  │ 8 bytes │
  +---------+
</code></pre>
</li>
<li>
<h3 id="压缩-1"><a class="header" href="#压缩-1">压缩</a></h3>
<p>压缩是将以写优化格式存储的数据迁移到读优化格式的循环过程。当写一个shard时，有几个压缩阶段:</p>
<p>1.快照 —— 必须将Cache和WAL中的值转换为TSM文件，以释放WAL段所使用的内存和磁盘空间。这些压缩是基于缓存内存和时间阈值进行的。</p>
<p>2.级别压缩 —— 级别压缩(级别1-4)发生在TSM文件生成时。TSM文件从快照文件压缩到一级文件。多个1级文件被压缩以生成2级文件。这个过程继续进行，直到文件达到TSM文件的最大大小4级(完全压缩)。除非需要运行删除、索引优化压缩或完全压缩，否则不会进一步压缩它们。较低级别的压缩使用的策略避免了cpu密集型活动，如解压缩和组合块。更高级别(因此更少频率)的压缩将重新组合块，以完全压缩它们，并增加压缩比。</p>
<p>3.索引优化 —— 当许多4级TSM文件累积时，内部索引将变得更大，访问成本也更高。索引优化压缩在一组新的TSM文件中分割序列和索引，将给定序列的所有点排序到一个TSM文件中。在进行索引优化之前，每个TSM文件包含大多数或所有系列的点，因此每个文件包含相同的系列索引。在索引优化之后，每个TSM文件包含来自最小序列的点，并且文件之间的序列重叠很少。因此，每个TSM文件都有一个较小的惟一系列索引，而不是完整系列列表的副本。此外，来自特定系列的所有点在TSM文件中是连续的，而不是分布在多个TSM文件中。</p>
<p>4.完全压缩(4级压缩) —— 当碎片长时间处于冷状态，或者碎片上发生删除时，就会发生完全压缩。完全压缩生成一组最优的TSM文件，并包括来自级别和索引优化压缩的所有优化。一旦碎片被完全压缩，除非存储了新的写或删除操作，否则不会在其上运行其他压缩操作。</p>
<p>每个块都被压缩，以减少查询时的存储空间和磁盘IO。一个块包含给定序列和字段的时间戳和值。每个块有一个字节头，后面是压缩时间戳和压缩值。</p>
<pre><code>  +--------------------------------------------------+
  | Type  |  Len  |   Timestamps    |      Values    |
  |1 Byte | VByte |     N Bytes     |    N Bytes     │
  +--------------------------------------------------+
</code></pre>
<p>根据数据类型及其形状，使用编码对时间戳和值进行压缩和单独存储。独立存储它们允许对所有时间戳使用时间戳编码，同时允许对不同的字段类型使用不同的编码。例如，有些点可以使用游程编码，而其他点则不能。</p>
<p>每个值类型还包含一个1字节的头，指示剩余字节的压缩类型。四个高位存储压缩类型，四个低位在需要时由编码器使用。</p>
<h4 id="时间戳-1"><a class="header" href="#时间戳-1">时间戳</a></h4>
<p>时间戳编码是自适应的，并基于所编码的时间戳的结构。它结合使用增量编码、缩放和使用simple8b游程编码的压缩，并在需要时退回到无压缩。</p>
<p>时间戳的分辨率是可变的，但可以是纳秒级的粒度，需要8个字节来存储未压缩的数据。在编码期间，值首先进行增量编码。第一个值是起始时间戳，随后的值是与前一个值的差值。这通常将值转换成更小的整数，更容易压缩。许多时间戳也是单调增加的，并落在时间的偶数边界上，例如每10秒。当时间戳具有这种结构时，它们的最大公约数也是10的倍数。这可以将非常大的整数delta转换为更小的整数delta，从而更好地压缩。</p>
<p>使用这些调整后的值，如果所有增量相同，则使用游程编码存储时间范围。如果不能进行游程编码，并且所有值都小于(1«60)- 1(在纳秒分辨率下~36.5年)，则使用simple8b编码对时间戳进行编码。Simple8b编码是一种64位字对齐整数编码，它将多个整数打包成一个64位字。如果任何值超过了最大值，增量将不压缩地存储，每个块使用8个字节。未来的编码可能使用补丁方案，如PFOR，以更有效地处理异常值。</p>
<h4 id="浮点数-1"><a class="header" href="#浮点数-1">浮点数</a></h4>
<p>浮点是使用<code>Facebook Gorilla paper</code>的实现进行编码的。将XORS连续的值编码在一起，当这些值很接近时产生一个小结果。然后使用控制位存储增量，以指示异或值中有多少前导和尾零。我们的实现删除了论文中描述的时间戳编码，只对浮点值进行编码。</p>
<h4 id="整数-1"><a class="header" href="#整数-1">整数</a></h4>
<p>整数编码根据未压缩数据中的值范围使用两种不同的策略。编码后的值首先使用ZigZag编码。它使正整数和负整数在一个正整数范围内交叉。</p>
<p>如果所有ZigZag编码的值都小于(1«60)- 1，则使用simple8b编码对它们进行压缩。如果任何值大于最大值，那么所有的值都被不压缩地存储在块中。如果所有值都相同，则使用游程编码。对于经常是常量的值，这种方法非常有效。</p>
<h4 id="布尔值-1"><a class="header" href="#布尔值-1">布尔值</a></h4>
<p>布尔值使用简单的位打包策略进行编码，每个布尔值使用1位。编码的布尔值的数量使用可变字节编码存储在块的开头。</p>
<h4 id="字符串-1"><a class="header" href="#字符串-1">字符串</a></h4>
<p>字符串使用<code>Snappy</code>压缩进行编码。每个字符串都是连续打包的，它们被压缩为一个更大的块。</p>
</li>
<li>
<h3 id="写-2"><a class="header" href="#写-2">写</a></h3>
<p>写操作被添加到当前的WAL段，同时也被添加到缓存中。每个WAL段都有一个最大尺寸。当前文件写满时，写入滚动到新文件。缓存也是有大小限制的；当缓存太满时，会进行snapshot和WAL压缩。如果写速率在一段持续时间内超过WAL压缩速率，那么缓存可能会变得太满，在这种情况下，新的写操作将会失败，直到snapshot进程赶上。</p>
<p>当WAL段被填满并关闭时，Compactor会snapshot缓存并将数据写入一个新的TSM文件。当成功写入TSM文件并进行fsync时，文件存储就会加载并引用它。</p>
</li>
<li>
<h3 id="更新-1"><a class="header" href="#更新-1">更新</a></h3>
<p>更新(为一个已经存在的点写一个新的值)与正常写操作一样发生。因为缓存的值会覆盖现有的值，所以新的写操作优先。如果写入将覆盖以前的TSM文件中的一个点，那么这些点将在查询运行时合并，新的写入优先。</p>
</li>
<li>
<h3 id="删除-1"><a class="header" href="#删除-1">删除</a></h3>
<p>删除是通过向WAL写入一个删除条目来进行的，该条目用于测量或序列，然后更新Cache和FileStore。Cache将收回所有相关条目。FileStore为每个包含相关数据的TSM文件写一个tombstone文件。这些tombstone文件在启动时用于忽略块以及在压缩期间用于删除已删除的条目。</p>
<p>对部分删除的系列的查询在查询时进行处理，直到压缩从TSM文件中完全删除数据。</p>
</li>
<li>
<h3 id="查询-1"><a class="header" href="#查询-1">查询</a></h3>
<p>当存储引擎执行查询时，它本质上是对与特定series key和field相关的给定时间的搜索。首先，我们对数据文件进行搜索，以找到包含与查询匹配的时间范围以及包含匹配序列的文件。</p>
<p>选中数据文件后，接下来需要找到series key索引条目在文件中的位置。我们对每个TSM索引执行二进制搜索，以找到其索引块的位置。</p>
<p>在通常情况下，多个TSM文件之间的块不会重叠，我们可以线性搜索索引条目，以找到要读取的起始块。如果有重叠的时间块，则对索引项进行排序，以确保较新的写操作优先，并且在查询执行期间可以按顺序处理这些块。</p>
<p>当遍历索引项时，块顺序地从块部分读取。块被解压缩，我们寻找特定的点。</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tsi的设计-1"><a class="header" href="#tsi的设计-1">TSI的设计</a></h1>
<h2 id="文件结构"><a class="header" href="#文件结构">文件结构</a></h2>
<p>TSI 由如下几部分构成
- 索引:包含单个分片的整个索引数据集。
- 分区:包含用于分片的数据的分片分区。
- 日志文件:以内存索引的形式包含新写入的series，并持久化为WAL。
- 索引文件:包含一个不可变的、内存映射的索引，由一个日志文件构建或由两个连续的索引文件合并而成。
- 序列文件：它包含整个数据库中所有series keys的集合。数据库中的每个分片共享相同的序列文件。</p>
<h2 id="写入"><a class="header" href="#写入">写入</a></h2>
<p>当写入操作系统时，会发生以下情况。</p>
<ol>
<li>Series被添加到Series文件中，如果Series文件已经存在，则查找它。这将返回一个自动递增的序列ID。</li>
<li>series被发送到索引。索引维护现有系列id的咆哮位图，并忽略已经创建的series。</li>
<li>该series被hash并发送到适当的分区。</li>
<li>分区将series作为一个条目写入日志文件。</li>
<li>日志文件将该series写入磁盘上的预写日志文件，并将该series添加到一组内存索引中。</li>
</ol>
<h2 id="压缩-2"><a class="header" href="#压缩-2">压缩</a></h2>
<p>一旦日志文件大小超过阈值(5MB)，就会创建一个新的活跃日志文件，并将前一个日志文件压缩到一个索引文件中。第一个索引文件的级别为L1。日志文件被认为是级别L0。</p>
<p>索引文件也可以通过合并两个较小的索引文件来创建。例如，如果两个相邻的L1索引文件存在，则可以将它们合并到L2索引文件中。</p>
<h2 id="读取"><a class="header" href="#读取">读取</a></h2>
<p>索引提供了几个API调用来检索数据集，例如:</p>
<p><code>MeasurementIterator ()</code>: 返回已排序的<code>measurement</code>名称列表。</p>
<p><code>TagKeyIterator() </code>: 返回<code>measurements</code>中已排序的<code>tag keys</code>列表。</p>
<p><code>TagValueIterator()</code>: 返回<code>tag keys</code>的<code>tag values</code>的排序列表。</p>
<p><code>MeasurementSeriesIDIterator()</code>: 返回measurements的所有series id的排序列表。</p>
<p><code>TagKeySeriesIDIterator()</code>: 返回<code>tag keys</code>的所有<code>series id</code>的排序列表。</p>
<p><code>TagValueSeriesIDIterator() </code>: 返回一个<code>tag values</code>的所有<code>series id</code>的排序列表。</p>
<h2 id="日志文件结构-1"><a class="header" href="#日志文件结构-1">日志文件结构</a></h2>
<p>日志文件的结构很简单，它是按顺序写入磁盘的LogEntry对象列表。日志文件一直写到5MB，然后压缩成索引文件。日志中的条目对象可以是以下任何一种类型:</p>
<ul>
<li>AddSeries</li>
<li>DeleteSeries</li>
<li>DeleteMeasurement</li>
<li>DeleteTagKey</li>
<li>DeleteTagValue</li>
</ul>
<p>日志文件的内存索引跟踪以下内容:</p>
<ul>
<li><code>measurements</code>的名字</li>
<li><code>measurements</code>的<code>tag keys</code></li>
<li><code>tag keys</code>的<code>tag values</code></li>
<li><code>series</code>的<code>measurements</code></li>
<li><code>series</code>的<code>tag values</code></li>
<li><code>series</code>, <code>measurements</code>, <code>tag keys</code>和<code>tag values</code>的<code>tombstones</code>文件</li>
</ul>
<h2 id="索引文件结构-1"><a class="header" href="#索引文件结构-1">索引文件结构</a></h2>
<p>索引文件是一个不可变的文件，它跟踪与日志文件类似的信息，但所有数据都被索引并写入磁盘，以便可以直接从内存映射中访问它。</p>
<p>索引文件包含以下部分：</p>
<ul>
<li><code>TagBlocks</code>: 为单个<code>tag key</code>维护<code>tag value</code>的索引。</li>
<li><code>MeasurementBlock</code>: 维护<code>measurements</code>值及其<code>tag keys</code>的索引。</li>
<li><code>Trailer</code>: 存储文件的偏移量信息，以及用于基数估计的<code>HyperLogLog</code>草图。</li>
</ul>
<h2 id="manifest文件-1"><a class="header" href="#manifest文件-1">MANIFEST文件</a></h2>
<p>MANIFEST文件存储在索引目录中，并列出属于该索引的所有文件以及访问它们的顺序。每次发生压缩时，都会更新此文件。目录中任何不在索引文件中的文件都是正在压缩过程中的索引文件。</p>
<h2 id="文件集-1"><a class="header" href="#文件集-1">文件集</a></h2>
<p>文件集是在CnosDB进程运行时获得的清单的内存快照。这需要提供索引在某个时间点的一致视图。该文件集还促进了对其所有文件的引用计数，以便在文件的所有读取器完成对文件的操作之前，不会通过压缩删除任何文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="文件系统布局-1"><a class="header" href="#文件系统布局-1">文件系统布局</a></h2>
<ul>
<li>
<h3 id="cnosdb-文件结构-1"><a class="header" href="#cnosdb-文件结构-1">CnosDB 文件结构</a></h3>
<h4 id="data-目录-1"><a class="header" href="#data-目录-1">Data 目录</a></h4>
<p>CnosDB存储时间序列数据(TSM文件)的目录路径。要定制此路径，请使用<code>[data].dir</code>配置选项。</p>
<h4 id="wal-目录-1"><a class="header" href="#wal-目录-1">WAL 目录</a></h4>
<p>CnosDB存放WAL(Write Ahead Log 预写日志)文件的目录路径。要定制此路径，请使用<code>[data].wal-dir</code>配置选项。</p>
<h4 id="meta-目录-1"><a class="header" href="#meta-目录-1">Meta 目录</a></h4>
<p>CnosDB存放meta文件的目录路径，存储有关用户、数据库、保留策略、分片和连续查询的信息。要定制此路径，请使用<code>[meta].dir</code>配置选项。</p>
</li>
<li>
<h3 id="文件布局-1"><a class="header" href="#文件布局-1">文件布局</a></h3>
<ul>
<li><a href="content/cnosdb/latest/concept/file_system_layout.html#macos">macOS</a></li>
<li><a href="content/cnosdb/latest/concept/file_system_layout.html#linux">Linux</a></li>
<li><a href="content/cnosdb/latest/concept/file_system_layout.html#windows">Windows</a></li>
<li><a href="content/cnosdb/latest/concept/file_system_layout.html#docker">Docker</a></li>
<li><a href="content/cnosdb/latest/concept/file_system_layout.html#kubernetes">Kubernetes</a></li>
</ul>
</li>
</ul>
<h4 id="macos-2"><a class="header" href="#macos-2">macOS</a></h4>
<p>macOs默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">~/.cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">~/.cnosdb/mata/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">~/.cnosdb/wal/</td></tr>
</tbody></table>
<p>macOS 文件系统概述</p>
<pre><code>          ~/.cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<h4 id="linux-1"><a class="header" href="#linux-1">Linux</a></h4>
<p>在Linux上安装CnosDB时，您可以下载并安装cnosdb二进制文件，也可以以包的形式安装。使用的安装方法决定了文件系统的布局。</p>
<p>Linux 默认目录 (以独立的二进制文件形式安装)</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">~/.cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">~/.cnosdb/mata/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">~/.cnosdb/wal/</td></tr>
</tbody></table>
<p>Linux 文件系统概述 (以独立的二进制文件形式安装)</p>
<pre><code>          ~/.cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<p>Linux 默认目录 (以包的形式安装)</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">/var/lib/cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">/var/lib/cnosdb/meta/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">/var/lib/cnosdb/wal/</td></tr>
<tr><td style="text-align: center">默认配置文件路径</td><td style="text-align: center">/etc/cnosdb/cnosdb.conf</td></tr>
</tbody></table>
<p>Linux 文件系统概述 (以包的形式安装)</p>
<pre><code>          /var/lib/cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db

          /etc/cnosdb/
            └──cnosdb.conf
</code></pre>
<h4 id="windows-1"><a class="header" href="#windows-1">Windows</a></h4>
<p>Windows 默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">%USERPROFILE% \ .cnosdb\data\</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">%USERPROFILE% \ .cnosdb\meta\</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">%USERPROFILE% \ .cnosdb\meta\</td></tr>
</tbody></table>
<p>Windows 文件系统概述</p>
<pre><code>          %USERPROFILE% \ .cnosdb\
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<h4 id="docker-2"><a class="header" href="#docker-2">Docker</a></h4>
<p>Docker 默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">/var/lib/cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">/var/lib/cnosdb/meta/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">/var/lib/cnosdb/wal/</td></tr>
</tbody></table>
<p>Docker 文件系统概述</p>
<pre><code>          /var/lib/cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<h4 id="kubernetes-1"><a class="header" href="#kubernetes-1">Kubernetes</a></h4>
<p>Kubernetes 默认目录</p>
<table><thead><tr><th style="text-align: center">路径</th><th style="text-align: center">默认路径</th></tr></thead><tbody>
<tr><td style="text-align: center">Data directory</td><td style="text-align: center">/var/lib/cnosdb/data/</td></tr>
<tr><td style="text-align: center">Meta directory</td><td style="text-align: center">/var/lib/cnosdb/meta/</td></tr>
<tr><td style="text-align: center">WAL directory</td><td style="text-align: center">/var/lib/cnosdb/wal/</td></tr>
</tbody></table>
<p>Kubernetes 文件系统概述</p>
<pre><code>          /var/lib/cnosdb/
            ├──data
            │  └──TSM目录和文件
            ├──wal
            │  └──WAL目录和文件
            └──meta
               └──meta.db
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="指南"><a class="header" href="#指南">指南</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-cli"><a class="header" href="#cnosdb-cli">cnosdb-cli</a></h1>
<blockquote>
<p>使用cnosdb-cli交互式命令行工具操作CnosDB</p>
</blockquote>
<ul>
<li><a href="content/cnosdb/latest/guide/cnosdb-cli.html#%E5%BC%80%E5%A7%8Bcnosdb-cli">开始cnosdb-cli</a></li>
<li><a href="content/cnosdb/latest/guide/cnosdb-cli.html#cnosdb-cli%E9%80%89%E9%A1%B9">cnosdb-cli选项</a></li>
<li><a href="content/cnosdb/latest/guide/cnosdb-cli.html#cnosdb-cli%E5%8F%82%E6%95%B0">cnosdb-cli参数</a></li>
<li><a href="content/cnosdb/latest/guide/cnosdb-cli.html#cnosdb-cli%E5%91%BD%E4%BB%A4">cnosdb-cli命令</a></li>
</ul>
<h2 id="开始cnosdb-cli"><a class="header" href="#开始cnosdb-cli">开始cnosdb-cli</a></h2>
<p>如果使用cnosdb-cli，则需要先启动cnosdb进程，然后在终端启动cnosdb-cli，如果成功连接，您将看到以下输出：</p>
<pre><code>$ cnosdb-cli
CnosDB shell version: v0.10.3
&gt;
</code></pre>
<p>您可以在终端输入<code>help</code>命令，查询有效的命令。CnosQL的语法请查看<a href="content/cnosdb/latest/guide/">TOOD</a></p>
<h2 id="cnosdb-cli选项"><a class="header" href="#cnosdb-cli选项">cnosdb-cli选项</a></h2>
<h2 id="cnosdb-cli参数"><a class="header" href="#cnosdb-cli参数">cnosdb-cli参数</a></h2>
<h2 id="cnosdb-cli命令"><a class="header" href="#cnosdb-cli命令">cnosdb-cli命令</a></h2>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h2 id="导入和导出"><a class="header" href="#导入和导出">导入和导出</a></h2>
<ul>
<li>
<h3 id="导入"><a class="header" href="#导入">导入</a></h3>
<pre><code>cnosdb-cli import --path &lt;path&gt; [arguments]
</code></pre>
<!--TODO -->
</li>
<li>
<h3 id="导出"><a class="header" href="#导出">导出</a></h3>
<pre><code>cnosdb-inspect export [arguments]
</code></pre>
<!--TODO --></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="备份和还原"><a class="header" href="#备份和还原">备份和还原</a></h1>
<h2 id="备份-cnosdb-backup"><a class="header" href="#备份-cnosdb-backup">备份 <code>cnosdb backup</code></a></h2>
<p>从指定数据节点创建数据库快照，并保存到 PATH 对应目录。</p>
<pre><code class="language-shell">cnosdb backup [flags] PATH
</code></pre>
<h3 id="参数介绍"><a class="header" href="#参数介绍">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>数据库名称；可选；如果未指定则备份所有数据库。</td></tr>
<tr><td><code>--rp</code></td><td>数据保留策略；可选；如果未指定则备份所有数据保留策略。</td></tr>
<tr><td><code>--shard</code></td><td>分片编号；可选；如果需要使用该参数，则需要同时使用 <code>-rp</code> 参数。</td></tr>
<tr><td><code>--start</code></td><td>备份中包含的数据的最小时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--end</code></td><td>备份中包含的数据的最大时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--skip-errors</code></td><td>创建某分片的备份时，若发生错误，继续创建剩余分片的备份。</td></tr>
</tbody></table>
<h2 id="还原-cnosdb-restore"><a class="header" href="#还原-cnosdb-restore">还原 <code>cnosdb restore</code></a></h2>
<p>从指定的备份目录中恢复数据和元数据。恢复开始时，服务将被关闭。</p>
<pre><code>cnosdb restore [flags]
</code></pre>
<h3 id="参数介绍-1"><a class="header" href="#参数介绍-1">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>从备份数据中恢复的数据库名称。</td></tr>
<tr><td><code>--newdb</code></td><td>创建新数据库以导入备份数据；可选；如果未指定，则使用 <code>--db &lt;db_name&gt;</code> 中指定的数据库名称。该参数指定的数据库名称在目标系统中不能重复。</td></tr>
<tr><td><code>--rp</code></td><td>从备份数据中恢复的数据库保留策略名称；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 参数。</td></tr>
<tr><td><code>--newrp</code></td><td>将备份数据导入其他的数据保留策略；可选；如果未指定，则使用 <code>--rp</code> 中指定的数据保留策略名称。</td></tr>
<tr><td><code>--shard</code></td><td>从备份数据中恢复的分片编号；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 和 <code>--rp</code> 参数。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb配置"><a class="header" href="#cnosdb配置">CnosDB配置</a></h1>
<h2 id="概述-1"><a class="header" href="#概述-1">概述</a></h2>
<h3 id="配置概述"><a class="header" href="#配置概述">配置概述</a></h3>
<p>通过配置文件(<code>cnosdb.conf</code>)和环境变量配置CnosDB。如果不取消注释配置选项，系统将使用其默认设置。本文档中的配置均为系统默认配置。</p>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>配置文件中的所有配置设置可以在配置文件中指定，也可以在环境变量中指定。环境变量覆盖配置文件中的等效选项。如果配置文件或环境变量中没有指定配置选项，则CnosDB使用其内部默认配置。</p>
<h3 id="使用配置文件"><a class="header" href="#使用配置文件">使用配置文件</a></h3>
<p>CnosDB系统对配置文件中的所有设置都有内部默认值。如果需要查看默认配置，使用命令cnosdb config。</p>
<p>本地CnosDB配置文件位于这里:
- Linux: /etc/cnosdb/cnosdb.conf
- macOS: /usr/local/etc/cnosdb.conf</p>
<p>注释掉的设置设置为系统内部默认值。未加注释的设置覆盖内部默认值。注意，本地配置文件不需要包含每个配置设置。</p>
<p>使用<code>--config</code>指令将配置文件导入CnosDB</p>
<p><code>cnosdb --config /etc/cnosdb/cnosdb.conf</code></p>
<p>将环境变量CNOSDB_CONFIG_PATH设置为配置文件的路径，并启动进程。例如:</p>
<pre><code>echo $CNOSDB_CONFIG_PATH
/etc/cnosdb/cnosdb.conf

cnosdb
</code></pre>
<h3 id="全局配置"><a class="header" href="#全局配置">全局配置</a></h3>
<h4 id="bind-address--1270018088"><a class="header" href="#bind-address--1270018088">bind-address = &quot;127.0.0.1:8088&quot;</a></h4>
<p>用于备份和恢复的RPC服务的绑定地址。环境变量为：<code>CNOSDB_BIND_ADDRESS</code></p>
<h3 id="port"><a class="header" href="#port">Port</a></h3>
<h4 id="可用端口"><a class="header" href="#可用端口">可用端口：</a></h4>
<p><code>8086</code>：提供cnosdb http服务的默认端口</p>
<p><code>8088</code>：提供cnosdb 内部RPC服务以及备份恢复的默认端口</p>
<h3 id="meta"><a class="header" href="#meta">meta</a></h3>
<h4 id="dir--varlibcnosdbmeta"><a class="header" href="#dir--varlibcnosdbmeta">dir = &quot;/var/lib/cnosdb/meta&quot;</a></h4>
<p>元数据/raft数据库所在的目录。meta目录中的文件包括meta.db、CnosDB metastore文件。环境变量为:<code>CNOSDB_META_DIR</code></p>
<h4 id="retention-autocreate--true"><a class="header" href="#retention-autocreate--true">retention-autocreate = true</a></h4>
<p>启用在创建数据库时自动创建DEFAULT保留策略autogen。保留策略autogen具有无限的持续时间，也被设置为数据库的DEFAULT保留策略，当写入或查询没有指定保留策略时使用该保留策略。禁用此设置，以防止在创建数据库时创建此保留策略。环境变量:<code>CNOSDB_META_RETENTION_AUTOCREATE</code></p>
<h4 id="logging-enabled--true"><a class="header" href="#logging-enabled--true">logging-enabled = true</a></h4>
<p>启用记录来自元服务的消息。 环境变量:<code>CNOSDB_META_LOGGING_ENABLED</code></p>
<h3 id="数据节点"><a class="header" href="#数据节点">数据节点</a></h3>
<h4 id="dir--varlibcnosdbdata"><a class="header" href="#dir--varlibcnosdbdata">dir = &quot;/var/lib/cnosdb/data&quot;</a></h4>
<p>TSM引擎存储TSM文件的CnosDB目录。该目录可以被修改。环境变量:CNOSDB_DATA_DIR</p>
<h4 id="wal-dir--varlibcnosdbwal"><a class="header" href="#wal-dir--varlibcnosdbwal">wal-dir = &quot;/var/lib/cnosdb/wal&quot;</a></h4>
<p>存放预写日志(WAL)文件的目录位置。 环境变量:CNOSDB_DATA_WAL_DIR</p>
<h4 id="wal-fsync-delay--0s"><a class="header" href="#wal-fsync-delay--0s">wal-fsync-delay = &quot;0s&quot;</a></h4>
<p>同步之前写操作等待的时间。使用大于0的持续时间批量处理多个fsync调用。这对于较慢的磁盘或遇到WAL写争用时非常有用。0的默认值为每次写入WAL时同步。环境变量:<code>CNOSDB_DATA_WAL_FSYNC_DELAY</code></p>
<h4 id="index-version--inmem"><a class="header" href="#index-version--inmem">index-version = &quot;inmem&quot;</a></h4>
<p><code>tsi1. </code>用于新分片的分片索引类型。默认的(<code>inmem</code>)索引是在启动时重新创建的内存索引。如果需要启用基于磁盘的TSI (Time Series Index)索引，请将该值设置为<code>tsi1</code>。环境变量:<code>CNOSDB_DATA_INDEX_VERSION</code></p>
<h4 id="trace-logging-enabled--false"><a class="header" href="#trace-logging-enabled--false">trace-logging-enabled = false</a></h4>
<p>在TSM引擎和WAL中启用附加调试信息的详细日志记录。跟踪日志为调试TSM引擎问题提供了更有用的输出。 环境变量:<code>CNOSDB_DATA_TRACE_LOGGING_ENABLED</code></p>
<h4 id="query-log-enabled--true"><a class="header" href="#query-log-enabled--true">query-log-enabled = true</a></h4>
<p>在执行之前启用解析查询的日志记录。查询日志对于故障排除很有用，但会记录查询中包含的任何敏感数据。 环境变量:<code>CNOSDB_DATA_QUERY_LOG_ENABLED</code></p>
<h4 id="query-log-enabled--true-1"><a class="header" href="#query-log-enabled--true-1">query-log-enabled = true</a></h4>
<p>在执行之前启用解析查询的日志记录。查询日志对于故障排除很有用，但会记录查询中包含的任何敏感数据。 环境变量:<code>CNOSDB_DATA_QUERY_LOG_ENABLED</code></p>
<h4 id="validate-keys--false"><a class="header" href="#validate-keys--false">validate-keys = false</a></h4>
<p>验证传入的写入以确保键只有有效的Unicode字符。这个设置将产生一个小开销，因为必须检查每个键。</p>
<h4 id="cache-max-memory-size--1g"><a class="header" href="#cache-max-memory-size--1g">cache-max-memory-size = &quot;1g&quot;</a></h4>
<p>分片缓存在开始拒绝写操作之前所能达到的最大大小。有效的内存大小后缀是:k、m或g。没有大小后缀的值以字节为单位。环境变量:<code>CNOSDB_DATA_CACHE_MAX_MEMORY_SIZE</code></p>
<h4 id="cache-snapshot-memory-size--25m"><a class="header" href="#cache-snapshot-memory-size--25m">cache-snapshot-memory-size = &quot;25m&quot;</a></h4>
<p>引擎快照缓存并将其写入TSM文件的大小，以释放内存。有效的内存大小后缀是:k、m或g。没有大小后缀的值以字节为单位。环境变量:<code>CNOSDB_DATA_CACHE_SNAPSHOT_MEMORY_SIZE</code></p>
<h4 id="cache-snapshot-write-cold-duration--10m"><a class="header" href="#cache-snapshot-write-cold-duration--10m">cache-snapshot-write-cold-duration = &quot;10m&quot;</a></h4>
<p>如果分片还没有收到写或删除，引擎将快照缓存并将其写入新的TSM文件的时间间隔。环境变量:<code>CNOSDB_DATA_CACHE_SNAPSHOT_WRITE_COLD_DURATION</code></p>
<h4 id="compact-full-write-cold-duration--4h"><a class="header" href="#compact-full-write-cold-duration--4h">compact-full-write-cold-duration = &quot;4h&quot;</a></h4>
<p>如果没有收到写或删除，TSM引擎将在一个分片中压缩所有TSM文件的时间间隔。环境变量:<code>CNOSDB_DATA_COMPACT_FULL_WRITE_COLD_DURATION</code></p>
<h4 id="max-concurrent-compactions--0"><a class="header" href="#max-concurrent-compactions--0">max-concurrent-compactions = 0</a></h4>
<p>一次可以运行的并发全量和级别压缩的最大数目。默认值0会导致运行时将50%的CPU内核用于压缩。如果显式设置，则用于压缩的内核数量将被限制为指定的值。该设置不适用于缓存快照。环境变量:<code>CNOSDB_DATA_MAX_CONCURRENT_COMPACTIONS</code></p>
<h4 id="compact-throughput--48m"><a class="header" href="#compact-throughput--48m">compact-throughput = &quot;48m&quot;</a></h4>
<p>允许TSM压缩写入磁盘的速率限制(以每秒字节为单位)。请注意，允许短突发以一个可能更大的值发生，该值由<code>compact-throughput-burst</code>设置。环境变量:<code>CNOSDB_DATA_COMPACT_THROUGHPUT</code></p>
<h4 id="compact-throughput-burst--48m"><a class="header" href="#compact-throughput-burst--48m">compact-throughput-burst = &quot;48m&quot;</a></h4>
<p>允许TSM压缩写入磁盘的速率限制(以每秒字节为单位)。环境变量:<code>CNOSDB_DATA_COMPACT_THROUGHPUT_BURST</code></p>
<h4 id="tsm-use-madv-willneed--false"><a class="header" href="#tsm-use-madv-willneed--false">tsm-use-madv-willneed = false</a></h4>
<p>如果为<code>true</code>，那么MMap Advise值<code>MADV_WILLNEED</code>就输入/输出分页方面向内核建议如何处理映射内存区域，以及如何期望在不久的将来访问映射内存区域(与TSM文件有关)。因为这个设置在一些内核(包括CentOS和RHEL)上有问题，所以默认值是<code>false</code>。在某些情况下，将该值更改为<code>true</code>可能对磁盘速度较慢的用户有所帮助。环境变量:<code>CNOSDB_DATA_TSM_USE_MADV_WILLNEED</code></p>
<h3 id="索引"><a class="header" href="#索引">索引</a></h3>
<h4 id="max-series-per-database--1000000"><a class="header" href="#max-series-per-database--1000000">max-series-per-database = 1000000</a></h4>
<p>在删除写操作之前，每个数据库允许的最大序列数。默认设置为1000000(100万)。将该设置更改为0，以允许每个数据库无限数量的序列。如果某个点导致数据库中序列的数量超过max-series-per-database，则CnosDB将不会写入该点，并返回500，并出现以下错误:</p>
<p><code>{&quot;error&quot;:&quot;max series per database exceeded: &lt;series&gt;&quot;}</code></p>
<p>环境变量:<code>CNOSDB_DATA_MAX_SERIES_PER_DATABASE</code></p>
<h4 id="max-values-per-tag--100000"><a class="header" href="#max-values-per-tag--100000">max-values-per-tag = 100000</a></h4>
<p>每个标记键允许的标记值的最大数目。缺省值为100000(100,000)。将设置更改为0，以允许每个标记键的标记值数量不限。如果标记值导致标记键的标记值数量超过<code>max-values-per-tag</code>，则CnosDB将不写入该点，并返回部分写入错误。</p>
<p>任何标签值超过<code>max-values-per-tag</code>的现有标签键将继续接受写操作，但创建新标签值的写操作将失败。</p>
<p>环境变量:<code>CNOSDB_DATA_MAX_VALUES_PER_TAG</code></p>
<h4 id="max-index-log-file-size--1m"><a class="header" href="#max-index-log-file-size--1m">max-index-log-file-size = &quot;1m&quot;</a></h4>
<p>当索引提前写日志(WAL)文件压缩为索引文件时，以字节为单位的阈值。较小的大小将导致日志文件被更快地压缩，并以写吞吐量为代价减少堆的使用。更高的大小将更少地被压缩，在内存中存储更多的系列，并提供更高的写吞吐量。有效的大小后缀是k、m或g(不区分大小写，1024 = 1k)。没有大小后缀的值以字节为单位。环境变量:<code>CNOSDB_DATA_MAX_INDEX_LOG_FILE_SIZE</code></p>
<h4 id="series-id-set-cache-size--100"><a class="header" href="#series-id-set-cache-size--100">series-id-set-cache-size = 100</a></h4>
<p>指定要为TSI索引缓存的系列ID集的数量(默认为100)。集合中的系列id指的是在同一个索引谓词(标记过滤器)上匹配的序列。序列ID集是一个LRU缓存，所以一旦缓存满了，最近最少使用的集就会被驱逐。缓存的结果可以快速返回，因为当执行带有匹配标记过滤器的后续查询时，它们不需要重新计算。</p>
<p>我们建议使用默认设置。将此值更改为0将禁用缓存，这可能会导致查询性能问题。只有当您知道数据库的所有度量的标记键值大于100时，才会增加这个值。增加缓存大小可能会导致堆使用的增加。</p>
<p>环境变量:<code>CNOSDB_DATA_SERIES_ID_SET_CACHE_SIZE</code></p>
<h3 id="查询管理"><a class="header" href="#查询管理">查询管理</a></h3>
<h4 id="write-timeout--10s"><a class="header" href="#write-timeout--10s">write-timeout = &quot;10s&quot;</a></h4>
<p>写请求等待的时间，直到一个“超时”错误返回给调用者。默认值是10秒。环境变量:<code>CNOSDB_COORDINATOR_WRITE_TIMEOUT</code></p>
<h4 id="max-concurrent-queries--0"><a class="header" href="#max-concurrent-queries--0">max-concurrent-queries = 0</a></h4>
<p>在您的实例上允许运行查询的最大数量。默认设置(0)允许无限次查询。环境变量:<code>CNOSDB_COORDINATOR_MAX_CONCURRENT_QUERIES</code></p>
<h4 id="query-timeout--0s"><a class="header" href="#query-timeout--0s">query-timeout = &quot;0s&quot;</a></h4>
<p>在CnosDB终止查询之前，允许执行查询的最大持续时间。默认设置(0)允许查询在没有时间限制的情况下运行。此设置是一个持续时间。环境变量:<code>CNOSDB_COORDINATOR_QUERY_TIMEOUT</code></p>
<h4 id="log-queries-after--0s"><a class="header" href="#log-queries-after--0s">log-queries-after = &quot;0s&quot;</a></h4>
<p>在CnosDB用检测到的慢速查询消息记录查询之前，查询所能持续的最长时间。默认设置(“0”)将永远不会告诉CnosDB记录查询。此设置是一个持续时间。环境变量:<code>CNOSDB_COORDINATOR_LOG_QUERIES_AFTER</code></p>
<h4 id="max-select-point--0"><a class="header" href="#max-select-point--0">max-select-point = 0</a></h4>
<p>一个SELECT语句可以处理的最大点数。默认设置(0)允许SELECT语句处理无限数量的点。环境变量:<code>CNOSDB_COORDINATOR_MAX_SELECT_POINT</code></p>
<h3 id="max-select-series--0"><a class="header" href="#max-select-series--0">max-select-series = 0</a></h3>
<p>一个SELECT语句可以处理的最大序列数。默认设置(0)允许SELECT语句处理无限数量的序列。环境变量:<code>CNOSDB_COORDINATOR_MAX_SELECT_SERIES</code></p>
<h4 id="max-select-buckets--0"><a class="header" href="#max-select-buckets--0">max-select-buckets = 0</a></h4>
<p>一个查询可以处理的GROUP BY time()桶的最大数量。默认设置(0)允许查询处理无限数量的桶。 环境变量:<code>CNOSDB_COORDINATOR_MAX_SELECT_BUCKETS</code></p>
<h3 id="保留策略"><a class="header" href="#保留策略">保留策略</a></h3>
<h4 id="enabled--true"><a class="header" href="#enabled--true">enabled = true</a></h4>
<p>设置为<code>false</code>可防止CnosDB强制执行保留策略。环境变量：<code>CNOSDB_RETENTION_ENABLED</code></p>
<h4 id="check-interval--30m0s"><a class="header" href="#check-interval--30m0s">check-interval = &quot;30m0s&quot;</a></h4>
<p>CnosDB检查以强制执行保留策略的时间间隔。环境变量:<code>CNOSDB_RETENTION_CHECK_INTERVAL</code></p>
<h3 id="分片"><a class="header" href="#分片">分片</a></h3>
<h4 id="enabled--true-1"><a class="header" href="#enabled--true-1">enabled = true</a></h4>
<p>判断是否开启分片预创建服务。环境变量:<code>CNOSDB_SHARD_PRECREATION_ENABLED</code></p>
<h4 id="check-interval--10m"><a class="header" href="#check-interval--10m">check-interval = &quot;10m&quot;</a></h4>
<p>运行预创建新分片检查的时间间隔。环境变量:<code>CNOSDB_SHARD_PRECREATION_CHECK_INTERVAL</code></p>
<h4 id="advance-period--30m"><a class="header" href="#advance-period--30m">advance-period = &quot;30m&quot;</a></h4>
<p>未来CnosDB预先创建分片的最长时间。30m的默认值应该适用于大多数系统。在未来将此设置增加得太久可能会导致效率低下。环境变量:<code>CNOSDB_SHARD_PRECREATION_ADVANCE_PERIOD</code></p>
<h3 id="监控"><a class="header" href="#监控">监控</a></h3>
<p>默认情况下，CnosDB将数据写入_internal数据库。如果该数据库不存在，则CnosDB自动创建它。_internal数据库的默认保留策略是7天。如果需要使用7天保留策略以外的其他策略，必须先创建该策略。</p>
<h4 id="store-enabled--true"><a class="header" href="#store-enabled--true">store-enabled = true</a></h4>
<p>设置为<code>false</code>在内部禁用记录统计。如果设置为<code>false</code>，它将大大增加诊断安装问题的难度。环境变量:<code>CNOSDB_MONITOR_STORE_ENABLED</code></p>
<h4 id="store-database--_internal"><a class="header" href="#store-database--_internal">store-database = &quot;_internal&quot;</a></h4>
<p>用于记录统计信息的目标数据库。环境变量:<code>CNOSDB_MONITOR_STORE_DATABASE</code></p>
<h4 id="store-interval--10s"><a class="header" href="#store-interval--10s">store-interval = &quot;10s&quot;</a></h4>
<p>CnosDB记录统计信息的时间间隔。默认值是每10秒一次。环境变量:<code>CNOSDB_MONITOR_STORE_INTERVAL</code></p>
<h3 id="http端点"><a class="header" href="#http端点">HTTP端点</a></h3>
<p>[http]部分设置控制CnosDB如何配置http端点。这些是进出CnosDB的主要机制。编辑此部分中的设置以启用HTTPS和身份验证。</p>
<h4 id="enabled--true-2"><a class="header" href="#enabled--true-2">enabled = true</a></h4>
<p>确定是否启用HTTP端点。如果要禁用对HTTP端点的访问，请将该值设置为false。请注意，CnosDB命令行接口(CLI)使用CnosDB API连接到数据库。环境变量:<code>CNOSDB_HTTP_ENABLED</code></p>
<h4 id="bind-address--8086"><a class="header" href="#bind-address--8086">bind-address = &quot;:8086&quot;</a></h4>
<p>HTTP服务使用的绑定地址(端口)。环境变量:<code>CNOSDB_HTTP_BIND_ADDRESS</code></p>
<h4 id="auth-enabled--false"><a class="header" href="#auth-enabled--false">auth-enabled = false</a></h4>
<p>确定是否通过HTTP和HTTPS启用用户认证。如果需要身份验证，请将该值设置为<code>true</code>。环境变量:<code>CNOSDB_HTTP_AUTH_ENABLED</code></p>
<h4 id="log-enabled--true"><a class="header" href="#log-enabled--true">log-enabled = true</a></h4>
<p>确定是否启用HTTP请求日志记录。若要禁用日志记录，请将该值设置为<code>false</code>。环境变量:<code>CNOSDB_HTTP_LOG_ENABLED</code></p>
<h4 id="suppress-write-log--false"><a class="header" href="#suppress-write-log--false">suppress-write-log = false</a></h4>
<p>确定启用日志时是否应该抑制HTTP写请求日志。</p>
<h4 id="access-log-path-"><a class="header" href="#access-log-path-">access-log-path = &quot;&quot;</a></h4>
<p>访问日志的路径，它决定是否使用<code>log-enabled = true</code>启用详细的写日志记录。指定启用时是否将HTTP请求日志写入指定的路径。如果cnosdb无法访问指定的路径，它将记录错误并退回到stderr。当启用HTTP请求日志记录时，此选项指定应该写入日志条目的路径。如果未指定，默认值是写入stderr，这会将HTTP日志与内部的CnosDB日志混合在一起。如果cnosdb无法访问指定的路径，它将记录一个错误，并退回到将请求日志写入stderr。环境变量:<code>CNOSDB_HTTP_ACCESS_LOG_PATH</code></p>
<h4 id="access-log-status-filters--"><a class="header" href="#access-log-status-filters--">access-log-status-filters = []</a></h4>
<p>筛选应该记录的请求。每个过滤器的模式为nnn、nnx或nxx，其中n是一个数字，x是任何数字的通配符。要过滤所有5xx响应，请使用字符串5xx。如果使用多个过滤器，则只需要匹配一个。默认值是没有过滤器，每个请求都会被打印出来。环境变量:<code>CNOSDB_HTTP_ACCESS_LOG_STATUS_FILTERS_x</code></p>
<h4 id="write-tracing--false"><a class="header" href="#write-tracing--false">write-tracing = false</a></h4>
<p>确定是否启用详细的写日志记录。设置为<code>true</code>为写负载启用日志记录。如果设置为<code>true</code>，这将复制日志中的每个写语句，因此不建议在一般情况下使用。环境变量:<code>CNOSDB_HTTP_WRITE_TRACING</code></p>
<h4 id="pprof-enabled--true"><a class="header" href="#pprof-enabled--true">pprof-enabled = true</a></h4>
<p>确定是否启用/net/http/pprof HTTP端点。用于故障排除和监视。环境变量:<code>CNOSDB_HTTP_PPROF_ENABLED</code></p>
<h4 id="pprof-auth-enabled--false"><a class="header" href="#pprof-auth-enabled--false">pprof-auth-enabled = false</a></h4>
<pre><code>- /debug/pprof
- /debug/requests
- /debug/vars
</code></pre>
<p>如果<code>auth-enabled</code>或<code>pprofessor -enabled</code>设置为<code>false</code>，则此设置无效。环境变量:<code>CNOSDB_HTTP_PPROF_AUTH_ENABLED</code></p>
<h4 id="debug-pprof-enabled--false"><a class="header" href="#debug-pprof-enabled--false">debug-pprof-enabled = false</a></h4>
<p>启用默认<code>/pprof</code>端点并绑定到<code>localhost:6060</code>。用于调试启动性能问题。环境变量:<code>CNOSDB_HTTP_DEBUG_PPROF_ENABLED</code></p>
<h4 id="ping-auth-enabled--false"><a class="header" href="#ping-auth-enabled--false">ping-auth-enabled = false</a></h4>
<p>启用<code>/ping</code>、<code>/metrics</code>和<code>/status</code>端点的身份验证。如果<code>auth-enabled</code>设置为<code>false</code>，则此设置无效。环境变量:<code>CNOSDB_HTTP_PING_AUTH_ENABLED</code></p>
<h4 id="https-enabled--false"><a class="header" href="#https-enabled--false">https-enabled = false</a></h4>
<p>HTTPS是否启用。如果启用HTTPS协议，请将该值设置为<code>true</code>。环境变量:<code>CNOSDB_HTTP_HTTPS_ENABLED</code></p>
<h4 id="https-certificate--etcsslcnosdbpem"><a class="header" href="#https-certificate--etcsslcnosdbpem">https-certificate = &quot;/etc/ssl/cnosdb.pem&quot;</a></h4>
<p>启用HTTPS时使用的SSL证书文件的路径。环境变量:<code>CNOSDB_HTTP_HTTPS_CERTIFICATE</code></p>
<h4 id="https-private-key-"><a class="header" href="#https-private-key-">https-private-key = &quot;&quot;</a></h4>
<p>使用单独的私钥位置。如果只指定了<code>https-certificate</code>, httpd服务将尝试从<code>https-certificate</code>文件中加载私钥。如果指定了一个单独的<code>https-private-key</code>文件，httpd服务将从<code>https-private-key</code>文件加载私钥。环境变量:<code>CNOSDB_HTTP_HTTPS_PRIVATE_KEY</code></p>
<h4 id="shared-secret-"><a class="header" href="#shared-secret-">shared-secret = &quot;&quot;</a></h4>
<p>用于使用JWT令牌验证公共API请求的共享秘密。环境变量:<code>CNOSDB_HTTP_SHARED_SECRET</code></p>
<h4 id="max-row-limit--0"><a class="header" href="#max-row-limit--0">max-row-limit = 0</a></h4>
<p>系统在非分块查询中可以返回的最大行数。默认设置(0)允许无限的行数。如果查询结果超过指定值，则CnosDB在响应体中包含一个“partial”:true标记。环境变量:<code>CNOSDB_HTTP_MAX_ROW_LIMIT</code></p>
<h4 id="max-connection-limit--0"><a class="header" href="#max-connection-limit--0">max-connection-limit = 0</a></h4>
<p>可以同时打开的最大连接数。超过限制的新连接将被删除。默认值<code>0</code>禁用限制。环境变量:<code>CNOSDB_HTTP_MAX_CONNECTION_LIMIT</code></p>
<h4 id="unix-socket-enabled--false"><a class="header" href="#unix-socket-enabled--false">unix-socket-enabled = false</a></h4>
<p>通过UNIX域套接字启用HTTP服务。如果需要通过UNIX域套接字开启HTTP服务，请将该值设置为true。环境变量:<code>CNOSDB_HTTP_UNIX_SOCKET_ENABLED</code></p>
<h4 id="bind-socket--varruncnosdbsock"><a class="header" href="#bind-socket--varruncnosdbsock">bind-socket = &quot;/var/run/cnosdb.sock&quot;</a></h4>
<p>UNIX域套接字的路径。环境变量:<code>CNOSDB_HTTP_UNIX_BIND_SOCKET</code></p>
<h4 id="max-body-size--25000000"><a class="header" href="#max-body-size--25000000">max-body-size = 25000000</a></h4>
<p>客户端请求体的最大大小(以字节为单位)。当HTTP客户端发送的数据超过配置的最大大小时，会返回<code>413 Request Entity Too Large HTTP</code>响应。若要禁用该限制，请将该值设置为0。环境变量:<code>CNOSDB_HTTP_MAX_BODY_SIZE</code></p>
<h4 id="max-concurrent-write-limit--0"><a class="header" href="#max-concurrent-write-limit--0">max-concurrent-write-limit = 0</a></h4>
<p>并发处理的最大写操作数。若要禁用该限制，请将该值设置为0。环境变量:<code>CNOSDB_HTTP_MAX_CONCURRENT_WRITE_LIMIT</code></p>
<h4 id="max-enqueued-write-limit--0"><a class="header" href="#max-enqueued-write-limit--0">max-enqueued-write-limit = 0</a></h4>
<p>排队等待处理的最大写操作数。若要禁用该限制，请将该值设置为0。环境变量:<code>CNOSDB_HTTP_MAX_ENQUEUED_WRITE_LIMIT</code></p>
<h4 id="enqueued-write-timeout--0"><a class="header" href="#enqueued-write-timeout--0">enqueued-write-timeout = 0</a></h4>
<p>在等待处理的队列中等待写操作的最大持续时间。如果要禁用该限制，请将该值设置为0或将<code>max-concurrent-write-limit</code>值设置为0。环境变量:<code>CNOSDB_HTTP_ENQUEUED_WRITE_TIMEOUT</code></p>
<h3 id="日志"><a class="header" href="#日志">日志</a></h3>
<h4 id="format--auto"><a class="header" href="#format--auto">format = &quot;auto&quot;</a></h4>
<p>确定要为日志使用哪个日志编码器。有效值为<code>auto</code>(默认值)、<code>logfmt</code>和<code>json</code>。使用默认的自动选项，如果输出到TTY设备(例如，终端)，则使用更友好的控制台编码。如果输出是<code>files</code>，则<code>auto</code>选项使用<code>logfmt</code>编码。<code>logfmt</code>和<code>json</code>选项对于与外部工具集成非常有用。环境变量:<code>CNOSDB_LOGGING_FORMAT</code></p>
<h4 id="level--info"><a class="header" href="#level--info">level = &quot;info&quot;</a></h4>
<p>要发出的日志级别。有效值为<code>error</code>、<code>warn</code>、<code>info</code>(默认值)和<code>debug</code>。等于或高于指定级别的日志将被触发。环境变量:<code>CNOSDB_LOGGING_LEVEL</code></p>
<h4 id="suppress-logo--false"><a class="header" href="#suppress-logo--false">suppress-logo = false</a></h4>
<p>抑制程序启动时打印的标志输出。如果STDOUT不是TTY，则标识总是被抑制的。环境变量:<code>CNOSDB_LOGGING_SUPPRESS_LOGO</code></p>
<h3 id="订阅"><a class="header" href="#订阅">订阅</a></h3>
<h4 id="enabled--true-3"><a class="header" href="#enabled--true-3">enabled = true</a></h4>
<p>确定是否启用用户服务。如果需要关闭用户服务，请将该值设置为<code>false</code>。环境变量:<code>CNOSDB_SUBSCRIBER_ENABLED</code></p>
<h4 id="http-timeout--30s"><a class="header" href="#http-timeout--30s">http-timeout = &quot;30s&quot;</a></h4>
<p>HTTP写入到订阅服务器直至超时的持续时间。环境变量:<code>CNOSDB_SUBSCRIBER_HTTP_TIMEOUT</code></p>
<h4 id="insecure-skip-verify--false"><a class="header" href="#insecure-skip-verify--false">insecure-skip-verify = false</a></h4>
<p>确定是否允许到订阅者的不安全的HTTPS连接。这在测试自签名证书时非常有用。环境变量:<code>CNOSDB_SUBSCRIBER_INSECURE_SKIP_VERIFY</code></p>
<h4 id="ca-certs-"><a class="header" href="#ca-certs-">ca-certs = &quot;&quot;</a></h4>
<p>pem编码的CA certs文件的路径。如果为空字符串<code>“”</code>，则使用系统默认证书。环境变量:<code>CNOSDB_SUBSCRIBER_CA_CERTS</code></p>
<h4 id="write-concurrency--40"><a class="header" href="#write-concurrency--40">write-concurrency = 40</a></h4>
<p>处理写通道的写入程序的数量。环境变量:<code>CNOSDB_SUBSCRIBER_WRITE_CONCURRENCY</code></p>
<h4 id="write-buffer-size--1000"><a class="header" href="#write-buffer-size--1000">write-buffer-size = 1000</a></h4>
<p>写通道中缓冲的正在写的次数。环境变量:<code>CNOSDB_SUBSCRIBER_WRITE_BUFFER_SIZE</code></p>
<h3 id="连续查询"><a class="header" href="#连续查询">连续查询</a></h3>
<h4 id="enabled--true-4"><a class="header" href="#enabled--true-4">enabled = true</a></h4>
<p>设置为<code>false</code>，禁用CQs。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_ENABLED</code></p>
<h4 id="log-enabled--true-1"><a class="header" href="#log-enabled--true-1">log-enabled = true</a></h4>
<p>设置为<code>false</code>，禁用CQ事件的日志记录。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_LOG_ENABLED</code></p>
<h4 id="query-stats-enabled--false"><a class="header" href="#query-stats-enabled--false">query-stats-enabled = false</a></h4>
<p>当设置为<code>true</code>时，连续查询执行统计信息将被写入默认监视存储区。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_QUERY_STATS_ENABLED</code></p>
<h4 id="run-interval--1s"><a class="header" href="#run-interval--1s">run-interval = &quot;1s&quot;</a></h4>
<p>CnosDB检查CQ是否需要运行的时间间隔。将此选项设置为CQs运行的最低时间间隔。例如，如果你最频繁的CQ每分钟运行，设置运行间隔为1米。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_RUN_INTERVAL</code></p>
<h3 id="传输层安全"><a class="header" href="#传输层安全">传输层安全</a></h3>
<p>如果没有指定TLS配置设置，则根据用于构建CnosDB的Go<code>crypto/tls</code>包文档中的常量部分，CnosDB支持列出的所有加密套件id和实现的所有TLS版本。使用<code>SHOW DIAGNOSTICS</code>命令查看用于构建CnosDB的Go版本。</p>
<h4 id="min-version--tls10"><a class="header" href="#min-version--tls10">min-version = &quot;tls1.0&quot;</a></h4>
<p>即将协商的TLS协议的最小版本。有效值包括:<code>tls1.0</code>、<code>tls1.1</code>、<code>tls1.2</code>。如果不指定，则<code>min-version</code>为Go<code>crypto/TLS</code>包中指定的TLS最小版本。在本例中，<code>tls1.0</code>将最小版本指定为<code>tls1.0</code>。环境变量:<code>CNOSDB_TLS_MIN_VERSION</code></p>
<h4 id="max-version--tls12"><a class="header" href="#max-version--tls12">max-version = &quot;tls1.2&quot;</a></h4>
<p>即将协商的TLS协议的最大版本。有效值包括:<code>tls1.0</code>、<code>tls1.1</code>、<code>tls1.2</code>。<code>max-version</code>为Go<code>crypto/TLS</code>包中指定的最大TLS版本号。在本例中，tls1.2将最大版本指定为TLS 1.2。环境变量:<code>CNOSDB_TLS_MAX_VERSION</code></p>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-1"><a class="header" href="#cnosdb-1">cnosdb</a></h1>
<p><code>cnosdb</code>命令用于启动 CnosDB 服务或相关功能。</p>
<h2 id="命令介绍"><a class="header" href="#命令介绍">命令介绍</a></h2>
<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody>
<tr><td>backup</td><td>创建数据节点的备份</td></tr>
<tr><td>config</td><td>显示默认配置项</td></tr>
<tr><td>help</td><td>显示帮助信息</td></tr>
<tr><td>restore</td><td>使用数据节点的备份进行恢复</td></tr>
<tr><td>run</td><td>启动服务</td></tr>
<tr><td>version</td><td>显示版本信息</td></tr>
</tbody></table>
<ul>
<li>
<h4 id="cnosdb-run"><a class="header" href="#cnosdb-run"><code>cnosdb [run]</code></a></h4>
<p>启动服务。</p>
<pre><code>cnosdb [run] [flags]
</code></pre>
<h4 id="参数介绍-2"><a class="header" href="#参数介绍-2"><em>参数介绍</em></a></h4>
</li>
</ul>
<table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>--config</code></td><td>配置文件路径</td></tr>
<tr><td><code>--pidfile</code></td><td>将进程 ID 写入指定文件</td></tr>
<tr><td><code>--cpuprofile</code></td><td>将 CPU 信息写入指定文件</td></tr>
<tr><td><code>--memprofile</code></td><td>将内存使用记录写入指定文件</td></tr>
</tbody></table>
<ul>
<li>
<h4 id="cnosdb-backup"><a class="header" href="#cnosdb-backup"><code>cnosdb backup</code></a></h4>
<p>从指定数据节点创建数据库快照，并保存到 PATH 对应目录。</p>
<pre><code>cnosdb backup [flags] PATH
</code></pre>
<h4 id="参数介绍-3"><a class="header" href="#参数介绍-3">参数介绍</a></h4>
</li>
</ul>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>数据库名称；可选；如果未指定则备份所有数据库。</td></tr>
<tr><td><code>--rp</code></td><td>数据保留策略；可选；如果未指定则备份所有数据保留策略。</td></tr>
<tr><td><code>--shard</code></td><td>分片编号；可选；如果需要使用该参数，则需要同时使用 <code>-rp</code> 参数。</td></tr>
<tr><td><code>--start</code></td><td>备份中包含的数据的最小时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--end</code></td><td>备份中包含的数据的最大时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--skip-errors</code></td><td>创建某分片的备份时，若发生错误，继续创建剩余分片的备份。</td></tr>
</tbody></table>
<ul>
<li>
<h4 id="cnosdb-restore"><a class="header" href="#cnosdb-restore"><code>cnosdb restore</code></a></h4>
<p>从指定的备份目录中恢复数据和元数据。恢复开始时，服务将被关闭。</p>
<pre><code>cnosdb restore [flags]
</code></pre>
<h4 id="参数介绍-4"><a class="header" href="#参数介绍-4">参数介绍</a></h4>
</li>
</ul>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>从备份数据中恢复的数据库名称。</td></tr>
<tr><td><code>--newdb</code></td><td>创建新数据库以导入备份数据；可选；如果未指定，则使用 <code>--db &lt;db_name&gt;</code> 中指定的数据库名称。该参数指定的数据库名称在目标系统中不能重复。</td></tr>
<tr><td><code>--rp</code></td><td>从备份数据中恢复的数据库保留策略名称；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 参数。</td></tr>
<tr><td><code>--newrp</code></td><td>将备份数据导入其他的数据保留策略；可选；如果未指定，则使用 <code>--rp</code> 中指定的数据保留策略名称。</td></tr>
<tr><td><code>--shard</code></td><td>从备份数据中恢复的分片编号；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 和 <code>--rp</code> 参数。</td></tr>
</tbody></table>
<ul>
<li>
<h4 id="cnosdb-config"><a class="header" href="#cnosdb-config"><code>cnosdb config</code></a></h4>
<p>显示服务运行时的默认配置。</p>
<pre><code>cnosdb config [flags]
</code></pre>
<h4 id="参数介绍-5"><a class="header" href="#参数介绍-5">参数介绍</a></h4>
</li>
</ul>
<table><thead><tr><th style="text-align: left">Flag</th><th style="text-align: left"></th><th>Description</th></tr></thead><tbody>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>--config</code></td><td>指定配置文件路径。若需要禁止从文件中加载配置项，可将该值设为 <code>/dev/null</code> 。</td></tr>
<tr><td style="text-align: left"><code>-h</code></td><td style="text-align: left"><code>--help</code></td><td>显示 <code>cnosdb config</code> 的帮助信息。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<h3 id="cnosdb-cli-1"><a class="header" href="#cnosdb-cli-1"><strong>cnosdb-cli</strong></a></h3>
<p>启动交互式命令行程序并连接 <code>cnosdb</code> 服务，以实现数据的写入、查询。</p>
<pre><code>cnosdb-cli [flags]
</code></pre>
<h4 id="参数介绍-6"><a class="header" href="#参数介绍-6">参数介绍</a></h4>
</li>
</ul>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>连接的 cnosdb HTTP 协议地址 (default: <code>http://localhost:8086</code>)</td></tr>
<tr><td><code>--port</code></td><td>连接的 cnosdb 的端口号</td></tr>
<tr><td><code>--password</code></td><td>连接服务时使用的密码</td></tr>
<tr><td><code>--username</code></td><td>连接服务时使用的用户名</td></tr>
<tr><td><code>--ssl</code></td><td>连接时使用 HTTPS 协议</td></tr>
<tr><td><code>--format</code></td><td>指定打印 cnosdb 服务的响应内容的格式: json, csv, or column</td></tr>
<tr><td><code>--precision</code></td><td>指定时间戳的格式: rfc3339, h, m, s, ms, u or ns</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<h3 id="cnosdb_inspect"><a class="header" href="#cnosdb_inspect">cnosdb_inspect</a></h3>
<p>CnosDB Inspect 是一个 CnosDB 磁盘实用程序，可用于：</p>
<ul>
<li>查看有关磁盘分片的详细信息。</li>
<li>将数据从分片导出到可以插入回数据库的CnosDB 线路协议。</li>
<li>将 TSM 索引分片转换为 TSI 索引分片。</li>
</ul>
<p><strong>语法</strong></p>
<pre><code>cnosdb_inspect [ [ command ] [ options ] ]
</code></pre>
<ul>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#deletetsm">deletetsm</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#dumptsm">dumptsm</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#dumptsi">dumptsi</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#buildtsi">buildtsi</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#dumptsmwal">dumptsmwal</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#report-disk">report-disk</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#report">report</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#reporttsi">reporttsi</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#verify">verify</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#verify-seriesfile">verify-seriesfile</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#verify-tombstone">verify-tombstone</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#export">export</a></li>
</ul>
</li>
<li>
<h3 id="deletetsm"><a class="header" href="#deletetsm"><code>deletetsm</code></a></h3>
<h4 id="cnosdb_inspect-deletetsm"><a class="header" href="#cnosdb_inspect-deletetsm"><code>cnosdb_inspect deletetsm</code></a></h4>
<p>批量从原始 <code>TSM</code> 文件中删除<code>measurement</code>数据</p>
<h4 id="注意仅当您的cnosdb离线cnosdb服务未运行-时才使用deletetsm"><a class="header" href="#注意仅当您的cnosdb离线cnosdb服务未运行-时才使用deletetsm">注意：仅当您的<code>CnosDB</code>离线（<code>CnosDB</code>服务未运行） 时才使用<code>deletetsm</code>。</a></h4>
<h4 id="语法"><a class="header" href="#语法">语法</a></h4>
<pre><code>cnosdb_inspect deletetsm --measurement &lt;measurement_name&gt; [ arguments ] &lt;path&gt;
</code></pre>
<p><code>&lt;path&gt;</code></p>
<p>文件的路径<code>.tsm</code>，默认位于<code>data</code>目录中。</p>
<p>指定路径时，通配符 (<code>*</code>) 可以替换一个或多个字符。</p>
<h4 id="选项"><a class="header" href="#选项">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>--measurement</code></p>
<p>要从 TSM 文件中删除的<code>measurement</code>的名称。</p>
<p><code>[ --sanitize]</code></p>
<p>标记以删除包含不可打印的 <code>Unicode </code>字符的所有键。</p>
<p><code>[--v]</code></p>
<p>标记以启用详细日志记录。</p>
<h4 id="例子"><a class="header" href="#例子">例子</a></h4>
<p>从单个<code>shard</code>中删除一个<code>measurement</code></p>
<pre><code>./cnosdb_inspect deletetsm --sanitize /cnosdb/data/location/autogen/1384/*.tsm
</code></pre>
<p>从数据库中的所有<code>shard</code>中删除<code>measurement</code></p>
<pre><code>./cnosdb_inspect deletetsm --sanitize /cnosdb/data/location/autogen/*/*.tsm
</code></pre>
</li>
<li>
<h3 id="dumptsm"><a class="header" href="#dumptsm"><code>dumptsm</code></a></h3>
<h4 id="cnosdb_inspect-dumptsm"><a class="header" href="#cnosdb_inspect-dumptsm"><code>cnosdb_inspect dumptsm</code></a></h4>
<p>转储<code>tsm1</code>文件的底层细节，包括<code>TSM</code>文件和<code>WAL</code>文件</p>
<h4 id="语法-1"><a class="header" href="#语法-1">语法</a></h4>
<p><code>cnosdb_inspect dumptsm [ options ] &lt;path&gt;</code></p>
<p><code>&lt;path&gt;</code></p>
<p>文件的路径<code>.tsm</code>，默认位于<code>data</code>目录中。</p>
<h4 id="选项-1"><a class="header" href="#选项-1">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ --index ]</code></p>
<p>用于转储原始索引数据的标志。默认值为<code>false</code>。</p>
<p><code>[ --blocks ]</code></p>
<p>转储原始块数据的标志。默认值为<code>false</code>。</p>
<p><code>[ --all ]</code></p>
<p>标志转储所有数据。注意：这可能会打印很多信息。默认值为<code>false</code>。</p>
<p><code>[ --filter-key &lt;key_name&gt; ]</code></p>
<p>仅显示与此键子字符串匹配的索引数据和块数据。默认值为<code>&quot;&quot;</code>。</p>
</li>
<li>
<h3 id="dumptsi"><a class="header" href="#dumptsi"><code>dumptsi</code></a></h3>
<h4 id="cnosdb_inspect-dumptsi-1"><a class="header" href="#cnosdb_inspect-dumptsi-1"><code>cnosdb_inspect dumptsi</code></a></h4>
<p>转储有关<code>TSI</code>文件的底层信息，包括<code>.tsl</code>日志文件和<code>.tsi</code>文件</p>
<h4 id="语法-2"><a class="header" href="#语法-2">语法</a></h4>
<p><code>cnosdb_inspect dumptsi [ options ] &lt;index_path&gt;</code></p>
<p>若未指定任何选项，则会为每个文件提供汇总信息。</p>
<h4 id="选项-2"><a class="header" href="#选项-2">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>--series-file &lt;series_path&gt;</code></p>
<p><code>_series</code>数据库目录下的目录路径<code>data</code>。必须要有。</p>
<p><code>[ --series]</code></p>
<p>转储原始系列数据。</p>
<p><code>[ --measurements]</code></p>
<p>转储原始测量数据。
<code> [ --tag-keys]</code></p>
<p>转储原始标签键。</p>
<p><code>[ --tag-values]</code></p>
<p>转储原始标签值。</p>
<p><code>[ --tag-value-series]</code></p>
<p>为每个标签值转储原始系列。</p>
<p><code>[ --measurement-filter &lt;regular_expression&gt;]</code></p>
<p>通过测量正则表达式过滤数据。</p>
<p><code>[ --tag-key-filter &lt;regular_expression&gt;]</code></p>
<p>按标签键正则表达式过滤数据。</p>
<p><code>[ --tag-value-filter &lt;regular_expresssion&gt;]</code></p>
<p>按标签值正则表达式过滤数据。</p>
<h4 id="例子-1"><a class="header" href="#例子-1">例子</a></h4>
<p>指定_series和index目录的路径</p>
<p><code>cnsodb_inspect dumptsi --series-file /path/to/db/_series /path/to/index</code></p>
<p>指定_series目录和index文件的路径</p>
<p><code>cnosdb_inspect dumptsi --series-file /path/to/db/_series /path/to/index/file0</code></p>
<p>指定_series目录和多个index文件的路径</p>
<pre><code>cnosdb_inspect dumptsi --series-file /path/to/db/_series /path/to/index/file0 /path/to/index/file1 ...
</code></pre>
</li>
<li>
<h3 id="buildtsi"><a class="header" href="#buildtsi"><code>buildtsi</code></a></h3>
<h4 id="cnosdb_inspect-buildtsi-1"><a class="header" href="#cnosdb_inspect-buildtsi-1"><code>cnosdb_inspect buildtsi</code></a></h4>
<p>构建基于 TSI（时间序列索引）磁盘的分片索引文件和关联的序列文件。索引被写入一个临时位置直到完成，然后移动到一个永久位置。如果发生错误，则此操作将回退到原始内存索引。</p>
<h4 id="注意-仅适用于离线转换-启用-tsi-后新分片使用-tsi-索引现有分片继续作为基于-tsm-的分片直到离线转换"><a class="header" href="#注意-仅适用于离线转换-启用-tsi-后新分片使用-tsi-索引现有分片继续作为基于-tsm-的分片直到离线转换">注意： 仅适用于离线转换。 启用 TSI 后，新分片使用 TSI 索引。现有分片继续作为基于 TSM 的分片，直到离线转换。</a></h4>
<h4 id="语法-3"><a class="header" href="#语法-3">语法</a></h4>
<pre><code>cnosdb_inspect buildtsi [ options ] -datadir &lt;data_dir&gt; -waldir &lt;wal_dir&gt; [ options ]
</code></pre>
<p>####注意：将buildtsi命令与您要运行数据库的用户帐户一起使用，或者在运行命令后确保权限匹配。</p>
<h4 id="选项-3"><a class="header" href="#选项-3">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ --batch-size ]</code></p>
<p>写入索引的批次大小。默认值为<code>10000</code>。设置此值会对性能和堆大小产生不利影响。</p>
<p><code>[ --compact-series-file]</code></p>
<p>压缩现有<code>series</code>文件，包括离线<code>series</code>。迭代每个<code>segment</code>中的<code>series</code>并将<code>Index</code>中的<code>non-tombstoned series</code>重写到旁边的新 <code>.tmp </code>文件。转换所有<code>segment</code>后，临时文件将覆盖原始段。</p>
<p><code>[ --concurrency ]</code></p>
<p>专用于分片索引的工作人员数量。默认值为<code>GOMAXPROCS</code>。</p>
<p><code>[ --database &lt;db_name&gt; ]</code></p>
<p>数据库的名称。</p>
<p><code>--datadir &lt;data_dir&gt;</code></p>
<p><code>data</code>的文件路径。</p>
<p><code>[ --max-cache-size ]</code></p>
<p>开始拒绝写入之前缓存的最大大小。此值覆盖的配置设置 <code>[data] cache-max-memory-size</code>。默认值为<code>1073741824</code>。</p>
<p><code>[ --max-log-file-size ]</code></p>
<p>日志文件的最大大小。默认值为<code>1048576</code>。</p>
<p><code>[ --retention &lt;rp_name&gt; ]</code></p>
<p>保留策略的名称。</p>
<p><code>[ --shard &lt;shard_ID&gt; ]</code></p>
<p>分片的标识符。</p>
<p><code>[ --v ]</code></p>
<p>以详细模式启用输出的标志。
<code> --waldir &lt;wal_dir&gt;</code></p>
<p><code>WAL</code>（预写日志）文件的目录。</p>
<h4 id="例子-2"><a class="header" href="#例子-2">例子</a></h4>
<p>转换节点上的所有<code>shard</code></p>
<p><code>cnosdb_inspect buildtsi --datadir ~/.cnosdb/data --waldir ~/.cnosdb/wal</code></p>
<p>转换数据库的所有<code>shard</code></p>
<p><code>cnosdb_inspect buildtsi --database mydb --datadir ~/.cnosdb/data --waldir ~/.cnosdb/wal</code></p>
<p>转换特定<code>shard</code></p>
<pre><code>cnodb_inspect buildtsi --database stress -shard 1 --datadir ~/.cnosdb/data --waldir ~/.cnosdb/wal
</code></pre>
</li>
<li>
<h3 id="dumptsmwal"><a class="header" href="#dumptsmwal"><code>dumptsmwal</code></a></h3>
<h4 id="cnosdb_inspect-dumptsmwal"><a class="header" href="#cnosdb_inspect-dumptsmwal"><code>cnosdb_inspect dumptsmwal</code></a></h4>
<p>仅转储一个或多个 WAL ( <code>.wal</code>) 文件中的所有条目，并排除 TSM ( <code>.tsm</code>) 文件</p>
<h4 id="语法-4"><a class="header" href="#语法-4">语法</a></h4>
<pre><code>cnosdb_inspect dumptsmwal [ options ] &lt;wal_dir&gt;
</code></pre>
<h4 id="选项-4"><a class="header" href="#选项-4">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ --show-duplicates]</code></p>
<p>标记以显示具有重复或无序<code>timestamp</code>的<code>key</code>。如果用户使用客户端设置的<code>timestamp</code>写入点，则可以写入具有相同<code>timestamp</code>（或具有时间降序<code>timestamp</code>）的多个点。</p>
</li>
<li>
<h3 id="report-disk"><a class="header" href="#report-disk"><code>report-disk</code></a></h3>
<h4 id="cnosdb_inspect-report"><a class="header" href="#cnosdb_inspect-report"><code>cnosdb_inspect report</code></a></h4>
<p>使用<code>report-disk</code>命令查看指定目录下的<code>TSM</code>文件的<code>shards</code>和<code>measurements</code>的磁盘使用情况。</p>
<h4 id="语法-5"><a class="header" href="#语法-5">语法</a></h4>
<p><code>cnosdb_inspect report-disk [ options ]</code></p>
<h4 id="选项-5"><a class="header" href="#选项-5">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ --detailed]</code></p>
<p>包括<code>flag</code>来报告<code>measurements</code>的磁盘使用情况。</p>
</li>
<li>
<h3 id="report"><a class="header" href="#report"><code>report</code></a></h3>
<h4 id="cnosdb_inspect-report-1"><a class="header" href="#cnosdb_inspect-report-1"><code>cnosdb_inspect report</code></a></h4>
<p>显示所有<code>shard</code>的系列元数据。默认位置是<code>$HOME/.cnosdb</code>。</p>
<h4 id="语法-6"><a class="header" href="#语法-6">语法</a></h4>
<p><code>cnosdb_inspect report [ options ]</code></p>
<h4 id="选项-6"><a class="header" href="#选项-6">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ --pattern &quot;&lt;regular expression/wildcard&gt;&quot;]</code></p>
<p>匹配包含文件的正则表达式或通配符模式。默认值为<code>&quot;&quot;</code>。</p>
<p><code>[ --detailed]</code></p>
<p>报告详细基数估计的标志。默认值为<code>false</code>。</p>
<p><code>[ --exact]</code></p>
<p>报告确切基数而不是估计值的标志。默认值为<code>false</code>。注意：这会占用大量内存。</p>
</li>
<li>
<h3 id="reporttsi"><a class="header" href="#reporttsi"><code>reporttsi</code></a></h3>
<h4 id="cnosdb_inspect-reporttsi"><a class="header" href="#cnosdb_inspect-reporttsi"><code>cnosdb_inspect reporttsi</code></a></h4>
<ul>
<li>计算数据库中的总精确<code>series</code>基数。</li>
<li>通过<code>measurements</code>分割<code>series</code>，并发出这些<code>series</code>值。</li>
<li>为数据库中的每个<code>shard</code>发出总的精确基数。</li>
<li>每个<code>shard</code>的<code>segment</code>是<code>shard</code>中每个<code>measurement</code>的确切基数。</li>
<li>可以选择将每个<code>shard</code>中的结果限制为“前 n 个”。</li>
</ul>
<h4 id="语法-7"><a class="header" href="#语法-7">语法</a></h4>
<p><code>cnosdb_inspect reporttsi --db-path &lt;path-to-db&gt; [ options ]</code></p>
<h4 id="选项-7"><a class="header" href="#选项-7">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>-db-path &lt;path-to-db&gt;</code></p>
<p>数据库的路径。</p>
<p><code>[ -top &lt;n&gt;]</code></p>
<p>将结果限制为每个<code>shard</code>中指定的数字。</p>
</li>
<li>
<h3 id="verify"><a class="header" href="#verify"><code>verify</code></a></h3>
<h4 id="cnosdb_inspect-verify"><a class="header" href="#cnosdb_inspect-verify"><code>cnosdb_inspect verify</code></a></h4>
<p>验证 <code>TSM</code>文件的完整性。</p>
<h4 id="语法-8"><a class="header" href="#语法-8">语法</a></h4>
<p><code>cnosdb_inspect verify [ options ]</code></p>
<h4 id="选项-8"><a class="header" href="#选项-8">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>--dir &lt;storage_root&gt;</code>
存储根目录的路径。默认值为&quot;<code>/root/.cnosdb</code>&quot;.</p>
</li>
<li>
<h3 id="verify-seriesfile"><a class="header" href="#verify-seriesfile"><code>verify-seriesfile</code></a></h3>
<h4 id="cnosdb_inspect-verify-seriesfile"><a class="header" href="#cnosdb_inspect-verify-seriesfile"><code>cnosdb_inspect verify-seriesfile</code></a></h4>
<p>验证 <code>series</code>文件的完整性。</p>
<h4 id="语法-9"><a class="header" href="#语法-9">语法</a></h4>
<p><code>cnosdb_inspect verify-series [ options ]</code></p>
<h4 id="选项-9"><a class="header" href="#选项-9">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ --c &lt;number&gt;]</code></p>
<p>指定要为此命令运行的并发工作人员的数量。默认值等于 GOMAXPROCS 的值。如果性能受到不利影响，您可以设置一个较低的值。</p>
<p><code>[ --dir &lt;path&gt;]</code></p>
<p>指定根数据路径。默认为<code>~/.cnosdb/data</code>.</p>
<p><code>[ --db &lt;db_name&gt;]</code></p>
<p>将验证系列文件限制为数据目录中的指定数据库。</p>
<p><code>[ --series-file &lt;path&gt;]</code></p>
<p>特定系列文件的路径；覆盖-<code>db</code>和<code>-dir</code>.</p>
<p><code>[ --v]</code></p>
<p>启用详细日志记录。</p>
</li>
<li>
<h3 id="verify-tombstone"><a class="header" href="#verify-tombstone"><code>verify-tombstone</code></a></h3>
<h4 id="cnosdb_inspect-verify-tombstone"><a class="header" href="#cnosdb_inspect-verify-tombstone"><code>cnosdb_inspect verify-tombstone</code></a></h4>
<p>验证 <code>tombstone</code>文件的完整性。</p>
<h4 id="语法-10"><a class="header" href="#语法-10">语法</a></h4>
<p><code>cnosdb_inspect verify-tombstone [ options ]</code></p>
<h4 id="选项-10"><a class="header" href="#选项-10">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ -dir &lt;path&gt;]</code></p>
<p>指定根数据路径。默认为<code>~/.cnosdb/data</code>. 该路径可以是任意的，例如，它不需要是<code>CnosDB</code>数据目录。</p>
<p><code>[ --v]</code></p>
<p>启用详细日志记录。确认正在验证文件并每500万条<code>tombstone</code>条目显示进度。</p>
<p><code>[ --vv]</code></p>
<p>启用非常详细的日志记录。显示<code>tombstone</code>文件中每个<code>series key</code>和时间范围。自(1970-01-01T00:00:00Z)以来的时间戳以纳秒为单位显示。</p>
<p><code>[ --vvv]</code></p>
<p>启用非常非常详细的日志记录。显示<code>tombstone</code>文件中每个<code>series key</code>和时间范围。时间戳以<code>RFC3339</code>格式显示，精度为纳秒。</p>
</li>
<li>
<h3 id="export"><a class="header" href="#export"><code>export</code></a></h3>
<h4 id="cnosdb_inspect-export"><a class="header" href="#cnosdb_inspect-export"><code>cnosdb_inspect export</code></a></h4>
<p>以 <code>CnosDB</code> 线路协议数据格式导出所有 <code>TSM</code> 文件。为所有 <code>WAL</code> 文件写入数据<code>_internal/monitor</code>。可以使用<code>cnosdb</code>命令导入此输出文件。</p>
<h4 id="语法-11"><a class="header" href="#语法-11">语法</a></h4>
<p><code>cnosdb_inspect export [ options ]</code></p>
<h4 id="选项-11"><a class="header" href="#选项-11">选项</a></h4>
<p>可选参数在括号中</p>
<p><code>[ --compress]</code></p>
<p>使用 gzip 压缩来压缩输出的标志。默认值为<code>false</code>。</p>
<p><code>[ --database &lt;db_name&gt;]</code></p>
<p>要导出的数据库的名称。默认值为<code>&quot;&quot;</code>.</p>
<p><code>--datadir &lt;data_dir&gt;</code></p>
<p>目录的路径<code>data</code>。默认值为&quot;<code>$HOME/.cnosdb/data</code>&quot;。</p>
<p><code>[ --end &lt;timestamp&gt;]</code></p>
<p>时间范围结束的时间戳。必须是<code>RFC3339 </code>格式。</p>
<p>RFC3339 需要非常具体的格式。例如，要指示没有时区偏移 (UTC+0)，您必须在秒后包含 Z 或 +00:00。有效 RFC3339 格式的示例包括：</p>
<h4 id="无偏移"><a class="header" href="#无偏移"><code>无偏移</code></a></h4>
<blockquote>
<p>YYYY-MM-DDTHH:MM:SS+00:00</p>
<p>YYYY-MM-DDTHH:MM:SSZ</p>
<p>YYYY-MM-DDTHH:MM:SS.nnnnnnZ (fractional seconds (.nnnnnn) are optional)</p>
</blockquote>
<h4 id="带偏移"><a class="header" href="#带偏移"><code>带偏移</code></a></h4>
<blockquote>
<p>YYYY-MM-DDTHH:MM:SS-08:00</p>
<p>YYYY-MM-DDTHH:MM:SS+07:00</p>
</blockquote>
<p><code>[ --out &lt;export_dir&gt;]</code>
导出文件的位置。默认值为&quot;<code>$HOME/.cnosdb/export</code>&quot;。</p>
<p><code>[ --retention &lt;rp_name&gt; ]</code>
要导出的保留策略的名称。默认值为<code>&quot;&quot;</code>。</p>
<p><code>[ --start &lt;timestamp&gt;]</code>
时间范围开始的时间戳。时间戳字符串必须采用<code>RFC3339 </code>格式。</p>
<p><code>[ --waldir &lt;wal_dir&gt;]</code>
<code>WAL</code>目录的路径。默认值为&quot;<code>$HOME/.cnosdb/wal</code>&quot;。</p>
<h4 id="例子-3"><a class="header" href="#例子-3">例子</a></h4>
<p>导出所有数据库并压缩输出</p>
<p><code>cnosdb_inspect export --compress</code></p>
<p>从特定数据库和保留策略中导出数据</p>
<p><code>cnosdb_inspect export --database mydb -retention autogen</code></p>
<p>输出文件</p>
<pre><code>#DDL
CREATE DATABASE MY_DB_NAME

CREATE RETENTION POLICY autogen ON MY_DB_NAME DURATION inf REPLICATION 1

# DML

# CONTEXT-DATABASE:MY_DB_NAME

# CONTEXT-RETENTION-POLICY:autogen

randset value=97.9296104805 1439856000000000000

randset value=25.3849066842 1439856100000000000

</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><ul>
<li>
<h3 id="查询入门"><a class="header" href="#查询入门">查询入门</a></h3>
<h4 id="查看所有-measurements"><a class="header" href="#查看所有-measurements">查看所有 <code>measurements</code></a></h4>
<pre><code>SHOW MEASUREMENTS
</code></pre>
<h4 id="计算air中temperature的数量"><a class="header" href="#计算air中temperature的数量">计算<code>air</code>中<code>temperature</code>的数量</a></h4>
<p><code>  SELECT COUNT(&quot;temperature&quot;) FROM air</code></p>
<h4 id="查看air中的前五个值"><a class="header" href="#查看air中的前五个值">查看<code>air</code>中的前五个值</a></h4>
<p><code>SELECT * FROM air LIMIT 5</code></p>
<h4 id="指定字段的标识符号"><a class="header" href="#指定字段的标识符号">指定字段的标识符号</a></h4>
<pre><code> SELECT &quot;temperature&quot;::field,&quot;station&quot;::tag,&quot;visibility&quot;::field FROM &quot;air&quot; limit 10
</code></pre>
<h4 id="查看measurement的tag-key"><a class="header" href="#查看measurement的tag-key">查看<code>measurement</code>的tag key</a></h4>
<p><code> SHOW TAG KEYS FROM air</code></p>
<h4 id="查看tag-value"><a class="header" href="#查看tag-value">查看tag value</a></h4>
<p><code> SHOW TAG VALUES FROM air WITH KEY = &quot;station&quot;</code></p>
<h4 id="查看field-key"><a class="header" href="#查看field-key">查看field key</a></h4>
<p><code> SHOW FIELD KEYS FROM air</code></p>
<h4 id="查看series"><a class="header" href="#查看series">查看series</a></h4>
<p><code>SHOW SERIES</code></p>
<h4 id="函数使用"><a class="header" href="#函数使用">函数使用</a></h4>
<blockquote>
<p><a href="https://www.cnosdb.com/content/cnosdb/0.10/cnosql/function.html">更多</a></p>
</blockquote>
<p><code> SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;</code></p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><div style="break-before: page; page-break-before: always;"></div><h3 id="数据库管理"><a class="header" href="#数据库管理">数据库管理</a></h3>
<h4 id="创建数据库"><a class="header" href="#创建数据库">创建数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE DATABASE &lt;database_name&gt; [WITH [DURATION &lt;duration&gt;] [REPLICATION &lt;n&gt;] [SHARD DURATION &lt;duration&gt;] [NAME &lt;rp-name&gt;]]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>CREATE DATABASE</code>需要一个数据库名称，其他都为可选项。如果未在<code>WITH</code>后面指定保留策略，则会创建一个默认的保留策略，名称为<code>autogen</code>。</p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>NAME</code>指定保留策略名称。</p>
<p><code>CREATE DATABASE</code>成功执行后不会返回任何结果。</p>
<p><strong>示例</strong></p>
<p>创建数据库</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，CnosDB还会在其下创建一个名为<code>autogen</code>的保留策略。</p>
</blockquote>
<pre><code class="language-sql"> CREATE DATABASE &quot;cnos&quot;
</code></pre>
<p>创建数据库并指定保留策略</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，并指定保留策略为<code>1d_events</code>，它的生命周期为总保留时长为一天，副本数为1，每个分片的的窗口长度为一小时。</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE DATABASE &quot;cnos&quot; WITH DURATION 1d REPLICATION 1 SHARD DURATION 1h NAME &quot;1d_events&quot;
</code></pre>
<h4 id="显示数据库"><a class="header" href="#显示数据库">显示数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code>SHOW DATABASES
</code></pre>
<h4 id="删除数据库"><a class="header" href="#删除数据库">删除数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP DATABASE &lt;database_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP DATABASE</code>会删除数据库下所有数据。</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP DATABASE &quot;cnos&quot;
</code></pre>
<h3 id="保留策略管理"><a class="header" href="#保留策略管理">保留策略管理</a></h3>
<h4 id="创建保留策略"><a class="header" href="#创建保留策略">创建保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; [SHARD DURATION &lt;duration&gt;] [DEFAULT]
</code></pre>
<p><strong>描述</strong></p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>DEFAULT</code>可选项，指定其是否为默认保留策略</p>
<p><strong>示例</strong></p>
<p>创建保留策略</p>
<blockquote>
<p>该语句创建了一个名为<code>1d_events</code>的保留策略，并且副本数为1</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 1d REPLICATION 1
&gt;
</code></pre>
<p>创建默认保留策略</p>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 23h60m REPLICATION 1 DEFAULT
&gt;
</code></pre>
<h4 id="显示保留策略"><a class="header" href="#显示保留策略">显示保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code>```sql
SHOW RETENTION POLICIES [ON &lt;database_name&gt;]
```
</code></pre>
<p><strong>示例</strong></p>
<pre><code>```sql
&gt; SHOW RETENTION POLICIES ON &quot;cnos&quot;

name      duration   shardGroupDuration   replicaN   default
----      --------   ------------------   --------   -------
autogen   0s         168h0m0s             1          true
```
</code></pre>
<h4 id="修改保留策略"><a class="header" href="#修改保留策略">修改保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; SHARD DURATION &lt;duration&gt; DEFAULT
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 7 SHARD DURATION 1d DEFAULT
</code></pre>
<h4 id="删除保留策略"><a class="header" href="#删除保留策略">删除保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt;
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">&gt; DROP RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot;
&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="schema查询"><a class="header" href="#schema查询">schema查询</a></h2>
<h3 id="显示series"><a class="header" href="#显示series">显示<code>SERIES</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW SERIES [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; [ '&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW SERIES</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW SERIES ON &quot;oceanic_station&quot; WHERE time &gt; now() - 1m LIMIT 10
</code></pre>
<h3 id="使用drop删除series"><a class="header" href="#使用drop删除series">使用<code>DROP</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SERIES FROM &lt;measurement_name[,measurement_name]&gt; WHERE &lt;tag_key&gt;='&lt;tag_value&gt;'
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据以及数据所对应的索引</p>
<p><strong>示例</strong></p>
<p>从一个<code>measurement</code>中删除所有<code>series</code></p>
<pre><code class="language-sql">&gt; DROP SERIES FROM &quot;oceanic_station&quot;
</code></pre>
<p>从一个<code>measurement</code>中删除具有特定条件的<code>series</code></p>
<pre><code class="language-sql">DROP SERIES FROM &quot;oceanic_station&quot; WHERE &quot;station&quot; = 'XiaoMaiDao'
</code></pre>
<h3 id="使用delete删除series"><a class="header" href="#使用delete删除series">使用<code>DELETE</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DELETE FROM &lt;measurement_name&gt; WHERE [&lt;tag_key&gt;='&lt;tag_value&gt;'] | [&lt;time interval&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据，但是不会删除索引，并且支持时间过滤</p>
<p><strong>示例</strong></p>
<blockquote>
<p>删除2020-01-01之前产生的的所有数据</p>
</blockquote>
<pre><code class="language-sql">&gt; DELETE WHERE time &lt; '2021-01-01'
</code></pre>
<h3 id="显示measurement"><a class="header" href="#显示measurement">显示<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW MEASUREMENTS [ON &lt;database_name&gt;] [WITH MEASUREMENT &lt;operator&gt; ['&lt;measurement_name&gt;' | &lt;regular_expression&gt;]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><code>SHOW MEASUREMENTS</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<blockquote>
<p>该查询返回数据库<code>oceanic_station</code>下<code>tag key</code>   oceanic_station下满足正则表达式air*的一个measurement</p>
</blockquote>
<pre><code class="language-sql">SHOW MEASUREMENTS ON &quot;oceanic_station&quot; WITH MEASUREMENT =~ /air*/
</code></pre>
<h3 id="删除measurement"><a class="header" href="#删除measurement">删除<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &lt;measurement_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP MEASUREMENT</code>会删除指定<code>measurement</code>下所有的数据</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &quot;air&quot;
</code></pre>
<h3 id="显示tag-key"><a class="header" href="#显示tag-key">显示<code>tag key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW tag keys</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON &quot;oceanic_station&quot; FROM &quot;air&quot; LIMIT 1 OFFSET 1
</code></pre>
<h3 id="显示tag-value"><a class="header" href="#显示tag-value">显示<code>tag value</code></a></h3>
<p><strong>语法</strong></p>
<pre><code>```sql
SHOW TAG VALUES [ON &lt;database_name&gt;][FROM_clause] WITH KEY [ [&lt;operator&gt; &quot;&lt;tag_key&gt;&quot; | &lt;regular_expression&gt;] | [IN (&quot;&lt;tag_key1&gt;&quot;,&quot;&lt;tag_key2&quot;)]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
```
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG VALUES ON &quot;oceanic_station&quot; WITH KEY IN (&quot;station&quot;)
</code></pre>
<h3 id="显示field-key"><a class="header" href="#显示field-key">显示<code>field key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS [ON &lt;database_name&gt;] [FROM &lt;measurement_name&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>FROM</code>子句为可选项</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS ON &quot;oceanic_station&quot; FROM &quot;air&quot;
</code></pre>
<h3 id="按时间过滤"><a class="header" href="#按时间过滤">按时间过滤</a></h3>
<p>可以在<code>SHOW TAG KEYS</code>、<code>SHOW TAG VALUES</code> <code>SHOW SERIES</code> <code>SHOW MEASUREMENTS</code> <code>SHOW FIELD KEYS</code>上使用</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON &quot;oceanic_station&quot; where time &gt; now() -1h and time &lt; now()
</code></pre>
<h3 id="删除分片"><a class="header" href="#删除分片">删除分片</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SHARD &lt;shard_id_number&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SHARD</code>会在磁盘上删除有关分片的所有数据以及元数据</p>
<pre><code class="language-sql">&gt; DROP SHARD 1
&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="连续查询-1"><a class="header" href="#连续查询-1">连续查询</a></h2>
<table><thead><tr><th><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></th><th><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95">高级语法</a></th><th><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E7%AE%A1%E7%90%86CQ">管理CQ</a></th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">基本语法示例</a></td><td><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">高级语法示例</a></td><td></td></tr>
</tbody></table>
<ul>
<li>
<h3 id="语法-12"><a class="header" href="#语法-12">语法</a></h3>
<h4 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<p><strong>语法描述</strong></p>
<p>CQ查询必须包含一个函数，一个<code>INTO</code>子句和一个<code>GROUP BY time()</code>子句：</p>
<pre><code class="language-sql">SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</code></pre>
<blockquote>
<p>在<code>WHERE</code>子句中，不需要指定时间范围，CQ查询会为语句自动匹配时间范围</p>
</blockquote>
<h4 id="基本语法示例"><a class="header" href="#基本语法示例">基本语法示例</a></h4>
<p>以下示例使用数据库<code>transportation</code>中的示例数据，<code>bus_data</code>中存储的数据是公交车乘客数量和投诉数量的15分钟数：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers   complaints
2020-08-28T07:00:00Z   5            9
2020-08-28T07:15:00Z   8            9
2020-08-28T07:30:00Z   8            9
2020-08-28T07:45:00Z   7            9
2020-08-28T08:00:00Z   8            9
2020-08-28T08:15:00Z   15           7
2020-08-28T08:30:00Z   15           7
2020-08-28T08:45:00Z   17           7
2020-08-28T09:00:00Z   20           7
</code></pre>
<p><strong>自动采样数据</strong></p>
<p>使用CQ自动从单个字段下采样数据，并将结果写入到同一个数据库的另一个<code>measurement</code>中：</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>自动采样数据并将结果保存到另一个保留策略中</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_rp&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>使用通配符自动下采样数据</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_br&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(*) INTO &quot;downsampled_transportation&quot;.&quot;autogen&quot;.:MEASUREMENT FROM /.*/ GROUP BY time(30m),*
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;downsampled_transportation.&quot;autogen&quot;.&quot;bus_data&quot;
name: bus_data
--------------
time                   mean_complaints   mean_passengers
2020-08-28T07:00:00Z   9                 6.5
2020-08-28T07:30:00Z   9                 7.5
2020-08-28T08:00:00Z   8                 11.5
2020-08-28T08:30:00Z   7                 16
</code></pre>
<p><strong>自动采样数据并配置CQ的时间边界</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_offset&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h,15m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:15:00Z   7.75
2020-08-28T08:15:00Z   16.75
</code></pre>
<h4 id="高级语法"><a class="header" href="#高级语法">高级语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<h4 id="高级语法示例"><a class="header" href="#高级语法示例">高级语法示例</a></h4>
<p>示例数据如下：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers
2020-08-28T06:30:00Z   2
2020-08-28T06:45:00Z   4
2020-08-28T07:00:00Z   5
2020-08-28T07:15:00Z   8
2020-08-28T07:30:00Z   8
2020-08-28T07:45:00Z   7
2020-08-28T08:00:00Z   8
2020-08-28T08:15:00Z   15
2020-08-28T08:30:00Z   15
2020-08-28T08:45:00Z   17
2020-08-28T09:00:00Z   20
</code></pre>
<p><strong>配置时间间隔</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>EVERY</code>来指明CQ的执行间隔</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 30m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>配置CQ的重采样时间范围</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>FOR</code>来指明CQ的时间间隔的长度</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for&quot; ON &quot;transportation&quot;
RESAMPLE FOR 1h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置执行间隔和CQ时间范围</strong></p>
<p>在<code>RESAMPLE</code>子句中使用<code>EVERY</code>和<code>FOR</code>来指定CQ的执行间隔和CQ的时间范围长度。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every_for&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 1h FOR 90m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T06:30:00Z   3
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置CQ的时间范围并填充空值</strong></p>
<p>使用<code>FOR</code>间隔和<code>fill()</code>来更改不含数据的时间间隔值。请注意，至少有一个数据点必须在<code>fill()</code>运行的<code>FOR</code>间隔内。 如果没有数据落在<code>FOR</code>间隔内，则CQ不会将任何数据写入目标<code>measurement</code>。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for_fill&quot; ON &quot;transportation&quot;
RESAMPLE FOR 2h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h) fill(1000)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T05:00:00Z   1000
2020-08-28T06:00:00Z   3
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
2020-08-28T09:00:00Z   20
2020-08-28T10:00:00Z   1000
</code></pre>
</li>
<li>
<h3 id="管理cq"><a class="header" href="#管理cq">管理CQ</a></h3>
<blockquote>
<p>CQ不能<code>update</code>，只能<code>drop</code>和<code>create</code></p>
</blockquote>
<p><strong>列出所有CQ</strong></p>
<pre><code class="language-sql">SHOW CONTINUOUS QUERIES
</code></pre>
<p><strong>删除CQ</strong></p>
<pre><code class="language-sql">DROP CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosql函数"><a class="header" href="#cnosql函数">CnosQL函数</a></h2>
<ul>
<li>
<h3 id="目录"><a class="header" href="#目录">目录</a></h3>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count">COUNT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#distinct">DISTINCT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#integral">INTEGRAL()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean">MEAN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median">MEDIAN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode">MODE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#spread">SPREAD()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#stddev">STDDEV()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum">SUM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0">选择函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#bottom">BOTTOM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first">FIRST()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last">LAST()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max">MAX()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min">MIN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile">PERCENTILE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sample">SAMPLE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#top">TOP()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">转换函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#abs">ABS()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#acos">ACOS()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#asin">ASIN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#atan">ATAN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#atan2">ATAN2()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#ceil">CEIL()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#cos">COS()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#cumulative-sum">CUMULATIVE_SUM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#derivative">DERIVATIVE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#difference">DIFFERENCE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#elapsed">ELAPSED()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exp">EXP()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#floor">FLOOR()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#histogram">HISTOGRAM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#ln">LN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#log">LOG()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#log2">LOG2()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#log10">LOG10()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#moving-average">MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#non-negative-derivative">NON_NEGATIVE_DERIVATIVE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#non-negative-difference">NON_NEGATIVE_DIFFERENCE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#pow">POW()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#round">ROUND()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sin">SIN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sqrt">SQRT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#tan">TAN()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E9%A2%84%E6%B5%8B%E5%87%BD%E6%95%B0">预测函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#holt_winters">HOLT_WINTERS()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0">分析函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#other">其他</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE">示例数据</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95">函数的通用语法</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%9C%A8SELECT%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">在<code>SELECT</code>中指定多个函数</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%AD%97%E6%AE%B5">重命名查询结果字段</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E6%94%B9%E5%8F%98%E4%B8%8D%E5%90%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">改变不含数据的时间间隔的返回值</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">函数常见问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h3>
<ul>
<li>
<h3 id="count"><a class="header" href="#count">COUNT()</a></h3>
<p>返回非空值 field values数量</p>
<h4 id="语法-13"><a class="header" href="#语法-13">语法</a></h4>
<pre><code class="language-sql">SELECT COUNT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法"><a class="header" href="#嵌套语法">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<p><code>COUNT(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT()</code>支持所有数据类型的<code>field value</code>。cnosQL支持将<a href="content/cnosdb/latest/cnosql/cnosql_function.html#distinct"><code>DISTINCT()</code></a>函数嵌套在<code>COUNT()</code>函数里。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key的field-value的数目"><a class="header" href="#计算指定field-key的field-value的数目">计算指定field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回<code>measurement``air</code>中的<code>temperature</code>的非空field value的数量。</p>
<ul>
<li>
<h4 id="计数measurement中每个field-key关联的field-value的数量"><a class="header" href="#计数measurement中每个field-key关联的field-value的数量">计数measurement中每个field key关联的field value的数量</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(*) FROM &quot;air&quot;
name: air
time                 count_pressure count_temperature count_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 3334           3334              3334
</code></pre>
<p>该查询返回与measurement<code>air</code>相关联的每个field key的非空field value的数量。<code>air</code>有3个field keys：<code>count_pressure</code> <code>count_temperature</code> <code>count_visibility</code></p>
<ul>
<li>
<h4 id="计算匹配一个正则表达式的每个field-key关联的field-value的数目"><a class="header" href="#计算匹配一个正则表达式的每个field-key关联的field-value的数目">计算匹配一个正则表达式的每个field key关联的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(/.*pre.*/) FROM &quot;air&quot;
name: air
time                 count_pressure
----                 --------------
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回measurement<code>air</code>中包含<code>pre</code>的每个field key的非空字段值的数量。</p>
<ul>
<li>
<h4 id="计数包括多个子句的field-key的field-value的数目"><a class="header" href="#计数包括多个子句的field-key的field-value的数目">计数包括多个子句的field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;  SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1ms),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                     count
----                     -----
2022-04-11T08:03:37.071Z 108
2022-04-11T08:03:37.072Z 193
2022-04-11T08:03:37.073Z 207
2022-04-11T08:03:37.074Z 209
2022-04-11T08:03:37.075Z 209
2022-04-11T08:03:37.076Z 218
2022-04-11T08:03:37.077Z 216
</code></pre>
<p>该查询返回<code>pressure</code>field key中的非空field value的数量。它涵盖<code>now()</code>之间的<code>时间段</code>，并将结果分组为1ms的时间间隔和每个tag(表示为以上代码中的<code>*</code>)。并用<code>-1</code>填充空的时间间隔，并返回7个<code>point</code>，表格返回1。</p>
</li>
<li>
<h4 id="计算一个field-key的distinct的field-value的数量"><a class="header" href="#计算一个field-key的distinct的field-value的数量">计算一个field key的distinct的field value的数量</a></h4>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
</li>
</ul>
<p>查询返回measurement为<code>air</code>field<code>为</code>pressure 的唯一field value的数量。</p>
<h4 id="count的常见问题"><a class="header" href="#count的常见问题"><code>COUNT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="count和fill"><a class="header" href="#count和fill"><code>COUNT()</code>和<code>fill()</code></a></h4>
</li>
</ul>
<p>大多数cnosQL函数对于没有数据的时间间隔返回<code>null</code>值，<code>fill(&lt;fill_option&gt;)</code>将该<code>null</code>值替换为<code>fill_option</code>。 <code>COUNT()</code>针对没有数据的时间间隔返回<code>0</code>，<code>fill(&lt;fill_option&gt;)</code>用<code>fill_option</code>替换0值。</p>
<p><em>示例</em></p>
<p>下面的代码块中的第一个查询不包括<code>fill()</code>。最后一个时间间隔没有数据，因此该时间间隔的值返回为零。第二个查询包括<code>fill(-1)</code>; 它将最后一个间隔中的零替换为<code>-1</code>。</p>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),*  LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z 0
2022-04-11T08:03:39Z 0
2022-04-11T08:03:40Z 0
2022-04-11T08:03:41Z 0
2022-04-11T08:03:42Z 0
2022-04-11T08:03:43Z 0

&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z -1
2022-04-11T08:03:39Z -1
2022-04-11T08:03:40Z -1
2022-04-11T08:03:41Z -1
2022-04-11T08:03:42Z -1
2022-04-11T08:03:43Z -1
</code></pre>
<ul>
<li>
<h3 id="distinct"><a class="header" href="#distinct"><code>DISTINCT()</code></a></h3>
<p>返回<code>field value</code>的不重复值列表。</p>
<h4 id="语法-14"><a class="header" href="#语法-14">语法</a></h4>
<pre><code class="language-sql">SELECT DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法-1"><a class="header" href="#嵌套语法-1">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<h4 id="语法描述"><a class="header" href="#语法描述">语法描述</a></h4>
<p><code>DISTINCT(field_key)</code> 返回<code>field key</code>对应的不同<code>field values</code>。</p>
<p><code>DISTINCT()</code> 支持所有数据类型的<code>field value</code>，cnosQL支持<a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>嵌套<code>DISTINCT()</code>。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<ul>
<li>
<h4 id="列出一个field-key的不同的field-value"><a class="header" href="#列出一个field-key的不同的field-value">列出一个<code>field key</code>的不同的<code>field value</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 57
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 60
</code></pre>
<p>该查询返回<code>air</code> measurement中<code>temperature</code>field 关键字中唯一<code>field values</code>的列表</p>
</li>
</ul>
<ul>
<li>
<h4 id="列出包含多个子句的field-key关联的不同值的列表"><a class="header" href="#列出包含多个子句的field-key关联的不同值的列表">列出包含多个子句的field key关联的不同值的列表</a></h4>
<pre><code class="language-sql">&gt;SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE  time &lt;now() GROUP BY time(12m),* SLIMIT 1
name: air
tags: station=LianYunGang
time                 distinct
----                 --------
2022-04-11T08:00:00Z 58
2022-04-11T08:00:00Z 56
2022-04-11T08:00:00Z 59
2022-04-11T08:00:00Z 57
2022-04-11T08:00:00Z 62
2022-04-11T08:00:00Z 60
2022-04-11T08:00:00Z 61
</code></pre>
</li>
</ul>
<p>该查询返回<code>pressure</code>field key中不同field value的列表。它涵盖now()之前的时间段，并将结果按12分钟的时间间隔和每个tag分组。查询限制（SLIMIT）返回一个series。</p>
<ul>
<li>
<h4 id="对一个字段的不同值进行计算"><a class="header" href="#对一个字段的不同值进行计算">对一个字段的不同值进行计算</a></h4>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
</li>
</ul>
<p>查询返回<code>air</code>这个measurement中字段<code>pressure</code>的不同值的数目。</p>
<h4 id="distinct的常见问题"><a class="header" href="#distinct的常见问题"><code>DISTINCT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="distinct-和-into-子句"><a class="header" href="#distinct-和-into-子句"><code>DISTINCT()</code> 和 <code>INTO</code> 子句</a></h4>
</li>
</ul>
<p>在<code>INTO</code>子句中使用<code>DISTINCT()</code>可能会导致CnosDB覆盖目标measurement中的<code>points</code>。<code>DISTINCT()</code>通常返回多个具有相同时间戳的结果；CnosDB假设在相同series中并具有相同时间戳的<code>point</code>是重复<code>point</code>，并简单地用目标measurement中最新的<code>point</code>覆盖重复<code>point</code>。</p>
<p>####示例</p>
<p>下面代码块中的第一个查询使用了<code>DISTINCT()</code>，并返回7个结果。请注意，每个结果都有相同的时间戳。第二个查询将<code>INTO</code>子句添加到查询中，并将查询结果写入measurement <code>distincts</code>。最后一个查询选择measurement <code>distincts</code>中所有数据。
因为原来的四个结果是重复的(它们在相同的series，有相同的时间戳)，所以最后一个查询只返回一个<code>point</code>。当系统遇到重复数据<code>point</code>，它会用最近的<code>point</code>覆盖之前的<code>point</code>。</p>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 60
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 57

&gt; SELECT DISTINCT(&quot;pressure&quot;) INTO &quot;distincts&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 7 

&gt; SELECT * FROM &quot;distincts&quot;
name: distincts
time                 distinct
----                 --------
1970-01-01T00:00:00Z 57
</code></pre>
<ul>
<li>
<h3 id="integral"><a class="header" href="#integral"><code>INTEGRAL()</code></a></h3>
<p>返回<code>field value</code>曲线下的面积，即关于<code>field value</code>的积分。</p>
<h4 id="语法-15"><a class="header" href="#语法-15">语法</a></h4>
<pre><code>SELECT INTEGRAL( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ]  ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-1"><a class="header" href="#语法描述-1">语法描述</a></h4>
<p>CnosDB计算field value曲线下的面积，并将这些结果转换为每个<code>unit</code>的总面积。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>INTEGRAL(field_key)</code>返回field key关联的值之下的面积。</p>
<p><code>INTEGRAL(/regular_expression/)</code>返回满足正则表达式的每个field key关联的值之下的面积。</p>
<p><code>INTEGRAL(*)</code>返回<code>measurement</code>中每个<code>field key</code>关联的值之下的面积。</p>
<p><code>INTEGRAL()</code>不支持<code>fill()</code>，<code>INTEGRAL()</code>支持int64和float64两个数据类型。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<p>下面的五个例子，使用数据库<a href="content/cnosdb/latest/cnosql/oceanic_station.txt"><code>oceanic_station</code>中的数据</a>：</p>
<pre><code class="language-sql">&gt;  SELECT  temperature  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                        temperature
----                        -----------
2022-04-11T08:03:37.07132Z  58
2022-04-11T08:03:37.071378Z 62
2022-04-11T08:03:37.071385Z 58
2022-04-11T08:03:37.071391Z 56
2022-04-11T08:03:37.071394Z 56
2022-04-11T08:03:37.071401Z 59
2022-04-11T08:03:37.071403Z 57
2022-04-11T08:03:37.071406Z 62
2022-04-11T08:03:37.071409Z 59
2022-04-11T08:03:37.071411Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定的field-key的值得积分"><a class="header" href="#计算指定的field-key的值得积分">计算指定的field key的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;SELECT  INTEGRAL(temperature)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10 
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 0.4677579999999999
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以秒为单位）。</p>
<ul>
<li>
<h4 id="计算指定的field-key和时间单位的值的积分"><a class="header" href="#计算指定的field-key和时间单位的值的积分">计算指定的field key和时间单位的值的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以1ms为单位）。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中每个field-key在指定时间单位的值得积分">计算measurement中每个field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(*,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_pressure  integral_temperature integral_visibility
----                 -----------------  -------------------- -------------------
1970-01-01T00:00:00Z 467.22900000000413 467.7580000000045    491.2000000000007
</code></pre>
<p>查询返回measurement<code>air</code>中存储的每个数值字段相关的字段值的曲线下面积（以1ms为单位）</p>
<ul>
<li>
<h4 id="计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分">计算measurement中匹配正则表达式的field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(/temp/,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_temperature
----                 --------------------
1970-01-01T00:00:00Z 467.7580000000045

</code></pre>
<p>查询返回field key包括单词<code>water</code>的每个数值类型的字段相关联的字段值的曲线下的区域（以分钟为单位）。</p>
<ul>
<li>
<h4 id="在含有多个子句中计算指定字段的积分"><a class="header" href="#在含有多个子句中计算指定字段的积分">在含有多个子句中计算指定字段的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now() GROUP BY time(12m) LIMIT 1
name: air
time                 integral_temperature
----                 --------------------
2022-04-11T08:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的field value曲线下的面积(以分钟为单位)，它涵盖的时间范围在now()之前，并将查询结果按12分钟的时间间隔进行分组，同时，该查询将返回的<code>point</code>个数限制为1。</p>
</li>
<li>
<h3 id="mean"><a class="header" href="#mean"><code>MEAN()</code></a></h3>
<p>返回field value的平均值。</p>
<h4 id="语法-16"><a class="header" href="#语法-16">语法</a></h4>
<pre><code>SELECT MEAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MEAN(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的field value的平均值。</p>
<p><code>MEAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值"><a class="header" href="#计算指定field-key对应的field-value的平均值">计算指定field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                   mean
----                   ----
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均值">计算measurement中每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(*) FROM &quot;air&quot; 
name: air
time                 mean_pressure     mean_temperature  mean_visibility
----                 -------------     ----------------  ---------------
1970-01-01T00:00:00Z 59.00689862027595 59.04949010197961 62.01889622075585
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均值">计算与正则表达式匹配的每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(/temp/) FROM &quot;air&quot; 
name: air
time                   mean_temperature
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822523
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均值并包含多个子句">计算指定field key对应的field value的平均值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(9.01) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 mean
----                 ----
2022-04-11T08:00:00Z 59.06864564007421
2022-04-11T08:12:00Z 9.01
2022-04-11T08:24:00Z 9.01
2022-04-11T08:36:00Z 9.01
2022-04-11T08:48:00Z 9.01
2022-04-11T09:00:00Z 9.01
2022-04-11T09:12:00Z 9.01 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value的平均值，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为7和1。</p>
</li>
<li>
<h3 id="median"><a class="header" href="#median">MEDIAN()</a></h3>
<p>返回<code>field value</code>的计算中值。</p>
<h4 id="语法-17"><a class="header" href="#语法-17">语法</a></h4>
<pre><code>SELECT MEDIAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-2"><a class="header" href="#语法描述-2">语法描述</a></h4>
<p><code>MEDIAN(field_key)</code>返回与<code>field key</code>对应的field value的中值。</p>
<p><code>MEDIAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN()</code> 支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong><code>MEDIAN()</code>近似于<code>PERCENTILE(field_key, 50)</code>，除非<code>field key</code>包含的<code>field value</code>有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</p>
</blockquote>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值"><a class="header" href="#计算指定field-key对应的field-value的中值">计算指定field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 median
----                 ------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>pressure</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的中值"><a class="header" href="#计算measurement中每个field-key对应的field-value的中值">计算measurement中每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(*) FROM &quot;air&quot;
name: air
time                 median_pressure median_temperature median_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 59              59                 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的中值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的中值">计算与正则表达式匹配的每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(/temp/) FROM &quot;air&quot;
name: air
time                 median_temperature
----                 ------------------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的中值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的中值并包含多个子句">计算指定field key对应的field value的中值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE  time&lt;now()  GROUP BY time(1m),* fill(-1) LIMIT 7 SLIMIT 3 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 median
----                 ------
2022-04-11T08:03:00Z 59
2022-04-11T08:04:00Z -1
2022-04-11T08:05:00Z -1
2022-04-11T08:06:00Z -1
2022-04-11T08:07:00Z -1
2022-04-11T08:08:00Z -1
2022-04-11T08:09:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均数，它涵盖的时间范围在now()之前，并将查询结果按1分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="mode"><a class="header" href="#mode">MODE()</a></h3>
<p>返回<code>field value</code>中出现频率最高的值。</p>
<h4 id="语法-18"><a class="header" href="#语法-18">语法</a></h4>
<pre><code>SELECT MODE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MODE(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE()</code> 支持所有数据类型的<code>field value</code>。</p>
<blockquote>
<p>**注意：**如果出现频率最高的值有两个或多个并且它们之间有关联，那么<code>MODE()</code>返回具有最早时间戳的<code>field value</code>。</p>
</blockquote>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值">计算指定field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mode
----                 ----
1970-01-01T00:00:00Z 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中某个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算measurement中每个field-key对应的field-value中出现频率最高的值">计算measurement中每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(*) FROM &quot;air&quot;
name: air
time                 mode_pressure mode_temperature mode_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 57            62               61
</code></pre>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值">计算与正则表达式匹配的每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT MODE(/temp/) FROM &quot;air&quot;
name: air
time                 mode_temperature
----                 ----------------
1970-01-01T00:00:00Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值并包含多个子句">计算指定field key对应的field value中出现频率最高的值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 mode
----                 ----
2022-04-11T08:00:00Z 59
2022-04-11T08:12:00Z 
2022-04-11T08:24:00Z 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>temperature</code>中出现频率最高的值，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="spread"><a class="header" href="#spread">SPREAD()</a></h3>
<p>返回<code>field value</code>中最大值和最小值之差。</p>
<h4 id="语法-19"><a class="header" href="#语法-19">语法</a></h4>
<pre><code class="language-sql">SELECT SPREAD( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-3"><a class="header" href="#语法描述-3">语法描述</a></h4>
<p><code>SPREAD(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD()</code>支持数据类型为int64和float64的<code>field value</code>。</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差">计算指定field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 spread
----                 ------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算measurement中每个field-key对应的field-value中最大值和最小值之差">计算measurement中每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(*) FROM &quot;air&quot;
name: air
time                 spread_pressure spread_temperature spread_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 6               6                  6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差">计算与正则表达式匹配的每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(/tem/) FROM &quot;air&quot;
name: air
time                 spread_temperature
----                 ------------------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句">计算指定field key对应的field value中最大值和最小值之差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(-1) LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 spread
----                 ------
2022-04-11T08:00:00Z 6
2022-04-11T08:12:00Z -1
2022-04-11T08:24:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value中最大值和最小值之差，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）</p>
</li>
<li>
<h3 id="stddev"><a class="header" href="#stddev">STDDEV()</a></h3>
<p>返回<code>field value</code>的标准差。</p>
<h4 id="语法-20"><a class="header" href="#语法-20">语法</a></h4>
<pre><code class="language-sql">SELECT STDDEV( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>STDDEV(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(*)</code>返回在measurement中每个field key对应的field value的标准差。</p>
<p><code>STDDEV()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差"><a class="header" href="#计算指定field-key对应的field-value的标准差">计算指定field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 stddev
----                 ------
1970-01-01T00:00:00Z 1.9933006709246002
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的标准差"><a class="header" href="#计算measurement中每个field-key对应的field-value的标准差">计算measurement中每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(*) FROM &quot;air&quot;
name: air
time                 stddev_pressure    stddev_temperature stddev_visibility
----                 ---------------    ------------------ -----------------
1970-01-01T00:00:00Z 2.0234776612813525 1.9933006709246002 1.9942769555619093
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的标准差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的标准差">计算与正则表达式匹配的每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(/temp/) FROM &quot;air&quot;
name: air
time                   stddev_temperature
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的标准差并包含多个子句">计算指定field key对应的field value的标准差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 2 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 stddev
----                 ------
2022-04-11T08:00:00Z 1.9988781365491315
2022-04-11T08:12:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为2和1，并将返回的series偏移一个（即第一个series的数据不返回）。</p>
</li>
<li>
<h3 id="sum"><a class="header" href="#sum">SUM()</a></h3>
<p>返回field value的总和。</p>
<h4 id="语法-21"><a class="header" href="#语法-21">语法</a></h4>
<pre><code>SELECT SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-4"><a class="header" href="#语法描述-4">语法描述</a></h4>
<p><code>SUM(field_key)</code>返回field key对应的field value的总和。</p>
<p><code>SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的总和。</p>
<p><code>SUM(*)</code>返回在measurement中每个field key对应的field value的总和。</p>
<p><code>SUM()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和"><a class="header" href="#计算指定field-key对应的field-value的总和">计算指定field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的总和">计算measurement中每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(*) FROM &quot;air&quot;
name: air
time                 sum_pressure sum_temperature sum_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 196729       196871          206771
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的总和">计算与正则表达式匹配的每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(/temp/) FROM &quot;air&quot;
name: air
time                 sum_temperature
----                 ---------------
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的总和并包含多个子句">计算指定field key对应的field value的总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 sum
----                 ---
2022-04-11T08:00:00Z 95514
2022-04-11T08:12:00Z 18000
2022-04-11T08:24:00Z 18000
2022-04-11T08:36:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
</li>
</ul>
<h2 id="选择函数"><a class="header" href="#选择函数">选择函数</a></h2>
<ul>
<li>
<h3 id="bottom"><a class="header" href="#bottom">BOTTOM()</a></h3>
<p>返回最小的N个field value。</p>
<h4 id="语法-22"><a class="header" href="#语法-22">语法</a></h4>
<pre><code>SELECT BOTTOM(&lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-5"><a class="header" href="#语法描述-5">语法描述</a></h4>
<p><code>BOTTOM(field_key,N)</code>返回field key对应的最小的N个值。</p>
<p><code>BOTTOM(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最小值。</p>
<p><code>BOTTOM(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最小的N个值，以及相关的tag和/或field。</p>
<p><code>BOTTOM()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最小值有两个或多个相等的值，<code>BOTTOM()</code>返回具有最早时间戳的field value。</li>
<li>当<code>BOTTOM()</code>函数与<code>INTO</code>子句一起使用时，<code>BOTTOM()</code>与其它cnosQL函数不同。请查看<code>BOTTOM()</code>的常见问题章节获得更多信息。</li>
</ul>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值"><a class="header" href="#选择指定field-key对应的最小的三个值">选择指定field key对应的最小的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom
----                 ------
2021-08-31T16:18:00Z 50
2021-08-31T17:09:00Z 50
2021-08-31T18:39:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最小的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最小值"><a class="header" href="#选择两个tag对应的field-key的最小值">选择两个tag对应的field key的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最小的四个值以及相关的tag和field">选择指定field key对应的最小的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 bottom station     pressure
----                 ------ -------     --------
2021-08-31T16:18:00Z 50     XiaoMaiDao  55
2021-08-31T17:09:00Z 50     XiaoMaiDao  63
2021-08-31T18:39:00Z 50     LianYunGang 64
2021-08-31T19:51:00Z 50     LianYunGang 62
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最小的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最小的三个值并包含多个子句">选择指定field key对应的最小的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 bottom station
----                 ------ -------
2021-09-18T00:54:00Z 69     LianYunGang
2021-09-18T00:51:00Z 65     LianYunGang
2021-09-18T00:48:00Z 68     XiaoMaiDao
2021-09-18T00:39:00Z 53     XiaoMaiDao
2021-09-18T00:36:00Z 52     LianYunGang
2021-09-18T00:33:00Z 50     LianYunGang
2021-09-18T00:06:00Z 55     LianYunGang
2021-09-18T00:03:00Z 53     XiaoMaiDao
2021-09-18T00:00:00Z 51     LianYunGang
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最小的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="bottom的常见问题"><a class="header" href="#bottom的常见问题"><code>BOTTOM()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="bottom和group-by-time子句同时使用"><a class="header" href="#bottom和group-by-time子句同时使用"><code>BOTTOM()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>BOTTOM()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>BOTTOM()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   bottom
----                   ------
                           __
2021-09-28T00:00:00Z  2.064 |
2021-09-18T00:12:00Z  2.028 | &lt;------- Smallest points for the first time interval
                           --
                           __
2021-09-18T00:24:00Z  2.041 |
2021-09-18T00:30:00Z  2.051 | &lt;------- Smallest points for the second time interval                      --
</code></pre>
<ul>
<li>
<h4 id="bottom和具有少于n个tag-value的tag-key"><a class="header" href="#bottom和具有少于n个tag-value的tag-key"><code>BOTTOM()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT BOTTOM(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最小值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<ul>
<li>
<h4 id="bottomtag和into子句"><a class="header" href="#bottomtag和into子句"><code>BOTTOM()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>BOTTOM()</code>函数除非<code>BOTTOM()</code>中包含tag key作为参数：<code>BOTTOM(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值，并且，它这些结果写入measurement <code>bottom_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>bottom_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;bottom_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;air&quot;
name: air
tagKey
------
station
</code></pre>
</li>
<li>
<h3 id="first"><a class="header" href="#first">FIRST()</a></h3>
<p>返回具有最早时间戳的field value。</p>
<h4 id="语法-23"><a class="header" href="#语法-23">语法</a></h4>
<pre><code>SELECT FIRST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-6"><a class="header" href="#语法描述-6">语法描述</a></h4>
<p><code>FIRST(field_key)</code>返回field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(*)</code>返回在measurement中每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最早时间戳的field value，以及相关的tag或field。</p>
<p><code>FIRST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value">选择指定field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 first
----                 -----
2021-08-31T16:00:00Z 78
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最早时间戳的field-value">选择measurement中每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;

name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最早时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(/temp/) FROM &quot;air&quot;

name: air
time                 first_temperature
----                 -----------------
2021-08-31T16:00:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最早时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 first station     temperature
----                 ----- -------     -----------
2021-08-31T16:00:00Z 78    LianYunGang 63
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value并包含多个子句">选择指定field key对应的具有最早时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 first
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 70
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最早时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="last"><a class="header" href="#last">LAST()</a></h3>
<p>返回具有最新时间戳的field value。</p>
<h4 id="语法-24"><a class="header" href="#语法-24">语法</a></h4>
<pre><code class="language-sql">SELECT LAST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_keys(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LAST(field_key)</code>返回field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(*)</code>返回在measurement中每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最新时间戳的field value，以及相关的tag或field。</p>
<p><code>LAST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value">选择指定field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 last
----                 ----
2021-09-30T04:00:00Z 65
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最新时间戳的field-value">选择measurement中每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(*) FROM &quot;air&quot;
name: air
time                 last_pressure last_temperature last_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 65            59               78
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最新时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(/temp/) FROM &quot;air&quot;
name: air
time                 last_temperature
----                 ----------------
2021-09-30T04:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最新时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 last station     temperature
----                 ---- -------     -----------
2021-09-30T04:00:00Z 65   LianYunGang 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value并包含多个子句">选择指定field key对应的具有最新时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 last
----                 ----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 68
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 58
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最新时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="max"><a class="header" href="#max">MAX()</a></h3>
<p>返回field value的最大值。</p>
<h4 id="语法-25"><a class="header" href="#语法-25">语法</a></h4>
<pre><code>SELECT MAX(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field__key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MAX(field_key)</code>返回field key对应的field value的最大值。</p>
<p><code>MAX(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最大值。</p>
<p><code>MAX(*)</code>返回在measurement中每个field key对应的field value的最大值。</p>
<p><code>MAX(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最大值，以及相关的tag或field。</p>
<p><code>MAX()</code> 支持数据类型为int64和float64的field value。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值"><a class="header" href="#选择指定field-key对应的field-value的最大值">选择指定field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max
----                 ---
2021-08-31T18:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最大值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最大值">选择measurement中每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最大值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最大值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最大值">选择与正则表达式匹配的每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(/pres/) FROM &quot;air&quot;
name: air
time                 max_pressure
----                 ------------
2021-08-31T17:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最大值以及相关的tag和field">选择指定field key对应的field value的最大值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 max station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最大值并包含多个子句">选择指定field key对应的field value的最大值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
2021-09-18T00:36:00Z 70
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="min"><a class="header" href="#min">MIN()</a></h3>
<p>返回field value的最小值。</p>
<h4 id="语法-26"><a class="header" href="#语法-26">语法</a></h4>
<pre><code>SELECT MIN(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MIN(field_key)</code>返回field key对应的field value的最小值。</p>
<p><code>MIN(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最小值。</p>
<p><code>MIN(*)</code>返回在measurement中每个field key对应的field value的最小值。</p>
<p><code>MIN(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最小值，以及相关的tag和/或field。</p>
<p><code>MIN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-13"><a class="header" href="#示例-13">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值"><a class="header" href="#选择指定field-key对应的field-value的最小值">选择指定field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min
----                 ---
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最小值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最小值">选择measurement中每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(*) FROM &quot;air&quot;

name: air
time                 min_pressure min_temperature min_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 50           50              50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最小值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最小值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最小值">选择与正则表达式匹配的每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(/temp/) FROM &quot;air&quot;

name: air
time                 min_temperature
----                 ---------------
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最小值以及相关的tag和field">选择指定field key对应的field value的最小值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 min station    pressure
----                 --- -------    --------
2021-08-31T16:18:00Z 50  XiaoMaiDao 55
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最小值并包含多个子句">选择指定field key对应的field value的最小值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 min
----                 ---
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="percentile"><a class="header" href="#percentile">PERCENTILE()</a></h3>
<p>返回第N个百分位数的<code>field value</code></p>
<h4 id="语法-27"><a class="header" href="#语法-27">语法</a></h4>
<pre><code>SELECT PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>PERCENTILE(field_key,N)</code>返回指定field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(*,N)</code>返回在measurement中每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的第N个百分位数的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是0到100之间的整数或浮点数。</p>
<p><code>PERCENTILE()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value">选择指定field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5) FROM &quot;air&quot;

name: air
time                 percentile
----                 ----------
2021-09-03T23:51:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择measurement中每个field-key对应的第五个百分位数的field-value">选择measurement中每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(*,5) FROM &quot;air&quot;

name: air
time                 percentile_pressure percentile_temperature percentile_visibility
----                 ------------------- ---------------------- ---------------------
1970-01-01T00:00:00Z 51                  51                     51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值的field key对应的所有field value中的百分之五。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value">选择与正则表达式匹配的每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(/visi/,5) FROM &quot;air&quot;
name: air
time                 percentile_visibility
----                 ---------------------
2021-09-29T09:54:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field">选择指定field key对应的第五个百分位数的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 percentile station    pressure
----                 ---------- -------    --------
2021-09-03T23:51:00Z 51         XiaoMaiDao 65
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第20个百分位数的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的第20个百分位数的field-value并包含多个子句">选择指定field key对应的第20个百分位数的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,20) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(24m) fill(15) LIMIT 2
name: air
time                 percentile
----                 ----------
2020-08-17T23:36:00Z 15
2020-08-18T00:00:00Z 15
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之二十，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按24分钟的时间间隔进行分组，同时，该查询用<code>15</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数限制为2。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每24分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:36:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:24:00Z</code>之间。</p>
<h4 id="percentile的常见问题"><a class="header" href="#percentile的常见问题"><code>PERCENTILE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="percentile-vs-其它cnosql函数"><a class="header" href="#percentile-vs-其它cnosql函数"><code>PERCENTILE()</code> vs 其它cnosQL函数</a></h4>
</li>
</ul>
<ul>
<li><code>PERCENTILE(&lt;field_key&gt;,100)</code>相当于<code>MAX(&lt;field_key&gt;)</code>。</li>
<li><code>PERCENTILE(&lt;field_key&gt;, 50)</code>近似于<code>MEDIAN(&lt;field_key&gt;)</code>，除非field key包含的field value有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</li>
<li><code>PERCENTILE(&lt;field_key&gt;,0)</code>不等于<code>MIN(&lt;field_key&gt;)</code>，<code>PERCENTILE(&lt;field_key&gt;,0)</code>会返回<code>null</code>。</li>
</ul>
</li>
<li>
<h3 id="sample"><a class="header" href="#sample">SAMPLE()</a></h3>
<p>返回包含N个field value的随机样本。<code>SAMPLE()</code>使用<a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a>来生成随机<code>point</code>。</p>
<h4 id="语法-28"><a class="header" href="#语法-28">语法</a></h4>
<pre><code>SELECT SAMPLE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SAMPLE(field_key,N)</code>返回指定field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(*,N)</code>返回在measurement中每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的N个随机选择的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是整数。</p>
<p><code>SAMPLE()</code>支持所有数据类型的field value。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本"><a class="header" href="#选择指定field-key对应的field-value的随机样本">选择指定field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot;
name: air
time                 sample
----                 ------
2021-09-07T02:18:00Z 77
2021-09-13T12:00:00Z 62
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的随机样本"><a class="header" href="#选择measurement中每个field-key对应的field-value的随机样本">选择measurement中每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(*,2) FROM &quot;air&quot;
name: air
time                 sample_pressure sample_temperature sample_visibility
----                 --------------- ------------------ -----------------
2021-08-31T16:18:00Z                 52                 
2021-09-03T14:33:00Z 74                                 
2021-09-12T19:39:00Z 59                                 
2021-09-17T11:33:00Z                 51                 
2021-09-20T04:09:00Z                                    50
2021-09-22T19:15:00Z                                    80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的两个随机选择的<code>point</code>。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的随机样本"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的随机样本">选择与正则表达式匹配的每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(/pres/,2) FROM &quot;air&quot;
name: air
time                 sample_pressure
----                 ---------------
2021-09-25T20:27:00Z 77
2021-09-26T20:33:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的随机样本以及相关的tag和field">选择指定field key对应的field value的随机样本以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 sample station     pressure
----                 ------ -------     --------
2021-09-09T00:03:00Z 71     LianYunGang 61
2021-09-11T01:39:00Z 53     LianYunGang 51
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应field-value的随机样本并包含多个子句"><a class="header" href="#选择指定field-key对应field-value的随机样本并包含多个子句">选择指定field key对应field value的随机样本并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,1) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                 sample
----                 ------
2021-09-18T00:09:00Z 55
2021-09-18T00:27:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的一个随机选择的<code>point</code>，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并将查询结果按18分钟的时间间隔进行分组。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="sample的常见问题"><a class="header" href="#sample的常见问题"><code>SAMPLE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="sample和group-by-time子句同时使用"><a class="header" href="#sample和group-by-time子句同时使用"><code>SAMPLE()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>SAMPLE()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数(<code>N</code>)的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>SAMPLE()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个随机选择的<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   sample
----                   ------
                           __
2021-09-18T00:09:00Z      55   |
2021-09-18T00:12:00Z      63   | &lt;------- Randomly-selected points for the first time interval
                           --
                           __
2021-09-18T00:18:00Z      79  |
2021-09-18T00:21:00Z      68  | &lt;------- Randomly-selected points for the second time interval
                           --
</code></pre>
</li>
<li>
<h3 id="top"><a class="header" href="#top">TOP()</a></h3>
<p>返回最大的N个field value</p>
<h4 id="语法-29"><a class="header" href="#语法-29">语法</a></h4>
<pre><code>SELECT TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TOP(field_key,N)</code>返回field key对应的最大的N个值。</p>
<p><code>TOP(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最大值。</p>
<p><code>TOP(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最大的N个值，以及相关的tag和/或field。</p>
<p><code>TOP()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最大值有两个或多个并且它们之间有关联，<code>TOP()</code>返回具有最早时间戳的field value。</li>
</ul>
<h4 id="示例-16"><a class="header" href="#示例-16">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值"><a class="header" href="#选择指定field-key对应的最大的三个值">选择指定field key对应的最大的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 top
----                 ---
2021-08-31T18:03:00Z 80
2021-08-31T18:18:00Z 80
2021-08-31T18:57:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最大的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最大值"><a class="header" href="#选择两个tag对应的field-key的最大值">选择两个tag对应的field key的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最大的四个值以及相关的tag和field">选择指定field key对应的最大的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 top station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
2021-08-31T18:18:00Z 80  XiaoMaiDao  53
2021-08-31T18:57:00Z 80  LianYunGang 51
2021-08-31T20:15:00Z 80  XiaoMaiDao  53
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最大的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最大的三个值并包含多个子句">选择指定field key对应的最大的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 top station
----                 --- -------
2021-09-18T00:54:00Z 79  XiaoMaiDao
2021-09-18T00:51:00Z 71  XiaoMaiDao
2021-09-18T00:48:00Z 77  LianYunGang
2021-09-18T00:30:00Z 75  LianYunGang
2021-09-18T00:27:00Z 79  LianYunGang
2021-09-18T00:24:00Z 70  LianYunGang
2021-09-18T00:18:00Z 79  LianYunGang
2021-09-18T00:09:00Z 80  XiaoMaiDao
2021-09-18T00:00:00Z 77  XiaoMaiDao
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最大的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="top的常见问题"><a class="header" href="#top的常见问题"><code>TOP()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="top和group-by-time子句同时使用"><a class="header" href="#top和group-by-time子句同时使用"><code>TOP()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>TOP()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>TOP()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)

name: air
time                   top
----                   ------
                        __
2021-09-18T00:12:00Z    63   |
2021-09-18T00:15:00Z    74   | &lt;------- Greatest points for the first time interval
                        --
                        __
2021-09-18T00:18:00Z    79   |
2021-09-18T00:27:00Z   79    | &lt;------- Greatest points for the second time interval
                        --
</code></pre>
<ul>
<li>
<h4 id="top和具有少于n个tag-value的tag-key"><a class="header" href="#top和具有少于n个tag-value的tag-key"><code>TOP()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT TOP(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最大值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<ul>
<li>
<h4 id="toptag和into子句"><a class="header" href="#toptag和into子句"><code>TOP()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>TOP()</code>函数，除非<code>TOP()</code>中包含tag key作为参数：<code>TOP(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值，并且，它这些结果写入measurement <code>top_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>top_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;top_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;top_temperatures&quot;
name: top_temperatures
tagKey
------
station
</code></pre>
</li>
</ul>
<h3 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h3>
<ul>
<li>
<h3 id="abs"><a class="header" href="#abs">ABS()</a></h3>
<p>返回field value的绝对值</p>
<h4 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h4>
<pre><code class="language-sql">SELECT ABS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ABS(field_key)</code>返回field key对应的field value的绝对值。</p>
<p><code>ABS(*)</code>返回在measurement中每个field key对应的field value的绝对值。</p>
<p><code>ABS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ABS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-17"><a class="header" href="#示例-17">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-09-24T12:00:00Z 76       LianYunGang 61          59
2021-09-24T12:00:00Z 58       XiaoMaiDao  52          77
2021-09-24T12:03:00Z 64       LianYunGang 57          72
2021-09-24T12:03:00Z 50       XiaoMaiDao  70          77
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值"><a class="header" href="#计算指定field-key对应的field-value的绝对值">计算指定field key对应的field value的绝对值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 76
2021-09-24T12:00:00Z 58
2021-09-24T12:03:00Z 64
2021-09-24T12:03:00Z 50
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值。</p>
</li>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的绝对值"><a class="header" href="#计算measurement中每个field-key对应的field-value的绝对值">计算measurement中每个field key对应的field value的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs_pressure abs_temperature abs_visibility
----                 ------------ --------------- --------------
2021-09-24T12:00:00Z 76           61              59
2021-09-24T12:00:00Z 58           52              77
2021-09-24T12:03:00Z 64           57              72
2021-09-24T12:03:00Z 50           70              77
</code></pre>
<p>该查询返回measurement <code>data</code>中每个存储数值的field key对应的field value的绝对值。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>,<code>pressure</code>和<code>visibility</code>。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的绝对值并包含多个子句">计算指定field key对应的field value的绝对值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 58
2021-09-24T12:00:00Z 76
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值，它涵盖的时间范围在<code>2020-06-24T12:00:00Z</code>和<code>2020-06-24T12:05:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-1"><a class="header" href="#高级语法-1">高级语法</a></h4>
<pre><code class="language-sql">SELECT ABS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的绝对值。</p>
<p><code>ABS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="计算平均值的绝对值"><a class="header" href="#计算平均值的绝对值">计算平均值的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 62.75
2021-09-24T12:12:00Z 64.25
2021-09-24T12:24:00Z 66
2021-09-24T12:36:00Z 64.375
2021-09-24T12:48:00Z 63.875
2021-09-24T13:00:00Z 59.5
</code></pre>
<p>该查询返回field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ABS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-24T12:00:00Z 61.75
2021-09-24T12:12:00Z 68.25
2021-09-24T12:24:00Z 66.125
2021-09-24T12:36:00Z 58
2021-09-24T12:48:00Z 68.625
2021-09-24T13:00:00Z 71
</code></pre>
<p>然后，CnosDB计算这些平均值的绝对值。</p>
</li>
<li>
<h3 id="acos"><a class="header" href="#acos">ACOS()</a></h3>
<p>返回field value的反余弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h4>
<pre><code>SELECT ACOS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ACOS(field_key)</code>返回field key对应的field value的反余弦。</p>
<p><code>ACOS(*)</code>返回在measurement中每个field key对应的field value的反余弦。</p>
<p><code>ACOS()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ACOS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ACOS()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦"><a class="header" href="#计算指定field-key对应的field-value的反余弦">计算指定field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  acos
----                  ----
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反余弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反余弦">计算measurement中每个field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 acos_pressure acos_temperature acos_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反余弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但由于这三个field key对应的field value超过余弦函数的范围，因此其反余弦值并不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反余弦并包含多个子句">计算指定field key对应的field value的反余弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 acos
----                 ----
2021-09-18T23:57:00Z 0.6435011087932843
2021-09-18T23:57:00Z 0.6599873293874983
2021-09-18T23:54:00Z 0.7669940078618667
2021-09-18T23:54:00Z 1.0003592173949745
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-2"><a class="header" href="#高级语法-2">高级语法</a></h4>
<pre><code class="language-sql">SELECT ACOS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反余弦。</p>
<p>ACOS()支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的反余弦"><a class="header" href="#计算平均值的反余弦">计算平均值的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 acos
----                 ----
2021-09-09T00:00:00Z
2021-09-12T00:00:00Z
2021-09-15T00:00:00Z
2021-09-18T00:00:00Z  、
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反余弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ACOS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反余弦。</p>
</li>
<li>
<h3 id="asin"><a class="header" href="#asin">ASIN()</a></h3>
<p>返回field value的反正弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h4>
<pre><code>SELECT ASIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ASIN(field_key)</code>返回field key对应的field value的反正弦。</p>
<p><code>ASIN(*)</code>返回在measurement中每个field key对应的field value的反正弦。</p>
<p><code>ASIN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ASIN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-19"><a class="header" href="#示例-19">示例</a></h4>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦"><a class="header" href="#计算指定field-key对应的field-value的反正弦">计算指定field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin
----                 ----
2021-09-11T00:00:00Z 0.8330703583416478
2021-09-11T00:00:00Z 0.9108089974073983
2021-09-11T00:03:00Z 0.6560605909249226
2021-09-11T00:03:00Z 0.8183219506315597
2021-09-11T00:06:00Z 0.8038023189330299
2021-09-11T00:06:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.8038023189330299
2021-09-11T00:12:00Z 0.546850950695944
2021-09-11T00:12:00Z 0.618728690672251
2021-09-11T00:15:00Z 0.8330703583416478
2021-09-11T00:15:00Z 0.8946658172342352
2021-09-11T00:18:00Z 0.7342087874533589
2021-09-11T00:18:00Z 0.8330703583416478
2021-09-11T00:21:00Z 0.7894982093461719
2021-09-11T00:21:00Z 0.5823642378687435
2021-09-11T00:24:00Z 0.7208187608700896
2021-09-11T00:24:00Z 0.7342087874533589
2021-09-11T00:27:00Z 0.8038023189330299
2021-09-11T00:27:00Z 0.7208187608700896
2021-09-11T00:30:00Z 0.6560605909249226
2021-09-11T00:30:00Z 0.570437109399922
2021-09-11T00:33:00Z 0.5823642378687435
2021-09-11T00:33:00Z 0.848062078981481
2021-09-11T00:36:00Z 0.7075844367253555
2021-09-11T00:36:00Z 0.7208187608700896
2021-09-11T00:39:00Z 0.7477626346599205
2021-09-11T00:39:00Z 0.618728690672251
2021-09-11T00:42:00Z 0.6310588407780212
2021-09-11T00:42:00Z 0.618728690672251
2021-09-11T00:45:00Z 0.7614890527476331
2021-09-11T00:45:00Z 0.7894982093461719
2021-09-11T00:48:00Z 0.7614890527476331
2021-09-11T00:48:00Z 0.6065058552130869
2021-09-11T00:51:00Z 0.5823642378687435
2021-09-11T00:51:00Z 0.8183219506315597
2021-09-11T00:54:00Z 0.7614890527476331
2021-09-11T00:54:00Z 0.6944982656265559
2021-09-11T00:57:00Z 0.8183219506315597
2021-09-11T00:57:00Z 0.546850950695944
2021-09-11T01:00:00Z 0.6310588407780212
2021-09-11T01:00:00Z 0.7477626346599205    
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正弦">计算measurement中每个field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin_pressure asin_temperature asin_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但是由于这三个field value全部大于1，因此其反正弦值不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正弦并包含多个子句">计算指定field key对应的field value的反正弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 asin
----                 ----
2021-09-18T23:57:00Z 0.9272952180016123
2021-09-18T23:57:00Z 0.9108089974073983
2021-09-18T23:54:00Z 0.8038023189330299
2021-09-18T23:54:00Z 0.570437109399922
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-3"><a class="header" href="#高级语法-3">高级语法</a></h4>
<pre><code class="language-sql">SELECT ASIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正弦。</p>
<p>ASIN()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-20"><a class="header" href="#示例-20">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正弦"><a class="header" href="#计算平均值的反正弦">计算平均值的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(MEAN(&quot;speed&quot;)) FROM &quot;wind&quot; WHERE time &gt;= '2021-09-01T00:00:00Z' AND time &lt;= '2021-09-30T00:00:00Z' GROUP BY time(1d)
name: air
time                  asin
----                  ----
2020-04-30T00:00:00Z  0.6004332535805232
2020-05-03T00:00:00Z  0.42245406218675574
2020-05-06T00:00:00Z  0.7894982093461719
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ASIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正弦。</p>
</li>
<li>
<h3 id="atan"><a class="header" href="#atan">ATAN()</a></h3>
<p>返回field value的反正切（以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h4>
<pre><code class="language-sql">SELECT ATAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN(field_key)</code>返回field key对应的field value的反正切。</p>
<p><code>ATAN(*)</code>返回在measurement中每个field key对应的field value的反正切。</p>
<p><code>ATAN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-21"><a class="header" href="#示例-21">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ATAN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切"><a class="header" href="#计算指定field-key对应的field-value的反正切">计算指定field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan
----                 ----
2021-09-11T00:00:00Z 1.5572836357815683
2021-09-11T00:00:00Z 1.5581387749608446
2021-09-11T00:03:00Z 1.5544043524868913
2021-09-11T00:03:00Z 1.5570985534220307
2021-09-11T00:06:00Z 1.5569083308639295
2021-09-11T00:06:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5569083308639295
2021-09-11T00:12:00Z 1.5515679276951893
2021-09-11T00:12:00Z 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683
2021-09-11T00:15:00Z 1.557976516321996
2021-09-11T00:18:00Z 1.5558720618048116
2021-09-11T00:18:00Z 1.5572836357815683
2021-09-11T00:21:00Z 1.5567127509720364
2021-09-11T00:21:00Z 1.5526165117219182
2021-09-11T00:24:00Z 1.5556459709201267
2021-09-11T00:24:00Z 1.5558720618048116
2021-09-11T00:27:00Z 1.5569083308639295
2021-09-11T00:27:00Z 1.5556459709201267
2021-09-11T00:30:00Z 1.5544043524868913
2021-09-11T00:30:00Z 1.5522799247268875
2021-09-11T00:33:00Z 1.5526165117219182
2021-09-11T00:33:00Z 1.557463783500751
2021-09-11T00:36:00Z 1.5554129250143014
2021-09-11T00:36:00Z 1.5556459709201267
2021-09-11T00:39:00Z 1.5560915044170451
2021-09-11T00:39:00Z 1.5535566556003668
2021-09-11T00:42:00Z 1.5538487969884915
2021-09-11T00:42:00Z 1.5535566556003668
2021-09-11T00:45:00Z 1.5563045877293966
2021-09-11T00:45:00Z 1.5567127509720364
2021-09-11T00:48:00Z 1.5563045877293966
2021-09-11T00:48:00Z 1.553254266737494
2021-09-11T00:51:00Z 1.5526165117219182
2021-09-11T00:51:00Z 1.5570985534220307
2021-09-11T00:54:00Z 1.5563045877293966
2021-09-11T00:54:00Z 1.5551725981744198
2021-09-11T00:57:00Z 1.5570985534220307
2021-09-11T00:57:00Z 1.5515679276951893
2021-09-11T01:00:00Z 1.5538487969884915
2021-09-11T01:00:00Z 1.5560915044170451
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正切"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正切">计算measurement中每个field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan_pressure      atan_temperature   atan_visibility
----                 -------------      ----------------   ---------------
2021-09-11T00:00:00Z 1.5544043524868913 1.5572836357815683 1.5526165117219182
2021-09-11T00:00:00Z 1.5576391913221408 1.5581387749608446 1.550798992821746
2021-09-11T00:03:00Z 1.5535566556003668 1.5544043524868913 1.551190995937692
2021-09-11T00:03:00Z 1.5541312030809558 1.5570985534220307 1.5581387749608446
2021-09-11T00:06:00Z 1.5549246438031066 1.5569083308639295 1.5556459709201267
2021-09-11T00:06:00Z 1.557976516321996  1.5544043524868913 1.5541312030809558
2021-09-11T00:09:00Z 1.553254266737494  1.5544043524868913 1.5560915044170451
2021-09-11T00:09:00Z 1.5556459709201267 1.5569083308639295 1.557463783500751
2021-09-11T00:12:00Z 1.5541312030809558 1.5515679276951893 1.5563045877293966
2021-09-11T00:12:00Z 1.550798992821746  1.5535566556003668 1.5565115842075
2021-09-11T00:15:00Z 1.5554129250143014 1.5572836357815683 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683 1.557976516321996  1.557976516321996
2021-09-11T00:18:00Z 1.557463783500751  1.5558720618048116 1.5526165117219182
2021-09-11T00:18:00Z 1.557810043874724  1.5572836357815683 1.551190995937692
2021-09-11T00:21:00Z 1.5544043524868913 1.5567127509720364 1.552941081655344
2021-09-11T00:21:00Z 1.5576391913221408 1.5526165117219182 1.5570985534220307
2021-09-11T00:24:00Z 1.552941081655344  1.5556459709201267 1.5541312030809558
2021-09-11T00:24:00Z 1.5570985534220307 1.5558720618048116 1.550798992821746
2021-09-11T00:27:00Z 1.550798992821746  1.5569083308639295 1.552941081655344
2021-09-11T00:27:00Z 1.5582969777755349 1.5556459709201267 1.5551725981744198
2021-09-11T00:30:00Z 1.5582969777755349 1.5544043524868913 1.5567127509720364
2021-09-11T00:30:00Z 1.5549246438031066 1.5522799247268875 1.5546686929512603
2021-09-11T00:33:00Z 1.5576391913221408 1.5526165117219182 1.5560915044170451
2021-09-11T00:33:00Z 1.5519306407732258 1.557463783500751  1.5560915044170451
2021-09-11T00:36:00Z 1.5558720618048116 1.5554129250143014 1.5519306407732258
2021-09-11T00:36:00Z 1.5560915044170451 1.5556459709201267 1.5563045877293966
2021-09-11T00:39:00Z 1.5526165117219182 1.5560915044170451 1.5567127509720364
2021-09-11T00:39:00Z 1.5563045877293966 1.5535566556003668 1.557810043874724
2021-09-11T00:42:00Z 1.5569083308639295 1.5538487969884915 1.5565115842075
2021-09-11T00:42:00Z 1.5522799247268875 1.5535566556003668 1.5549246438031066
2021-09-11T00:45:00Z 1.557810043874724  1.5563045877293966 1.5576391913221408
2021-09-11T00:45:00Z 1.5560915044170451 1.5567127509720364 1.557810043874724
2021-09-11T00:48:00Z 1.5535566556003668 1.5563045877293966 1.5551725981744198
2021-09-11T00:48:00Z 1.5546686929512603 1.553254266737494  1.5560915044170451
2021-09-11T00:51:00Z 1.5526165117219182 1.5526165117219182 1.5570985534220307
2021-09-11T00:51:00Z 1.557463783500751  1.5570985534220307 1.5572836357815683
2021-09-11T00:54:00Z 1.5563045877293966 1.5563045877293966 1.5558720618048116
2021-09-11T00:54:00Z 1.5538487969884915 1.5551725981744198 1.5544043524868913
2021-09-11T00:57:00Z 1.5565115842075    1.5570985534220307 1.5572836357815683
2021-09-11T00:57:00Z 1.5576391913221408 1.5515679276951893 1.5572836357815683
2021-09-11T01:00:00Z 1.5522799247268875 1.5538487969884915 1.5522799247268875
2021-09-11T01:00:00Z 1.557810043874724  1.5560915044170451 1.5551725981744198
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正切。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正切并包含多个子句">计算指定field key对应的field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan
----                 ----
2021-09-18T23:57:00Z 1.5582969777755349
2021-09-18T23:57:00Z 1.5581387749608446
2021-09-18T23:54:00Z 1.5569083308639295
2021-09-18T23:54:00Z 1.5522799247268875
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-4"><a class="header" href="#高级语法-4">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切。</p>
<p><code>ATAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-22"><a class="header" href="#示例-22">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切"><a class="header" href="#计算平均值的反正切">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 atan
----                 ----
2021-09-09T00:00:00Z 1.5554743016680184
2021-09-12T00:00:00Z 1.5554056912417906
2021-09-15T00:00:00Z 1.555415060964228
2021-09-18T00:00:00Z 1.555490506678637
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正切。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="atan2"><a class="header" href="#atan2">ATAN2()</a></h3>
<p>返回以弧度表示的<code>y/x</code>的反正切。</p>
<h4 id="基本语法-5"><a class="header" href="#基本语法-5">基本语法</a></h4>
<pre><code>SELECT ATAN2( [ * | &lt;field_key&gt; | num ], [ &lt;field_key&gt; | num ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN2(field_key_y, field_key_x)</code>返回field key “field_key_y”对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2(*, field_key_x)&lt;br /&gt;</code>返回在measurement中每个field key对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN2()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-23"><a class="header" href="#示例-23">示例</a></h4>
<p>下面的示例将使用如下模拟的飞行数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot;, &quot;pressure&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:15:00Z'
name: air
time                 temperature pressure
----                 ----------- --------
2021-09-06T12:03:00Z 53          78
2021-09-06T12:03:00Z 72          71
2021-09-06T12:06:00Z 69          58
2021-09-06T12:06:00Z 59          76
2021-09-06T12:09:00Z 71          55
2021-09-06T12:09:00Z 57          76
2021-09-06T12:12:00Z 53          75
2021-09-06T12:12:00Z 65          52
2021-09-06T12:15:00Z 69          67
2021-09-06T12:15:00Z 64          56
</code></pre>
<ul>
<li>
<h4 id="计算field_key_y除以field_key_x的反正切"><a class="header" href="#计算field_key_y除以field_key_x的反正切">计算field_key_y除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T13:01:00Z'
name: air
time                 atan2
----                 -----
2021-09-06T12:03:00Z 0.5968259039857009
2021-09-06T12:03:00Z 0.7923910564027816
2021-09-06T12:06:00Z 0.8717967127558954
2021-09-06T12:06:00Z 0.6601315920749263
2021-09-06T12:09:00Z 0.9117062804606886
2021-09-06T12:09:00Z 0.6435011087932844
2021-09-06T12:12:00Z 0.6151862381119739
2021-09-06T12:12:00Z 0.8960553845713439
2021-09-06T12:15:00Z 0.8001029857752997
2021-09-06T12:15:00Z 0.851966327173272
2021-09-06T12:18:00Z 0.6960841704042261
2021-09-06T12:18:00Z 0.8010218920179252
2021-09-06T12:21:00Z 0.7594299761858918
2021-09-06T12:21:00Z 0.7028792089644667
2021-09-06T12:24:00Z 0.812418612584713
2021-09-06T12:24:00Z 0.7309067071567171
2021-09-06T12:27:00Z 0.9948777271765435
2021-09-06T12:27:00Z 0.7546386373269791
2021-09-06T12:30:00Z 0.7785017210090998
2021-09-06T12:30:00Z 0.6435011087932844
2021-09-06T12:33:00Z 0.8960553845713439
2021-09-06T12:33:00Z 0.8007815651780434
2021-09-06T12:36:00Z 0.8498250028230019
2021-09-06T12:36:00Z 0.8736040677941312
2021-09-06T12:39:00Z 0.7168036599431737
2021-09-06T12:39:00Z 0.9296875579351908
2021-09-06T12:42:00Z 0.8633647972289906
2021-09-06T12:42:00Z 0.9437256642058782
2021-09-06T12:45:00Z 0.6215266244966218
2021-09-06T12:45:00Z 0.8152400480645576
2021-09-06T12:48:00Z 0.7378150601204648
2021-09-06T12:48:00Z 0.7638187798309181
2021-09-06T12:51:00Z 0.9179496956941223
2021-09-06T12:51:00Z 0.7935280655773922
2021-09-06T12:54:00Z 0.9572401812829798
2021-09-06T12:54:00Z 0.6593100683328579
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T13:00:00Z 0.8187191592756955
2021-09-06T13:00:00Z 0.8134282033572947
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切。这两个field key都在measurement <code>wind</code>中。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key除以field_key_x的反正切"><a class="header" href="#计算measurement中每个field-key除以field_key_x的反正切">计算measurement中每个field key除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(*, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:06:00Z'
name: air
time                 atan2_pressure     atan2_temperature  atan2_visibility
----                 --------------     -----------------  ----------------
2021-09-06T12:03:00Z 0.7853981633974483 0.5968259039857009 0.60554466360497
2021-09-06T12:03:00Z 0.7853981633974483 0.7923910564027816 0.7257674502662789
2021-09-06T12:06:00Z 0.7853981633974483 0.8717967127558954 0.8645972343668997
2021-09-06T12:06:00Z 0.7853981633974483 0.6601315920749263 0.6435011087932844
</code></pre>
<p>该查询返回measurement <code>wind</code>中每个存储数值的field key对应的field value除以field key <code>pressure</code>对应的field value的反正切。measurement <code>wind</code>中有两个数值类型的field：<code>temperature</code>和<code>pressure</code>。</p>
<ul>
<li>
<h4 id="计算field-value的反正切并包含多个子句"><a class="header" href="#计算field-value的反正切并包含多个子句">计算field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-16T13:01:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan2
----                 -----
2021-09-16T12:57:00Z 0.8773368222796695
2021-09-16T12:57:00Z 0.8114792046882006
2021-09-16T12:54:00Z 0.8007815651780434
2021-09-16T12:54:00Z 1.003258702010146
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-16T12:10:00Z</code>和<code>2020-05-16T12:10:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-5"><a class="header" href="#高级语法-5">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN2(&lt;function()&gt;, &lt;function()&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切(<code>ATAN2()</code>)。</p>
<p>ATAN2()支持以下嵌套函数：</p>
<ul>
<li>COUNT()</li>
<li>MEAN()</li>
<li>MEDIAN()</li>
<li>MODE()</li>
<li>SUM()</li>
<li>FIRST()</li>
<li>LAST()</li>
<li>MIN()</li>
<li>MAX()</li>
<li>PERCENTILE()</li>
</ul>
<h4 id="示例-24"><a class="header" href="#示例-24">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切-1"><a class="header" href="#计算平均值的反正切-1">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 atan2
----                 -----
2021-09-16T12:00:00Z 0.7916716068182019
2021-09-16T12:12:00Z 0.7687819020057319
2021-09-16T12:24:00Z 0.8293469014295621
2021-09-16T12:36:00Z 0.7483094274728471
2021-09-16T12:48:00Z 0.8579805385837196
2021-09-16T13:00:00Z 0.7640815957515122
2021-09-16T13:12:00Z 0.7660813391498594
2021-09-16T13:24:00Z 0.7595170787800846
2021-09-16T13:36:00Z 0.781755192263569
2021-09-16T13:48:00Z 0.8137459550765823
2021-09-16T14:00:00Z 0.7572931159369924
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value的平均值除以field key <code>pressure</code>对应的field value的平均值的反正切。平均值是按每12分钟的时间间隔计算的。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>和<code>pressure</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 mean              mean_1
----                 ----              ------
2021-09-16T12:00:00Z 66.83333333333333 66
2021-09-16T12:12:00Z 62.875            65
2021-09-16T12:24:00Z 68.25             62.5
2021-09-16T12:36:00Z 64.875            69.875
2021-09-16T12:48:00Z 71                61.375
2021-09-16T13:00:00Z 60.25             62.875
2021-09-16T13:12:00Z 66.625            69.25
2021-09-16T13:24:00Z 63.5              66.875
2021-09-16T13:36:00Z 68.375            68.875
2021-09-16T13:48:00Z 68                64.25
2021-09-16T14:00:00Z 60.5              64
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="ceil"><a class="header" href="#ceil">CEIL()</a></h3>
<p>返回大于指定值的最小整数。</p>
<h4 id="基本语法-6"><a class="header" href="#基本语法-6">基本语法</a></h4>
<pre><code>SELECT CEIL( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CEIL(field_key)</code>返回field key对应的大于field value的最小整数。</p>
<p><code>CEIL(*)</code>返回在measurement中每个field key对应的大于field value的最小整数。</p>
<p><code>CEIL()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CEIL()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-25"><a class="header" href="#示例-25">示例</a></h4>
<p>下面的示例将使用<a href="content/cnosdb/latest/cnosql/oceanic_station.txt"><code>oceanic_station</code>数据集</a>的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数">计算指定field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的大于field value的最小整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的大于field-value的最小整数"><a class="header" href="#计算measurement中每个field-key对应的大于field-value的最小整数">计算measurement中每个field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil_pressure ceil_temperature ceil_visibility
----                 ------------- ---------------- ---------------
2021-09-18T00:00:00Z 64            51               68
2021-09-18T00:03:00Z 72            60               74
2021-09-18T00:06:00Z 54            55               77
2021-09-18T00:09:00Z 66            55               55
2021-09-18T00:12:00Z 64            63               70
2021-09-18T00:15:00Z 58            74               62
2021-09-18T00:18:00Z 55            79               54
2021-09-18T00:21:00Z 64            68               58
2021-09-18T00:24:00Z 66            70               69
2021-09-18T00:27:00Z 77            79               78
2021-09-18T00:30:00Z 62            75               80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的大于field value的最小整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数并包含多个子句"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数并包含多个子句">计算指定field key对应的大于field value的最小整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ceil
----                 ----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的大于field value的最小整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-6"><a class="header" href="#高级语法-6">高级语法</a></h4>
<pre><code>SELECT CEIL(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>CEIL()</code>应用于这些结果。</p>
<p><code>CEIL()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-26"><a class="header" href="#示例-26">示例</a></h4>
<ul>
<li>
<h4 id="计算大于平均值的最小整数"><a class="header" href="#计算大于平均值的最小整数">计算大于平均值的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 56
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的大于<code>temperature</code>平均值的最小整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的大于<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CEIL()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算大于这些平均值的最小整数。</p>
</li>
<li>
<h3 id="cos"><a class="header" href="#cos">COS()</a></h3>
<p>返回field value的余弦值。</p>
<h4 id="基本语法-7"><a class="header" href="#基本语法-7">基本语法</a></h4>
<pre><code>SELECT COS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>COS(field_key)</code>返回field key对应的field value的余弦值。</p>
<p><code>COS(*)</code>返回在measurement中每个field key对应的field value的余弦值。</p>
<p><code>COS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>COS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-27"><a class="header" href="#示例-27">示例</a></h4>
<ul>
<li>
<h4 id="下面的示例将使用oceanic_station数据集的如下数据"><a class="header" href="#下面的示例将使用oceanic_station数据集的如下数据">下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值"><a class="header" href="#计算指定field-key对应的field-value的余弦值">计算指定field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.7421541968137826
2021-09-18T00:03:00Z -0.9524129804151563
2021-09-18T00:06:00Z 0.022126756261955732
2021-09-18T00:09:00Z 0.022126756261955732
2021-09-18T00:12:00Z 0.9858965815825497
2021-09-18T00:15:00Z 0.17171734183077755
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:27:00Z -0.8959709467909631
2021-09-18T00:30:00Z 0.9217512697247493
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的余弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的余弦值">计算measurement中每个field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos_pressure          cos_temperature      cos_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.39185723042955      0.7421541968137826   0.4401430224960407
2021-09-18T00:03:00Z -0.9672505882738824   -0.9524129804151563  0.17171734183077755
2021-09-18T00:06:00Z -0.8293098328631501   0.022126756261955732 -0.030975031731216456
2021-09-18T00:09:00Z -0.9996474559663501   0.022126756261955732 0.022126756261955732
2021-09-18T00:12:00Z 0.39185723042955      0.9858965815825497   0.6333192030862999
2021-09-18T00:15:00Z 0.11918013544881928   0.17171734183077755  0.6735071623235862
2021-09-18T00:18:00Z 0.022126756261955732  -0.8959709467909631  -0.8293098328631501
2021-09-18T00:21:00Z 0.39185723042955      0.4401430224960407   0.11918013544881928
2021-09-18T00:24:00Z -0.9996474559663501   0.6333192030862999   0.9933903797222716
2021-09-18T00:27:00Z -0.030975031731216456 -0.8959709467909631  -0.8578030932449878
2021-09-18T00:30:00Z 0.6735071623235862    0.9217512697247493   -0.11038724383904756
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的余弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的余弦值并包含多个子句">计算指定field key对应的field value的余弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cos
----                 ---
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:15:00Z 0.17171734183077755
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-7"><a class="header" href="#高级语法-7">高级语法</a></h4>
<pre><code>SELECT COS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的余弦值。</p>
<p><code>COS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-28"><a class="header" href="#示例-28">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的余弦值"><a class="header" href="#计算平均值的余弦值">计算平均值的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.2687822771684872
2021-09-18T00:12:00Z -0.3090227281660707
2021-09-18T00:24:00Z 0.7441351704799297
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的余弦值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>COS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的余弦值。</p>
</li>
<li>
<h3 id="cumulative_sum"><a class="header" href="#cumulative_sum">CUMULATIVE_SUM()</a></h3>
<p>返回field value的累积总和。</p>
<h4 id="基本语法-8"><a class="header" href="#基本语法-8">基本语法</a></h4>
<pre><code>SELECT CUMULATIVE_SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CUMULATIVE_SUM(field_key)</code>返回field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(*)</code>返回在measurement中每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CUMULATIVE_SUM()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-29"><a class="header" href="#示例-29">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和"><a class="header" href="#计算指定field-key对应的field-value的累积总和">计算指定field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的累积总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的累积总和">计算measurement中每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum_pressure cumulative_sum_temperature cumulative_sum_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:00:00Z 64                      51                         68
2021-09-18T00:03:00Z 136                     111                        142
2021-09-18T00:06:00Z 190                     166                        219
2021-09-18T00:09:00Z 256                     221                        274
2021-09-18T00:12:00Z 320                     284                        344
2021-09-18T00:15:00Z 378                     358                        406
2021-09-18T00:18:00Z 433                     437                        460
2021-09-18T00:21:00Z 497                     505                        518
2021-09-18T00:24:00Z 563                     575                        587
2021-09-18T00:27:00Z 640                     654                        665
2021-09-18T00:30:00Z 702                     729                        745
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的累积总和。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的累积总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的累积总和">计算与正则表达式匹配的每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(/temp/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
time                 cumulative_sum_temperature
----                 --------------------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的累积总和并包含多个子句">计算指定field key对应的field value的累积总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:24:00Z 224
2021-09-18T00:21:00Z 292
2021-09-18T00:18:00Z 371
2021-09-18T00:15:00Z 445
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-8"><a class="header" href="#高级语法-8">高级语法</a></h4>
<pre><code class="language-sql">SELECT CUMULATIVE_SUM(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的累积总和"><a class="header" href="#计算平均值的累积总和">计算平均值的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 126.25
2021-09-18T00:24:00Z 200.91666666666669
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的累积总和。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CUMULATIVE_SUM()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的累积总和。最终查询结果中的第二个<code>point</code>(<code>4.167</code>)是<code>2.09</code>和<code>2.077</code>的总和，第三个<code>point</code>(<code>6.213</code>)是<code>2.09</code>、<code>2.077</code>和<code>2.0460000000000003</code>的总和。</p>
</li>
<li>
<h3 id="derivative"><a class="header" href="#derivative">DERIVATIVE()</a></h3>
<p>返回field value之间的变化率，即导数。</p>
<h4 id="基本语法-9"><a class="header" href="#基本语法-9">基本语法</a></h4>
<pre><code>SELECT DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>DERIVATIVE(field_key)</code>返回field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-30"><a class="header" href="#示例-30">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数"><a class="header" href="#计算指定field-key对应的field-value的导数">计算指定field key对应的field value的导数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 0.05
2021-09-18T00:06:00Z -0.027777777777777776
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0.044444444444444446
2021-09-18T00:15:00Z 0.06111111111111111
2021-09-18T00:18:00Z 0.027777777777777776
2021-09-18T00:21:00Z -0.06111111111111111
2021-09-18T00:24:00Z 0.011111111111111112
2021-09-18T00:27:00Z 0.05
2021-09-18T00:30:00Z -0.022222222222222223
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率。</p>
<p>第一个结果(<code>0.05</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的导数并指定unit"><a class="header" href="#计算指定field-key对应的field-value的导数并指定unit">计算指定field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;,6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 18
2021-09-18T00:06:00Z -10
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 16
2021-09-18T00:15:00Z 22
2021-09-18T00:18:00Z 10
2021-09-18T00:21:00Z -22
2021-09-18T00:24:00Z 4
2021-09-18T00:27:00Z 18
2021-09-18T00:30:00Z -8
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每六分钟的变化率。</p>
<p>第一个结果(<code>0.052000000000000046</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 6m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算measurement中每个field-key对应的field-value的导数并指定unit">计算measurement中每个field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(*,3m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_pressure derivative_temperature derivative_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的每三分钟的变化率。measurement <code>air</code>中数值类型的field：<code>temperature</code>,<code>pressure</code>,<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit">计算与正则表达式匹配的每个field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(/temp/,2m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_temperature
----                 ----------------------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z -3.3333333333333335
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 5.333333333333333
2021-09-18T00:15:00Z 7.333333333333333
2021-09-18T00:18:00Z 3.3333333333333335
2021-09-18T00:21:00Z -7.333333333333333
2021-09-18T00:24:00Z 1.3333333333333333
2021-09-18T00:27:00Z 6
2021-09-18T00:30:00Z -2.6666666666666665
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中的对应field key&quot;temperature&quot;对应的field value的每两分钟的变化率。</p>
<p>第一个结果(<code>6</code>)是原始数据中前两个field value在两分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为两分钟的变化率：</p>
<pre><code>(-3.3333333333333335 6) / (6m / 2m)
--------------            ----------
       |                      |
       |                the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的导数并包含多个子句">计算指定field key对应的field value的导数并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 1 OFFSET 2
name: air
time                 derivative
----                 ----------
2021-09-18T00:21:00Z -0.011111111111111112
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<p>唯一的结果(<code>-0.011111111111111112</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
<h4 id="高级语法-9"><a class="header" href="#高级语法-9">高级语法</a></h4>
<pre><code>SELECT DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。</p>
<p><code>DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的导数"><a class="header" href="#计算平均值的导数">计算平均值的导数</a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -14.25
2021-09-18T00:12:00Z 15.75
2021-09-18T00:24:00Z 3.6666666666666714
</code></pre>
</li>
</ul>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每12分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每12分钟的变化率。第一个结果(<code>55.25</code>)是原始数据中前两个field value在12分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为12分钟的变化率：</p>
<pre><code>(71 - 74.66666666666667)  / (12m / 12m)
-------------                   ----------
       |                           |
       |                     the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算平均值的导数并指定unit"><a class="header" href="#计算平均值的导数并指定unit">计算平均值的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;),6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -7.125
2021-09-18T00:12:00Z 7.875
2021-09-18T00:24:00Z 1.8333333333333357
</code></pre>
</li>
</ul>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每六分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)

name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每六分钟的变化率。第一个结果(<code>-55.25</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code class="language-sql">(71 - 74.66666666666667) / (12m / 6m)
-------------    ----------
       |                         |
       |                    the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h3 id="difference"><a class="header" href="#difference">DIFFERENCE()</a></h3>
<p>返回field value之间的差值。</p>
<h4 id="基本语法-10"><a class="header" href="#基本语法-10">基本语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>DIFFERENCE(field_key)</code>返回field key对应的field value的差值。</p>
<p><code>DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-31"><a class="header" href="#示例-31">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值"><a class="header" href="#计算指定field-key对应的field-value的差值">计算指定field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference
----                 ----------
2021-09-18T00:03:00Z 9
2021-09-18T00:06:00Z -5
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 8
2021-09-18T00:15:00Z 11
2021-09-18T00:18:00Z 5
2021-09-18T00:21:00Z -11
2021-09-18T00:24:00Z 2
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z -4
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的差值"><a class="header" href="#计算measurement中每个field-key对应的field-value的差值">计算measurement中每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_pressure difference_temperature difference_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value之间的差值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的差值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的差值">计算与正则表达式匹配的每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(/visi/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_visibility
----                 ----------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z -22
2021-09-18T00:12:00Z 15
2021-09-18T00:15:00Z -8
2021-09-18T00:18:00Z -8
2021-09-18T00:21:00Z 4
2021-09-18T00:24:00Z 11
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z 2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的差值并包含多个子句">计算指定field key对应的field value的差值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 2 OFFSET 2
name: air
time                 difference
----                 ----------
2021-09-18T00:21:00Z -2
2021-09-18T00:18:00Z 11
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-10"><a class="header" href="#高级语法-10">高级语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的差值。</p>
<p>DIFFERENCE()支持以下嵌套函数：
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-32"><a class="header" href="#示例-32">示例</a></h4>
<ul>
<li>
<h4 id="计算最大值之间的差值"><a class="header" href="#计算最大值之间的差值">计算最大值之间的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(MAX(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 difference
----                 ----------
2021-09-18T00:00:00Z -19
2021-09-18T00:12:00Z 19
2021-09-18T00:24:00Z 0
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值之间的差值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DIFFERENCE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值之间的差值。最终查询结果中的第一个<code>point</code>(<code>0.009999999999999787</code>)是<code>2.126</code>和<code>2.116</code>的差，第二个<code>point</code>(<code>-0.07499999999999973</code>)是<code>2.051</code>和<code>2.126</code>的差。</p>
</li>
<li>
<h3 id="elapsed"><a class="header" href="#elapsed">ELAPSED()</a></h3>
<p>返回field value的时间戳之间的差值。</p>
<h4 id="语法-30"><a class="header" href="#语法-30">语法</a></h4>
<pre><code>SELECT ELAPSED( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算时间戳之间的差值。参数<code>unit</code>的值是一个整数，后跟一个时间单位，它决定了返回的差值的单位。这个参数是可选的，不是必须要有的。如果没有指定<code>unit</code>的值，那么查询将返回以纳秒为单位的两个时间戳之间的差值。</p>
<p><code>ELAPSED(field_key)</code>返回field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(*)</code>返回在measurement中每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED()</code>支持所有数据类型的field value。</p>
<h4 id="示例-33"><a class="header" href="#示例-33">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔">计算指定field key对应的field value之间的时间间隔</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 180000000000
2021-09-18T00:06:00Z 180000000000
2021-09-18T00:09:00Z 180000000000
2021-09-18T00:12:00Z 180000000000
2021-09-18T00:15:00Z 180000000000
2021-09-18T00:18:00Z 180000000000
2021-09-18T00:21:00Z 180000000000
2021-09-18T00:24:00Z 180000000000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以纳秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并指定unit">计算指定field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的时间戳之间的差值(以分钟为单位)。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(/press/,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed_pressure
----                 ----------------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并包含多个子句">计算指定field key对应的field value之间的时间间隔并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1ms) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z' ORDER BY time DESC LIMIT 1 OFFSET 1
name: air
time                 elapsed
----                 -------
2021-09-18T00:18:00Z -180000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以毫秒为单位)，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:12:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移一个（即前一个<code>point</code>不返回）。</p>
<p>请注意，查询结果是负数；因为<code>ORDER BY time DESC</code>子句按递减的顺序对时间戳进行排序，所以<code>ELAPSED()</code>以相反的顺序计算时间戳的差值。</p>
<h4 id="elapsed的常见问题"><a class="header" href="#elapsed的常见问题"><code>ELAPSED()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="elapsed和大于经过时间的单位"><a class="header" href="#elapsed和大于经过时间的单位"><code>ELAPSED()</code>和大于经过时间的单位</a></h4>
</li>
</ul>
<p>I如果<code>unit</code>的值大于时间戳之间的差值，那么CnosDB将会返回<code>0</code>。</p>
<p>measurement <code>air</code>中每六分钟有一个<code>point</code>。如果查询将<code>unit</code>设置为一小时，CnosDB将会返回<code>0</code>：</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1h) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:12:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 0
2021-09-18T00:06:00Z 0
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0
</code></pre>
<ul>
<li>
<h4 id="elapsed和group-by-time子句同时使用"><a class="header" href="#elapsed和group-by-time子句同时使用"><code>ELAPSED()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p><code>ELAPSED()</code>函数支持<code>GROUP BY time()</code>子句，但是查询结果不是特别有用。目前，如果<code>ELAPSED()</code>查询包含一个嵌套的cnosQL函数和一个<code>GROUP BY time()</code>子句，那么只会返回指定<code>GROUP BY time()</code>子句中的时间间隔。</p>
<p><code>GROUP BY time()</code>子句决定了查询结果中的时间戳：每个时间戳表示时间间隔的开始时间。该行为也适用于嵌套的selector函数(例如<code>FIRST()</code>或<code>MAX()</code>)，而在其它的所有情况下，这些函数返回的是原始数据的特定时间戳。因为<code>GROUP BY time()</code>子句会覆盖原始时间戳，所以<code>ELAPSED()</code>始终返回与<code>GROUP BY time()</code>的时间间隔相同的时间戳。</p>
<p>下面代码块中的第一个查询尝试使用<code>ELAPSED()</code>和<code>GROUP BY time()</code>子句来查找最小的<code>temperature</code>的值之间经过的时间(以分钟为单位)。查询的两个时间间隔都返回了12分钟。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔的<code>temperature</code>的最小值。代码块中的第二个查询展示了这一步的结果。这一步跟同时使用<code>MIN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ELAPSED()</code>的情形一样。请注意，第二个查询返回的时间戳间隔12分钟。在原始数据中，第一个结果(<code>2.057</code>)发生在<code>2020-08-18T00:42:00Z</code>，但是<code>GROUP BY time()</code>子句覆盖了原始的时间戳。因为时间戳由<code>GROUP BY time()</code>的时间间隔(而不是原始数据)决定，所以<code>ELAPSED()</code>始终返回与GROUP BY time()的时间间隔相同的时间戳。</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(MIN(&quot;temperature&quot;),1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 elapsed
----                 -------
2021-09-08T00:36:00Z 12
2021-09-08T00:48:00Z 12

&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 min
----                 ---
2021-09-08T00:36:00Z 50
2021-09-08T00:48:00Z 73  &lt;--- Actually occurs at 2021-09-08T00:48:00Z
</code></pre>
</li>
<li>
<h3 id="exp"><a class="header" href="#exp">EXP()</a></h3>
<p>返回field value的指数。</p>
<h4 id="基本语法-11"><a class="header" href="#基本语法-11">基本语法</a></h4>
<pre><code>SELECT EXP( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>EXP(field_key)</code>返回field key对应的field value的指数。</p>
<p><code>EXP(*)</code>返回在measurement中每个field key对应的field value的指数。</p>
<p><code>EXP()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>EXP()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-34"><a class="header" href="#示例-34">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.85.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数"><a class="header" href="#计算指定field-key对应的field-value的指数">计算指定field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 1.4093490824269389e+22
2021-09-18T00:03:00Z 1.1420073898156842e+26
2021-09-18T00:06:00Z 7.694785265142018e+23
2021-09-18T00:09:00Z 7.694785265142018e+23
2021-09-18T00:12:00Z 2.29378315946961e+27
2021-09-18T00:15:00Z 1.3733829795401763e+32
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:27:00Z 2.0382810665126688e+34
2021-09-18T00:30:00Z 3.7332419967990015e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的指数"><a class="header" href="#计算measurement中每个field-key对应的field-value的指数">计算measurement中每个field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp_pressure           exp_temperature        exp_visibility
----                 ------------           ---------------        --------------
2021-09-18T00:00:00Z 6.235149080811617e+27  1.4093490824269389e+22 3.404276049931741e+29
2021-09-18T00:03:00Z 1.8586717452841279e+31 1.1420073898156842e+26 1.3733829795401763e+32
2021-09-18T00:06:00Z 2.830753303274694e+23  7.694785265142018e+23  2.7585134545231703e+33
2021-09-18T00:09:00Z 4.607186634331292e+28  7.694785265142018e+23  7.694785265142018e+23
2021-09-18T00:12:00Z 6.235149080811617e+27  2.29378315946961e+27   2.515438670919167e+30
2021-09-18T00:15:00Z 1.545538935590104e+25  1.3733829795401763e+32 8.438356668741455e+26
2021-09-18T00:18:00Z 7.694785265142018e+23  2.0382810665126688e+34 2.830753303274694e+23
2021-09-18T00:21:00Z 6.235149080811617e+27  3.404276049931741e+29  1.545538935590104e+25
2021-09-18T00:24:00Z 4.607186634331292e+28  2.515438670919167e+30  9.253781725587789e+29
2021-09-18T00:27:00Z 2.7585134545231703e+33 2.0382810665126688e+34 7.49841699699012e+33
2021-09-18T00:30:00Z 8.438356668741455e+26  3.7332419967990015e+32 5.54062238439351e+34
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的指数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的指数并包含多个子句">计算指定field key对应的field value的指数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 exp
----                 ---
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:15:00Z 1.3733829795401763e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-11"><a class="header" href="#高级语法-11">高级语法</a></h4>
<pre><code>SELECT EXP(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的指数。</p>
<p>EXP()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-35"><a class="header" href="#示例-35">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的指数"><a class="header" href="#计算平均值的指数">计算平均值的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 9.880299856396672e+23
2021-09-18T00:12:00Z 6.837671229762744e+30
2021-09-18T00:24:00Z 2.674984780655511e+32
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>EXP()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>.然后，CnosDB计算这些平均值的指数。</p>
<h3 id="floor"><a class="header" href="#floor">FLOOR()</a></h3>
<p>返回小于指定值的最大整数。</p>
<h4 id="基本语法-12"><a class="header" href="#基本语法-12">基本语法</a></h4>
<pre><code>SELECT FLOOR( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>FLOOR(field_key)</code>返回field key对应的小于field value的最大整数。</p>
<p><code>FLOOR(*)</code>返回在measurement中每个field key对应的小于field value的最大整数。</p>
<p><code>FLOOR()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>FLOOR()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-36"><a class="header" href="#示例-36">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数">计算指定field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的小于field value的最大整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的小于field-value的最大整数"><a class="header" href="#计算measurement中每个field-key对应的小于field-value的最大整数">计算measurement中每个field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor_pressure floor_temperature floor_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的小于field value的最大整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数并包含多个子句"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数并包含多个子句">计算指定field key对应的小于field value的最大整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 floor
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的小于field value的最大整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-12"><a class="header" href="#高级语法-12">高级语法</a></h4>
<pre><code>SELECT FLOOR(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>FLOOR()</code>应用于这些结果。</p>
<p><code>FLOOR()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算小于平均值的最大整数"><a class="header" href="#计算小于平均值的最大整数">计算小于平均值的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的小于<code>temperature</code>平均值的最大整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>FLOOR()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算小于这些平均值的最大整数。</p>
</li>
<li>
<h3 id="ln"><a class="header" href="#ln">LN()</a></h3>
<p>返回field value的自然对数。</p>
<h4 id="基本语法-13"><a class="header" href="#基本语法-13">基本语法</a></h4>
<pre><code>SELECT LN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LN(field_key)</code>返回field key对应的field value的自然对数。</p>
<p><code>LN(*)</code>返回在measurement中每个field key对应的field value的自然对数。</p>
<p><code>LN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-37"><a class="header" href="#示例-37">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.86.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数"><a class="header" href="#计算指定field-key对应的field-value的自然对数">计算指定field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 3.9318256327243257
2021-09-18T00:03:00Z 4.0943445622221
2021-09-18T00:06:00Z 4.007333185232471
2021-09-18T00:09:00Z 4.007333185232471
2021-09-18T00:12:00Z 4.143134726391533
2021-09-18T00:15:00Z 4.304065093204169
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:27:00Z 4.3694478524670215
2021-09-18T00:30:00Z 4.31748811353631
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的自然对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的自然对数">计算measurement中每个field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln_pressure        ln_temperature     ln_visibility
----                 -----------        --------------     -------------
2021-09-18T00:00:00Z 4.1588830833596715 3.9318256327243257 4.219507705176107
2021-09-18T00:03:00Z 4.276666119016055  4.0943445622221    4.304065093204169
2021-09-18T00:06:00Z 3.9889840465642745 4.007333185232471  4.343805421853684
2021-09-18T00:09:00Z 4.189654742026425  4.007333185232471  4.007333185232471
2021-09-18T00:12:00Z 4.1588830833596715 4.143134726391533  4.248495242049359
2021-09-18T00:15:00Z 4.060443010546419  4.304065093204169  4.127134385045092
2021-09-18T00:18:00Z 4.007333185232471  4.3694478524670215 3.9889840465642745
2021-09-18T00:21:00Z 4.1588830833596715 4.219507705176107  4.060443010546419
2021-09-18T00:24:00Z 4.189654742026425  4.248495242049359  4.23410650459726
2021-09-18T00:27:00Z 4.343805421853684  4.3694478524670215 4.356708826689592
2021-09-18T00:30:00Z 4.127134385045092  4.31748811353631   4.382026634673881
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的自然对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的自然对数并包含多个子句">计算指定field key对应的field value的自然对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ln
----                 --
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:15:00Z 4.304065093204169
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-13"><a class="header" href="#高级语法-13">高级语法</a></h4>
<pre><code>SELECT LN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个 GROUP BY time() <code>和一个嵌套的cnosQL 函数. 该查询受限以指定</code>GROUP BY time()<code>间隔计算嵌套函数的结果 </code>LN()` .</p>
<p>LN()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
</li>
</ul>
<h4 id="示例-38"><a class="header" href="#示例-38">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的自然对数"><a class="header" href="#计算平均值的自然对数">计算平均值的自然对数</a></h4>
<pre><code class="language-sql">&gt; SELECT LN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 4.0118683403978626
2021-09-18T00:12:00Z 4.2626798770413155
2021-09-18T00:24:00Z 4.31303376318693
</code></pre>
</li>
</ul>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的自然对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的自然对数。</p>
<ul>
<li>
<h3 id="log"><a class="header" href="#log">LOG()</a></h3>
<p>返回field value的以<code>b</code>为底数的对数。</p>
<h4 id="基本语法-14"><a class="header" href="#基本语法-14">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG( [ * | &lt;field_key&gt; ], &lt;b&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG(field_key, b)</code>返回field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG(*, b)</code>返回在measurement中每个field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.87.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数">计算指定field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.836212670985748
2021-09-18T00:03:00Z 2.9534452978042594
2021-09-18T00:06:00Z 2.89067985676233
2021-09-18T00:09:00Z 2.89067985676233
2021-09-18T00:12:00Z 2.9886399617499584
2021-09-18T00:15:00Z 3.1047266828144746
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:27:00Z 3.1518903740885515
2021-09-18T00:30:00Z 3.11440934524794
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以4为底数的对数">计算measurement中每个field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log_pressure       log_temperature    log_visibility
----                 ------------       ---------------    --------------
2021-09-18T00:00:00Z 3                  2.836212670985748  3.04373142062517
2021-09-18T00:03:00Z 3.084962500721156  2.9534452978042594 3.1047266828144746
2021-09-18T00:06:00Z 2.8774437510817346 2.89067985676233   3.133393270347451
2021-09-18T00:09:00Z 3.0221970596792267 2.89067985676233   2.89067985676233
2021-09-18T00:12:00Z 3                  2.9886399617499584 3.0646415084724836
2021-09-18T00:15:00Z 2.928990497563786  3.1047266828144746 2.977098155193438
2021-09-18T00:18:00Z 2.89067985676233   3.1518903740885515 2.8774437510817346
2021-09-18T00:21:00Z 3                  3.04373142062517   2.928990497563786
2021-09-18T00:24:00Z 3.0221970596792267 3.0646415084724836 3.054262228389085
2021-09-18T00:27:00Z 3.133393270347451  3.1518903740885515 3.1427011094311244
2021-09-18T00:30:00Z 2.977098155193438  3.11440934524794   3.160964047443681
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以4为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数并包含多个子句">计算指定field key对应的field value的以4为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log
----                 ---
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:15:00Z 3.1047266828144746
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-14"><a class="header" href="#高级语法-14">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;b&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的对数。</p>
<p><code>LOG()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以4为底数的对数"><a class="header" href="#计算平均值的以4为底数的对数">计算平均值的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.8939512796957163
2021-09-18T00:12:00Z 3.074873559752341
2021-09-18T00:24:00Z 3.1111962106682243
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以4为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以4为底数的对数。</p>
</li>
<li>
<h3 id="log2"><a class="header" href="#log2">LOG2()</a></h3>
<p>返回field value的以2为底数的对数。</p>
<h4 id="基本语法-15"><a class="header" href="#基本语法-15">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG2( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG2(field_key)</code>返回field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2(*)</code>返回在measurement中每个field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG2()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.88.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数">计算指定field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.672425341971495
2021-09-18T00:03:00Z 5.906890595608519
2021-09-18T00:06:00Z 5.78135971352466
2021-09-18T00:09:00Z 5.78135971352466
2021-09-18T00:12:00Z 5.977279923499917
2021-09-18T00:15:00Z 6.20945336562895
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:27:00Z 6.303780748177103
2021-09-18T00:30:00Z 6.22881869049588
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以2为底数的对数">计算measurement中每个field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2_pressure     log2_temperature  log2_visibility
----                 -------------     ----------------  ---------------
2021-09-18T00:00:00Z 6                 5.672425341971495 6.087462841250339
2021-09-18T00:03:00Z 6.169925001442312 5.906890595608519 6.20945336562895
2021-09-18T00:06:00Z 5.754887502163468 5.78135971352466  6.266786540694901
2021-09-18T00:09:00Z 6.044394119358453 5.78135971352466  5.78135971352466
2021-09-18T00:12:00Z 6                 5.977279923499917 6.129283016944966
2021-09-18T00:15:00Z 5.857980995127572 6.20945336562895  5.954196310386875
2021-09-18T00:18:00Z 5.78135971352466  6.303780748177103 5.754887502163468
2021-09-18T00:21:00Z 6                 6.087462841250339 5.857980995127572
2021-09-18T00:24:00Z 6.044394119358453 6.129283016944966 6.108524456778169
2021-09-18T00:27:00Z 6.266786540694901 6.303780748177103 6.285402218862249
2021-09-18T00:30:00Z 5.954196310386875 6.22881869049588  6.321928094887363
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以2为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数并包含多个子句">计算指定field key对应的field value的以2为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log2
----                 ----
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:15:00Z 6.20945336562895
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-15"><a class="header" href="#高级语法-15">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG2(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以2为底数的对数。</p>
<p><code>LOG2()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以2为底数的对数"><a class="header" href="#计算平均值的以2为底数的对数">计算平均值的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.787902559391432
2021-09-18T00:12:00Z 6.149747119504682
2021-09-18T00:24:00Z 6.222392421336448
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以2为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以2为底数的对数。</p>
</li>
<li>
<h3 id="log10"><a class="header" href="#log10">LOG10()</a></h3>
<p>返回field value的以10为底数的对数。</p>
<h4 id="基本语法-16"><a class="header" href="#基本语法-16">基本语法</a></h4>
<pre><code>SELECT LOG10( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG10(field_key)</code>返回field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10(*)</code>返回在measurement中每个field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG10()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.89.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数">计算指定field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7075701760979363
2021-09-18T00:03:00Z 1.7781512503836434
2021-09-18T00:06:00Z 1.7403626894942439
2021-09-18T00:09:00Z 1.7403626894942439
2021-09-18T00:12:00Z 1.7993405494535817
2021-09-18T00:15:00Z 1.869231719730976
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:27:00Z 1.8976270912904414
2021-09-18T00:30:00Z 1.8750612633916999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以10为底数的对数">计算measurement中每个field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10_pressure     log10_temperature  log10_visibility
----                 --------------     -----------------  ----------------
2021-09-18T00:00:00Z 1.806179973983887  1.7075701760979363 1.8325089127062364
2021-09-18T00:03:00Z 1.8573324964312685 1.7781512503836434 1.869231719730976
2021-09-18T00:06:00Z 1.7323937598229686 1.7403626894942439 1.8864907251724818
2021-09-18T00:09:00Z 1.8195439355418686 1.7403626894942439 1.7403626894942439
2021-09-18T00:12:00Z 1.806179973983887  1.7993405494535817 1.845098040014257
2021-09-18T00:15:00Z 1.7634279935629371 1.869231719730976  1.792391689498254
2021-09-18T00:18:00Z 1.7403626894942439 1.8976270912904414 1.7323937598229686
2021-09-18T00:21:00Z 1.806179973983887  1.8325089127062364 1.7634279935629371
2021-09-18T00:24:00Z 1.8195439355418686 1.845098040014257  1.8388490907372554
2021-09-18T00:27:00Z 1.8864907251724818 1.8976270912904414 1.8920946026904804
2021-09-18T00:30:00Z 1.792391689498254  1.8750612633916999 1.9030899869919433
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以10为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数并包含多个子句">计算指定field key对应的field value的以10为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log10
----                 -----
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:15:00Z 1.869231719730976
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-16"><a class="header" href="#高级语法-16">高级语法</a></h4>
<pre><code>SELECT LOG10(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以10为底数的对数。</p>
<p><code>LOG10()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以10为底数的对数"><a class="header" href="#计算平均值的以10为底数的对数">计算平均值的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7423322823571483
2021-09-18T00:12:00Z 1.8512583487190752
2021-09-18T00:24:00Z 1.8731267636145004
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以10为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG10()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以10为底数的对数。</p>
</li>
<li>
<h3 id="moving_average"><a class="header" href="#moving_average">MOVING_AVERAGE()</a></h3>
<p>返回field value窗口的滚动平均值。</p>
<h4 id="基本语法-17"><a class="header" href="#基本语法-17">基本语法</a></h4>
<pre><code class="language-sql">SELECT MOVING_AVERAGE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] , &lt;N&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MOVING_AVERAGE()</code>计算包含<code>N</code>个连续field value的窗口的滚动平均值。参数<code>N</code>是一个整数，并且它是必须的。</p>
<p><code>MOVING_AVERAGE(field_key,N)</code>返回field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(*,N)</code>返回在measurement中每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>MOVING_AVERAGE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值">计算指定field key对应的field value的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average
----                 --------------
2021-09-18T00:03:00Z 55.5
2021-09-18T00:06:00Z 57.5
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 59
2021-09-18T00:15:00Z 68.5
2021-09-18T00:18:00Z 76.5
2021-09-18T00:21:00Z 73.5
2021-09-18T00:24:00Z 69
2021-09-18T00:27:00Z 74.5
2021-09-18T00:30:00Z 77
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值。第一个结果(<code>2.09</code>)是原始数据中前两个field value的平均值：(2.064 + 2.116) / 2。第二个结果(<code>2.072</code>)是原始数据中第二和第三个field value的平均值：(2.116 + 2.028) / 2。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的滚动平均值">计算measurement中每个field key对应的field value的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(*,3) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure moving_average_temperature moving_average_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:06:00Z 63.333333333333336      55.333333333333336         73
2021-09-18T00:09:00Z 64                      56.666666666666664         68.66666666666667
2021-09-18T00:12:00Z 61.333333333333336      57.666666666666664         67.33333333333333
2021-09-18T00:15:00Z 62.666666666666664      64                         62.333333333333336
2021-09-18T00:18:00Z 59                      72                         62
2021-09-18T00:21:00Z 59                      73.66666666666667          58
2021-09-18T00:24:00Z 61.666666666666664      72.33333333333333          60.333333333333336
2021-09-18T00:27:00Z 69                      72.33333333333333          68.33333333333333
2021-09-18T00:30:00Z 68.33333333333333       74.66666666666667          75.66666666666667
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的窗口大小为三个field value的滚动平均值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值">计算与正则表达式匹配的每个field key对应的field value的滚动平均值</a></h4>
<pre><code>&gt; SELECT MOVING_AVERAGE(/press/,4) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure
----                 -----------------------
2021-09-18T00:09:00Z 64
2021-09-18T00:12:00Z 64
2021-09-18T00:15:00Z 60.5
2021-09-18T00:18:00Z 60.75
2021-09-18T00:21:00Z 60.25
2021-09-18T00:24:00Z 60.75
2021-09-18T00:27:00Z 65.5
2021-09-18T00:30:00Z 67.25
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>level</code>的field key对应的窗口大小为四个field value的滚动平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值并包含多个子句">计算指定field key对应的field value的滚动平均值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 2 OFFSET 3
name: air
time                 moving_average
----                 --------------
2021-09-18T00:18:00Z 73.5
2021-09-18T00:15:00Z 76.5
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移三个(即前三个<code>point</code>不返回）。</p>
<h4 id="高级语法-17"><a class="header" href="#高级语法-17">高级语法</a></h4>
<pre><code>SELECT MOVING_AVERAGE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) , N ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算最大值的滚动平均值"><a class="header" href="#计算最大值的滚动平均值">计算最大值的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(MAX(&quot;temperature&quot;),2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 moving_average
----                 --------------
2021-09-18T00:00:00Z 69.5
2021-09-18T00:12:00Z 69.5
2021-09-18T00:24:00Z 79
</code></pre>
</li>
</ul>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的最大值的窗口大小为两个值的滚动平均值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>MOVING_AVERAGE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值的窗口大小为两个值的滚动平均值。最终查询结果中的第一个<code>point</code>(<code>2.121</code>)是前两个最大值的平均值(<code>(2.116 + 2.126) / 2</code>)。</p>
<ul>
<li>
<h3 id="non_negative_derivative"><a class="header" href="#non_negative_derivative">NON_NEGATIVE_DERIVATIVE()</a></h3>
<p>返回field value之间的非负变化率。非负变化率包括正的变化率和等于0的变化率。</p>
<h4 id="基本语法-18"><a class="header" href="#基本语法-18">基本语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(field_key)</code>返回field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
<h4 id="高级语法-18"><a class="header" href="#高级语法-18">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的非负导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>
####示例</li>
</ul>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
</li>
<li>
<h3 id="non_negative_difference"><a class="header" href="#non_negative_difference">NON_NEGATIVE_DIFFERENCE()</a></h3>
<p>返回field value之间的非负差值。非负差值包括正的差值和等于0的差值。</p>
<h4 id="基本语法-19"><a class="header" href="#基本语法-19">基本语法</a></h4>
<pre><code>SELECT NON_NEGATIVE_DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>NON_NEGATIVE_DIFFERENCE(field_key)</code>返回field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
<h4 id="高级语法-19"><a class="header" href="#高级语法-19">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的非负差值。</p>
<p>`NON_NEGATIVE_DIFFERENCE()支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
</li>
<li>
<h3 id="pow"><a class="header" href="#pow">POW()</a></h3>
<p>返回field value的<code>x</code>次方。</p>
<h4 id="基本语法-20"><a class="header" href="#基本语法-20">基本语法</a></h4>
<pre><code>SELECT POW( [ * | &lt;field_key&gt; ], &lt;x&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>POW(field_key, x)</code>返回field key对应的field value的<code>x</code>次方。</p>
<p><code>POW(*, x)</code>返回在measurement中每个field key对应的field value的<code>x</code>次方。</p>
<p><code>POW()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>POW()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.90.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方"><a class="header" href="#计算指定field-key对应的field-value的4次方">计算指定field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 6765201
2021-09-18T00:03:00Z 12960000
2021-09-18T00:06:00Z 9150625
2021-09-18T00:09:00Z 9150625
2021-09-18T00:12:00Z 15752961
2021-09-18T00:15:00Z 29986576
2021-09-18T00:18:00Z 38950081
2021-09-18T00:21:00Z 21381376
2021-09-18T00:24:00Z 24010000
2021-09-18T00:27:00Z 38950081
2021-09-18T00:30:00Z 31640625
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的4次方"><a class="header" href="#计算measurement中每个field-key对应的field-value的4次方">计算measurement中每个field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow_pressure pow_temperature pow_visibility
----                 ------------ --------------- --------------
2021-09-18T00:00:00Z 16777216     6765201         21381376
2021-09-18T00:03:00Z 26873856     12960000        29986576
2021-09-18T00:06:00Z 8503056      9150625         35153041
2021-09-18T00:09:00Z 18974736     9150625         9150625
2021-09-18T00:12:00Z 16777216     15752961        24010000
2021-09-18T00:15:00Z 11316496     29986576        14776336
2021-09-18T00:18:00Z 9150625      38950081        8503056
2021-09-18T00:21:00Z 16777216     21381376        11316496
2021-09-18T00:24:00Z 18974736     24010000        22667121
2021-09-18T00:27:00Z 35153041     38950081        37015056
2021-09-18T00:30:00Z 14776336     31640625        40960000
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的4次方。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的4次方并包含多个子句">计算指定field key对应的field value的4次方并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 pow
----                 ---
2021-09-18T00:24:00Z 24010000
2021-09-18T00:21:00Z 21381376
2021-09-18T00:18:00Z 38950081
2021-09-18T00:15:00Z 29986576
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-20"><a class="header" href="#高级语法-20">高级语法</a></h4>
<pre><code class="language-sql">SELECT POW(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;x&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的<code>x</code>次方。</p>
<p><code>POW()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的4次方"><a class="header" href="#计算平均值的4次方">计算平均值的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 9318137.81640625
2021-09-18T00:12:00Z 25411681
2021-09-18T00:24:00Z 31081863.901234582
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的4次方。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>POW()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的4次方。</p>
</li>
<li>
<h3 id="round"><a class="header" href="#round">ROUND()</a></h3>
<p>返回指定值的四舍五入后的整数。</p>
<h4 id="基本语法-21"><a class="header" href="#基本语法-21">基本语法</a></h4>
<pre><code>SELECT ROUND( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ROUND(field_key)</code>返回field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND(*)</code>返回在measurement中每个field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ROUND()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.91.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数">计算指定field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算measurement中每个field-key对应的field-value四舍五入后的整数">计算measurement中每个field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round_pressure round_temperature round_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数并包含多个子句">计算指定field key对应的field value四舍五入后的整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 round
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-21"><a class="header" href="#高级语法-21">高级语法</a></h4>
<pre><code class="language-sql">SELECT ROUND(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果四舍五入后的整数。</p>
<p><code>ROUND()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值四舍五入后的整数"><a class="header" href="#计算平均值四舍五入后的整数">计算平均值四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值四舍五入后的整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ROUND()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值四舍五入后的整数。</p>
</li>
<li>
<h3 id="sin"><a class="header" href="#sin">SIN()</a></h3>
<p>返回field value的正弦值。</p>
<h4 id="基本语法-22"><a class="header" href="#基本语法-22">基本语法</a></h4>
<pre><code class="language-sql">SELECT SIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SIN(field_key)</code>返回field key对应的field value的正弦值。</p>
<p><code>SIN(*)</code>返回在measurement中每个field key对应的field value的正弦值。</p>
<p><code>SIN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SIN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值"><a class="header" href="#计算指定field-key对应的field-value的正弦值">计算指定field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z 0.6702291758433747
2021-09-18T00:03:00Z -0.3048106211022167
2021-09-18T00:06:00Z -0.9997551733586199
2021-09-18T00:09:00Z -0.9997551733586199
2021-09-18T00:12:00Z 0.16735570030280694
2021-09-18T00:15:00Z -0.9851462604682474
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:27:00Z -0.4441126687075084
2021-09-18T00:30:00Z -0.38778163540943045
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正弦值">计算measurement中每个field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin_pressure          sin_temperature      sin_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.9200260381967907    0.6702291758433747   -0.8979276806892912
2021-09-18T00:03:00Z 0.25382336276203626   -0.3048106211022167  -0.9851462604682474
2021-09-18T00:06:00Z -0.5587890488516162   -0.9997551733586199  0.9995201585807312
2021-09-18T00:09:00Z -0.026551154023966794 -0.9997551733586199  -0.9997551733586199
2021-09-18T00:12:00Z 0.9200260381967907    0.16735570030280694  0.7738906815578891
2021-09-18T00:15:00Z 0.9928726480845371    -0.9851462604682474  -0.7391806966492229
2021-09-18T00:18:00Z -0.9997551733586199   -0.4441126687075084  -0.5587890488516162
2021-09-18T00:21:00Z 0.9200260381967907    -0.8979276806892912  0.9928726480845371
2021-09-18T00:24:00Z -0.026551154023966794 0.7738906815578891   -0.11478481378318722
2021-09-18T00:27:00Z 0.9995201585807312    -0.4441126687075084  0.5139784559875352
2021-09-18T00:30:00Z -0.7391806966492229   -0.38778163540943045 -0.9938886539233751
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正弦值并包含多个子句">计算指定field key对应的field value的正弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sin
----                 ---
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:15:00Z -0.9851462604682474
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-22"><a class="header" href="#高级语法-22">高级语法</a></h4>
<pre><code class="language-sql">SELECT SIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正弦值。</p>
<p><code>SIN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值"><a class="header" href="#计算平均值的正弦值">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z -0.9632009590319781
2021-09-18T00:12:00Z 0.9510546532543747
2021-09-18T00:24:00Z -0.6680290772524845
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正弦值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正弦值。</p>
</li>
<li>
<h3 id="sqrt"><a class="header" href="#sqrt">SQRT()</a></h3>
<p>返回field value的平方根。</p>
<h4 id="基本语法-23"><a class="header" href="#基本语法-23">基本语法</a></h4>
<pre><code>SELECT SQRT( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SQRT(field_key)</code>返回field key对应的field value的平方根。</p>
<p><code>SQRT(*)</code>返回在measurement中每个field key对应的field value的平方根。</p>
<p><code>SQRT()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SQRT()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用”oceanic_station”数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根"><a class="header" href="#计算指定field-key对应的field-value的平方根">计算指定field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.14142842854285
2021-09-18T00:03:00Z 7.745966692414834
2021-09-18T00:06:00Z 7.416198487095663
2021-09-18T00:09:00Z 7.416198487095663
2021-09-18T00:12:00Z 7.937253933193772
2021-09-18T00:15:00Z 8.602325267042627
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:27:00Z 8.888194417315589
2021-09-18T00:30:00Z 8.660254037844387
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平方根"><a class="header" href="#计算measurement中每个field-key对应的field-value的平方根">计算measurement中每个field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt_pressure      sqrt_temperature  sqrt_visibility
----                 -------------      ----------------  ---------------
2021-09-18T00:00:00Z 8                  7.14142842854285  8.246211251235321
2021-09-18T00:03:00Z 8.48528137423857   7.745966692414834 8.602325267042627
2021-09-18T00:06:00Z 7.3484692283495345 7.416198487095663 8.774964387392123
2021-09-18T00:09:00Z 8.12403840463596   7.416198487095663 7.416198487095663
2021-09-18T00:12:00Z 8                  7.937253933193772 8.366600265340756
2021-09-18T00:15:00Z 7.615773105863909  8.602325267042627 7.874007874011811
2021-09-18T00:18:00Z 7.416198487095663  8.888194417315589 7.3484692283495345
2021-09-18T00:21:00Z 8                  8.246211251235321 7.615773105863909
2021-09-18T00:24:00Z 8.12403840463596   8.366600265340756 8.306623862918075
2021-09-18T00:27:00Z 8.774964387392123  8.888194417315589 8.831760866327848
2021-09-18T00:30:00Z 7.874007874011811  8.660254037844387 8.94427190999916
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的平方根。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平方根并包含多个子句">计算指定field key对应的field value的平方根并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sqrt
----                 ----
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:15:00Z 8.602325267042627
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-23"><a class="header" href="#高级语法-23">高级语法</a></h4>
<pre><code>SELECT SQRT(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的平方根。</p>
<p><code>SQRT()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的平方根"><a class="header" href="#计算平均值的平方根">计算平均值的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.433034373659253
2021-09-18T00:12:00Z 8.426149773176359
2021-09-18T00:24:00Z 8.640987597877148
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的平方根。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SQRT()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的平方根。</p>
</li>
<li>
<h3 id="tan"><a class="header" href="#tan">TAN()</a></h3>
<p>返回field value的正切值。</p>
<h4 id="基本语法-24"><a class="header" href="#基本语法-24">基本语法</a></h4>
<pre><code>SELECT TAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TAN(field_key)</code>返回field key对应的field value的正切值。</p>
<p><code>TAN(*)</code>返回在measurement中每个field key对应的field value的正切值。</p>
<p><code>TAN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>TAN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值"><a class="header" href="#计算指定field-key对应的field-value的正切值">计算指定field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z 0.9030861493754311
2021-09-18T00:03:00Z 0.320040389379563
2021-09-18T00:06:00Z -45.18308791052113
2021-09-18T00:09:00Z -45.18308791052113
2021-09-18T00:12:00Z 0.16974975208268753
2021-09-18T00:15:00Z -5.737022539278999
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:27:00Z 0.49567753318135577
2021-09-18T00:30:00Z -0.42070095062112434
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正切值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正切值">计算measurement中每个field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan_pressure         tan_temperature      tan_visibility
----                 ------------         ---------------      --------------
2021-09-18T00:00:00Z 2.3478603091954366   0.9030861493754311   -2.040081598015946
2021-09-18T00:03:00Z -0.26241737750193517 0.320040389379563    -5.737022539278999
2021-09-18T00:06:00Z 0.6738001006480597   -45.18308791052113   -32.268575775934416
2021-09-18T00:09:00Z 0.026560517776039395 -45.18308791052113   -45.18308791052113
2021-09-18T00:12:00Z 2.3478603091954366   0.16974975208268753  1.2219599181369432
2021-09-18T00:15:00Z 8.33085685249046     -5.737022539278999   -1.0975097786622852
2021-09-18T00:18:00Z -45.18308791052113   0.49567753318135577  0.6738001006480597
2021-09-18T00:21:00Z 2.3478603091954366   -2.040081598015946   8.33085685249046
2021-09-18T00:24:00Z 0.026560517776039395 1.2219599181369432   -0.11554854579453279
2021-09-18T00:27:00Z -32.268575775934416  0.49567753318135577  -0.5991799983411151
2021-09-18T00:30:00Z -1.0975097786622852  -0.42070095062112434 9.00365494560708
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正切值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正切值并包含多个子句">计算指定field key对应的field value的正切值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 tan
----                 ---
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:15:00Z -5.737022539278999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-24"><a class="header" href="#高级语法-24">高级语法</a></h4>
<pre><code class="language-sql">SELECT TAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正切值。</p>
<p><code>TAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值-1"><a class="header" href="#计算平均值的正弦值-1">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z -3.583573177439047
2021-09-18T00:12:00Z -3.0776204031933605
2021-09-18T00:24:00Z -0.8977254452596822
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正切值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>TAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正切值。</p>
</li>
</ul>
<h3 id="预测函数"><a class="header" href="#预测函数">预测函数</a></h3>
<ul>
<li>
<h3 id="holt_winters"><a class="header" href="#holt_winters">HOLT_WINTERS()</a></h3>
<ul>
<li>
<p>使用<a href="https://www.otexts.org/fpp/7/5?spm=a2c4g.11186623.2.92.41fc3ee27HC1R6">Holt-Winters</a>的季节性方法返回N个预测的field value。</p>
<p><code>HOLT_WINTERS()</code>可用于：</p>
<ul>
<li>预测时间什么时候会超过给定的阈值</li>
<li>将预测值与实际值进行比较，检测数据中的异常</li>
</ul>
</li>
</ul>
<h4 id="语法-31"><a class="header" href="#语法-31">语法</a></h4>
<pre><code>SELECT HOLT_WINTERS[_WITH-FIT](&lt;function&gt;(&lt;field_key&gt;),&lt;N&gt;,&lt;S&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>HOLT_WINTERS(function(field_key),N,S)</code>返回field key对应的<code>N</code>个季节性调整的预测field value。</p>
<p><code>N</code>个预测值出现的时间间隔跟group by time时间间隔相同。如果您的<code>GROUP BY time()</code>时间间隔是<code>6m</code>并且<code>N</code>等于<code>3</code>，那么您将会得到3个时间间隔为6分钟的预测值。</p>
<p><code>S</code>是一个季节性模式参数，并且根据<code>GROUP BY time()</code>时间间隔限定一个季节性模式的长度。如果您的<code>GROUP BY time()</code>时间间隔是<code>2m</code>并且<code>S</code>等于<code>3</code>，那么这个季节性模式每六分钟出现一次，也就是每三个<code>point</code>。如果您不希望季节性调整您的预测值，请将<code>S</code>设置为<code>0</code>或<code>1</code>。</p>
<p><code>HOLT_WINTERS_WITH_FIT(function(field_key),N,S)</code>除了返回field key对应的<code>N</code>个季节性调整的预测field value，还返回拟合值。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>处理以相同的时间间隔出现的数据；嵌套的cnosQL函数和<code>GROUP BY time()</code>子句确保Holt-Winters函数能够对常规数据进行操作。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-39"><a class="header" href="#示例-39">示例</a></h4>
<ul>
<li>
<h4 id="预测指定field-key的field-value"><a class="header" href="#预测指定field-key的field-value">预测指定field key的field value</a></h4>
</li>
<li>
<h4 id="原始数据"><a class="header" href="#原始数据">原始数据</a></h4>
</li>
</ul>
<p>该示例重点关注<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">SELECT &quot;temperature&quot; FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00'
</code></pre>
<ul>
<li>
<h4 id="步骤一匹配原始数据的趋势"><a class="header" href="#步骤一匹配原始数据的趋势">步骤一：匹配原始数据的趋势</a></h4>
</li>
</ul>
<p>编写一个<code>GROUP BY time()</code>查询，使得它匹配原始<code>temperature</code>数据的总体趋势。这里，我们使用了<code>FIRST()</code>函数：</p>
<pre><code class="language-sql">SELECT FIRST(&quot;temperature&quot;) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' and time &gt;= '2021-09-12 12:12:00' and time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>GROUP BY time()</code>子句中，第一个参数(<code>379m</code>)匹配<code>temperature</code>数据中每个波峰和波谷之间发生的时间长度，第二个参数(<code>348m</code>)是一个偏移间隔，它通过改变CnosDB的默认<code>GROUP BY time()</code>边界来匹配原始数据的时间范围。</p>
<ul>
<li>
<h4 id="步骤二确定季节性模式"><a class="header" href="#步骤二确定季节性模式">步骤二：确定季节性模式</a></h4>
</li>
</ul>
<p>使用步骤一中查询的信息确定数据中的季节性模式。</p>
<ul>
<li>
<h4 id="步骤三应用holt_winters函数"><a class="header" href="#步骤三应用holt_winters函数">步骤三：应用<code>HOLT_WINTERS()</code>函数</a></h4>
</li>
</ul>
<p>在查询中加入Holt-Winters函数。这里，我们使用<code>HOLT_WINTERS_WITH_FIT()</code>来查看拟合值和预测值：</p>
<pre><code class="language-sql">SELECT HOLT_WINTERS_WITH_FIT(FIRST(&quot;temperature&quot;),10,4) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>HOLT_WINTERS_WITH_FIT()</code>函数中，第一个参数(<code>10</code>)请求10个预测的field value。每个预测的<code>point</code>相距<code>379m</code>，与<code>GROUP BY time()</code>子句中的第一个参数相同。<code>HOLT_WINTERS_WITH_FIT()</code>函数中的第二个参数(<code>4</code>)是我们在上一步骤中确定的季节性模式。</p>
<h4 id="holt_winters的常见问题"><a class="header" href="#holt_winters的常见问题"><code>HOLT_WINTERS()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="holt_winters和收到的point少于n个"><a class="header" href="#holt_winters和收到的point少于n个"><code>HOLT_WINTERS()</code>和收到的<code>point</code>少于”N”个</a></h4>
</li>
</ul>
<p>在某些情况下，用户可能会收到比参数<code>N</code>请求的更少的预测<code>point</code>。当数学计算不稳定和不能预测更多<code>point</code>时，这种情况就会发生。这意味着该数据集不适合使用<code>HOLT_WINTERS()</code>，或者，季节性调整参数是无效的并且是算法混乱。</p>
</li>
</ul>
<h3 id="分析函数"><a class="header" href="#分析函数">分析函数</a></h3>
<p>下面技术分析的函数将广泛使用的算法应用在您的数据中。虽然这些函数主要应用在金融和投资领域，但是它们也适用于其它行业和用例。</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></p>
<ul>
<li>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>除了field key，技术分析函数还接受以下参数：</p>
<p><code>PERIOD</code></p>
<p><strong>必需，整数，min=1</strong></p>
<p>算法的样本大小。这基本上是对算法的输出有显著影响的历史样本的数量。例如，<code>2</code>表示当前的<code>point</code>和前一个<code>point</code>。算法使用指数衰减率来决定历史<code>point</code>的权重，通常称为<code>alpha(α)</code>。参数<code>PERIOD</code>控制衰减率。</p>
<blockquote>
<p>请注意，历史<code>point</code>仍然可以产生影响。</p>
</blockquote>
<h4 id="hold_period"><a class="header" href="#hold_period">HOLD_PERIOD</a></h4>
<p><strong>整数，min=-1</strong></p>
<p>算法需要多少个样本才会开始发送结果。默认值<code>-1</code>表示该参数的值基于算法、<code>PERIOD</code>和<code>WARMUP_TYPE</code>，但是这是一个可以使算法发送有意义的结果的值。</p>
<p><strong>默认的Hold Periods：</strong></p>
<p>对于大多数提供的技术分析，<code>HOLD_PERIOD</code>的默认值由您使用的技术分析算法和<code>WARMUP_TYPE</code>决定。</p>
</li>
</ul>
<table><thead><tr><th>算法 \ Warmup Type</th><th>simple</th><th>exponential</th><th style="text-align: center">none</th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE</a></td><td>PERIOD - 1</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 2</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 3</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE</a></td><td>( PERIOD - 1 ) * 3 + 1</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center">PERIOD - 1</td></tr>
</tbody></table>
<p><em><strong>Kaufman算法默认的Hold Periods：</strong></em></p>
<table><thead><tr><th>算法</th><th>默认的Hold Period</th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></td><td>PERIOD</td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></td><td>PERIOD</td></tr>
</tbody></table>
<h4 id="warmup_type"><a class="header" href="#warmup_type">WARMUP_TYPE</a></h4>
<p><strong>默认=”exponential”</strong></p>
<p>这个参数控制算法如何为第一个<code>PERIOD</code>样本初始化自身，它本质上是具有不完整样本集的持续时间。</p>
<p><code>simple</code>
第一个<code>PERIOD</code>样本的简单移动平均值(simple moving average，SMA)。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.106.41fc3ee27HC1R6">ta-lib</a>使用的方法。</p>
<p><code>exponential</code>
具有缩放alpha(α)的指数移动平均值(exponential moving average，EMA)。基本上是这样使用EMA：<code>PERIOD=1</code>用于第一个点，<code>PERIOD=2</code>用于第二个点，以此类推，直至算法已经消耗了<code>PERIOD</code>个<code>point</code>。由于算法一开始就使用了EMA，当使用此方法并且没有指定<code>HOLD_PERIOD</code>的值或<code>HOLD_PERIOD</code>的值为<code>-1</code>时，算法可能会在比<code>simple</code>小得多的样本大小的情况下开始发送<code>point</code>。</p>
<p><code>none</code>
算法不执行任何的平滑操作。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.107.41fc3ee27HC1R6">ta-lib</a>使用的方法。当使用此方法并且没有指定<code>HOLD_PERIOD</code>时，<code>HOLD_PERIOD</code>的默认值是<code>PERIOD - 1</code>。</p>
<blockquote>
<p>类型<code>none</code>仅适用于<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数。</p>
</blockquote>
<ul>
<li>
<h3 id="chande_momentum_oscillator"><a class="header" href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></h3>
<p>Chande Momentum Oscillator (CMO)是由Tushar Chande开发的一个技术动量指标。通过计算所有最近较高<code>point</code>的总和与所有最近较低<code>point</code>的总和的差值，然后将结果除以给定时间范围内的所有数据变动的总和来创建CMO指标。将结果乘以100可以得到一个从-100到+100的范围。
<sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo" target="\_blank">Source</a></p>
<h4 id="基本语法-25"><a class="header" href="#基本语法-25">基本语法</a></h4>
<pre><code>CHANDE_MOMENTUM_OSCILLATOR([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;, [warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup-type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 2)</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 10, 9, 'none')</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>none</code>。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用CMO算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(/regular_expression/, 2)</code>返回使用CMO算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(*, 2)</code>返回使用CMO算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="exponential_moving_average"><a class="header" href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>指数移动平均值 (Exponential Moving Average，EMA)类似于简单移动平均值，不同的是，指数移动平均值对最新数据给予更多的权重，它也被称为”指数加权移动平均值”。与简单移动平均值相比，这种类型的移动平均值对最近数据的变化反应更快。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/e/ema.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-26"><a class="header" href="#基本语法-26">基本语法</a></h4>
<pre><code>EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用参数:</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用EMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用EMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用EMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="double_exponential_moving_average"><a class="header" href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>双重指数移动平均值 (Double Exponential Moving Average，DEMA)通过增加最近数据的权重，尝试消除与移动平均值相关的固有滞后。该名字似乎表明这是通过双重指数平滑来实现的，然而事实并非如此，它表示的是将EMA的值翻倍。为了使它与实际数据保持一致，也为了消除滞后，从之前两倍EMA的值中把”EMA of EMA”的值减去，公式为：DEMA = 2 * EMA - EMA(EMA)。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Double_exponential_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-27"><a class="header" href="#基本语法-27">基本语法</a></h4>
<pre><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用DEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用DEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用DEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="kaufmans_efficiency_ratio"><a class="header" href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></h3>
<p>Kaufman效率比 (Kaufman’s Efficiency Ration)，或简称为效率比 (Efficiency Ratio，ER)，它的计算方法是：将一段时间内的数据变化除以实现该变化所发生的数据变动的绝对值的总和。得出的比率在0和1之间，比率越高，表示市场越有效率或越有趋势。</p>
</li>
</ul>
<p>ER跟Chande Momentum Oscillator (CMO)非常类似。不同的是，CMO将市场方向考虑在内，但是如果您将CMO的绝对值除以100，就可以得到ER。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://etfhq.com/blog/2011/02/07/kaufmans-efficiency-ratio/" target="\_blank">Source</a></p>
<h4 id="基本语法-28"><a class="header" href="#基本语法-28">基本语法</a></h4>
<pre><code class="language-sql">KAUFMANS_EFFICIENCY_RATIO([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 2)</code>返回使用效率指数(Efficiency Index)算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 10, 10)</code>返回使用效率指数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用效率指数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_EFFICIENCY_RATIO()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_EFFICIENCY_RATIO(/regular_expression/, 2)</code>返回使用效率指数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(*, 2)</code>返回使用效率指数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO()</code>支持数据类型为int64和float64的field value。</p>
<ul>
<li>
<h3 id="kaufmans_adaptive_moving_average"><a class="header" href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></h3>
<p>Kaufman自适应移动平均值 (Kaufman’s Adaptive Moving Average，KAMA)，是一个用于计算样本噪音或波动率的移动平均值。当数据波动相对较小并且噪音较低时，KAMA会密切关注<code>point</code>。当数据波动较大时，KAMA会进行调整，平滑噪音。该趋势跟踪指标可用于识别总体趋势、时间转折点和过滤价格变动。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:kaufman_s_adaptive_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-29"><a class="header" href="#基本语法-29">基本语法</a></h4>
<pre><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 2)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 10, 10)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用KAMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用KAMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(*, 2)</code>返回使用KAMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_moving_average"><a class="header" href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>三重指数移动平均值 (Triple Exponential Moving Average，TEMA)，旨在过滤常规移动平均值的波动。该名字似乎表明这是通过三重指数平滑来实现的，然而事实并非如此，它实际上是包含指数移动平均值、双重指数移动平均值和三重指数移动平均值的复合函数。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/t/triple-exponential-moving-average.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-30"><a class="header" href="#基本语法-30">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用TEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用TEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用TEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_derivative"><a class="header" href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></h3>
<p>三重指数导数指标 (Triple Exponential Derivative Indicator)，通常称为”TRIX”，是一种用于识别超卖和超买市场的振荡器，也可用作动量指标。TRIX计算一段时间内输入数据的对数的三重指数移动平均值。从当前的值中减去之前的值，这可以防止指标考虑比规定期间短的周期。</p>
</li>
</ul>
<p>跟很多振荡器一样，TRIX围绕着零线震荡。当它用作振荡器时，正数表示炒买超买市场，而负数表示超卖市场。当它用作动量指标时，正数表示动量在增加，而负数表示动量在减少。很多分析师认为，当TRIX超过零线时，它会给出买入信号，当低于零线时，它会给出卖出信号。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/articles/technical/02/092402.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-31"><a class="header" href="#基本语法-31">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_DERIVATIVE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 2)</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 10, 10, 'exponential')</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用三重指数导数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(/regular_expression/, 2)</code>返回使用三重指数导数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(*, 2)</code>返回使用三重指数导数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<ul>
<li>
<h3 id="relative_strength_index"><a class="header" href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></h3>
<p>相对强弱指数 (Relative Strength Index，RSI)是一个动量指标，用于比较在指定时间段内最近数据增大和减小的幅度，以便measurement数据变动的速度和变化。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/r/rsi.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-32"><a class="header" href="#基本语法-32">基本语法</a></h4>
<pre><code>RELATIVE_STRENGTH_INDEX([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 2)</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 10, 10, 'exponential')</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>RELATIVE_STRENGTH_INDEX(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用RSI算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>RELATIVE_STRENGTH_INDEX()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>RELATIVE_STRENGTH_INDEX(/regular_expression/, 2)</code>返回使用RSI算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(*, 2)</code>返回使用RSI算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<h4 id="示例数据"><a class="header" href="#示例数据">示例数据</a></h4>
<p>本文档使用的数据可在<a href="content/cnosdb/latest/cnosql/oceanic_station.txt">示例数据</a>中下载。</p>
<h4 id="函数的通用语法"><a class="header" href="#函数的通用语法">函数的通用语法</a></h4>
<ul>
<li>
<h4 id="在select中指定多个函数"><a class="header" href="#在select中指定多个函数">在<code>SELECT</code>中指定多个函数</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;(),&lt;function&gt;() FROM_clause [...]
</code></pre>
<p>使用逗号(<code>,</code>)将<code>SELECT</code>语句中的多个函数分开。该语法适用于除<code>TOP()</code>和<code>BOTTOM()</code>之外的所有cnosQL函数。<code>SELECT</code>子句不支持<code>TOP()</code>或<code>BOTTOM()</code>和其它函数同时使用。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的平均值和平均数"><a class="header" href="#在一个查询中计算field-value的平均值和平均数">在一个查询中计算field value的平均值和平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;),MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mean              median
----                 ----              ------
1970-01-01T00:00:00Z 64.94933267424616 65
</code></pre>
<p>该查询返回<code>temperature</code>的平均值和平均数。</p>
<ul>
<li>
<h4 id="在一个查询中计算两个field的mode"><a class="header" href="#在一个查询中计算两个field的mode">在一个查询中计算两个field的mode</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;),MODE(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 mode mode_1
----                 ---- ------
1970-01-01T00:00:00Z 53
</code></pre>
<p>该查询返回<code>temperature</code>中出现频率最高的field value和<code>pressure</code>中出现频率最高的field value。<code>temperature</code>对应的值在列<code>mode</code>中，<code>pressure</code>对应的值在列<code>mode_1</code>中。因为系统不能返回多个具有相同名字的列，所以它将第二个列<code>mode</code>重命名为<code>mode_1</code>。</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的最小值和最大值"><a class="header" href="#在一个查询中计算field-value的最小值和最大值">在一个查询中计算field value的最小值和最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;), MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min max
----                 --- ---
1970-01-01T00:00:00Z 50  80
</code></pre>
<p>该查询返回<code>temperature</code>的最小值和最大值。</p>
<p>请注意，该查询返回<code>1970-01-01T00:00:00Z</code>作为时间戳，这是CnosDB的空时间戳。<code>MIN()</code>和<code>MAX()</code>是selector函数；当selector函数是<code>SELECT</code>子句中的唯一函数时，它返回一个特定的时间戳。因为<code>MIN()</code>和<code>MAX()</code>返回两个不同的时间戳（见下面的例子），所以系统会用空时间戳覆盖这些时间戳。</p>
<pre><code class="language-sql">&gt;  SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  min
----                  ---
2021-08-31T16:18:00Z  50    &lt;--- Timestamp 1

&gt;  SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2021-08-31T18:03:00Z  80    &lt;--- Timestamp 2
</code></pre>
<h4 id="重命名查询结果字段"><a class="header" href="#重命名查询结果字段">重命名查询结果字段</a></h4>
<ul>
<li>
<h4 id="语法-32"><a class="header" href="#语法-32">语法</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;() AS &lt;field_key&gt; [...]
</code></pre>
<p>默认情况下，函数返回的结果在与函数名称匹配的field key下面。使用<code>AS</code>子句可以指定输出的field key的名字。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="指定输出的field-key"><a class="header" href="#指定输出的field-key">指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) AS &quot;dream_name&quot; FROM &quot;air&quot;
name: air
time                  dream_name
----                  ----------
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<p>该查询返回<code>temperature</code>的平均值，并将输出的field key重命名为<code>dream_name</code>。如果没有<code>AS</code>子句，那么查询会返回<code>mean</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  mean
----                  ----
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<ul>
<li>
<h4 id="为多个函数指定输出的field-key"><a class="header" href="#为多个函数指定输出的field-key">为多个函数指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) AS &quot;med_wat&quot;,MODE(&quot;temperature&quot;) AS &quot;mode_wat&quot; FROM &quot;air&quot;
name: air
time                 med_wat mode_wat
----                 ------- --------
1970-01-01T00:00:00Z 65      53
</code></pre>
<p>该查询返回<code>temperature</code>的平均数和<code>temperature</code>中出现频率最高的field value，并将输出的field key分别重命名为<code>med_wat</code>和<code>mode_wat</code>。如果没有<code>AS</code>子句，那么查询会返回<code>median</code>和<code>mode</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;),MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 median mode
----                 ------ ----
1970-01-01T00:00:00Z 65     53
</code></pre>
<h4 id="改变不含数据的时间间隔的返回值"><a class="header" href="#改变不含数据的时间间隔的返回值">改变不含数据的时间间隔的返回值</a></h4>
<p>默认情况下，包含cnosQL函数和<code>GROUP BY time()</code>子句的查询对不包含数据的时间间隔返回空值。在<code>GROUP BY</code>子句后面加上<code>fill()</code>可以更改这个值。关于<code>fill()</code>的详细讨论，请查看数据探索。</p>
<h4 id="函数的常见问题"><a class="header" href="#函数的常见问题">函数的常见问题</a></h4>
<p>以下部分描述了所有函数、聚合函数和选择函数的常见混淆来源，有关单个功能的常见问题，请参见以下特定文档：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-distinct">DISTINCT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-bottom">BOTTOM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-percentile">PERCENTILE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-sample">SAMPLE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-top">TOP()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-elapsed">ELAPSED()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-holt-winters">HOLT_WINTERS()</a></li>
</ul>
<h4 id="所有函数"><a class="header" href="#所有函数">所有函数</a></h4>
<ul>
<li>
<h4 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h4>
</li>
</ul>
</li>
</ul>
<p>某些cnosQL 函数支持 <a href="content/cnosdb/latest/cnosql//cnosdb/v1.8/query_language/explore-data/#select-clause"><code>SELECT</code> clause</a>中嵌套:</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a> with <a href="content/cnosdb/latest/cnosql/cnosql_function.html#distinct"><code>DISTINCT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#cumulative-sum"><code>CUMULATIVE_SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#derivative"><code>DERIVATIVE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#difference"><code>DIFFERENCE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#elapsed"><code>ELAPSED()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#moving-average"><code>MOVING_AVERAGE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#non-negative-derivative"><code>NON_NEGATIVE_DERIVATIVE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#holt-winters"><code>HOLT_WINTERS()</code></a> and <a href="content/cnosdb/latest/cnosql/cnosql_function.html#holt-winters"><code>HOLT_WINTERS_WITH_FIT()</code></a></li>
</ul>
<ul>
<li>
<h4 id="查询在now之后的时间范围"><a class="header" href="#查询在now之后的时间范围">查询在now()之后的时间范围</a></h4>
</li>
</ul>
<p>大多数<code>SELECT</code>语句的默认时间范围在<code>1677-09-21 00:12:43.145224194</code> UTC和<code>2262-04-11T23:47:16.854775806Z</code> UTC之间。对于包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询，默认的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。</p>
<p>如果要查询时间戳发生在<code>now()</code>之后的数据，那么包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询必须在<code>WHERE</code>子句中提供一个时间上限。请查看常见问题。</p>
<h4 id="聚合函数-1"><a class="header" href="#聚合函数-1">聚合函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳"><a class="header" href="#理解返回的时间戳">理解返回的时间戳</a></h4>
</li>
</ul>
<p>子句中具有 <a href="content/cnosdb/latest/cnosql/cnosql_function.html#aggregations">聚合函数</a> 且 <code>WHERE</code>没有时间范围的查询讲返回 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间戳.
CnosDB 使用 epoch 0 作为等效的空时间戳.
带有聚合函数的查询，如果 <code>WHERE</code> 子句中包含时间范围，将返回时间下限作为时间戳.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用聚合函数并且没有指定时间范围"><a class="header" href="#使用聚合函数并且没有指定时间范围">使用聚合函数并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 1839495
</code></pre>
</li>
</ul>
<p>该查询将CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为时间戳返回。<code>SUM()</code>将多个<code>point</code>聚合，没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围"><a class="header" href="#使用聚合函数并且指定时间范围">使用聚合函数并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 134766
</code></pre>
</li>
</ul>
<p>该查询将时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为时间戳返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围和使用group-by-time子句"><a class="header" href="#使用聚合函数并且指定时间范围和使用group-by-time子句">使用聚合函数并且指定时间范围和使用GROUP BY time()子句</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:28:00Z' GROUP BY time(12m)
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 490
2021-09-28T00:12:00Z 524
2021-09-28T00:24:00Z 263
</code></pre>
</li>
</ul>
<p>该查询将每个<code>GROUP BY time()</code>间隔的时间下界作为时间戳返回。</p>
<ul>
<li>
<h4 id="将聚合函数和不聚合的数据混合使用"><a class="header" href="#将聚合函数和不聚合的数据混合使用">将聚合函数和不聚合的数据混合使用</a></h4>
</li>
</ul>
<p>聚合函数不支持在<code>SELECT</code>语句中指定不使用聚合函数的单独的field key或tag key。聚合函数返回一个计算结果，对于没有被聚合的field或tag，没有明显的单个值可以返回。当<code>SELECT</code>语句同时包含聚合函数和单独的field key或tag key时，会返回错误：</p>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;),&quot;station&quot; FROM &quot;air&quot;
ERR: mixing aggregate and non-aggregate queries is not supported
</code></pre>
<ul>
<li>
<h4 id="得到略有不同的结果"><a class="header" href="#得到略有不同的结果">得到略有不同的结果</a></h4>
</li>
</ul>
<p>对于某些聚合函数，在相同的<code>point</code>（数据类型为float64)上执行相同的函数，可能会产生稍微不同的结果。在应用聚合函数之间，CnosDB不会将<code>point</code>进行排序；该行为可能会导致查询结果中出现小小的差异。</p>
<h4 id="selector函数"><a class="header" href="#selector函数">Selector函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳-1"><a class="header" href="#理解返回的时间戳-1">理解返回的时间戳</a></h4>
</li>
</ul>
<p>selector函数返回的时间戳依赖查询中函数的数量和查询中的其它子句：</p>
<p>带有单个选择器函数，单个 field key 参数和无 <code>GROUP BY time()</code> 的查询返回原始数据中出现的point时间戳.
具有单个 selector 函数, 多个 <code>field key</code> 参数的查询, <code>GROUP BY time()</code> 返回原始数据中出现的point 时间戳，或与空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>)等价的CnosDB.</p>
<p><code>WHERE</code>子句中有多个函数且没有时间范围的查询将返回相当于空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>).
在 <code>WHERE</code>子句中包含多个函数和时间范围的查询将时间下限作为时间戳返回</p>
<p>带有 selector 函数和  <code>GROUP BY time()</code> 子句的查询返回每个 <code>GROUP BY time()</code>间隔的时间下限.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用单个selector函数和单个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和单个field-key并且没有指定时间范围">使用单个selector函数和单个field key，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964

&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 max
----                 ---
2021-09-28T01:57:00Z 80
</code></pre>
</li>
</ul>
<p>该查询返回原始数据中具有<code>最大</code>值的<code>point</code>的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数和多个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和多个field-key并且没有指定时间范围">使用单个selector函数和多个field key，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;
name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71

&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80

</code></pre>
</li>
</ul>
<p>第一个查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>FIRST(*)</code>返回两个时间戳（对应measurement <code>air</code>中的每个field key），所以系统使用空时间戳覆盖这两个时间戳。</p>
<p>第二个查询返回原始数据中具有最大值的<code>point</code>的时间戳。因为<code>MAX(*)</code>只返回一个时间戳(measurement <code>air</code>中只有一个数值类型的field)，所以系统不会覆盖原始时间戳。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且没有指定时间范围"><a class="header" href="#使用多个selector函数并且没有指定时间范围">使用多个selector函数，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max min
----                 --- ---
1970-01-01T00:00:00Z 80  50 
</code></pre>
</li>
</ul>
<p>该查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>MAX()</code>和<code>MIN()</code>函数返回不同的时间戳，所以系统没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且指定时间范围"><a class="header" href="#使用多个selector函数并且指定时间范围">使用多个selector函数，并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
  name: air
  time                 max min
  ----                 --- ---
  2021-09-28T00:00:00Z 80  50
</code></pre>
</li>
</ul>
<p>该查询返回时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为查询结果中的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数并且指定时间范围"><a class="header" href="#使用单个selector函数并且指定时间范围">使用单个selector函数，并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:18:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 80
2021-09-18T00:12:00Z 797
</code></pre>
</li>
</ul>
<p>该查询返回每个<code>GROUP BY time()</code>间隔的时间下限作为查询结果中的时间戳。</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosql-数学运算符"><a class="header" href="#cnosql-数学运算符">CnosQL 数学运算符</a></h2>
<ul>
<li>
<h3 id="数学运算符"><a class="header" href="#数学运算符"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6">数学运算符</a></a></h3>
<ul>
<li>
<h4 id="加法"><a class="header" href="#加法"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E5%8A%A0%E6%B3%95">加法</a></a></h4>
</li>
<li>
<h4 id="减法"><a class="header" href="#减法"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E5%87%8F%E6%B3%95">减法</a></a></h4>
</li>
<li>
<h4 id="乘法"><a class="header" href="#乘法"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%B9%98%E6%B3%95">乘法</a></a></h4>
</li>
<li>
<h4 id="除法"><a class="header" href="#除法"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E9%99%A4%E6%B3%95">除法</a></a></h4>
</li>
<li>
<h4 id="模运算"><a class="header" href="#模运算"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%A8%A1%E8%BF%90%E7%AE%97">模运算</a></a></h4>
</li>
<li>
<h4 id="位与运算"><a class="header" href="#位与运算"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97">位与运算</a></a></h4>
</li>
<li>
<h4 id="位或运算"><a class="header" href="#位或运算"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%BD%8D%E6%88%96%E8%BF%90%E7%AE%97">位或运算</a></a></h4>
</li>
<li>
<h4 id="位异运算"><a class="header" href="#位异运算"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%BD%8D%E5%BC%82%E8%BF%90%E7%AE%97">位异运算</a></a></h4>
</li>
<li>
<h4 id="常见问题"><a class="header" href="#常见问题"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></a></h4>
</li>
</ul>
</li>
<li>
<h3 id="不支持的运算符"><a class="header" href="#不支持的运算符"><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6">不支持的运算符</a></a></h3>
</li>
<li>
<h3 id="数学运算符-1"><a class="header" href="#数学运算符-1">数学运算符</a></h3>
<ul>
<li>
<h4 id="加法-1"><a class="header" href="#加法-1">加法</a></h4>
</li>
</ul>
<p>常量的加法</p>
<pre><code>SELECT &quot;temperature&quot; + 5 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; + 5 &gt; 10
</code></pre>
<p>两字段的加法</p>
<pre><code>SELECT &quot;temperature&quot; + &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; + &quot;visibility&quot; &gt; 10
</code></pre>
<ul>
<li>
<h4 id="减法-1"><a class="header" href="#减法-1">减法</a></h4>
</li>
</ul>
<p>常量的减法</p>
<pre><code>SELECT &quot;temperature&quot; - 2 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - 2 &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; - &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - &quot;visibility&quot; &gt; 10
</code></pre>
<ul>
<li>
<h4 id="乘法-1"><a class="header" href="#乘法-1">乘法</a></h4>
</li>
</ul>
<p>常量的乘法</p>
<pre><code>SELECT &quot;temperature&quot; * 2 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - 2 &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; * &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; * &quot;visibility&quot; &gt; 10
</code></pre>
<p>乘法和其他操作符并用</p>
<pre><code>SELECT 10 * (&quot;temperature&quot; + &quot;visibility&quot; + &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 * (&quot;temperature&quot; + &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 * (&quot;temperature&quot; - &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
</code></pre>
<ul>
<li>
<h4 id="除法-1"><a class="header" href="#除法-1">除法</a></h4>
</li>
</ul>
<p>常量的除法</p>
<pre><code>SELECT 10 / &quot;temperature&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE 10 / &quot;temperature&quot; &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; / &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; / &quot;visibility&quot; &gt; 10
</code></pre>
<p>乘法和其他操作符并用</p>
<pre><code>SELECT 10 / (&quot;temperature&quot; + &quot;visibility&quot; + &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 / (&quot;temperature&quot; + &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 / (&quot;temperature&quot; - &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
</code></pre>
<ul>
<li>
<h4 id="模运算-1"><a class="header" href="#模运算-1">模运算</a></h4>
</li>
</ul>
<p>常量的模运算</p>
<pre><code>SELECT 10 % &quot;temperature&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE 10 % &quot;temperature&quot; = 0
</code></pre>
<p>两字段的模运算</p>
<pre><code>SELECT &quot;temperature&quot; % &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; % &quot;visibility&quot; = 0
</code></pre>
<ul>
<li>
<h4 id="按位与运算"><a class="header" href="#按位与运算">按位与运算</a></h4>
</li>
</ul>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; &amp; 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; &amp; &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; &amp; 15 &gt; 0
SELECT &quot;temperature&quot; &amp; &quot;pressure&quot; FROM &quot;air&quot;
SELECT (&quot;temperature&quot; ^ true) &amp; &quot;pressure&quot; FROM &quot;air&quot;
</code></pre>
<ul>
<li>
<h4 id="按位或运算"><a class="header" href="#按位或运算">按位或运算</a></h4>
</li>
</ul>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; | 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; | &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; | 12 = 12
</code></pre>
<ul>
<li>
<h4 id="按位异运算"><a class="header" href="#按位异运算">按位异运算</a></h4>
</li>
</ul>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; ^ 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; ^ &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; ^ 12 = 12
</code></pre>
<ul>
<li>
<h4 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h4>
<ul>
<li>
<h4 id="带有通配符和正则表达式的数学操作符"><a class="header" href="#带有通配符和正则表达式的数学操作符">带有通配符和正则表达式的数学操作符</a></h4>
</li>
</ul>
<p>CnosDB不支持在SELECT子句中组合数学操作与通配符(*)或正则表达式。以下查询无效，系统返回错误:
对通配符执行数学运算。</p>
<pre><code>&gt; SELECT * + 2 FROM &quot;air&quot;
ERR: unsupported expression with wildcard: * + 2
</code></pre>
<p>对函数中的通配符执行数学运算。</p>
<pre><code>&gt; SELECT COUNT(*) / 2 FROM &quot;nope&quot;
ERR: unsupported expression with wildcard: count(*) / 2
</code></pre>
<p>对正则表达式执行数学运算。</p>
<pre><code>&gt; SELECT /A/ + 2 FROM &quot;air&quot;
ERR: error parsing query: found +, expected FROM at line 1, char 12
</code></pre>
<p>对函数中的正则表达式执行数学运算。</p>
<pre><code>&gt; SELECT COUNT(/A/) + 2 FROM &quot;nope&quot;
ERR: unsupported expression with regex field: count(/A/) + 2
</code></pre>
<ul>
<li>
<h4 id="函数的数学运算符"><a class="header" href="#函数的数学运算符">函数的数学运算符</a></h4>
</li>
</ul>
<p>目前不支持在函数调用中使用数学运算符。注意，CnosDB只允许SELECT子句中的函数。
可行操作：</p>
<pre><code>SELECT 10 * mean(&quot;value&quot;) FROM &quot;cpu&quot;
</code></pre>
<p>不可行操作：</p>
<pre><code>SELECT mean(10 * &quot;value&quot;) FROM &quot;cpu&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<h3 id="不支持的运算符-1"><a class="header" href="#不支持的运算符-1">不支持的运算符</a></h3>
<ul>
<li>
<h4 id="比较运算"><a class="header" href="#比较运算">比较运算</a></h4>
</li>
</ul>
<p>所有的比较运算符都不支持。例如：<code>=</code>,<code>!=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>,<code>&lt;&gt;</code>。在SELECT语句中均不可以使用。</p>
<ul>
<li>
<h4 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h4>
</li>
</ul>
<p>使用逻辑运算符，如：<code>!|</code>, <code>NAND</code>,<code>XOR</code>,<code>NOR</code>；都会导致解析错误。</p>
<p>此外，在查询的<code>SELECT</code>子句中使用<code>AND</code>和<code>OR</code>不会表现为数学运算符，只会产生空结果，因为它们在CnosQL中已经被定义。但是，您可以对布尔数据应用位操作符<code>&amp;</code>、<code>|</code>和<code>^</code>。</p>
<ul>
<li>
<h4 id="位非运算"><a class="header" href="#位非运算">位非运算</a></h4>
</li>
</ul>
<p>没有位非运算符，因为您期望的结果取决于您的位域的宽度。CnosQL不知道您的位域有多宽，因此无法实现合适的位非运算。</p>
<p>您可以通过使用<code>^</code>(位异或)操作符和代表字宽的全1的二进制数字来实现位非操作:</p>
<pre><code>8-bit 数据：

SELECT &quot;temperature&quot; ^ 255 FROM &quot;air&quot;

16-bit 数据:

SELECT &quot;temperature&quot; ^ 65535 FROM &quot;air&quot;

32-bit 数据:

SELECT &quot;temperature&quot; ^ 4294967295 FROM &quot;air&quot;
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosql参考"><a class="header" href="#cnosql参考">CnosQL参考</a></h2>
<ul>
<li>
<h3 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h3>
<p>CnosQL的定义和详细信息</p>
<ul>
<li>
<h4 id="符号"><a class="header" href="#符号"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E7%AC%A6%E5%8F%B7">符号</a></a></h4>
</li>
<li>
<h4 id="查询表示"><a class="header" href="#查询表示"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E7%A4%BA">查询表示</a></a></h4>
</li>
<li>
<h4 id="字母和数字"><a class="header" href="#字母和数字"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97">字母和数字</a></a></h4>
</li>
<li>
<h4 id="标识符"><a class="header" href="#标识符"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></a></h4>
</li>
<li>
<h4 id="关键字"><a class="header" href="#关键字"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></a></h4>
</li>
<li>
<h4 id="文字"><a class="header" href="#文字"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%96%87%E5%AD%97">文字</a></a></h4>
</li>
<li>
<h4 id="查询-2"><a class="header" href="#查询-2"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%9F%A5%E8%AF%A2">查询</a></a></h4>
</li>
<li>
<h4 id="语句"><a class="header" href="#语句"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E8%AF%AD%E5%8F%A5">语句</a></a></h4>
</li>
<li>
<h4 id="条款"><a class="header" href="#条款"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%9D%A1%E6%AC%BE">条款</a></a></h4>
</li>
<li>
<h4 id="表达式"><a class="header" href="#表达式"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a></a></h4>
</li>
<li>
<h4 id="其他"><a class="header" href="#其他"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E5%85%B6%E4%BB%96">其他</a></a></h4>
</li>
<li>
<h4 id="查询引擎内部"><a class="header" href="#查询引擎内部"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E5%86%85%E9%83%A8">查询引擎内部</a></a></h4>
</li>
</ul>
<p>要了解更多关于CnosQL的信息，请浏览以下内容：</p>
<ul>
<li>
<h4 id="使用cnosql探索数据"><a class="header" href="#使用cnosql探索数据"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E4%BD%BF%E7%94%A8cnosql%E6%8E%A2%E7%B4%A2%E6%95%B0%E6%8D%AE">使用CnosQL探索数据</a></a></h4>
</li>
<li>
<h4 id="使用cnosql探索您的模式"><a class="header" href="#使用cnosql探索您的模式"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#">使用CnosQL探索您的模式</a></a></h4>
</li>
<li>
<h4 id="数据库管理-1"><a class="header" href="#数据库管理-1"><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#">数据库管理</a></a></h4>
</li>
</ul>
</li>
<li>
<h3 id="符号-1"><a class="header" href="#符号-1">符号</a></h3>
<p>使用Extended Backus-Naur Form(&quot; EBNF &quot;)指定语法。EBNF与Go编程语言规范中使用的符号相同。并非巧合的是，CnosDB是用Go编写的。</p>
<pre><code>Production  = production_name &quot;=&quot; [ Expression ] &quot;.&quot; .
Expression  = Alternative { &quot;|&quot; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &quot;…&quot; token ] | Group | Option | Repetition .
Group       = &quot;(&quot; Expression &quot;)&quot; .
Option      = &quot;[&quot; Expression &quot;]&quot; .
Repetition  = &quot;{&quot; Expression &quot;}&quot; .
</code></pre>
<p>按优先级递增的顺序表示操作符:</p>
<pre><code>|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
</code></pre>
</li>
<li>
<h3 id="查询表示-1"><a class="header" href="#查询表示-1">查询表示</a></h3>
<ul>
<li>
<h4 id="字符"><a class="header" href="#字符">字符</a></h4>
</li>
</ul>
<p>CnosQL是使用UTF-8编码的Unicode文本。</p>
<pre><code>newline             = /* the Unicode code point U+000A */ .
unicode_char        = /* an arbitrary Unicode code point except newline */ .
</code></pre>
</li>
<li>
<h3 id="字母和数字-1"><a class="header" href="#字母和数字-1">字母和数字</a></h3>
<p>字母是ASCII字符的集合，加上下划线_ (U+005F)也被认为是字母。只支持十进制数字。</p>
<pre><code>letter              = ascii_letter | &quot;_&quot; .
ascii_letter        = &quot;A&quot; … &quot;Z&quot; | &quot;a&quot; … &quot;z&quot; .
digit               = &quot;0&quot; … &quot;9&quot; .
</code></pre>
</li>
<li>
<h3 id="标识符-1"><a class="header" href="#标识符-1">标识符</a></h3>
<p>标识符包括数据库名、保留策略名、用户名、度量名、标记键以及字段键。</p>
<p>标识符使用规则如下；</p>
<ul>
<li>双引号标识符可以包含除新行以外的任何unicode字符。</li>
<li>双引号标识符可以包括转义的<code>&quot;</code>字符。例如；<code>\&quot;</code> 。</li>
<li>双引号标识符中可以包括CnosQL的关键字。</li>
<li>未加引号的标识符必须以大写或小写ASCII字符或者&quot;_&quot;开头。</li>
<li>未加引号的标识符只能包括ASCII字母、十进制数字或者&quot;_&quot;。</li>
</ul>
<pre><code>identifier          = unquoted_identifier | quoted_identifier .
unquoted_identifier = ( letter ) { letter | digit } .
quoted_identifier   = `&quot;` unicode_char { unicode_char } `&quot;` .
</code></pre>
<p>例如：</p>
<pre><code>air
_air_temperature
&quot;1h&quot;
&quot;anything really&quot;
&quot;1_Crazy-1337.identifier&gt;NAME👍&quot;
</code></pre>
</li>
<li>
<h3 id="关键字-1"><a class="header" href="#关键字-1">关键字</a></h3>
<pre><code>ALL           ALTER         ANY           AS            ASC           BEGIN
BY            CREATE        CONTINUOUS    DATABASE      DATABASES     DEFAULT
DELETE        DESC          DESTINATIONS  DIAGNOSTICS   DISTINCT      DROP
DURATION      END           EVERY         EXPLAIN       FIELD         FOR
FROM          GRANT         GRANTS        GROUP         GROUPS        IN
INF           INSERT        INTO          KEY           KEYS          KILL
LIMIT         SHOW          MEASUREMENT   MEASUREMENTS  NAME          OFFSET
ON            ORDER         PASSWORD      POLICY        POLICIES      PRIVILEGES
QUERIES       QUERY         READ          REPLICATION   RESAMPLE      RETENTION
REVOKE        SELECT        SERIES        SET           SHARD         SHARDS
SLIMIT        SOFFSET       STATS         SUBSCRIPTION  SUBSCRIPTIONS TAG
TO            USER          USERS         VALUES        WHERE         WITH
WRITE
</code></pre>
<p>如果使用了CnosQL的关键字作为标识符，则需要在每次查询中对该标识符加双引号。</p>
<p>关键字<code>time</code>是一种特殊情况。<code>time</code>可以是连续查询名称、数据库名称、测量名称、保留策略名称、订阅名称和用户名称。在这些情况下，查询中的<code>time</code>不需要双引号。<code>time</code>不能是字段键或标签键；CnosQL拒绝将<code>time</code>作为字段键或标记键的写入，并返回错误。</p>
</li>
<li>
<h3 id="文字-1"><a class="header" href="#文字-1">文字</a></h3>
<ul>
<li>
<h4 id="整数-2"><a class="header" href="#整数-2">整数</a></h4>
</li>
</ul>
<p>CnosQL目前只支持十进制数字，并不支持其他进制数字。</p>
<pre><code>int_lit             = ( &quot;1&quot; … &quot;9&quot; ) { digit } .
</code></pre>
<ul>
<li>
<h4 id="浮点数-2"><a class="header" href="#浮点数-2">浮点数</a></h4>
</li>
</ul>
<p>CnosQL目前只支持浮点数，并不支持指数。</p>
<pre><code>float_lit           = int_lit &quot;.&quot; int_lit .
</code></pre>
<ul>
<li>
<h4 id="字符串-2"><a class="header" href="#字符串-2">字符串</a></h4>
</li>
</ul>
<p>字符串必须和单引号搭配使用。如果加上转义字符，那么字符串中可以包含单引号。</p>
<pre><code>string_lit          = `'` { unicode_char } `'` .
</code></pre>
<ul>
<li>
<h4 id="持续时间"><a class="header" href="#持续时间">持续时间</a></h4>
</li>
</ul>
<p>持续时间的字面值指定时间长度。整数字面值紧跟着(没有空格)下面列出的持续时间单位被称为持续时间字面值。可以使用混合单元指定持续时间。</p>
<pre><code>duration_lit        = int_lit duration_unit .
duration_unit       = &quot;ns&quot; | &quot;u&quot; | &quot;µ&quot; | &quot;ms&quot; | &quot;s&quot; | &quot;m&quot; | &quot;h&quot; | &quot;d&quot; | &quot;w&quot; .
</code></pre>
<ul>
<li>
<h4 id="日期和时间"><a class="header" href="#日期和时间">日期和时间</a></h4>
</li>
</ul>
<p>与本文档的其余部分一样，EBNF中没有指定日期和时间文本格式。它是使用Go的日期/时间解析格式指定的，它是按照CnosQL要求的格式编写的引用日期。</p>
<p>参考日期时间为:January 2nd, 2006 at 3:04:05 PM</p>
<pre><code>time_lit            = &quot;2006-01-02 15:04:05.999999&quot; | &quot;2006-01-02&quot; .
</code></pre>
<ul>
<li>
<h4 id="布尔值-2"><a class="header" href="#布尔值-2">布尔值</a></h4>
</li>
</ul>
<pre><code>bool_lit            = TRUE | FALSE .
</code></pre>
<ul>
<li>
<h4 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h4>
</li>
</ul>
<pre><code>regex_lit           = &quot;/&quot; { unicode_char } &quot;/&quot; .
</code></pre>
</li>
<li>
<h3 id="查询-3"><a class="header" href="#查询-3">查询</a></h3>
<p>查询由一个或多个以分号分隔的语句组成。</p>
<pre><code>query               = statement { &quot;;&quot; statement } .

statement           = alter_retention_policy_stmt |
                      create_continuous_query_stmt |
                      create_database_stmt |
                      create_retention_policy_stmt |
                      create_subscription_stmt |
                      create_user_stmt |
                      delete_stmt |
                      drop_continuous_query_stmt |
                      drop_database_stmt |
                      drop_measurement_stmt |
                      drop_retention_policy_stmt |
                      drop_series_stmt |
                      drop_shard_stmt |
                      drop_subscription_stmt |
                      drop_user_stmt |
                      explain_stmt |
                      explain_analyze_stmt |
                      grant_stmt |
                      kill_query_statement |
                      revoke_stmt |
                      select_stmt |
                      show_continuous_queries_stmt |
                      show_databases_stmt |
                      show_diagnostics_stmt |
                      show_field_key_cardinality_stmt |
                      show_field_keys_stmt |
                      show_grants_stmt |
                      show_measurement_cardinality_stmt |
                      show_measurement_exact_cardinality_stmt |
                      show_measurements_stmt |
                      show_queries_stmt |
                      show_retention_policies_stmt |
                      show_series_cardinality_stmt |
                      show_series_exact_cardinality_stmt |
                      show_series_stmt |
                      show_shard_groups_stmt |
                      show_shards_stmt |
                      show_stats_stmt |
                      show_subscriptions_stmt |
                      show_tag_key_cardinality_stmt |
                      show_tag_key_exact_cardinality_stmt |
                      show_tag_keys_stmt |
                      show_tag_values_stmt |
                      show_tag_values_cardinality_stmt |
                      show_users_stmt .
</code></pre>
</li>
<li>
<h3 id="语句-1"><a class="header" href="#语句-1">语句</a></h3>
<ul>
<li>
<h4 id="改变保留策略"><a class="header" href="#改变保留策略">改变保留策略</a></h4>
</li>
</ul>
<pre><code>alter_retention_policy_stmt  = &quot;ALTER RETENTION POLICY&quot; policy_name on_clause
                               retention_policy_option
                               [ retention_policy_option ]
                               [ retention_policy_option ]
                               [ retention_policy_option ] .
</code></pre>
<ul>
<li>
<h4 id="创建连续查询"><a class="header" href="#创建连续查询">创建连续查询</a></h4>
</li>
</ul>
<pre><code>create_continuous_query_stmt = &quot;CREATE CONTINUOUS QUERY&quot; query_name on_clause
[ &quot;RESAMPLE&quot; resample_opts ]
&quot;BEGIN&quot; select_stmt &quot;END&quot; .

query_name                   = identifier .

resample_opts                = (every_stmt for_stmt | every_stmt | for_stmt) .
every_stmt                   = &quot;EVERY&quot; duration_lit
for_stmt                     = &quot;FOR&quot; duration_lit
</code></pre>
<ul>
<li>
<h4 id="创建数据库-1"><a class="header" href="#创建数据库-1">创建数据库</a></h4>
</li>
</ul>
<pre><code>create_database_stmt = &quot;CREATE DATABASE&quot; db_name
                       [ WITH
                           [ retention_policy_duration ]
                           [ retention_policy_replication ]
                           [ retention_policy_shard_group_duration ]
                           [ retention_policy_name ]
                        ] .
</code></pre>
<ul>
<li>
<h4 id="创建保留策略-1"><a class="header" href="#创建保留策略-1">创建保留策略</a></h4>
</li>
</ul>
<pre><code>create_retention_policy_stmt = &quot;CREATE RETENTION POLICY&quot; policy_name on_clause
                               retention_policy_duration
                               retention_policy_replication
                               [ retention_policy_shard_group_duration ]
                               [ &quot;DEFAULT&quot; ] .
</code></pre>
<ul>
<li>
<h4 id="创建用户"><a class="header" href="#创建用户">创建用户</a></h4>
</li>
</ul>
<pre><code>create_user_stmt = &quot;CREATE USER&quot; user_name &quot;WITH PASSWORD&quot; password
                   [ &quot;WITH ALL PRIVILEGES&quot; ] .
</code></pre>
<ul>
<li>
<h4 id="删除-2"><a class="header" href="#删除-2">删除</a></h4>
</li>
</ul>
<pre><code>e_stmt = &quot;DELETE&quot; ( from_clause | where_clause | from_clause where_clause ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃连续查询"><a class="header" href="#抛弃连续查询">抛弃连续查询</a></h4>
</li>
</ul>
<pre><code>drop_continuous_query_stmt = &quot;DROP CONTINUOUS QUERY&quot; query_name on_clause .
</code></pre>
<ul>
<li>
<h4 id="抛弃数据库"><a class="header" href="#抛弃数据库">抛弃数据库</a></h4>
</li>
</ul>
<pre><code>drop_database_stmt = &quot;DROP DATABASE&quot; db_name .
</code></pre>
<ul>
<li>
<h4 id="抛弃度量"><a class="header" href="#抛弃度量">抛弃度量</a></h4>
</li>
</ul>
<pre><code>drop_measurement_stmt = &quot;DROP MEASUREMENT&quot; measurement .
</code></pre>
<ul>
<li>
<h4 id="抛弃保留策略"><a class="header" href="#抛弃保留策略">抛弃保留策略</a></h4>
</li>
</ul>
<pre><code>drop_retention_policy_stmt = &quot;DROP RETENTION POLICY&quot; policy_name on_clause .
</code></pre>
<ul>
<li>
<h4 id="抛弃序列"><a class="header" href="#抛弃序列">抛弃序列</a></h4>
</li>
</ul>
<pre><code>drop_series_stmt = &quot;DROP SERIES&quot; ( from_clause | where_clause | from_clause where_clause ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃分片"><a class="header" href="#抛弃分片">抛弃分片</a></h4>
</li>
</ul>
<pre><code>drop_shard_stmt = &quot;DROP SHARD&quot; ( shard_id ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃用户"><a class="header" href="#抛弃用户">抛弃用户</a></h4>
</li>
</ul>
<pre><code>drop_user_stmt = &quot;DROP USER&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="explain"><a class="header" href="#explain">EXPLAIN</a></h4>
</li>
</ul>
<pre><code>explain_stmt = &quot;EXPLAIN&quot; select_stmt .
</code></pre>
<ul>
<li>
<h4 id="explain-analyze"><a class="header" href="#explain-analyze">EXPLAIN ANALYZE</a></h4>
</li>
</ul>
<p>例如</p>
<pre><code>&gt; explain analyze select mean(temperature) from air where time &gt;= '2018-02-22T00:00:00Z' and time &lt; '2018-02-22T12:00:00Z'
EXPLAIN ANALYZE
----    -----------
 .
 └── select
   ├── execution_time: 279.292µs
   ├── planning_time: 952.75µs
   ├── total_time: 1.232042ms
   └── build_cursor
    ├── labels
     │   └── statement: SELECT mean(temperature) FROM data.autogen.air
     └── iterator_scanner
      └── labels
       └── expr: mean(temperature)
</code></pre>
<p>execution_time: 执行查询所花费的时间，包括读取时间序列数据、在数据流经迭代器时执行操作，以及从迭代器中提取已处理的数据。执行时间不包括将输出序列化为JSON或其他格式所花费的时间。
planning_time: 显示计划查询所花费的时间量。在CnosDB中规划查询需要许多步骤。根据查询的复杂性，与执行查询相比，计划可能需要更多的工作并消耗更多的CPU和内存资源。例如，执行查询所需的系列键的数量会影响计划查询的速度和所需的内存。
create_iterator: 表示本地CnosDB实例所做的工作──一组复杂的嵌套迭代器组合在一起，以产生最终的查询输出。
cursor type：EXPLAIN ANALYZE区分3种游标类型。虽然游标类型具有相同的数据结构和相同的CPU和I/O成本，但每种游标类型的构造原因不同，并在最终输出中分开。
block types：EXPLAIN ANALYZE分离存储块类型，并报告被解码的块的总数和它们在磁盘上的大小(以字节为单位)。</p>
<ul>
<li>
<h4 id="授权"><a class="header" href="#授权">授权</a></h4>
</li>
</ul>
<pre><code>grant_stmt = &quot;GRANT&quot; privilege [ on_clause ] to_clause .
</code></pre>
<ul>
<li>
<h4 id="关闭查询"><a class="header" href="#关闭查询">关闭查询</a></h4>
</li>
</ul>
<pre><code>kill_query_statement = &quot;KILL QUERY&quot; query_id .
</code></pre>
<ul>
<li>
<h4 id="撤销"><a class="header" href="#撤销">撤销</a></h4>
</li>
</ul>
<pre><code>revoke_stmt = &quot;REVOKE&quot; privilege [ on_clause ] &quot;FROM&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="选择"><a class="header" href="#选择">选择</a></h4>
</li>
</ul>
<pre><code>select_stmt = &quot;SELECT&quot; fields [ into_clause ] from_clause [ where_clause ]
         [ group_by_clause ] [ order_by_clause ] [ limit_clause ]
         [ offset_clause ] [ slimit_clause ] [ soffset_clause ] [ timezone_clause ] .
</code></pre>
<ul>
<li>
<h4 id="展示基数"><a class="header" href="#展示基数">展示基数</a></h4>
</li>
</ul>
<p>指用于精确估计或计数测量值、序列、标记键、标记键值和字段键的基数的一组命令。SHOW CARDINALITY命令有两种变体:估计的和精确的。估计值使用草图计算，是所有基数大小的安全默认值。准确的值是直接从TSM(时间结构合并树)数据中计算的，但是对于高基数的数据来说，运行这些值是非常昂贵的。除非必要，使用估计的品种。仅当在数据库上启用了时间序列索引(TSI)时，才支持按时间过滤。</p>
<ul>
<li>
<h4 id="show-continuous-queries"><a class="header" href="#show-continuous-queries">SHOW CONTINUOUS QUERIES</a></h4>
</li>
</ul>
<pre><code>show_continuous_queries_stmt = &quot;SHOW CONTINUOUS QUERIES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-databases"><a class="header" href="#show-databases">SHOW DATABASES</a></h4>
</li>
</ul>
<pre><code>show_databases_stmt = &quot;SHOW DATABASES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-diagnostics"><a class="header" href="#show-diagnostics">SHOW DIAGNOSTICS</a></h4>
</li>
</ul>
<p>示节点信息，如构建信息、正常运行时间、主机名、服务器配置、内存使用和运行时诊断。</p>
<pre><code>show_diagnostics_stmt = &quot;SHOW DIAGNOSTICS&quot;
</code></pre>
<ul>
<li>
<h4 id="show-field-key-cardinality"><a class="header" href="#show-field-key-cardinality">SHOW FIELD KEY CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_field_key_cardinality_stmt = &quot;SHOW FIELD KEY CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

show_field_key_exact_cardinality_stmt = &quot;SHOW FIELD KEY EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]
</code></pre>
<ul>
<li>
<h4 id="show-field-keys"><a class="header" href="#show-field-keys">SHOW FIELD KEYS</a></h4>
</li>
</ul>
<pre><code>show_field_keys_stmt = &quot;SHOW FIELD KEYS&quot; [on_clause] [ from_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-grants"><a class="header" href="#show-grants">SHOW GRANTS</a></h4>
</li>
</ul>
<pre><code>show_grants_stmt = &quot;SHOW GRANTS FOR&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="show-measurements"><a class="header" href="#show-measurements">SHOW MEASUREMENTS</a></h4>
</li>
</ul>
<pre><code>show_measurements_stmt = &quot;SHOW MEASUREMENTS&quot; [on_clause] [ with_measurement_clause ] [ where_clause ] [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-queries"><a class="header" href="#show-queries">SHOW QUERIES</a></h4>
</li>
</ul>
<pre><code>show_queries_stmt = &quot;SHOW QUERIES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-retention-policies"><a class="header" href="#show-retention-policies">SHOW RETENTION POLICIES</a></h4>
</li>
</ul>
<pre><code>show_retention_policies_stmt = &quot;SHOW RETENTION POLICIES&quot; [on_clause] .
</code></pre>
<ul>
<li>
<h4 id="show-series"><a class="header" href="#show-series">SHOW SERIES</a></h4>
</li>
</ul>
<pre><code>show_series_stmt = &quot;SHOW SERIES&quot; [on_clause] [ from_clause ] [ where_clause ] [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-series-cardinality"><a class="header" href="#show-series-cardinality">SHOW SERIES CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_series_cardinality_stmt = &quot;SHOW SERIES CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

show_series_exact_cardinality_stmt = &quot;SHOW SERIES EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

</code></pre>
<ul>
<li>
<h4 id="show-shard-groups"><a class="header" href="#show-shard-groups">SHOW SHARD GROUPS</a></h4>
</li>
</ul>
<pre><code>show_shard_groups_stmt = &quot;SHOW SHARD GROUPS&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-shards"><a class="header" href="#show-shards">SHOW SHARDS</a></h4>
</li>
</ul>
<pre><code>show_shards_stmt = &quot;SHOW SHARDS&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-stats"><a class="header" href="#show-stats">SHOW STATS</a></h4>
</li>
</ul>
<pre><code>show_stats_stmt = &quot;SHOW STATS [ FOR '&lt;component&gt;' | 'indexes' ]&quot;
</code></pre>
<ul>
<li>
<h4 id="show-tag-keys"><a class="header" href="#show-tag-keys">SHOW TAG KEYS</a></h4>
</li>
</ul>
<pre><code>show_tag_keys_stmt = &quot;SHOW TAG KEYS&quot; [on_clause] [ from_clause ] [ where_clause ]
                [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-tag-values"><a class="header" href="#show-tag-values">SHOW TAG VALUES</a></h4>
</li>
</ul>
<pre><code>show_tag_values_stmt = &quot;SHOW TAG VALUES&quot; [on_clause] [ from_clause ] with_tag_clause [ where_clause ]
                  [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-tag-values-cardinality"><a class="header" href="#show-tag-values-cardinality">SHOW TAG VALUES CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_tag_values_cardinality_stmt = &quot;SHOW TAG VALUES CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ] with_key_clause

show_tag_values_exact_cardinality_stmt = &quot;SHOW TAG VALUES EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ] with_key_clause
</code></pre>
<ul>
<li>
<h4 id="show-users"><a class="header" href="#show-users">SHOW USERS</a></h4>
</li>
</ul>
<pre><code>show_users_stmt = &quot;SHOW USERS&quot; .
</code></pre>
</li>
<li>
<h3 id="条款-1"><a class="header" href="#条款-1">条款</a></h3>
<pre><code>from_clause     = &quot;FROM&quot; measurements .

group_by_clause = &quot;GROUP BY&quot; dimensions fill(fill_option).

into_clause     = &quot;INTO&quot; ( measurement | back_ref ).

limit_clause    = &quot;LIMIT&quot; int_lit .

offset_clause   = &quot;OFFSET&quot; int_lit .

slimit_clause   = &quot;SLIMIT&quot; int_lit .

soffset_clause  = &quot;SOFFSET&quot; int_lit .

timezone_clause = tz(string_lit) .

on_clause       = &quot;ON&quot; db_name .

order_by_clause = &quot;ORDER BY&quot; sort_fields .

to_clause       = &quot;TO&quot; user_name .

where_clause    = &quot;WHERE&quot; expr .

with_measurement_clause = &quot;WITH MEASUREMENT&quot; ( &quot;=&quot; measurement | &quot;=~&quot; regex_lit ) .

with_tag_clause = &quot;WITH KEY&quot; ( &quot;=&quot; tag_key | &quot;!=&quot; tag_key | &quot;=~&quot; regex_lit | &quot;IN (&quot; tag_keys &quot;)&quot;  ) .
</code></pre>
</li>
<li>
<h3 id="表达式-1"><a class="header" href="#表达式-1">表达式</a></h3>
<pre><code>binary_op        = &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&amp;&quot; | &quot;|&quot; | &quot;^&quot; | &quot;AND&quot; |
                &quot;OR&quot; | &quot;=&quot; | &quot;!=&quot; | &quot;&lt;&gt;&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; .

expr             = unary_expr { binary_op unary_expr } .

unary_expr       = &quot;(&quot; expr &quot;)&quot; | var_ref | time_lit | string_lit | int_lit |
float_lit | bool_lit | duration_lit | regex_lit .
</code></pre>
</li>
<li>
<h3 id="其他-1"><a class="header" href="#其他-1">其他</a></h3>
<pre><code>alias            = &quot;AS&quot; identifier .

back_ref         = ( policy_name &quot;.:MEASUREMENT&quot; ) |
( db_name &quot;.&quot; [ policy_name ] &quot;.:MEASUREMENT&quot; ) .

db_name          = identifier .

dimension        = expr .

dimensions       = dimension { &quot;,&quot; dimension } .

field_key        = identifier .

field            = expr [ alias ] .

fields           = field { &quot;,&quot; field } .

fill_option      = &quot;null&quot; | &quot;none&quot; | &quot;previous&quot; | int_lit | float_lit | &quot;linear&quot; .

host             = string_lit .

measurement      = measurement_name |
( policy_name &quot;.&quot; measurement_name ) |
( db_name &quot;.&quot; [ policy_name ] &quot;.&quot; measurement_name ) .

measurements     = measurement { &quot;,&quot; measurement } .

measurement_name = identifier | regex_lit .

password         = string_lit .

policy_name      = identifier .

privilege        = &quot;ALL&quot; [ &quot;PRIVILEGES&quot; ] | &quot;READ&quot; | &quot;WRITE&quot; .

query_id         = int_lit .

query_name       = identifier .

retention_policy = identifier .

retention_policy_option      = retention_policy_duration |
retention_policy_replication |
retention_policy_shard_group_duration |
&quot;DEFAULT&quot; .

retention_policy_duration    = &quot;DURATION&quot; duration_lit .

retention_policy_replication = &quot;REPLICATION&quot; int_lit .

retention_policy_shard_group_duration = &quot;SHARD DURATION&quot; duration_lit .

retention_policy_name = &quot;NAME&quot; identifier .

series_id        = int_lit .

shard_id         = int_lit .

sort_field       = field_key [ ASC | DESC ] .

sort_fields      = sort_field { &quot;,&quot; sort_field } .

subscription_name = identifier .

tag_key          = identifier .

tag_keys         = tag_key { &quot;,&quot; tag_key } .

user_name        = identifier .

var_ref          = measurement .
</code></pre>
</li>
<li>
<h3 id="查询引擎内部-1"><a class="header" href="#查询引擎内部-1">查询引擎内部</a></h3>
<p>查询的生命周期是这样的；</p>
<ul>
<li>
<p>对CnosQL查询字符串进行标记，然后将其解析为抽象语法树(AST)。这是查询本身的代码表示。</p>
</li>
<li>
<p>AST被传递给<code>QueryExecutor</code>, <code>QueryExecutor</code>将查询定向到适当的处理程序。例如，与元数据相关的查询由元服务执行，<code>SELECT</code>语句由分片自己执行。</p>
</li>
<li>
<p>然后，查询引擎确定与<code>SELECT</code>语句的时间范围匹配的分片。从这些分片中，为语句中的每个字段创建迭代器。</p>
</li>
<li>
<p>迭代器被传递给发射器，发射器耗尽迭代器并连接结果点。发射器的工作是将简单的时间/值点转换为返回给客户端的更复杂的结果对象。</p>
</li>
<li>
<h4 id="理解迭代器"><a class="header" href="#理解迭代器">理解迭代器</a></h4>
<p>迭代器是查询引擎的核心。它们为在一组点上循环提供了一个简单的接口。例如，这是一个浮点数的迭代器:</p>
<pre><code>type FloatIterator interface {
    Next() *FloatPoint
}
</code></pre>
<p>这些迭代器是通过<code>IteratorCreator</code>接口创建的:</p>
<pre><code>type IteratorCreator interface {
    CreateIterator(opt *IteratorOptions) (Iterator, error)
}
</code></pre>
<p><code>IteratorOptions</code>提供了关于字段选择、时间范围和维度的参数，迭代器创建者在规划迭代器时可以使用这些参数。<code>IteratorCreator</code>接口用于许多级别，如<code>Shards</code>、<code>Shard</code>和<code>Engine</code>。这允许在适当的时候执行优化，例如返回预先计算的<code>COUNT()</code>。
迭代器不仅仅是从存储器中读取原始数据。迭代器可以进行组合，以便围绕输入迭代器提供额外的功能。例如，<code>DistinctIterator</code>可以为输入迭代器计算每个时间窗口的不同值。或者，<code>FillIterator</code>可以生成输入迭代器所缺少的额外点。
这种组合也很适合聚合。例如，像这样的语句:</p>
<pre><code>SELECT MEAN(temperature) FROM cpu GROUP BY time(10m)
</code></pre>
<p>本例中，MEAN(temperature)是一个从底层分片包装迭代器的<code>MeanIterator</code>。但是，如果我们可以添加一个额外的迭代器来确定平均值的导数:</p>
<pre><code>SELECT DERIVATIVE(MEAN(temperature), 20m) FROM cpu GROUP BY time(10m)
</code></pre>
</li>
<li>
<h4 id="理解游标"><a class="header" href="#理解游标">理解游标</a></h4>
<p>游标通过元组(时间、值)中的分片标识单个序列(测量值、标签集和字段)的数据。游标遍历以日志结构的合并树形式存储的数据，并跨级别处理重复数据删除、删除数据的tombstone和合并缓存(Write Ahead Log)。游标按时间升序或降序对(时间，值)元组进行排序。</p>
</li>
<li>
<h4 id="理解辅助字段"><a class="header" href="#理解辅助字段">理解辅助字段</a></h4>
<p>因为CnosQL允许用户使用FIRST()、LAST()、MIN()和MAX()等选择器函数，所以引擎必须提供一种方法，在选择点的同时返回相关数据。</p>
</li>
<li>
<h4 id="内置的迭代器"><a class="header" href="#内置的迭代器">内置的迭代器</a></h4>
<p>有许多内置迭代器可以让我们构建查询:</p>
<ul>
<li>排序合并迭代器——该迭代器将一个或多个迭代器合并成一个相同类型的新迭代器。该迭代器保证在开始下一个窗口之前输出窗口内的所有点，但不提供窗口内的排序保证。这允许快速访问聚合查询，而聚合查询不需要更强的排序保证。</li>
<li>限制迭代器——该迭代器限制每个名称/标签组的点数。这是<code>LIMIT &amp; OFFSET</code>语法的实现。</li>
<li>填充迭代器——如果输入迭代器缺少额外的点，这个迭代器会注入额外的点。它可以提供空点、带有前一个值的点或带有特定值的点。</li>
<li>缓冲迭代器——该迭代器提供了将一个点“未读”回缓冲区的能力，以便下次可以再次读取它。这被广泛用于为窗口提供前瞻。</li>
<li>Reduce迭代器——该迭代器为窗口中的每个点调用一个Reduce函数。当窗口完成时，输出该窗口的所有点。这用于简单的聚合函数，如COUNT()。</li>
<li>Reduce Slice迭代器——该迭代器首先收集窗口的所有点，然后将它们一次性全部传递给Reduce函数。迭代器返回结果。这用于聚合函数，如DERIVATIVE()。</li>
<li>Transform迭代器——该迭代器为输入迭代器中的每个点调用Transform函数。它用于执行二进制表达式。</li>
<li>重复数据删除迭代器——此迭代器只输出唯一的点。它是资源密集型的，所以它只用于像元查询语句这样的小查询。</li>
</ul>
</li>
<li>
<h4 id="调用迭代器"><a class="header" href="#调用迭代器">调用迭代器</a></h4>
<p>CnosQL中的函数调用在两个级别上实现。为了提高效率，可以将一些调用封装在多个层上。例如，一个<code>COUNT()</code>可以在分片层执行，然后多个<code>counterator</code>可以与另一个<code>counterator</code>包装，以计算所有分片的计数。这些迭代器可以使用<code>NewCallIterator()</code>创建。有些迭代器更复杂，或者需要在更高的级别上实现。例如，在执行计算之前，<code>DERIVATIVE()</code>需要首先检索窗口的所有点。这个迭代器是由引擎本身创建的，较低级别的迭代器不会被要求创建。</p>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosdb-line-protocol"><a class="header" href="#cnosdb-line-protocol">CnosDB line Protocol</a></h2>
<p>CnosDB行协议是一种基于文本格式将点写入CnosDB的行协议。</p>
<ul>
<li>
<h3 id="cnosdb行协议参考"><a class="header" href="#cnosdb行协议参考">CnosDB行协议参考</a></h3>
<h4 id="语法-33"><a class="header" href="#语法-33">语法</a></h4>
<pre><code>&lt;measurement&gt;[,&lt;tag_key&gt;=&lt;tag_value&gt;[,&lt;tag_key&gt;=&lt;tag_value&gt;]] &lt;field_key&gt;=&lt;field_value&gt;[,&lt;field_key&gt;=&lt;field_value&gt;] [&lt;timestamp&gt;]
</code></pre>
<p>行协议接受换行符<code>\n</code>，对空格敏感。</p>
<blockquote>
<p>注意：行协议不支持在标签值或字段值中使用换行符<code>\n</code>。</p>
</blockquote>
<h4 id="语法描述-7"><a class="header" href="#语法描述-7">语法描述</a></h4>
<ul>
<li>
<p><code>measurement</code>- 必须。是measurement项的名字。CnosDB接受每一个点的measurement值。为string类型。</p>
</li>
<li>
<p><code>tag set</code> - 可选。为该点所有的标记键值对。tag keys和tag values都是string类型。</p>
</li>
<li>
<p><code>field set</code> - 必须。每一个点必须要有一个field。是该点所有的字段键值对。可以是任何类型。</p>
</li>
<li>
<p><code>timestamp</code> - 可选。如果时间戳没有包含在点中，则CnosDB将在UTC中使用服务器的本地纳秒时间戳。</p>
</li>
</ul>
<h4 id="性能小提示"><a class="header" href="#性能小提示">性能小提示</a></h4>
<ul>
<li>将数据发送到CnosDB之前，请使用<a href="https://pkg.go.dev/bytes#Compare">Go bytes.Compare function</a>对数据根据tag key排序。</li>
<li>要显著改善压缩，请对时间戳使用尽可能粗糙的精度。</li>
<li>使用NTP (Network Time Protocol)同步主机时间。CnosDB使用UTC格式的主机本地时间为数据分配时间戳。如果主机的时钟没有与NTP同步，则主机写入到CnosDB的数据可能有不准确的时间戳。</li>
</ul>
<h4 id="例子-4"><a class="header" href="#例子-4">例子</a></h4>
<ul>
<li>
<p>将field值<code>-1.234456e+78</code>作为浮点数写入CnosDB</p>
<p><code>INSERT mydb value=-1.234456e+78</code></p>
<p>CnosDB支持用科学符号指定的字段值。</p>
</li>
<li>
<p>将field值<code>1.0</code>作为浮点数写入CnosDB</p>
<p><code>INSERT mydb value=1.0</code></p>
</li>
<li>
<p>将field值<code>1</code>作为浮点数写入CnosDB</p>
<p><code>INSERT mydb value=1</code></p>
</li>
<li>
<p>将field值<code>1.0</code>作为整数写入CnosDB，在字段值后附加i，告诉CnosDB将数字存储为整数。</p>
<p><code>INSERT mydb value=1i</code></p>
</li>
<li>
<p>将field值<code>string exapmple</code>作为字符串写入CnosDB</p>
<p><code>INSERT mydb value=&quot;stringing along&quot;</code></p>
</li>
<li>
<p>将field值<code>true</code>作为布尔值写入CnosDB</p>
<p><code>INSERT mydb value=true</code></p>
</li>
<li>
<p>尝试将字符串写入先前接收浮点数的字段</p>
</li>
<li></li>
</ul>
<p>如果float和string的时间戳存储在同一个分片中:</p>
<pre><code>INSERT mydb value=3 1465934559000000000
INSERT mydb value=&quot;stringing example&quot; 1465934559000000001
ERR: {&quot;error&quot;:&quot;field type conflict: input field \&quot;value\&quot; on measurement \&quot;mymeas\&quot; is type string, already exists as type float&quot;}
</code></pre>
<p>如果float和string的时间戳没有存储在同一个分片中:</p>
<pre><code>INSERT mymeas value=3 1465934559000000000
INSERT mymeas value=&quot;stringing example&quot; 1466625759000000000
</code></pre>
<ul>
<li>
<h3 id="cnosdb行协议教程"><a class="header" href="#cnosdb行协议教程">CnosDB行协议教程</a></h3>
<p>CnosDB行协议是一种将点写入数据库的基于文本的格式。点必须是行协议格式，以便CnosDB成功解析和写入点。</p>
<h4 id="语法-34"><a class="header" href="#语法-34">语法</a></h4>
<p>行协议格式中的一行文本表示CnosDB中的一个数据点。它将点的measurement value、tag set、field set和timestamp告知CnosDB。下面的代码块显示了一个行协议的示例，并将其分解为独立的组件:</p>
<pre><code>air,station=LianYunGang temperature=74 1642176540000000000
|    -------------------- -----------------  |
|              |              |              |
|              |              |              |
+-----------+--------+-+---------+-+---------+
|measurement|,tag_set| |field_set| |timestamp|
+-----------+--------+-+---------+-+---------+
</code></pre>
<p><strong><code>measurement</code></strong></p>
<ul>
<li><code>measurement</code> - 要将数据写入的measurement的名字。measurement需符合线路协议。在本例子中，measurement为weather。</li>
<li><code>tag set</code> - 标记集。包含在数据点中的标记。tag在行协议中是可选的。需要注意的是，tag set和measurement之间由逗号分隔，没有空格。用等号<code>=</code>分隔标签的键值对时，不需要插入空格，如:<code>&lt;tag_key&gt;=&lt;tag_value&gt;</code>。多个标记值对之间用逗号分隔，不能有空格。在本例子中，标记集由标记<code>station=LianYunGang</code>组成。
当在标记集中使用引号时，行协议支持单引号和双引号，如下表所示:</li>
<li><code>空格 I</code> - 将度量和字段集分开，或者，如果您在数据点中包含一个标记集，则使用空格将标记集和字段集分开。在行协议中需要空格。例如，没有tag set的有效行协议<code>air temperature=75 1642176360000000000</code>。</li>
<li><code>field set</code> - 您的数据点的字段。每个行协议中的数据点至少需要一个字段。用等号=分隔字段的键值对，并且没有空格，比如：<code>&lt;field_key&gt;=&lt;field_value&gt;</code>。多个字段值对用逗号分隔，不能用空格，如：<code>&lt;field_key&gt;=&lt;field_value&gt;,&lt;field_key&gt;=&lt;field_value&gt;</code>。</li>
<li><code>空格 II</code> - 用空格分隔field set和时间戳。如果包含时间戳，则行协议中需要空格。</li>
<li><code>timestamp</code> - 数据点的时间戳，以纳秒级Unix时间为单位。时间戳在行协议中是可选的。如果没有为数据点指定时间戳，则CnosDB将在UTC中使用服务器的本地纳秒时间戳。</li>
</ul>
<h4 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h4>
<ul>
<li>measurements, tag keys, tag values和field keys总是字符串。</li>
<li>时间戳为UNIX时间戳。最小时间戳为<code>-9223372036854775806</code>或<code>1677-09-21T00:12:43.145224194Z</code>。最大时间戳为<code>9223372036854775806</code>或<code>2262-04-11T23:47:16.854775806Z</code>。如上所述，根据默认配置，CnosDB假设时间戳具有纳秒精度。</li>
<li>field value可以是浮点数、整数、字符串或布尔值。在默认情况下，CnosDB假设所有的field value都是浮点数。</li>
<li>在一个measurement中，一个分片中的字段类型不能不同。但多个分片中的字段类型可以不同。例如，如果InfluxDB试图将整数存储在与浮点数相同的分片中，则将整数写入之前接受的浮点数字段将失败:
<pre><code>&gt; INSERT air,station=LianYunGang temperature=72 1642176180000000000
&gt; INSERT air,station=LianYunGang temperature=79i 1642176540000000000
ERR: {&quot;error&quot;:&quot;field type conflict: input field \&quot;temperature\&quot; on measurement \&quot;air\&quot; is type int64, already exists as type float&quot;}
``
</code></pre>
</li>
</ul>
<h4 id="引号"><a class="header" href="#引号">引号</a></h4>
<ul>
<li>不要对时间戳使用双引号或单引号。这不是有效的线路协议。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature=72 &quot;1642176180000000000&quot;
ERR: {&quot;error&quot;:&quot;unable to parse 'air,station=LianYunGang temperature=72 \&quot;1642176180000000000\&quot;': bad timestamp&quot;}
</code></pre>
</li>
<li>永远不要给字段值(即使它们是字符串)加单引号，这也不是有效的线路协议。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature='72' 1642176180000000000
ERR: {&quot;error&quot;:&quot;unable to parse 'air,station=LianYunGang temperature='72'': invalid boolean&quot;} 
</code></pre>
</li>
<li>不要用双引号或单引号引用measurement名称、tag key、tag value和field key。这是有效的行协议，但CnosDB假定引用是名称的一部分。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature=72 1642176180000000000
&gt; INSERT &quot;air&quot;,station=LianYunGang temperature=79 1642176540000000000
&gt; SHOW MEASUREMENTS
  name: measurements
  ------------------
  name
  &quot;air&quot;
  air
</code></pre>
要查询&quot;air&quot;中的数据，需要使用双引号，并使用正确的转义字符。
<pre><code>&gt; SELECT * FROM &quot;\&quot;air\&quot;&quot;
name: &quot;air&quot;
time                 station     temperature
----                 -------     -----------
2022-01-14T16:09:00Z LianYunGang 79

</code></pre>
</li>
<li>不要对浮点型、整型或布尔型字段值使用双引号。CnosDB将假定这些值是字符串。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature=&quot;72&quot;
&gt; SELECT * FROM air WHERE temperature &gt;= 70
&gt;
</code></pre>
</li>
<li>对类型为字符串的字段值使用双引号。
<pre><code>&gt; INSERT air,station=LianYunGang temperature=&quot;too warm&quot;
&gt; SELECT * FROM air
name: air
-------------
time				            station	 temperature
2022-01-14T16:09:00Z	LianYunGang	 too warm
</code></pre>
</li>
</ul>
<h4 id="特殊字符和关键字"><a class="header" href="#特殊字符和关键字">特殊字符和关键字</a></h4>
<p>对于tag keys,tag values,measurement,字符串类型的field values以及field keys总是使用反斜杠字符<code>\</code>进行转义。</p>
<ul>
<li>逗号<code>,</code>：
<pre><code>wind,station=Lian\,YunGang visibility=59,temperature=59,pressure=56 1649664217071649000
</code></pre>
</li>
<li>等号<code>=</code>：
<pre><code>wind,station=LianYunGang vis\=ibility=59,temperature=59,pressure=56 1649664217071649000
</code></pre>
</li>
<li>空格<code> </code>：
<pre><code>wind,stat\ ion=LianYunGang visibility=59,temperature=59,pressure=56 1649664217071649000
</code></pre>
</li>
<li>emojis 🥰： CnosDB的行协议支持emojis表情的输入，并且无需使用转义字符转义。例如：
<pre><code>&gt; INSERT 🌤,⛪️=LianYunGang 🌡=23
&gt; SELECT * FROM &quot;🌤&quot;
name: 🌤
time                        ⛪️          🌡
----                        ------      ----
2022-04-14T03:50:01.705037Z LianYunGang 23

</code></pre>
</li>
<li>关键字:行协议接受CnosQL关键字作为标识符名称。通常，我们建议避免在模式中使用CnosQL关键字，因为它可能会在查询数据时造成混乱。 关键字<code>time</code>是一种特殊情况。<code>time</code>可以是连续查询名称、数据库名称、measurement名称、保留策略名称和用户名称。在这些情况下，<code>time</code>不需要在查询中使用双引号。<code>time</code>不能是字段键或标记键;CnosDB拒绝以<code>time</code>作为字段键或标记键的写操作，并返回错误。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosdb-write-api"><a class="header" href="#cnosdb-write-api">CnosDB Write API</a></h2>
<ul>
<li>
<h3 id="使用cnosdb-api创建数据库"><a class="header" href="#使用cnosdb-api创建数据库">使用CnosDB API创建数据库</a></h3>
<p>要创建数据库，先向<code>/query</code>端点发送<code>POST</code>请求，并将URL参数中的<code>q</code>设置为<code>CREATE DATABASE &lt;new_database_name&gt;</code>。例如,在CnosDB中创建一个名为&quot;weather_data&quot;的数据库。</p>
<pre><code>curl -i -XPOST http://localhost:8086/query --data-urlencode &quot;q=CREATE DATABASE weather_data&quot;
</code></pre>
</li>
<li>
<h3 id="使用cnosdb-api写入数据"><a class="header" href="#使用cnosdb-api写入数据">使用CnosDB API写入数据</a></h3>
<blockquote>
<p><code>measurement</code>与<code>tag</code>之间使用<code>,</code>分隔</p>
<p><code>tag</code>组合可以有多个，<code>tag</code>之间使用<code>,</code>分隔</p>
<p><code>tag</code>与<code>field</code>之间使用空格分隔</p>
<p><code>field</code>组合可以有多个，<code>field</code>之间使用<code>,</code>分隔</p>
<p><code>field</code>与时间戳使用空格分隔</p>
</blockquote>
<p>使用CnosDB API写入数据，向/write端点发送POST请求。例如，向&quot;weather_data&quot;写入一个点。此数据的组成为：measurement为<code>wind</code>，field key为<code>speed</code>和<code>direction</code>，field values分别为<code>75</code>和<code>65</code>，timestamp为<code>1649664217085031000</code>。</p>
<pre><code>curl -i -XPOST 'http://localhost:8086/write?db=weather_data' --data-binary 'wind,station=LianYunGang speed=75,direction=65 1649664217085031000'
</code></pre>
<p>写入点时，必须在<code>db</code>查询参数中指定一个已存在的数据库。如果你不通过<code>rp</code>查询参数提供保留策略，点将被写入数据库的默认保留策略。</p>
</li>
<li>
<h3 id="写入多点"><a class="header" href="#写入多点">写入多点</a></h3>
<p>将多个点同时Post到多个序列，每个点用一个新行分开。以这种方式对点进行批处理可以获得更高的性能。</p>
<p>通过用换行分隔每个<code>Points</code>，将多个<code>Points</code>同时写入到多个<code>series</code>中，以这种方式批处理<code>Points</code>可以提高性能。</p>
<p>下面的示例将三个<code>Points</code>写入数据库<code>mydb</code>:</p>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?db=weather_data' --data-binary 'wind,station=LianYunGang speed=75,direction=65 1649664217085027000
wind,station=LianYunGang speed=75,direction=65 1649664217085031000
wind,station=XiaoMaiDao speed=70,direction=63 1649664217085036000'

</code></pre>
</li>
<li>
<h3 id="配置gzip压缩"><a class="header" href="#配置gzip压缩">配置gzip压缩</a></h3>
<p>cnosdb支持gzip压缩，要减少网络流量，需优先考虑一下选项</p>
<ul>
<li>
<p>要接受来自cnosdb的压缩数据，请将<code>Accept-Encoding：gzip</code>heade信息添加到cnosdb API请求中</p>
</li>
<li>
<p>要在将数据发送到cnosdb之前压缩数据，将<code>Content-Encoding:gzip</code>heade信息添加到cnosdb API请求中</p>
</li>
</ul>
</li>
<li>
<h3 id="从文件写入points"><a class="header" href="#从文件写入points">从文件写入Points</a></h3>
<p>通过传递<code>@filename</code>到文件来写入文件中的数据</p>
<p>格式正确的文件（<code>data.txt</code>）的示例：</p>
<p>写入数据data.txt到weather_data数据库</p>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?weather_data' --data-binary @data.txt
</code></pre>
<p>注意：如果您的数据文件具有超过5000个Points，则可能有必要将该文件拆分为多个文件，以便将数据批量写入cnosdb，默认情况下，HTTP请求在五秒后超时，超时后，cnosdb仍然将尝试写入这些点，但是不会确认它们已经成功写入</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosdb-query-api"><a class="header" href="#cnosdb-query-api">CnosDB Query API</a></h2>
<ul>
<li>
<h3 id="单条查询语句"><a class="header" href="#单条查询语句">单条查询语句</a></h3>
<p>CnosDB API 是在 CnosDB中查询数据的主要方式。</p>
<p>如果需要执行查询请求，需要将GET请求发送到/query端点，将URL参数db设置为目标数据库，并将参数q设置为查询语句。还可以通过发送相同的参数作为URL参数或作为带有<code>application/x-www-form-urlencoded</code>的正文的一部分来使用POST请求。</p>
<p>示例：</p>
<pre><code>curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode &quot;db=weather_data&quot; --data-urlencode &quot;q=SELECT \&quot;speed\&quot; FROM \&quot;wind\&quot; WHERE \&quot;station\&quot;='LianYunGang'&quot;
</code></pre>
<p>其结果为：</p>
<pre><code>{
&quot;results&quot;: [
    {
        &quot;statement_id&quot;: 0,
        &quot;series&quot;: [
            {
                &quot;name&quot;: &quot;wind&quot;,
                &quot;columns&quot;: [
                    &quot;time&quot;,
                    &quot;speed&quot;
                ],
                &quot;values&quot;: [
                    [
                        &quot;2022-04-11T08:03:37.085027Z&quot;,
                        75
                    ],
                    [
                        &quot;2022-04-11T08:03:37.085031Z&quot;,
                        75
                    ]
                  ]  
                }
            ]
        }
    ]
}

</code></pre>
</li>
<li>
<h3 id="返回错误"><a class="header" href="#返回错误">返回错误</a></h3>
<p>CnosDB返回JSON，查询的结果会在<code>rusults</code>数组中，如果发生错误，CnosDB会设置一个带有<code>error</code>的key</p>
</li>
<li>
<h3 id="多条查询语句"><a class="header" href="#多条查询语句">多条查询语句</a></h3>
<p>多条查询语句需要用<code>;</code>分隔</p>
<pre><code class="language-shell">curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode &quot;db=weather_data&quot; --data-urlencode &quot;q=SELECT speed FROM wind WHERE station = 'XiaoMaiDao';SELECT temperature FROM air WHERE station = 'XiaoMaiDao'&quot;
</code></pre>
</li>
<li>
<h3 id="时间精度"><a class="header" href="#时间精度">时间精度</a></h3>
<p>CnosDB中的所有内容都以UTC存储和输出。默认情况下，时间戳以RFC3339格式返回，例如 2015-08-04T19:05:00Z，如果想要Unix纪元格式的时间戳，则需要在请求中包含字符串参数：epoch=[h, m, s, ms, u, ns]</p>
<pre><code class="language-shell">curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode &quot;db=oceanic_station&quot; --data-urlencode &quot;epoch=s&quot; --data-urlencode &quot;q=SELECT temperature FROM air WHERE station = 'XiaoMaiDao'&quot;
</code></pre>
</li>
<li>
<h3 id="最大行限制"><a class="header" href="#最大行限制">最大行限制</a></h3>
<p><code>max-row-limit</code>配置选项允许用于限制返回结果最大数量，以防止CnosDB在聚合结果时耗尽内存，<code>max-row-limit</code>配置选项默认设置为0，该默认设置允许每个请求返回无限数量的行。
最大行限制适用于非块查询，分块查询可以返回无限数量的points。</p>
</li>
<li>
<h3 id="chunking"><a class="header" href="#chunking">Chunking</a></h3>
<p>通过设置查询字符串参数chunked=true，可以使用分块以流式批处理而不是作为单个响应返回结果。响应将按series或每10000point分块，以先发生者为准。要将最大块大小更改为不同的值，需要将查询字符串chunk_size设置为不同的值</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h2>
<p>CnosDB对Prometheus远程读写的支持是将以下HTTP端点添加到CnosDB。</p>
<ul>
<li>/api/v1/prom/read</li>
<li>/api/v1/prom/write</li>
</ul>
<p>此外，还有一个<code>/metrics</code>端点被配置为以Prometheus度量格式生成默认的Go度量。</p>
<ul>
<li>
<h3 id="创建目标数据库"><a class="header" href="#创建目标数据库">创建目标数据库</a></h3>
<p>在您的CnosDB中创建一个数据库来存放从Prometheus发送的数据。在下面的示例中，我们使用prometheus作为数据库名。</p>
<p><code>CREATE DATABASE &quot;prometheus&quot;</code></p>
</li>
<li>
<h3 id="配置"><a class="header" href="#配置">配置</a></h3>
<p>若要在CnosDB中使用Prometheus远程读写API，请在Prometheus配置文件中的以下设置中添加URL值:</p>
<ul>
<li><code>remote_write</code></li>
<li><code>remote_read</code></li>
</ul>
<p>这些URL必须可以从运行的Prometheus服务器解析，并使用运行CnosDB的端口(默认情况下为8086)。还要使用包含数据库名称的<code>db= </code>查询参数。</p>
<p>例如：</p>
<pre><code>remote_write:
- url: &quot;http://localhost:8086/api/v1/prom/write?db=prometheus&quot;

remote_read:
- url: &quot;http://localhost:8086/api/v1/prom/read?db=prometheus&quot;
</code></pre>
</li>
<li>
<h3 id="如何在cnosdb中解析prometheus度量"><a class="header" href="#如何在cnosdb中解析prometheus度量">如何在CnosDB中解析Prometheus度量</a></h3>
<ul>
<li>Prometheus度量名称成为CnosDB的measurement名称。</li>
<li>Prometheus的样本值成为CnosDB的字段键及字段值。通常是浮点数形式。</li>
<li>Prometheus的标签成为CnosDB的tags。</li>
<li>所有的<code># HELP </code>和<code># TYPE </code>行被忽略。</li>
</ul>
<pre><code>  # Prometheus 
  example_metric{queue=&quot;0:http://example:8086/api/v1/prom/write?db=prometheus&quot;,le=&quot;0.005&quot;} 308
  
  # CnosDB
  measurement
  example_metric
  tags
  queue = &quot;0:http://example:8086/api/v1/prom/write?db=prometheus&quot;
  le = &quot;0.005&quot;
  job = &quot;prometheus&quot;
  instance = &quot;localhost:9090&quot;
  __name__ = &quot;example_metric&quot;
  fields
  value = 308
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="telegraf"><a class="header" href="#telegraf">Telegraf</a></h2>
<p>Telegraf是CnosDB的数据收集代理，用于收集和报告指标。它庞大的输入插件库和“即插即用”的架构可以让您快速、轻松地从许多不同的来源收集指标。</p>
<ul>
<li>
<h3 id="配置-telegraf"><a class="header" href="#配置-telegraf">配置 Telegraf</a></h3>
<p>Telegraf的输入和输出插件在Telegraf的配置文件(<code>Telegraf .conf</code>)中启用和配置。您有以下配置Telegraf的选项:</p>
<ul>
<li>
<h4 id="自动配置-telegraf"><a class="header" href="#自动配置-telegraf">自动配置 Telegraf</a></h4>
</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集群管理"><a class="header" href="#集群管理">集群管理</a></h1>
<h2 id="介绍-2"><a class="header" href="#介绍-2">介绍</a></h2>
<p>CnosDB由两组软件组成，<code>data</code>节点和<code>meta</code>节点，集群内的通讯如下所示：</p>
<p><code>meta</code>节点使用<code>tcp</code>和<code>raft</code>协议进行通信，<code>meta</code>节点之间使用默认端口<code>8091</code>通信，多个<code>meta</code>节点需要互相能够访问，用来维持<code>meta</code>集群的一致性。同时<code>8091</code>端口也用来和外界通信，比如<code>cnosd-ctl</code>或<code>data</code>节点等。</p>
<p><code>data</code>节点通过<code>tcp</code>的8088端口互相通信，并且通过<code>8091</code>访问<code>meta</code>节点的API，使状态保持同步。</p>
<p><code>meta</code>节点数量必须为大于等于3的奇数，这样可以保证集群能够保持选举稳定。</p>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<p>配置文件的<code>hostname</code>需要其他的<code>meta node</code>和<code>data node</code>节点都能够访问。</p>
<p>配置文件可以通过<code>cnosdb-meta config &gt; config_path</code>获得。</p>
<ul>
<li>
<h3 id="启动meta节点"><a class="header" href="#启动meta节点">启动<code>meta</code>节点</a></h3>
<pre><code>./cnosdb-meta --config [cnosdb_meta_config_path]
</code></pre>
</li>
<li>
<h3 id="将meta加入到集群"><a class="header" href="#将meta加入到集群">将<code>meta</code>加入到集群</a></h3>
<blockquote>
<p>添加完后会提示：Added meta node x at cnosdb-meta-0x:8091</p>
</blockquote>
<pre><code>cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-01:8091
cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-02:8091
cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-03:8091
</code></pre>
<p>3个节点都添加完输入<code>cnosdb-ctl show</code>查看集群状态</p>
<pre><code>Data Nodes:
==========


Meta Nodes:
==========

1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
<p>请注意，一但没有出现3个节点，不要进行下一步。</p>
</li>
<li>
<h3 id="启动data节点"><a class="header" href="#启动data节点">启动<code>data</code>节点</a></h3>
<blockquote>
<p>启动前将配置文件中的<code>cluster</code>改为<code>true</code></p>
</blockquote>
<pre><code> cnosdb --config [cnosdb_config_path]
</code></pre>
</li>
<li>
<h3 id="将data节点加入到集群"><a class="header" href="#将data节点加入到集群">将<code>data</code>节点加入到集群</a></h3>
<blockquote>
<p>添加完后会提示：Added data node x at cnosdb-data-0x:8088</p>
</blockquote>
<pre><code>cnosdb-ctl --bind cnosdb-data-01:8091 add-data cnosdb-data-01:8088
cnosdb-ctl --bind cnosdb-data-01:8091 add-data cnosdb-data-02:8088
</code></pre>
<p>2个节点都添加完输入<code>cnosdb-ctl show</code>查看集群状态</p>
<pre><code>Data Nodes:
==========

4      cnosdb-data-01:8088
5      cnosdb-data-02:8088
Meta Nodes:
==========

1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
</li>
</ul>
<h2 id="distributed-sandbox"><a class="header" href="#distributed-sandbox">Distributed-sandbox</a></h2>
<p>可以使用<code>Distributed-sandbox</code>工具快速生产分布式集群</p>
<ul>
<li>
<h3 id="要求"><a class="header" href="#要求">要求</a></h3>
<p>本地上要有<code>Docker</code></p>
</li>
<li>
<h3 id="克隆项目"><a class="header" href="#克隆项目">克隆项目</a></h3>
<pre><code>git clone https://github.com/IvanGao01/distributed-sandbox.git
</code></pre>
</li>
<li>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<pre><code>docker-compose up -d
chmod 777 cluster.sh
./cluster.sh
</code></pre>
<p>运行成功后可看到如下结果</p>
<pre><code>Joining meta nodes to cluster...
Added meta node 1 at cnosdb-meta-01:8091
Added meta node 2 at cnosdb-meta-02:8091
Added meta node 3 at cnosdb-meta-03:8091
Data Nodes:
==========
4      cnosdb-data-01:8088
5      cnosdb-data-02:8088

Meta Nodes:
==========
1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091

Joining data nodes to cluster...
EOF
EOF
Cluster successfully created
Data Nodes:
==========
4      cnosdb-data-01:8088
5      cnosdb-data-02:8088

Meta Nodes:
==========
1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="常见问题-2"><a class="header" href="#常见问题-2">常见问题</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
