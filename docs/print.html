<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CnosDB</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="content/cnosdb/0.10/about.html"><strong aria-hidden="true">1.</strong> 关于本项目</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/introduction/index.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/0.10/introduction/download.html"><strong aria-hidden="true">2.1.</strong> 下载</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/introduction/install.html"><strong aria-hidden="true">2.2.</strong> 安装</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/introduction/get-start.html"><strong aria-hidden="true">2.3.</strong> 快速开始</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/concept/index.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/guide/index.html"><strong aria-hidden="true">4.</strong> 指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/0.10/guide/cnosdb.html"><strong aria-hidden="true">4.1.</strong> cnosdb</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/guide/cnosdb-cli.html"><strong aria-hidden="true">4.2.</strong> cnosdb-cli</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/guide/write.html"><strong aria-hidden="true">4.3.</strong> HTTP写入</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/guide/query.html"><strong aria-hidden="true">4.4.</strong> HTTP查询</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html"><strong aria-hidden="true">4.5.</strong> CnosDB Inspect</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/cnosql/index.html"><strong aria-hidden="true">5.</strong> CnosQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/0.10/cnosql/ddl.html"><strong aria-hidden="true">5.1.</strong> DDL</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/cnosql/dml.html"><strong aria-hidden="true">5.2.</strong> DML</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/cnosql/function.html"><strong aria-hidden="true">5.3.</strong> 函数</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/cnosql/countine_query.html"><strong aria-hidden="true">5.4.</strong> 连续查询</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/cluster/introduction.html"><strong aria-hidden="true">6.</strong> CnosDB分布式</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/other/index.html"><strong aria-hidden="true">7.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/0.10/other/kubernetes-deployment.html"><strong aria-hidden="true">7.1.</strong> 使用Kubernetes部署CnosDB</a></li><li class="chapter-item expanded "><a href="content/cnosdb/0.10/other/kubernetes-StatefulSet.html"><strong aria-hidden="true">7.2.</strong> 使用Kubernetes部署CnosDB集群</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CnosDB</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cnosdb"><a class="header" href="#cnosdb">CnosDB</a></h1>
<p>CnosDB是一个由社区驱动的开源时间序列数据库。</p>
<h2 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h2>
<blockquote>
<p>CnosDB是一个专注于时序数据场景的时序型数据库，适用于各种时序场景，如服务器指标、应用程序指标、性能指标、函数接口调用指标、网络流量数据、探测器数据、日志、市场交易记录等。</p>
</blockquote>
<h3 id="devops监控"><a class="header" href="#devops监控">DevOps监控</a></h3>
<p>通过监控基础设施（服务器、容器、数据库、微服务、云服务等）的核心指标来及时发现问题并在影响关键业务之前解决问题，尽管一些新兴技术提升了基础设施的DevOps监控的复杂性，但CnosDB都能很好的适应。CnosDB通过灵活的插件的形式，采集指标或者从第三方服务（如StatsD或Kafka）拉取数据，并通过自定义配置按需上报给外部存储系统。</p>
<h3 id="iot监控"><a class="header" href="#iot监控">IoT监控</a></h3>
<p>主要用于接收和处理来自IoT设备的海量数据，并进行实时分析，在无人工干预的情况下，执行预定义操作，IoT设备无处不在，公路摄像头，智能网联车、手机、冰箱都有它的身影，不过IoT设备的硬件性能和缓存能力有限，数据往往是以流式方式实时上报，所以需要一个弹性、扩展性强的高性能时序后台来应对突发流量的挑战。CnosDB的水平扩展、实时分析等能力，是专门针对这类场景来设计的，具有足够的读写性能和容量弹性。</p>
<h2 id="产品特性"><a class="header" href="#产品特性">产品特性</a></h2>
<ul>
<li>全面与InfluxDB 1.X 稳定版兼容。</li>
<li>开源分布式集群，产品永久免费。</li>
<li>24*7全球开源社区支持。</li>
<li>实时时序数据库：可将您的离线监控平台，提升为一个实时决策系统</li>
<li>支持海量时间序列线：在海量标签、海量时间序列线的情况下，依然能够高效实现分布式迭代器及查询优化</li>
<li>低成本/碳中和：高效的存储引擎可充分发挥硬件性能，并在高效压缩存储的同时保障查询效率</li>
<li>强大完整的生态：可集成市面上主流的采集、存储、分析、可视化等工具</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="介绍"><a class="header" href="#介绍">介绍</a></h1>
<h3 id="构建"><a class="header" href="#构建">构建</a></h3>
<ol>
<li>
<p>克隆项目</p>
<pre><code>git clone https://github.com/cnosdb/cnosdb.git
</code></pre>
</li>
<li>
<p>编译</p>
<pre><code>go install ./...
</code></pre>
</li>
</ol>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<ol>
<li>
<p>启动</p>
<pre><code class="language-bash">$GOPATH/bin/cnosdb
</code></pre>
</li>
<li>
<p>使用</p>
<pre><code class="language-bash">$GOPATH/bin/cnosdb-cli
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="下载"><a class="header" href="#下载">下载</a></h1>
<h2 id="ubuntu--debian"><a class="header" href="#ubuntu--debian">Ubuntu &amp; Debian</a></h2>
<blockquote>
<p>MD5: 3aa8049d784487f6aeeab21a4e8f7c1c</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb_0.10.3_amd64.deb
sudo dpkg -i cnosdb_0.10.3_amd64.deb
</code></pre>
<h2 id="docker-image"><a class="header" href="#docker-image">Docker Image</a></h2>
<pre><code class="language-shell">docker pull cnosdb:0.10.3
</code></pre>
<h2 id="redhat--centos"><a class="header" href="#redhat--centos">RedHat &amp; CentOS</a></h2>
<blockquote>
<p>MD5: 0d3c00abdb34764dcbd79eee33ea1c0f</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3.x86_64.rpm
sudo yum localinstall cnosdb-0.10.3.x86_64.rpm
</code></pre>
<h2 id="macos"><a class="header" href="#macos">macOS</a></h2>
<blockquote>
<p>MD5: 7711a3167255ee015f1f62f53d0e38cd</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_darwin_amd64.tar.gz
tar zxvf cnosdb-0.10.3_darwin_amd64.tar.gz
</code></pre>
<h2 id="windows-binaries64-bit---using-powershell"><a class="header" href="#windows-binaries64-bit---using-powershell">Windows Binaries(64-bit) - using PowerShell</a></h2>
<blockquote>
<p>MD5: 62ea309b3edd8fe9c4b98d10f9bc7dcf</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_windows_amd64.zip -UseBasicParsing -OutFile cnosdb-0.10.3_windows_amd64.zip
Expand-Archive .\cnosdb-0.10.3_windows_amd64.zip -DestinationPath 'C:\Program Files\CnosDB\cnosdb\'
</code></pre>
<h2 id="linux-binaries64-bit"><a class="header" href="#linux-binaries64-bit">Linux Binaries(64-bit)</a></h2>
<blockquote>
<p>MD5: 64c763c917030134971d21e54c21a59d</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_amd64.tar.gz
tar xvfz cnosdb-0.10.3_linux_amd64.tar.gz
</code></pre>
<h2 id="linux-binaries64-bit-static"><a class="header" href="#linux-binaries64-bit-static">Linux Binaries(64-bit, static)</a></h2>
<blockquote>
<p>MD5: eebb5665fcc4f540de488567caec187d</p>
</blockquote>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3-static_linux_amd64.tar.gz
tar xvfz cnosdb-0.10.3-static_linux_amd64.tar.gz
</code></pre>
<h2 id="linux-binaries32-bit"><a class="header" href="#linux-binaries32-bit">Linux Binaries(32-bit)</a></h2>
<p>MD5: 3ed72382eb79d664baeac3b71d744b4b</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_i386.tar.gz
tar xvfz cnosdb-0.10.3_linux_i386.tar.gz
</code></pre>
<h2 id="linux-binariesarmv7"><a class="header" href="#linux-binariesarmv7">Linux Binaries(ARMv7)</a></h2>
<p>MD5: 90b2b8c72404e1835988325b3ea05f3d</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_armhf.tar.gz
tar xvfz cnosdb-0.10.3_linux_armhf.tar.gz
</code></pre>
<h2 id="linux-binariesarmv8"><a class="header" href="#linux-binariesarmv8">Linux Binaries(ARMv8)</a></h2>
<p>MD5: 631ef2e05b2d0f5a310422d1871bb003</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_arm64.tar.gz
tar xvfz cnosdb-0.10.3_linux_arm64.tar.gz
</code></pre>
<h2 id="验证下载二进制文件的真实性可选"><a class="header" href="#验证下载二进制文件的真实性可选">验证下载二进制文件的真实性（可选）</a></h2>
<p>为了验证安全性，请按照以下步骤验证您下载的CnosDB的<code>gpg</code>签名（大多数系统默认包含<code>gpg</code>命令，如果<code>gpg</code>不可用，请参阅<a href="https://gnupg.org/download">Gun主页</a>获取安装说明。</p>
<ol>
<li>下载并导入CnosDB公钥
<pre><code>curl -s https://www.cnosdb.com/cnosdb.key | gpg --import
</code></pre>
</li>
<li>通过在URL上添加<code>.asc</code>来下载指定版本的签名文件
<pre><code class="language-shell"> wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3_linux_amd64.tar.gz
</code></pre>
</li>
<li>验证签名 <code>gpg --verify</code>
<pre><code class="language-shell">gpg --verify cnosdb-0.10.3_linux_amd64.tar.gz.asc cnosdb-0.10.3_linux_amd64.tar.gz
</code></pre>
此命令应该输出：
<pre><code class="language-shell">gpg: Good signature from &quot;CnosDB &lt;contact@cnosdb.com&gt;&quot; [unknown]
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<ol>
<li>
<p>拉取镜像</p>
<pre><code class="language-shell">docker pull cnosdb/cnosdb:latest
</code></pre>
</li>
<li>
<p>启动容器</p>
<pre><code class="language-shell">docker run -itd -p 8086:8086 cnosdb/cnosdb:latest
</code></pre>
</li>
</ol>
<h2 id="ubuntu--debian-1"><a class="header" href="#ubuntu--debian-1">Ubuntu &amp; Debian</a></h2>
<ol>
<li>
<p>下载</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb_0.10.3_amd64.deb
sudo dpkg -i cnosdb_0.10.3_amd64.deb
</code></pre>
</li>
<li>
<p>启动</p>
<pre><code class="language-shell">sudo systemctl start cnosdb
</code></pre>
</li>
</ol>
<h2 id="red-hat--centos"><a class="header" href="#red-hat--centos">Red Hat &amp; CentOS</a></h2>
<ol>
<li>下载
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v0.10.3/cnosdb-0.10.3.x86_64.rpm
sudo yum localinstall cnosdb-0.10.3.x86_64.rpm
</code></pre>
</li>
<li>启动
<pre><code class="language-shell">sudo systemctl start cnosdb
</code></pre>
</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h1>
<p>安装完成后，您就拥有了一个CnosDB数据库了，可以通过命令行或HTTP API对数据库进行操作，<code>8086</code>是CnosDB默认端口，您可以使用<a href="content/cnosdb/0.10/introduction/../guide/cnosdb-cli.html"><code>cnosdb-cli</code></a>连接数据库进行操作。</p>
<p>使用命令行操作数据库请<a href="content/cnosdb/0.10/introduction/../cnosql/ddl.html">点击这里</a></p>
<p>使用命令行进行读写操作请<a href="content/cnosdb/0.10/introduction/../cnosql/dml.html">点击这里</a></p>
<p>使用HTTP API进行写入请<a href="content/cnosdb/0.10/introduction/../guide/write.html">点击这里</a></p>
<p>使用HTTP API进行读取操作请<a href="content/cnosdb/0.10/introduction/../guide/query.html">点击这里</a></p>
<p>函数手册请<a href="content/cnosdb/0.10/introduction/../cnosql/function.html">参考这里</a></p>
<p>连续查询请<a href="content/cnosdb/0.10/introduction/../cnosql/countine_query.html">参考这里</a></p>
<p>使用Kubernetes部署CnosDB请<a href="content/cnosdb/0.10/introduction/../other/kubernetes-deployment.html">点击这里</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="概念"><a class="header" href="#概念">概念</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用指南"><a class="header" href="#使用指南">使用指南</a></h1>
<blockquote>
<p>CnosDB 使用指南</p>
</blockquote>
<ul>
<li><a href="content/cnosdb/0.10/guide/./cnosdb.html">cnosdb</a></li>
<li><a href="content/cnosdb/0.10/guide/./cnosdb-cli.html">cnosdb-cli</a></li>
<li><a href="content/cnosdb/0.10/guide/./write.html">CnosDB Write 接口</a></li>
<li><a href="content/cnosdb/0.10/guide/./query.html">CnosDB Query接口</a></li>
<li><a href="content/cnosdb/0.10/guide/./cnosdb_inspect.html">CnosDB Inspect</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-1"><a class="header" href="#cnosdb-1">cnosdb</a></h1>
<p><code>cnosdb</code>命令用于启动 CnosDB 服务或相关功能。</p>
<h2 id="命令介绍"><a class="header" href="#命令介绍">命令介绍</a></h2>
<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody>
<tr><td>backup</td><td>创建数据节点的备份</td></tr>
<tr><td>config</td><td>显示默认配置项</td></tr>
<tr><td>help</td><td>显示帮助信息</td></tr>
<tr><td>restore</td><td>使用数据节点的备份进行恢复</td></tr>
<tr><td>run</td><td>启动服务</td></tr>
<tr><td>version</td><td>显示版本信息</td></tr>
</tbody></table>
<h2 id="cnosdb-run"><a class="header" href="#cnosdb-run"><code>cnosdb [run]</code></a></h2>
<p>启动服务。</p>
<pre><code>cnosdb [run] [flags]
</code></pre>
<h3 id="参数介绍"><a class="header" href="#参数介绍">参数介绍</a></h3>
<table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>--config</code></td><td>配置文件路径</td></tr>
<tr><td><code>--pidfile</code></td><td>将进程 ID 写入指定文件</td></tr>
<tr><td><code>--cpuprofile</code></td><td>将 CPU 信息写入指定文件</td></tr>
<tr><td><code>--memprofile</code></td><td>将内存使用记录写入指定文件</td></tr>
</tbody></table>
<h2 id="cnosdb-backup"><a class="header" href="#cnosdb-backup"><code>cnosdb backup</code></a></h2>
<p>从指定数据节点创建数据库快照，并保存到 PATH 对应目录。</p>
<pre><code>cnosdb backup [flags] PATH
</code></pre>
<h3 id="参数介绍-1"><a class="header" href="#参数介绍-1">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>数据库名称；可选；如果未指定则备份所有数据库。</td></tr>
<tr><td><code>--rp</code></td><td>数据保留策略；可选；如果未指定则备份所有数据保留策略。</td></tr>
<tr><td><code>--shard</code></td><td>分片编号；可选；如果需要使用该参数，则需要同时使用 <code>-rp</code> 参数。</td></tr>
<tr><td><code>--start</code></td><td>备份中包含的数据的最小时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--end</code></td><td>备份中包含的数据的最大时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--skip-errors</code></td><td>创建某分片的备份时，若发生错误，继续创建剩余分片的备份。</td></tr>
</tbody></table>
<h2 id="cnosdb-restore"><a class="header" href="#cnosdb-restore"><code>cnosdb restore</code></a></h2>
<p>从指定的备份目录中恢复数据和元数据。恢复开始时，服务将被关闭。</p>
<pre><code>cnosdb restore [flags]
</code></pre>
<h3 id="参数介绍-2"><a class="header" href="#参数介绍-2">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>从备份数据中恢复的数据库名称。</td></tr>
<tr><td><code>--newdb</code></td><td>创建新数据库以导入备份数据；可选；如果未指定，则使用 <code>--db &lt;db_name&gt;</code> 中指定的数据库名称。该参数指定的数据库名称在目标系统中不能重复。</td></tr>
<tr><td><code>--rp</code></td><td>从备份数据中恢复的数据库保留策略名称；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 参数。</td></tr>
<tr><td><code>--newrp</code></td><td>将备份数据导入其他的数据保留策略；可选；如果未指定，则使用 <code>--rp</code> 中指定的数据保留策略名称。</td></tr>
<tr><td><code>--shard</code></td><td>从备份数据中恢复的分片编号；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 和 <code>--rp</code> 参数。</td></tr>
</tbody></table>
<h2 id="cnosdb-config"><a class="header" href="#cnosdb-config"><code>cnosdb config</code></a></h2>
<p>显示服务运行时的默认配置。</p>
<pre><code>cnosdb config [flags]
</code></pre>
<h3 id="参数介绍-3"><a class="header" href="#参数介绍-3">参数介绍</a></h3>
<table><thead><tr><th style="text-align: left">Flag</th><th style="text-align: left"></th><th>Description</th></tr></thead><tbody>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>--config</code></td><td>指定配置文件路径。若需要禁止从文件中加载配置项，可将该值设为 <code>/dev/null</code> 。</td></tr>
<tr><td style="text-align: left"><code>-h</code></td><td style="text-align: left"><code>--help</code></td><td>显示 <code>cnosdb config</code> 的帮助信息。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-cli"><a class="header" href="#cnosdb-cli">cnosdb-cli</a></h1>
<p>启动交互式命令行程序并连接 <code>cnosdb</code> 服务，以实现数据的写入、查询。</p>
<pre><code>cnosdb-cli [flags]
</code></pre>
<h2 id="参数介绍-4"><a class="header" href="#参数介绍-4">参数介绍</a></h2>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>连接的 cnosdb HTTP 协议地址 (default: <code>http://localhost:8086</code>)</td></tr>
<tr><td><code>--port</code></td><td>连接的 cnosdb 的端口号</td></tr>
<tr><td><code>--password</code></td><td>连接服务时使用的密码</td></tr>
<tr><td><code>--username</code></td><td>连接服务时使用的用户名</td></tr>
<tr><td><code>--ssl</code></td><td>连接时使用 HTTPS 协议</td></tr>
<tr><td><code>--format</code></td><td>指定打印 cnosdb 服务的响应内容的格式: json, csv, or column</td></tr>
<tr><td><code>--precision</code></td><td>指定时间戳的格式: rfc3339, h, m, s, ms, u or ns</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http写入"><a class="header" href="#http写入">HTTP写入</a></h1>
<h3 id="使用cnosdb-api创建数据库"><a class="header" href="#使用cnosdb-api创建数据库">使用CnosDB API创建数据库</a></h3>
<p>要创建数据库，请向<code>/query</code>端点发送POST请求，并将URL参数<code>q</code>设置为<code>CREATE DATABASE &lt;new_database_name&gt;</code>下面的示例向本地主机上运行的cnosdb发送一个请求，并创建mydb数据库；</p>
<pre><code class="language-bash">curl -i -XPOST http://localhost:8086/query --data-urlencode &quot;q=CREATE DATABASE mydb&quot;
</code></pre>
<h3 id="使用cnosdb-api写入数据"><a class="header" href="#使用cnosdb-api写入数据">使用CnosDB API写入数据</a></h3>
<p>cnosdb API是将数据写入cnosdb的主要方法</p>
<ul>
<li>
<p>如果使用cnosdb 0.9 API写入数据，需要发送<code>POST</code>送到<code>/write</code>接口，将数据写入到<code>mydb</code>数据库，那么数据应该包含以下部分：</p>
<blockquote>
<p><code>measurement</code>与<code>tag</code>之间使用<code>,</code>分隔</p>
<p><code>tag</code>组合可以有多个，<code>tag</code>之间使用<code>,</code>分隔</p>
<p><code>tag</code>与<code>field</code>之间使用空格分隔</p>
<p><code>field</code>组合可以有多个，<code>field</code>之间使用<code>,</code>分隔</p>
<p><code>field</code>与时间戳使用空格分隔</p>
</blockquote>
<ul>
<li><code>measurement</code> : <code>cpu_load_short</code></li>
<li><code>tag key</code>=<code>tag value</code> : <code>host=server01,region=us-west</code></li>
<li><code>field key=field value</code>: <code>value=0.64</code> </li>
<li><code>timestamp</code> : <code>1434055562000000000</code></li>
</ul>
<pre><code>curl -i -XPOST 'http://localhost:8086/write?db=mydb'
--data-binary 'cpu_load_short,host=server01,region=us-west value=0.64 1434055562000000000'
</code></pre>
</li>
</ul>
<h3 id="配置gzip压缩"><a class="header" href="#配置gzip压缩">配置gzip压缩</a></h3>
<p>cnosdb支持gzip压缩，要减少网络流量，需优先考虑一下选项</p>
<ul>
<li>
<p>要接受来自cnosdb的压缩数据，请将<code>Accept-Encoding：gzip</code>heade信息添加到cnosdb API请求中</p>
</li>
<li>
<p>要在将数据发送到cnosdb之前压缩数据，将<code>Content-Encoding:gzip</code>heade信息添加到cnosdb API请求中</p>
</li>
</ul>
<h3 id="批量写入数据"><a class="header" href="#批量写入数据">批量写入数据</a></h3>
<p>通过用换行分隔每个<code>Points</code>，将多个<code>Points</code>同时写入到多个<code>series</code>中，以这种方式批处理<code>Points</code>可以提高性能。</p>
<p>下面的示例将三个<code>Points</code>写入数据库<code>mydb</code>:</p>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?db=mydb' --data-binary 'cpu_load_short,host=server02 value=0.67
cpu_load_short,host=server02,region=us-west value=0.55 1422568543702900257
cpu_load_short,direction=in,host=server01,region=us-west value=2.0 1422568543702900257'
</code></pre>
<h3 id="从文件写入points"><a class="header" href="#从文件写入points">从文件写入Points</a></h3>
<p>通过传递<code>@filename</code>到文件来写入文件中的数据</p>
<p>格式正确的文件（<code>cpu_data.txt</code>）的示例：</p>
<pre><code class="language-txt">cpu_load_short,host=server02 value=0.67
cpu_load_short,host=server02,region=us-west value=0.55 1422568543702900257
cpu_load_short,direction=in,host=server01,region=us-west value=2.0 1422568543702900257
</code></pre>
<p>写入数据cpu_data.txt到mydb与数据库</p>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?db=mydb' --data-binary @cpu_data.txt
</code></pre>
<blockquote>
<p>注意：如果您的数据文件具有超过5000个Points，则可能有必要将该文件拆分为多个文件，以便将数据批量写入cnosdb，默认情况下，HTTP请求在五秒后超时，超时后，cnosdb仍然将尝试写入这些点，但是不会确认它们已经成功写入</p>
</blockquote>
<h3 id="no-schame设计"><a class="header" href="#no-schame设计">No Schame设计</a></h3>
<p>CnosDB是<code>schemaless</code> 数据库.
可以随时添加新的<code>measurement</code>, <code>tag</code>, 和<code>field</code></p>
<h3 id="http-响应摘要"><a class="header" href="#http-响应摘要">HTTP 响应摘要</a></h3>
<ul>
<li>2xx: 如果收到写请求<code>HTTP 204 No Content</code>,</li>
<li>4xx: CnosDB 无法处理该请求</li>
<li>5xx: 系统过载或严重损坏</li>
</ul>
<h4 id="例子"><a class="header" href="#例子">例子</a></h4>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?db=hamlet' --data-binary 'tobeornottobe booleanonly=true'

curl -i -XPOST 'http://localhost:8086/write?db=hamlet' --data-binary 'tobeornottobe booleanonly=5'
</code></pre>
<p>返回内容：</p>
<pre><code class="language-bash">HTTP/1.1 400 Bad Request
Content-Type: application/json
Request-Id: [...]
X-cnosdb-Version: 1.4.x
Date: Wed, 01 Mar 2017 19:38:01 GMT
Content-Length: 150

{&quot;error&quot;:&quot;field type conflict: input field \&quot;booleanonly\&quot; on measurement \&quot;tobeornottobe\&quot; is type float, already exists as type boolean dropped=1&quot;}
</code></pre>
<h5 id="将point写入不存在的数据库"><a class="header" href="#将point写入不存在的数据库">将<code>Point</code>写入不存在的数据库</a></h5>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?db=atlantis' --data-binary 'liters value=10'
</code></pre>
<p>返回内容:</p>
<pre><code class="language-bash">HTTP/1.1 404 Not Found
Content-Type: application/json
Request-Id: [...]
X-cnosdb-Version: 1.4.x
Date: Wed, 01 Mar 2017 19:38:35 GMT
Content-Length: 45

{&quot;error&quot;:&quot;database not found: \&quot;atlantis\&quot;&quot;}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="http查询"><a class="header" href="#http查询">HTTP查询</a></h1>
<p>要执行<code>CnosQL</code>查询，请向<code>/query</code>端点发送GET请求，将URL参数设置<code>db</code>为目标数据库，然后将URL参数设置<code>q</code>为查询，也可<code>POST</code>通过发送与URL参数相同或作为正文一部分参数来使用请求<code>application/x-www-form-urlencoded</code>.</p>
<pre><code class="language-bash">curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode &quot;db=mydb&quot; --data-urlencode &quot;q=SELECT \&quot;value\&quot; FROM \&quot;cpu_load_short\&quot; WHERE \&quot;region\&quot;='us-west'&quot;
</code></pre>
<p>CnosDB 返回 JSON:</p>
<pre><code class="language-json">{
    &quot;results&quot;: [
        {
            &quot;statement_id&quot;: 0,
            &quot;series&quot;: [
                {
                    &quot;name&quot;: &quot;cpu_load_short&quot;,
                    &quot;columns&quot;: [
                        &quot;time&quot;,
                        &quot;value&quot;
                    ],
                    &quot;values&quot;: [
                        [
                            &quot;2015-01-29T21:55:43.702900257Z&quot;,
                            2
                        ],
                        [
                            &quot;2015-01-29T21:55:43.702900257Z&quot;,
                            0.55
                        ],
                        [
                            &quot;2015-06-11T20:46:02Z&quot;,
                            0.64
                        ]
                    ]
                }
            ]
        }
    ]
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> 附加<code>pretty=true</code>到URL会启用精美打印的JSON输出，虽然这对于调试或在使用诸如之类的工具直接查询很有用<code>curl</code>，但不建议用于生产环境，因为会消耗很多不必须要的网络带宽</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb_inspect"><a class="header" href="#cnosdb_inspect">cnosdb_inspect</a></h1>
<h2 id="cnosdb_inspect-工具"><a class="header" href="#cnosdb_inspect-工具">cnosdb_inspect 工具</a></h2>
<blockquote>
<p>CnosDB Inspect 是一个 CnosDB 磁盘实用程序，可用于：</p>
<p>1.查看有关磁盘分片的详细信息。</p>
<p>2.将数据从分片导出到可以插入回数据库的InfluxDB 线路协议。</p>
<p>3.将 TSM 索引分片转换为 TSI 索引分片。</p>
</blockquote>
<p><strong>语法</strong></p>
<pre><code>cnosdb_inspect [ [ command ] [ options ] ]
</code></pre>
<ul>
<li><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html#deletetsm">deletetsm</a></li>
<li><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html#dumptsm">dumptsm</a></li>
<li><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html#dumptsmwal">dumptsmwal</a></li>
<li><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html#report-disk">report-disk</a></li>
<li><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html#verify">verify</a></li>
<li><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html#verify-seriesfile">verify-seriesfile</a></li>
<li><a href="content/cnosdb/0.10/guide/cnosdb_inspect.html#export">export</a></li>
</ul>
<h1 id="deletetsm"><a class="header" href="#deletetsm"><code>deletetsm</code></a></h1>
<h2 id="cnosdb_inspect-deletetsm"><a class="header" href="#cnosdb_inspect-deletetsm"><code>cnosdb_inspect deletetsm</code></a></h2>
<p>批量从原始 <code>TSM</code> 文件中删除<code>measurement</code>数据</p>
<h3 id="警告"><a class="header" href="#警告"><code>警告</code></a></h3>
<p>仅当您的<code>CnosDB</code>离线（<code>CnosDB</code>服务未运行） 时才使用<code>deletetsm</code>。</p>
<h3 id="语法"><a class="header" href="#语法"><code>语法</code></a></h3>
<pre><code>cnosdb_inspect deletetsm --measurement &lt;measurement_name&gt; [ arguments ] &lt;path&gt;
</code></pre>
<p><code>&lt;path&gt;</code></p>
<p>文件的路径<code>.tsm</code>，默认位于<code>data</code>目录中。</p>
<p>指定路径时，通配符 (<code>*</code>) 可以替换一个或多个字符。</p>
<h3 id="选项"><a class="header" href="#选项"><code>选项</code></a></h3>
<p>可选参数在括号中</p>
<p><code>--measurement</code></p>
<p>要从 TSM 文件中删除的<code>measurement</code>的名称。</p>
<p><code>[ --sanitize]</code></p>
<p>标记以删除包含不可打印的 <code>Unicode </code>字符的所有键。</p>
<p><code>[--v]</code></p>
<p>标记以启用详细日志记录。</p>
<h3 id="例子-1"><a class="header" href="#例子-1"><code>例子</code></a></h3>
<p>从单个<code>shard</code>中删除一个<code>measurement</code></p>
<pre><code>./cnosdb_inspect deletetsm --sanitize /cnosdb/data/location/autogen/1384/*.tsm
</code></pre>
<p>从数据库中的所有<code>shard</code>中删除<code>measurement</code></p>
<pre><code>./cnosdb_inspect deletetsm --sanitize /cnosdb/data/location/autogen/*/*.tsm
</code></pre>
<h1 id="dumptsm"><a class="header" href="#dumptsm"><code>dumptsm</code></a></h1>
<h2 id="cnosdb_inspect-dumptsm"><a class="header" href="#cnosdb_inspect-dumptsm"><code>cnosdb_inspect dumptsm</code></a></h2>
<p>转储<code>tsm1</code>文件的底层细节，包括<code>TSM</code>文件和<code>WAL</code>文件</p>
<h3 id="语法-1"><a class="header" href="#语法-1"><code>语法</code></a></h3>
<p><code>cnosdb_inspect dumptsm [ options ] &lt;path&gt;</code></p>
<p><code>&lt;path&gt;</code></p>
<p>文件的路径<code>.tsm</code>，默认位于<code>data</code>目录中。</p>
<h3 id="选项-1"><a class="header" href="#选项-1"><code>选项</code></a></h3>
<p>可选参数在括号中</p>
<p><code>[ --index ]</code></p>
<p>用于转储原始索引数据的标志。默认值为<code>false</code>。</p>
<p><code>[ --blocks ]</code></p>
<p>转储原始块数据的标志。默认值为<code>false</code>。</p>
<p><code>[ --all ]</code></p>
<p>标志转储所有数据。注意：这可能会打印很多信息。默认值为<code>false</code>。</p>
<p><code>[ --filter-key &lt;key_name&gt; ]</code></p>
<p>仅显示与此键子字符串匹配的索引数据和块数据。默认值为<code>&quot;&quot;</code>。</p>
<h1 id="dumptsmwal"><a class="header" href="#dumptsmwal"><code>dumptsmwal</code></a></h1>
<h2 id="cnosdb_inspect-dumptsmwal"><a class="header" href="#cnosdb_inspect-dumptsmwal"><code>cnosdb_inspect dumptsmwal</code></a></h2>
<p>仅转储一个或多个 WAL ( <code>.wal</code>) 文件中的所有条目，并排除 TSM ( <code>.tsm</code>) 文件</p>
<h3 id="语法-2"><a class="header" href="#语法-2"><code>语法</code></a></h3>
<pre><code>influx_inspect dumptsmwal [ options ] &lt;wal_dir&gt;
</code></pre>
<h3 id="选项-2"><a class="header" href="#选项-2"><code>选项</code></a></h3>
<p>可选参数在括号中</p>
<p><code>[ --show-duplicates]</code></p>
<p>标记以显示具有重复或无序<code>timestamp</code>的<code>key</code>。如果用户使用客户端设置的<code>timestamp</code>写入点，则可以写入具有相同<code>timestamp</code>（或具有时间降序<code>timestamp</code>）的多个点。</p>
<h1 id="report-disk"><a class="header" href="#report-disk"><code>report-disk</code></a></h1>
<h2 id="cnosdb_inspect-report-disk"><a class="header" href="#cnosdb_inspect-report-disk"><code>cnosdb_inspect report-disk</code></a></h2>
<p>显示所有<code>shard</code>的系列元数据。默认位置是<code>$HOME/.cnosdb</code>。</p>
<h3 id="语法-3"><a class="header" href="#语法-3"><code>语法</code></a></h3>
<p><code>cnosdb_inspect report-disk [ options ]</code></p>
<h3 id="选项-3"><a class="header" href="#选项-3"><code>选项</code></a></h3>
<p>可选参数在括号中</p>
<p><code>[ --pattern &quot;&lt;regular expression/wildcard&gt;&quot;]</code></p>
<p>匹配包含文件的正则表达式或通配符模式。默认值为<code>&quot;&quot;</code>。</p>
<p><code>[ --detailed]</code></p>
<p>报告详细基数估计的标志。默认值为<code>false</code>。</p>
<p><code>[ --exact]</code></p>
<p>报告确切基数而不是估计值的标志。默认值为<code>false</code>。注意：这会占用大量内存。</p>
<h1 id="verify"><a class="header" href="#verify"><code>verify</code></a></h1>
<h2 id="cnosdb_inspect-verify"><a class="header" href="#cnosdb_inspect-verify"><code>cnosdb_inspect verify</code></a></h2>
<p>验证 <code>TSM</code>文件的完整性。</p>
<h3 id="语法-4"><a class="header" href="#语法-4"><code>语法</code></a></h3>
<p><code>cnosdb_inspect verify [ options ]</code></p>
<h3 id="选项-4"><a class="header" href="#选项-4"><code>选项</code></a></h3>
<p>可选参数在括号中</p>
<p><code>--dir &lt;storage_root&gt;</code>
存储根目录的路径。默认值为&quot;<code>/root/.cnosdb</code>&quot;.</p>
<h1 id="verify-seriesfile"><a class="header" href="#verify-seriesfile"><code>verify-seriesfile</code></a></h1>
<h2 id="cnosdb_inspect-verify-seriesfile"><a class="header" href="#cnosdb_inspect-verify-seriesfile"><code>cnosdb_inspect verify-seriesfile</code></a></h2>
<p>验证 <code>series</code>文件的完整性。</p>
<h3 id="语法-5"><a class="header" href="#语法-5"><code>语法</code></a></h3>
<p><code>cnosdb_inspect verify-series [ options ]</code></p>
<h3 id="选项-5"><a class="header" href="#选项-5"><code>选项</code></a></h3>
<p>可选参数在括号中</p>
<p><code>[ --c &lt;number&gt;]</code></p>
<p>指定要为此命令运行的并发工作人员的数量。默认值等于 GOMAXPROCS 的值。如果性能受到不利影响，您可以设置一个较低的值。</p>
<p><code>[ --dir &lt;path&gt;]</code></p>
<p>指定根数据路径。默认为<code>~/.cnosdb/data</code>.</p>
<p><code>[ --db &lt;db_name&gt;]</code></p>
<p>将验证系列文件限制为数据目录中的指定数据库。</p>
<p><code>[ --series-file &lt;path&gt;]</code></p>
<p>特定系列文件的路径；覆盖-<code>db</code>和<code>-dir</code>.</p>
<p><code>[ --v]</code></p>
<p>启用详细日志记录。</p>
<h1 id="export"><a class="header" href="#export"><code>export</code></a></h1>
<h2 id="cnosdb_inspect-export"><a class="header" href="#cnosdb_inspect-export"><code>cnosdb_inspect export</code></a></h2>
<p>以 <code>CnosDB</code> 线路协议数据格式导出所有 <code>TSM</code> 文件。为所有 <code>WAL</code> 文件写入数据<code>_internal/monitor</code>。可以使用<code>cnosdb</code>命令导入此输出文件。</p>
<h3 id="语法-6"><a class="header" href="#语法-6"><code>语法</code></a></h3>
<p><code>cnosdb_inspect export [ options ]</code></p>
<h3 id="选项-6"><a class="header" href="#选项-6"><code>选项</code></a></h3>
<p>可选参数在括号中</p>
<p><code>[ --compress]</code></p>
<p>使用 gzip 压缩来压缩输出的标志。默认值为<code>false</code>。</p>
<p><code>[ --database &lt;db_name&gt;]</code></p>
<p>要导出的数据库的名称。默认值为<code>&quot;&quot;</code>.</p>
<p><code>--datadir &lt;data_dir&gt;</code></p>
<p>目录的路径<code>data</code>。默认值为&quot;<code>$HOME/.influxdb/data</code>&quot;。</p>
<p><code>[ --end &lt;timestamp&gt;]</code></p>
<p>时间范围结束的时间戳。必须是<code>RFC3339</code>格式。</p>
<p><code>RFC3339</code>需要非常具体的格式。例如，要指示没有时区偏移 (UTC+0)，您必须在秒后包含 Z 或 +00:00。有效<code>RFC3339</code>格式的示例包括：</p>
<h4 id="无偏移"><a class="header" href="#无偏移"><code>无偏移</code></a></h4>
<blockquote>
<p>YYYY-MM-DDTHH:MM:SS+00:00</p>
<p>YYYY-MM-DDTHH:MM:SSZ</p>
<p>YYYY-MM-DDTHH:MM:SS.nnnnnnZ (fractional seconds (.nnnnnn) are optional)</p>
</blockquote>
<h4 id="带偏移"><a class="header" href="#带偏移"><code>带偏移</code></a></h4>
<blockquote>
<p>YYYY-MM-DDTHH:MM:SS-08:00</p>
<p>YYYY-MM-DDTHH:MM:SS+07:00</p>
</blockquote>
<p><code>[ --out &lt;export_dir&gt;]</code>
导出文件的位置。默认值为&quot;<code>$HOME/.cnosdb/export</code>&quot;。</p>
<p><code>[ --retention &lt;rp_name&gt; ]</code>
要导出的保留策略的名称。默认值为<code>&quot;&quot;</code>。</p>
<p><code>[ --start &lt;timestamp&gt;]</code>
时间范围开始的时间戳。时间戳字符串必须采用<code>RFC3339 </code>格式。</p>
<p><code>[ --waldir &lt;wal_dir&gt;]</code>
<code>WAL</code>目录的路径。默认值为&quot;<code>$HOME/.cnosdb/wal</code>&quot;。</p>
<h3 id="例子-2"><a class="header" href="#例子-2"><code>例子</code></a></h3>
<p>导出所有数据库并压缩输出</p>
<p><code>cnosdb_inspect export --compress</code></p>
<p>从特定数据库和保留策略中导出数据</p>
<p><code>cnosdb_inspect export --database mydb -retention autogen</code></p>
<p>输出文件</p>
<pre><code class="language-#DDL">CREATE DATABASE MY_DB_NAME

CREATE RETENTION POLICY autogen ON MY_DB_NAME DURATION inf REPLICATION 1

# DML

# CONTEXT-DATABASE:MY_DB_NAME

# CONTEXT-RETENTION-POLICY:autogen

randset value=97.9296104805 1439856000000000000

randset value=25.3849066842 1439856100000000000
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosql"><a class="header" href="#cnosql">CnosQL</a></h1>
<blockquote>
<p>CnosQL 使用说明</p>
</blockquote>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/./ddl.html">DDL</a></li>
<li><a href="content/cnosdb/0.10/cnosql/./dml.html">DML</a></li>
<li><a href="content/cnosdb/0.10/cnosql/./function.html">函数</a></li>
<li><a href="content/cnosdb/0.10/cnosql/./countine_query.html">连续查询</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ddl"><a class="header" href="#ddl">DDL</a></h1>
<p>CnosQL提供了一整套DDL（数据定义语言）</p>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86">数据库管理</a></th><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">CREATE DATABASE</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93">SHOW DATABASES</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">DROP DATABASE</a></td></tr>
<tr><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%98%BE%E7%A4%BAseries">SHOW SERIES</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E4%BD%BF%E7%94%A8drop%E5%88%A0%E9%99%A4series">DROP SERIES</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E4%BD%BF%E7%94%A8delete%E5%88%A0%E9%99%A4series">DELETE</a></td></tr>
<tr><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%98%BE%E7%A4%BAmeasurement">SHOW MEASUREMENTS</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E5%88%A0%E9%99%A4measurement">DROP MEASUREMENT</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%98%BE%E7%A4%BAtag-key">SHOW TAG KEYS</a></td></tr>
<tr><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%98%BE%E7%A4%BAtag-value">SHOW TAG VALUES</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%98%BE%E7%A4%BAfield-key">SHOW FIELD KEYS</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%8C%89%E6%97%B6%E9%97%B4%E8%BF%87%E6%BB%A4">按时间过滤</a></td></tr>
<tr><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E5%88%A0%E9%99%A4%E5%88%86%E7%89%87">DROP SHARD</a></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5%E7%AE%A1%E7%90%86"><strong>保留策略管理</strong></a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E5%88%9B%E5%BB%BA%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">CREATE RETENTION POLICY</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E6%98%BE%E7%A4%BA%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">SHOW RETENTION POLICIES</a></td><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E4%BF%AE%E6%94%B9%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">ALTER RETENTION POLICY</a></td></tr>
<tr><td style="text-align: center"><a href="content/cnosdb/0.10/cnosql/ddl.html#%E5%88%A0%E9%99%A4%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">DROP RETENTION POLICY</a></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
<h2 id="数据库管理"><a class="header" href="#数据库管理">数据库管理</a></h2>
<h3 id="创建数据库"><a class="header" href="#创建数据库">创建数据库</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE DATABASE &lt;database_name&gt; [WITH [DURATION &lt;duration&gt;] [REPLICATION &lt;n&gt;] [SHARD DURATION &lt;duration&gt;] [NAME &lt;rp-name&gt;]]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>CREATE DATABASE</code>需要一个数据库名称，其他都为可选项。如果未在<code>WITH</code>后面指定保留策略，则会创建一个默认的保留策略，名称为<code>autogen。</code></p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>NAME</code>指定保留策略名称。</p>
<p><code>CREATE DATABASE</code>成功执行后不会返回任何结果。</p>
<p><strong>示例</strong></p>
<p>创建数据库</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，CnosDB还会在其下创建一个名为<code>autogen</code>的保留策略。</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE DATABASE &quot;cnos&quot;
&gt;
</code></pre>
<p>创建数据库并指定保留策略</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，并指定保留策略为<code>1d_events</code>，它的生命周期为总保留时长为一天，副本数为1，每个分片的的窗口长度为一小时。</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE DATABASE &quot;cnos&quot; WITH DURATION 1d REPLICATION 1 SHARD DURATION 1h NAME &quot;1d_events&quot;
</code></pre>
<h3 id="显示数据库"><a class="header" href="#显示数据库">显示数据库</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW DATABASES
</code></pre>
<h3 id="删除数据库"><a class="header" href="#删除数据库">删除数据库</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP DATABASE &lt;database_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP DATABASE</code>会删除数据库下所有数据。</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP DATABASE &quot;cnos&quot;
</code></pre>
<h3 id="显示series"><a class="header" href="#显示series">显示<code>SERIES</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW SERIES [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; [ '&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW SERIES</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW SERIES ON &quot;cnos&quot; WHERE time &gt; now() - 1m LIMIT 10
</code></pre>
<h3 id="使用drop删除series"><a class="header" href="#使用drop删除series">使用<code>DROP</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SERIES FROM &lt;measurement_name[,measurement_name]&gt; WHERE &lt;tag_key&gt;='&lt;tag_value&gt;'
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据以及数据所对应的索引</p>
<p><strong>示例</strong></p>
<p>从一个<code>measurement</code>中删除所有<code>series</code></p>
<pre><code class="language-sql">&gt; DROP SERIES FROM &quot;cpu&quot;
</code></pre>
<p>从一个<code>measurement</code>中删除具有特定条件的<code>series</code></p>
<pre><code class="language-sql">DROP SERIES FROM &quot;cpu&quot; WHERE &quot;region&quot; = 'Shanghai'
</code></pre>
<h3 id="使用delete删除series"><a class="header" href="#使用delete删除series">使用<code>DELETE</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DELETE FROM &lt;measurement_name&gt; WHERE [&lt;tag_key&gt;='&lt;tag_value&gt;'] | [&lt;time interval&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据，但是不会删除索引，并且支持时间过滤</p>
<p><strong>示例</strong></p>
<blockquote>
<p>删除2020-01-01之前产生的的所有数据</p>
</blockquote>
<pre><code class="language-sql">&gt; DELETE WHERE time &lt; '2021-01-01'
</code></pre>
<h3 id="显示measurement"><a class="header" href="#显示measurement">显示<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW MEASUREMENTS [ON &lt;database_name&gt;] [WITH MEASUREMENT &lt;operator&gt; ['&lt;measurement_name&gt;' | &lt;regular_expression&gt;]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><code>SHOW MEASUREMENTS</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<blockquote>
<p>该查询返回数据库<code>cnos</code>下<code>tag key</code>host下的<code>tag value</code>的值中包含一个整数</p>
</blockquote>
<pre><code class="language-sql">SHOW MEASUREMENTS ON &quot;cnos&quot; WITH MEASUREMENT =~ /h2o.*/ WHERE &quot;host&quot;  =~ /\d/
</code></pre>
<h3 id="删除measurement"><a class="header" href="#删除measurement">删除<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &lt;measurement_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP MEASUREMENT</code>会删除指定<code>measurement</code>下所有的数据</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &quot;cpu&quot;
</code></pre>
<h3 id="显示tag-key"><a class="header" href="#显示tag-key">显示<code>tag key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW tag keys</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON &quot;cnos&quot; FROM &quot;cpu&quot; LIMIT 1 OFFSET 1
</code></pre>
<h3 id="显示tag-value"><a class="header" href="#显示tag-value">显示<code>tag value</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW TAG VALUES [ON &lt;database_name&gt;][FROM_clause] WITH KEY [ [&lt;operator&gt; &quot;&lt;tag_key&gt;&quot; | &lt;regular_expression&gt;] | [IN (&quot;&lt;tag_key1&gt;&quot;,&quot;&lt;tag_key2&quot;)]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG VALUES ON &quot;cnos&quot; WITH KEY IN (&quot;region&quot;,&quot;host&quot;) WHERE &quot;host&quot; =~ /./ LIMIT 3
</code></pre>
<h3 id="显示field-key"><a class="header" href="#显示field-key">显示<code>field key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS [ON &lt;database_name&gt;] [FROM &lt;measurement_name&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>FROM</code>子句为可选项</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS ON &quot;cnos&quot; FROM &quot;cpu&quot;
</code></pre>
<h3 id="按时间过滤"><a class="header" href="#按时间过滤">按时间过滤</a></h3>
<blockquote>
<p>可以在<code>SHOW TAG KEYS</code>、<code>SHOW TAG VALUES</code> <code>SHOW SERIES</code> <code>SHOW MEASUREMENTS</code> <code>SHOW FIELD KEYS</code>上使用</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON cnos where time &gt; now() -1h and time &lt; now()
</code></pre>
<h3 id="删除分片"><a class="header" href="#删除分片">删除分片</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SHARD &lt;shard_id_number&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SHARD</code>会在磁盘上删除有关分片的所有数据以及元数据</p>
<pre><code class="language-sql">&gt; DROP SHARD 1
&gt;
</code></pre>
<h2 id="保留策略管理"><a class="header" href="#保留策略管理">保留策略管理</a></h2>
<h3 id="创建保留策略"><a class="header" href="#创建保留策略">创建保留策略</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; [SHARD DURATION &lt;duration&gt;] [DEFAULT]
</code></pre>
<p><strong>描述</strong></p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>DEFAULT</code>可选项，指定其是否为默认保留策略</p>
<p><strong>示例</strong></p>
<p>创建保留策略</p>
<blockquote>
<p>该语句创建了一个名为<code>1d_events</code>的保留策略，并且副本数为1</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 1d REPLICATION 1
&gt;
</code></pre>
<p>创建默认保留策略</p>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 23h60m REPLICATION 1 DEFAULT
&gt;
</code></pre>
<h3 id="显示保留策略"><a class="header" href="#显示保留策略">显示保留策略</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW RETENTION POLICIES [ON &lt;database_name&gt;]
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">&gt; SHOW RETENTION POLICIES ON &quot;cnos&quot;

name      duration   shardGroupDuration   replicaN   default
----      --------   ------------------   --------   -------
autogen   0s         168h0m0s             1          true
</code></pre>
<h3 id="修改保留策略"><a class="header" href="#修改保留策略">修改保留策略</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; SHARD DURATION &lt;duration&gt; DEFAULT
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 7 SHARD DURATION 1d DEFAULT
</code></pre>
<h3 id="删除保留策略"><a class="header" href="#删除保留策略">删除保留策略</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt;
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">&gt; DROP RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot;
&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="dml"><a class="header" href="#dml">DML</a></h1>
<table><thead><tr><th>基础</th><th>查询结果限制</th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/0.10/cnosql/dml.html#insert">INSERT</a></td><td><a href="content/cnosdb/0.10/cnosql/dml.html#order-by-time-desc">ORDER BY time DESC</a></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/dml.html#insert-into">INSERT INTO</a></td><td><a href="content/cnosdb/0.10/cnosql/dml.html#limit-%E5%92%8C-slimit">LIMIT 和 SLIMIT</a></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/dml.html#select">SELECT</a></td><td><a href="content/cnosdb/0.10/cnosql/dml.html#offset-%E5%92%8C-soffset">OFFSET 和 SOFFSET</a></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/dml.html#where">WHERE</a></td><td><a href="content/cnosdb/0.10/cnosql/dml.html#%E6%97%B6%E5%8C%BA">时区</a></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/dml.html#group-by">GROUP BY</a></td><td></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/dml.html#into">INTO</a></td><td></td></tr>
</tbody></table>
<h2 id="insert"><a class="header" href="#insert">INSERT</a></h2>
<p><strong>语法</strong></p>
<blockquote>
<p>需要在<code>cnos</code>中<code>USE &lt;database&gt;</code>后执行<code>INSERT</code></p>
</blockquote>
<pre><code class="language-sql">INSERT &lt;measurement_name&gt; &lt;&quot;tag_key1=tag_value1&quot;,&quot;tag_key2=tag_value2&quot;&gt; &lt;&quot;field_key1=field_value1&quot;,&quot;field_key2=field_value2&quot;&gt; [timestamp]
</code></pre>
<p><strong>示例</strong></p>
<blockquote>
<p>以下语句将数据写入到默认保留策略中</p>
</blockquote>
<pre><code class="language-sql">INSERT cpu,host=cnosdb-data-01 usage_idle=87
</code></pre>
<h2 id="insert-into"><a class="header" href="#insert-into">INSERT INTO</a></h2>
<p><strong>语法</strong></p>
<blockquote>
<p>需要在<code>cnos</code>中<code>USE &lt;database&gt;</code>后执行<code>INSERT</code></p>
</blockquote>
<pre><code class="language-sql">INSERT INTO &lt;rp&gt; &lt;measurement_name&gt; &lt;&quot;tag_key1=tag_value1&quot;,&quot;tag_key2=tag_value2&quot;&gt; &lt;&quot;field_key1=field_value1&quot;,&quot;field_key2=field_value2&quot;&gt; [timestamp]
</code></pre>
<p><strong>示例</strong></p>
<blockquote>
<p>以下语句将数据写入到保留策略<code>1d_events</code>中</p>
</blockquote>
<pre><code>INSERT INTO 1d_events cpu,host=cnosdb-data-01 usage_idle=87
</code></pre>
<h2 id="select"><a class="header" href="#select">SELECT</a></h2>
<blockquote>
<p><code>SELECT</code>从一个或多个<code>measurement</code>中查询数据</p>
</blockquote>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT &lt;field_key&gt;[,&lt;field_key&gt;,&lt;tag_key&gt;] FROM &lt;measurement_name&gt;[,&lt;measurement_name&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SELECT</code>语句需要和<code>FROM</code>语句配合使用</p>
<p><code>SELECT *</code>返回所有<code>tag</code>和<code>field</code></p>
<p><code>SELECT &quot;&lt;field_key&gt;&quot;</code>返回一个特定的<code>field</code></p>
<p><code>SELECT &quot;&lt;field_key&gt;&quot;,&quot;&lt;field_key&gt;&quot;</code>返回多个<code>field</code></p>
<p><code>SELECT &quot;&lt;field_key&gt;&quot;,&quot;&lt;tag_key&gt;&quot;</code>返回特定的<code>tag</code>和<code>field</code>，当包含标签时，至少指定一个<code>field</code></p>
<p><code>SELECT &quot;&lt;field_key&gt;&quot;::field,&quot;&lt;tag_key&gt;&quot;::tag</code>返回特定的<code>tag</code>和<code>field</code>，<code>::[field | tag]</code>用来区分相同名称的<code>tag</code>和<code>field</code></p>
<h2 id="from"><a class="header" href="#from">FROM</a></h2>
<blockquote>
<p><code>FROM</code>支持指定<code>measurement</code>的格式</p>
</blockquote>
<p><strong>语法</strong></p>
<pre><code class="language-sql">FROM [&lt;database_name&gt;.&lt;rp_name&gt;. | &lt;database_name&gt;..]&lt;measurement_name&gt;,&lt;measurement_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>FROM &lt;measurement_name&gt;</code>返回一个<code>measurement</code>中的数据</p>
<p><code>FROM &lt;measurement_name&gt;,&lt;measurement_name&gt;</code>返回多个<code>measurement</code>中的数据</p>
<p><code>FROM &lt;database_name&gt;.&lt;rp_name&gt;.&lt;measurement_name&gt;</code>指定数据库、保留策略中返回具体<code>measurement</code>中的数据</p>
<p><code>FROM &lt;database_name&gt;..&lt;measurement_name&gt;</code>从指定的数据库的<code>measurement</code>中返回数据</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT * FROM &quot;cnos&quot;
SELECT &quot;host&quot;,&quot;region&quot;,&quot;usage_idle&quot; FROM &quot;cpu&quot;
SELECT &quot;usage_idle&quot;::field,&quot;region&quot;::tag,&quot;usage_idle&quot;::field FROM &quot;cpu&quot;
SELECT *::field FROM &quot;cpu&quot;
SELECT (&quot;usage_idle&quot; * 2) + 4 FROM &quot;cpu&quot;
SELECT * FROM &quot;cpu&quot;,&quot;disk&quot;
SELECT * FROM &quot;cnos&quot;.&quot;autogen&quot;.&quot;cpu&quot;
SELECT * FROM &quot;cnos&quot;..&quot;cpu&quot;
</code></pre>
<h2 id="where"><a class="header" href="#where">WHERE</a></h2>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause FROM_clause WHERE &lt;conditional_expression&gt; [(AND|OR) &lt;conditional_expression&gt; [...]]
</code></pre>
<blockquote>
<p>CnosDB不支持在<code>WHERE</code>子句中使用<code>OR</code>来指定多个时间范围</p>
</blockquote>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT * FROM &quot;cpu&quot; WHERE &quot;usage_idle&quot; &gt; 8
SELECT * FROM &quot;cpu&quot; WHERE &quot;usage_idle&quot; + 2 &gt; 11.9
SELECT &quot;region&quot; FROM &quot;cpu&quot; WHERE &quot;region&quot; = 'Shanghai'
SELECT &quot;location&quot; FROM &quot;cpu&quot; WHERE &quot;region&quot; &lt;&gt; 'Shanghai' AND (usage_idle &lt; -0.59 OR water_level &gt; 9.95)
SELECT * FROM &quot;cpu&quot; WHERE time &gt; now() - 7d
</code></pre>
<h2 id="group-by"><a class="header" href="#group-by">GROUP BY</a></h2>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause FROM_clause [WHERE_clause] GROUP BY [* | &lt;tag_key&gt;[,&lt;tag_key]]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>GROUP BY *</code>按所有<code>tag</code>分组</p>
<p><code>GROUP BY &lt;tag_key&gt;</code>按指定<code>tag</code>分组</p>
<p><code>GROUP BY &lt;tag_key&gt;,&lt;tag_key&gt;</code>按多个<code>tag</code>分组</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT MEAN(&quot;usage_idle&quot;) FROM &quot;cpu&quot; GROUP BY &quot;host&quot;
SELECT MEAN(&quot;usage_idle&quot;) FROM &quot;cpu&quot; GROUP BY &quot;host&quot;,&quot;region&quot;
SELECT MEAN(&quot;usage_idle&quot;) FROM &quot;cpu&quot; GROUP BY *
</code></pre>
<h2 id="按时间间隔分组"><a class="header" href="#按时间间隔分组">按时间间隔分组</a></h2>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT &lt;function&gt;(&lt;field_key&gt;) FROM_clause WHERE &lt;time_range&gt; GROUP BY time(&lt;time_interval&gt;),[tag_key] [fill(&lt;fill_option&gt;)]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>GROUP BY &lt;time(time_interval)&gt;</code>按时间分组，支持的单位为：<code>u</code>,<code>ns</code>,<code>ms</code>,<code>s</code>,<code>m</code>,<code>h</code>,<code>d</code></p>
<p><code>fill(&lt;fill_option&gt;)</code>是可选项，可以对缺失值进行填充</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT &quot;host&quot;,&quot;usage_idle&quot; FROM &quot;cpu&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'
SELECT COUNT(&quot;usage_idle&quot;) FROM &quot;cpu&quot; WHERE &quot;region&quot;='Shanghai' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)
SELECT COUNT(&quot;usage_idle&quot;) FROM &quot;cpu&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m),&quot;host&quot;
</code></pre>
<h2 id="into"><a class="header" href="#into">INTO</a></h2>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause INTO &lt;measurement_name&gt; FROM_clause [WHERE_clause] [GROUP_BY_clause]
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql"># 重命名数据库
SELECT * INTO &quot;copy_cnos&quot;.&quot;autogen&quot;.:MEASUREMENT FROM &quot;cnos&quot;.&quot;autogen&quot;./.*/ GROUP BY *
# 将查询结果写入指定measurement
&gt; SELECT &quot;usage_idle&quot; INTO &quot;cnos_copy&quot; FROM &quot;cpu&quot; WHERE &quot;region&quot; = 'Shanghai'
# 下采样数据
SELECT MEAN(&quot;usage_idle&quot;) INTO &quot;usage_idle_30d&quot; FROM &quot;cpu&quot; WHERE &quot;region&quot; = 'Shanghai' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)
</code></pre>
<h2 id="order-by-time-desc"><a class="header" href="#order-by-time-desc">ORDER BY time DESC</a></h2>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] ORDER BY time DESC
</code></pre>
<p><strong>语法描述</strong></p>
<p>如果查询语句中包含<code>GROUP BY</code>，那么<code>ORDER BY time DESC</code>必须放在<code>GROUP BY</code>后面。如果查询语句中包含<code>WHERE</code>并且没有<code>GROUP BY</code>，那么<code>ORDER BY time DESC</code>必须放在<code>WHERE</code>后面。</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT &quot;usage_idle&quot; FROM &quot;cpu&quot; WHERE &quot;region&quot; = 'Shanghai' ORDER BY time DESC
SELECT MEAN(&quot;usage&quot;) FROM &quot;cpu&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:42:00Z' GROUP BY time(12m) ORDER BY time DESC
</code></pre>
<h2 id="limit-和-slimit"><a class="header" href="#limit-和-slimit">LIMIT 和 SLIMIT</a></h2>
<blockquote>
<p><code>LIMIT</code>和<code>SLIMIT</code>分别限制每个查询返回的数据条数和<code>series</code>个数。</p>
</blockquote>
<h3 id="limit"><a class="header" href="#limit">LIMIT</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] LIMIT &lt;N&gt;
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT &quot;usage_idle&quot;,&quot;region&quot; FROM &quot;cpu&quot; LIMIT 3
SELECT MEAN(&quot;usage_idle&quot;) FROM &quot;cpu&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:42:00Z' GROUP BY *,time(12m) LIMIT 2
</code></pre>
<h3 id="slimit"><a class="header" href="#slimit">SLIMIT</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause [INTO_clause] FROM_clause [WHERE_clause] GROUP BY *[,time(&lt;time_interval&gt;)] [ORDER_BY_clause] SLIMIT &lt;N&gt;
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT &quot;usage_idle&quot; FROM &quot;cpu&quot; GROUP BY * SLIMIT 1
SELECT MEAN(&quot;usage_idle&quot;) FROM &quot;cpu&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:42:00Z' GROUP BY *,time(12m) SLIMIT 1
</code></pre>
<h2 id="offset-和-soffset"><a class="header" href="#offset-和-soffset">OFFSET 和 SOFFSET</a></h2>
<blockquote>
<p><code>OFFSET</code>和<code>SOFFSET</code>分别标记数据和<code>series</code>返回的位置。</p>
</blockquote>
<h3 id="offset"><a class="header" href="#offset">OFFSET</a></h3>
<blockquote>
<p><code>OFFSET &lt;N&gt;</code>表示从查询结果中的第<code>N</code>条数据开始返回。</p>
</blockquote>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] LIMIT_clause OFFSET &lt;N&gt; [SLIMIT_clause]
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT &quot;host&quot;,&quot;region&quot; FROM &quot;cpu&quot; LIMIT 3 OFFSET 3
SELECT MEAN(&quot;usage_idle&quot;) FROM &quot;cpu&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:42:00Z' GROUP BY *,time(12m) ORDER BY time DESC LIMIT 2 OFFSET 2 SLIMIT 1
</code></pre>
<h3 id="soffset"><a class="header" href="#soffset">SOFFSET</a></h3>
<blockquote>
<p><code>SOFFSET &lt;N&gt;</code>表示从查询结果中的第<code>N</code>个<code>series</code>开始返回。</p>
</blockquote>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause [INTO_clause] FROM_clause [WHERE_clause] GROUP BY *[,time(time_interval)] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] SLIMIT_clause SOFFSET &lt;N&gt;
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SELECT &quot;usage_idle&quot; FROM &quot;cpu&quot; GROUP BY * SLIMIT 1 SOFFSET 1
SELECT MEAN(&quot;usage_idle&quot;) FROM &quot;cpu&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:42:00Z' GROUP BY *,time(12m) ORDER BY time DESC LIMIT 2 OFFSET 2 SLIMIT 1 SOFFSET 1
</code></pre>
<h2 id="时区"><a class="header" href="#时区">时区</a></h2>
<blockquote>
<p><code>tz()</code>子句返回指定时区的UTC偏移量。</p>
</blockquote>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SELECT_clause [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause] tz('&lt;time_zone&gt;')
</code></pre>
<p><strong>示例</strong></p>
<pre><code>SELECT &quot;usage_idle&quot; FROM &quot;cpu&quot; WHERE &quot;region&quot; = 'Shanghai' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:18:00Z' tz('Asia/Shanghai')
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="函数"><a class="header" href="#函数">函数</a></h1>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count">COUNT()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#distinct">DISTINCT()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#integral">INTEGRAL()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean">MEAN()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median">MEDIAN()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode">MODE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#spread">SPREAD()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#stddev">STDDEV()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum">SUM()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0">选择函数</a>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#bottom">BOTTOM()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first">FIRST()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last">LAST()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max">MAX()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min">MIN()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile">PERCENTILE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sample">SAMPLE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#top">TOP()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">转换函数</a>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#abs">ABS()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#acos">ACOS()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#asin">ASIN()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#atan">ATAN()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#atan2">ATAN2()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#ceil">CEIL()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#cos">COS()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#cumulative-sum">CUMULATIVE_SUM()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#derivative">DERIVATIVE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#difference">DIFFERENCE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#elapsed">ELAPSED()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#exp">EXP()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#floor">FLOOR()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#histogram">HISTOGRAM()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#ln">LN()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#log">LOG()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#log2">LOG2()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#log10">LOG10()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#moving-average">MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#non-negative-derivative">NON_NEGATIVE_DERIVATIVE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#non-negative-difference">NON_NEGATIVE_DIFFERENCE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#pow">POW()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#round">ROUND()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sin">SIN()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sqrt">SQRT()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#tan">TAN()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E9%A2%84%E6%B5%8B%E5%87%BD%E6%95%B0">预测函数</a>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#holt_winters">HOLT_WINTERS()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0">分析函数</a>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#other">其他</a>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE">示例数据</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95">函数的通用语法</a>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E5%9C%A8SELECT%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">在<code>SELECT</code>中指定多个函数</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%AD%97%E6%AE%B5">重命名查询结果字段</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E6%94%B9%E5%8F%98%E4%B8%8D%E5%90%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">改变不含数据的时间间隔的返回值</a></li>
</ul>
</li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">函数常见问题</a></li>
</ul>
</li>
</ul>
<h2 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h2>
<h3 id="count"><a class="header" href="#count">COUNT()</a></h3>
<p>返回非空值 field values数量</p>
<h4 id="语法-7"><a class="header" href="#语法-7">语法</a></h4>
<pre><code class="language-sql">SELECT COUNT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h5 id="嵌套语法"><a class="header" href="#嵌套语法">嵌套语法</a></h5>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<p><code>COUNT(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT()</code>支持所有数据类型的<code>field value</code>。cnosQL支持将<a href="content/cnosdb/0.10/cnosql/function.html#distinct"><code>DISTINCT()</code></a>函数嵌套在<code>COUNT()</code>函数里。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<h5 id="计算指定field-key的field-value的数目"><a class="header" href="#计算指定field-key的field-value的数目">计算指定field key的field value的数目</a></h5>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count
----                   -----
1970-01-01T00:00:00Z   15258
</code></pre>
<p>该查询返回<code>measurement``h2o_feet</code>中的<code>water_level</code>的非空field value的数量。</p>
<h5 id="计数measurement中每个field-key关联的field-value的数量"><a class="header" href="#计数measurement中每个field-key关联的field-value的数量">计数measurement中每个field key关联的field value的数量</a></h5>
<pre><code class="language-sql">&gt; SELECT COUNT(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count_level description   count_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   15258                     15258
</code></pre>
<p>该查询返回与1measurement``h2o_feet<code>相关联的每个field key的非空field value的数量。</code>h2o_feet<code>有两个field keys：</code>level_description<code>和</code>water_level`</p>
<h5 id="计算匹配一个正则表达式的每个field-key关联的field-value的数目"><a class="header" href="#计算匹配一个正则表达式的每个field-key关联的field-value的数目">计算匹配一个正则表达式的每个field key关联的field value的数目</a></h5>
<pre><code class="language-sql">&gt; SELECT COUNT(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count_water_level
----                   -----------------
1970-01-01T00:00:00Z   15258
</code></pre>
<p>该查询返回measurement<code>h2o_feet</code>中包含<code>water</code>单词的每个field key的非空字段值的数量。</p>
<h5 id="计数包括多个子句的field-key的field-value的数目"><a class="header" href="#计数包括多个子句的field-key的field-value的数目">计数包括多个子句的field key的field value的数目</a></h5>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(200) LIMIT 7 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   count
----                   -----
2020-08-17T23:48:00Z   200
2020-08-18T00:00:00Z   2
2020-08-18T00:12:00Z   2
2020-08-18T00:24:00Z   2
2020-08-18T00:36:00Z   2
2020-08-18T00:48:00Z   2
</code></pre>
<p>该查询返回<code>water_level</code>field key中的非空field value的数量。它涵盖<code>2020-08-17T23：48：00Z</code>和<code>2020-08-18T00：54：00Z</code>之间的<code>时间段</code>，并将结果分组为12分钟的时间间隔和每个tag。并用<code>200</code>填充空的时间间隔，并返回7个<code>point</code>，表格返回1。</p>
<h5 id="计算一个field-key的distinct的field-value的数量"><a class="header" href="#计算一个field-key的distinct的field-value的数量">计算一个field key的distinct的field value的数量</a></h5>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;level description&quot;)) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count
----                   -----
1970-01-01T00:00:00Z   4
</code></pre>
<p>查询返回measurement为<code>h2o_feet</code>field<code>为</code>level description 的唯一field value的数量。</p>
<h3 id="count的常见问题"><a class="header" href="#count的常见问题"><code>COUNT()</code>的常见问题</a></h3>
<h4 id="count和fill"><a class="header" href="#count和fill"><code>COUNT()</code>和<code>fill()</code></a></h4>
<p>大多数cnosQL函数对于没有数据的时间间隔返回<code>null</code>值，<code>fill(&lt;fill_option&gt;)</code>将该<code>null</code>值替换为<code>fill_option</code>。 <code>COUNT()</code>针对没有数据的时间间隔返回<code>0</code>，<code>fill(&lt;fill_option&gt;)</code>用<code>fill_option</code>替换0值。</p>
<h5 id="示例-1"><a class="header" href="#示例-1">示例</a></h5>
<p>下面的代码块中的第一个查询不包括<code>fill()</code>。最后一个时间间隔没有数据，因此该时间间隔的值返回为零。第二个查询包括<code>fill(800000)</code>; 它将最后一个间隔中的零替换为<code>800000</code>。</p>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-09-18T21:24:00Z' AND time &lt;= '2020-09-18T21:54:00Z' GROUP BY time(12m)

name: h2o_feet
time                   count
----                   -----
2020-09-18T21:24:00Z   2
2020-09-18T21:36:00Z   2
2020-09-18T21:48:00Z   0

&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-09-18T21:24:00Z' AND time &lt;= '2020-09-18T21:54:00Z' GROUP BY time(12m) fill(800000)

name: h2o_feet
time                   count
----                   -----
2020-09-18T21:24:00Z   2
2020-09-18T21:36:00Z   2
2020-09-18T21:48:00Z   800000
</code></pre>
<h3 id="distinct"><a class="header" href="#distinct"><code>DISTINCT()</code></a></h3>
<p>返回<code>field value</code>的不重复值列表。</p>
<h4 id="语法-8"><a class="header" href="#语法-8">语法</a></h4>
<pre><code class="language-sql">SELECT DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h5 id="嵌套语法-1"><a class="header" href="#嵌套语法-1">嵌套语法</a></h5>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<h5 id="语法描述"><a class="header" href="#语法描述">语法描述</a></h5>
<p><code>DISTINCT(field_key)</code> 返回<code>field key</code>对应的不同<code>field values</code>。</p>
<p><code>DISTINCT()</code> 支持所有数据类型的<code>field value</code>，cnosQL支持<a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a>嵌套<code>DISTINCT()</code>。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<h5 id="列出一个field-key的不同的field-value"><a class="header" href="#列出一个field-key的不同的field-value">列出一个<code>field key</code>的不同的<code>field value</code></a></h5>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   distinct
----                   --------
1970-01-01T00:00:00Z   between 6 and 9 feet
1970-01-01T00:00:00Z   below 3 feet
1970-01-01T00:00:00Z   between 3 and 6 feet
1970-01-01T00:00:00Z   at or greater than 9 feet
</code></pre>
<p>该查询返回<code>h2o_feet</code> measurement中<code>level description</code>filed 关键字中唯一<code>field values</code>的列表</p>
<h5 id="列出一个measurement中每个field-key的不同的值"><a class="header" href="#列出一个measurement中每个field-key的不同的值">列出一个measurement中每个field key的不同的值</a></h5>
<pre><code class="language-sql">&gt; SELECT DISTINCT(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   distinct_level description   distinct_water_level
----                   --------------------------   --------------------
1970-01-01T00:00:00Z   between 6 and 9 feet         8.12
1970-01-01T00:00:00Z   between 3 and 6 feet         8.005
1970-01-01T00:00:00Z   at or greater than 9 feet    7.887
1970-01-01T00:00:00Z   below 3 feet                 7.762
[...]
</code></pre>
<p>查询返回<code>h2o_feet</code>中每个字段的唯一字段值的列表。<code>h2o_feet</code>有两个字段：<code>description</code>和<code>water_level</code>。</p>
<h5 id="列出包含多个子句的field-key关联的不同值的列表"><a class="header" href="#列出包含多个子句的field-key关联的不同值的列表">列出包含多个子句的field key关联的不同值的列表</a></h5>
<pre><code class="language-sql">&gt;  SELECT DISTINCT(&quot;level description&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   distinct
----                   --------
2020-08-18T00:00:00Z   between 6 and 9 feet
2020-08-18T00:12:00Z   between 6 and 9 feet
2020-08-18T00:24:00Z   between 6 and 9 feet
2020-08-18T00:36:00Z   between 6 and 9 feet
2020-08-18T00:48:00Z   between 6 and 9 feet
</code></pre>
<p>该查询返回<code>level description</code>field key中不同field value的列表。它涵盖<code>2020-08-17T23：48：00Z</code>和<code>2020-08-18T00：54：00Z</code>之间的时间段，并将结果按12分钟的时间间隔和每个tag分组。查询限制返回一个series。</p>
<h5 id="对一个字段的不同值进行计算"><a class="header" href="#对一个字段的不同值进行计算">对一个字段的不同值进行计算</a></h5>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;level description&quot;)) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count
----                   -----
1970-01-01T00:00:00Z   4
</code></pre>
<p>查询返回<code>h2o_feet</code>这个measurement中字段<code>level description</code>的不同值的数目。</p>
<h3 id="distinct的常见问题"><a class="header" href="#distinct的常见问题"><code>DISTINCT()</code>的常见问题</a></h3>
<h4 id="distinct-和-into-子句"><a class="header" href="#distinct-和-into-子句"><code>DISTINCT()</code> 和 <code>INTO</code> 子句</a></h4>
<p>在<code>INTO</code>子句中使用<code>DISTINCT()</code>可能会导致cnosDB覆盖目标measurement中的<code>points</code>。<code>DISTINCT()</code>通常返回多个具有相同时间戳的结果；cnosDB假设在相同series中并具有相同时间戳的<code>point</code>是重复<code>point</code>，并简单地用目标measurement中最新的<code>point</code>覆盖重复<code>point</code>。</p>
<h5 id="示例-3"><a class="header" href="#示例-3">示例</a></h5>
<p>下面代码块中的第一个查询使用了<code>DISTINCT()</code>，并返回四个结果。请注意，每个结果都有相同的时间戳。第二个查询将<code>INTO</code>子句添加到查询中，并将查询结果写入measurement <code>distincts</code>。最后一个查询选择measurement <code>distincts</code>中所有数据。
因为原来的四个结果是重复的(它们在相同的series，有相同的时间戳)，所以最后一个查询只返回一个<code>point</code>。当系统遇到重复数据<code>point</code>，它会用最近的<code>point</code>覆盖之前的<code>point</code>。</p>
<pre><code class="language-sql">&gt;  SELECT DISTINCT(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   distinct
----                   --------
1970-01-01T00:00:00Z   below 3 feet
1970-01-01T00:00:00Z   between 6 and 9 feet
1970-01-01T00:00:00Z   between 3 and 6 feet
1970-01-01T00:00:00Z   at or greater than 9 feet

&gt;  SELECT DISTINCT(&quot;level description&quot;) INTO &quot;distincts&quot; FROM &quot;h2o_feet&quot;

name: result
time                   written
----                   -------
1970-01-01T00:00:00Z   4

&gt; SELECT * FROM &quot;distincts&quot;

name: distincts
time                   distinct
----                   --------
1970-01-01T00:00:00Z   at or greater than 9 feet
</code></pre>
<h3 id="integral"><a class="header" href="#integral"><code>INTEGRAL()</code></a></h3>
<p>返回<code>field value</code>曲线下的面积，即关于<code>field value</code>的积分。</p>
<h4 id="语法-9"><a class="header" href="#语法-9">语法</a></h4>
<pre><code>SELECT INTEGRAL( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ]  ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-1"><a class="header" href="#语法描述-1">语法描述</a></h4>
<p>cnosDB计算field value曲线下的面积，并将这些结果转换为每个<code>unit</code>的总面积。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>INTEGRAL(field_key)</code>返回field key关联的值之下的面积。</p>
<p><code>INTEGRAL(/regular_expression/)</code>返回满足正则表达式的每个field key关联的值之下的面积。</p>
<p><code>INTEGRAL(*)</code>返回<code>measurement</code>中每个<code>field key</code>关联的值之下的面积。</p>
<p><code>INTEGRAL()</code>不支持<code>fill()</code>，<code>INTEGRAL()</code>支持int64和float64两个数据类型。</p>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<p>下面的五个例子，使用数据库<a href="content/cnosdb/0.10/cnosql/NOAA_water_database.txt"><code>NOAA_water_database</code>中的数据</a>：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<h5 id="计算指定的field-key的值得积分"><a class="header" href="#计算指定的field-key的值得积分">计算指定的field key的值得积分</a></h5>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral
----                 --------
1970-01-01T00:00:00Z 3732.66
</code></pre>
<p>该查询返回<code>h2o_feet</code>中的字段<code>water_level</code>的曲线下的面积（以秒为单位）。</p>
<h5 id="计算指定的field-key和时间单位的值得积分"><a class="header" href="#计算指定的field-key和时间单位的值得积分">计算指定的field key和时间单位的值得积分</a></h5>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(&quot;water_level&quot;,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral
----                 --------
1970-01-01T00:00:00Z 62.211
</code></pre>
<p>该查询返回<code>h2o_feet</code>中的字段<code>water_level</code>的曲线下的面积（以分钟为单位）。</p>
<h5 id="计算measurement中每个field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中每个field-key在指定时间单位的值得积分">计算measurement中每个field key在指定时间单位的值得积分</a></h5>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(*,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral_water_level
----                 --------------------
1970-01-01T00:00:00Z 62.211
</code></pre>
<p>查询返回measurement<code>h2o_feet</code>中存储的每个数值字段相关的字段值的曲线下面积（以分钟为单位）。 <code>h2o_feet</code>的数值字段为<code>water_level</code>。</p>
<h5 id="计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分">计算measurement中匹配正则表达式的field key在指定时间单位的值得积分</a></h5>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(/water/,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral_water_level
----                 --------------------
1970-01-01T00:00:00Z 62.211
</code></pre>
<p>查询返回field key包括单词<code>water</code>的每个数值类型的字段相关联的字段值的曲线下的区域（以分钟为单位）。</p>
<h5 id="在含有多个子句中计算指定字段的积分"><a class="header" href="#在含有多个子句中计算指定字段的积分">在含有多个子句中计算指定字段的积分</a></h5>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(&quot;water_level&quot;,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m) LIMIT 1

name: h2o_feet
time                 integral
----                 --------
2020-08-18T00:00:00Z 24.972
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的field value曲线下的面积(以分钟为单位)，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并将查询结果按12分钟的时间间隔进行分组，同时，该查询将返回的<code>point</code>个数限制为1。</p>
<h3 id="mean"><a class="header" href="#mean"><code>MEAN()</code></a></h3>
<p>返回field value的平均值。</p>
<h4 id="语法-10"><a class="header" href="#语法-10">语法</a></h4>
<pre><code>SELECT MEAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MEAN(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的field value的平均值。</p>
<p><code>MEAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<h5 id="计算指定field-key对应的field-value的平均值"><a class="header" href="#计算指定field-key对应的field-value的平均值">计算指定field key对应的field value的平均值</a></h5>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mean
----                   ----
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>的平均值。</p>
<h5 id="计算measurement中每个field-key对应的field-value的平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均值">计算measurement中每个field key对应的field value的平均值</a></h5>
<pre><code class="language-sql">&gt; SELECT MEAN(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mean_water_level
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均值。<code>measurement</code> <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value的平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均值">计算与正则表达式匹配的每个field key对应的field value的平均值</a></h5>
<pre><code class="language-sql">&gt; SELECT MEAN(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mean_water_level
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822523
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<h5 id="计算指定field-key对应的field-value的平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均值并包含多个子句">计算指定field key对应的field value的平均值并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 7 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   mean
----                   ----
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.0625
2020-08-18T00:12:00Z   7.8245
2020-08-18T00:24:00Z   7.5675
2020-08-18T00:36:00Z   7.303
2020-08-18T00:48:00Z   7.046
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的平均值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为7和1。</p>
<h3 id="median"><a class="header" href="#median">MEDIAN()</a></h3>
<p>返回<code>field value</code>的计算平均值。</p>
<h4 id="语法-11"><a class="header" href="#语法-11">语法</a></h4>
<pre><code>SELECT MEDIAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-2"><a class="header" href="#语法描述-2">语法描述</a></h4>
<p><code>MEDIAN(field_key)</code>返回与<code>field key</code>对应的field value的平均值。</p>
<p><code>MEDIAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEDIAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEDIAN()</code> 支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong><code>MEDIAN()</code>近似于<code>PERCENTILE(field_key, 50)</code>，除非<code>field key</code>包含的<code>field value</code>有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</p>
</blockquote>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<h5 id="计算指定field-key对应的field-value的平均数"><a class="header" href="#计算指定field-key对应的field-value的平均数">计算指定field key对应的field value的平均数</a></h5>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   median
----                   ------
1970-01-01T00:00:00Z   4.124
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中field key <code>water_level</code>对应的<code>field value</code>的平均数。</p>
<h5 id="计算measurement中每个field-key对应的field-value的平均数"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均数">计算measurement中每个field key对应的field value的平均数</a></h5>
<pre><code class="language-sql">&gt; SELECT MEDIAN(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   median_water_level
----                   ------------------
1970-01-01T00:00:00Z   4.124
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均数。<code>measurement</code> <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value的平均数"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均数">计算与正则表达式匹配的每个field key对应的field value的平均数</a></h5>
<pre><code class="language-sql">&gt; SELECT MEDIAN(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   median_water_level
----                   ------------------
1970-01-01T00:00:00Z   4.124
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的平均数。</p>
<h5 id="计算指定field-key对应的field-value的平均数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均数并包含多个子句">计算指定field key对应的field value的平均数并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(700) LIMIT 7 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   median
----                   ------
2020-08-17T23:48:00Z   700
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
2020-08-18T00:36:00Z   2.0620000000000003
2020-08-18T00:48:00Z   700
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>的平均数，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>700</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为7和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
<h3 id="mode"><a class="header" href="#mode">MODE()</a></h3>
<p>返回<code>field value</code>中出现频率最高的值。</p>
<h4 id="语法-12"><a class="header" href="#语法-12">语法</a></h4>
<pre><code>SELECT MODE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MODE(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE()</code> 支持所有数据类型的<code>field value</code>。</p>
<blockquote>
<p>**注意：**如果出现频率最高的值有两个或多个并且它们之间有关联，那么<code>MODE()</code>返回具有最早时间戳的<code>field value</code>。</p>
</blockquote>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<h5 id="计算指定field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值">计算指定field key对应的field value中出现频率最高的值</a></h5>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mode
----                   ----
1970-01-01T00:00:00Z   between 3 and 6 feet
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。measurement <code>h2o_feet</code>中有两个<code>field key</code>：<code>level description</code>和<code>water_level</code>。</p>
<h5 id="计算measurement中每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算measurement中每个field-key对应的field-value中出现频率最高的值">计算measurement中每个field key对应的field value中出现频率最高的值</a></h5>
<pre><code class="language-sql">&gt; SELECT MODE(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mode_level description   mode_water_level
----                   ----------------------   ----------------
1970-01-01T00:00:00Z   between 3 and 6 feet     2.69
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。<code>measurement</code> <code>h2o_feet</code>中有两个<code>field key</code>：<code>level description</code>和<code>water_level</code>。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值">计算与正则表达式匹配的每个field key对应的field value中出现频率最高的值</a></h5>
<pre><code class="language-sql">&gt; SELECT MODE(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mode_water_level
----                   ----------------
1970-01-01T00:00:00Z   2.69
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<h5 id="计算指定field-key对应的field-value中出现频率最高的值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值并包含多个子句">计算指定field key对应的field value中出现频率最高的值并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;level description&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* LIMIT 3 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   mode
----                   ----
2020-08-17T23:48:00Z
2020-08-18T00:00:00Z   below 3 feet
2020-08-18T00:12:00Z   below 3 feet
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>中出现频率最高的值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
<h3 id="spread"><a class="header" href="#spread">SPREAD()</a></h3>
<p>返回<code>field value</code>中最大值和最小值之差。</p>
<h4 id="语法-13"><a class="header" href="#语法-13">语法</a></h4>
<pre><code class="language-sql">SELECT SPREAD( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-3"><a class="header" href="#语法描述-3">语法描述</a></h4>
<p><code>SPREAD(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD()</code>支持数据类型为int64和float64的<code>field value</code>。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<h5 id="计算指定field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差">计算指定field key对应的field value中最大值和最小值之差</a></h5>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   spread
----                   ------
1970-01-01T00:00:00Z   10.574
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<h5 id="计算measurement中每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算measurement中每个field-key对应的field-value中最大值和最小值之差">计算measurement中每个field key对应的field value中最大值和最小值之差</a></h5>
<pre><code class="language-sql">&gt; SELECT SPREAD(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   spread_water_level
----                   ------------------
1970-01-01T00:00:00Z   10.574
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。<code>measurement</code> <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差">计算与正则表达式匹配的每个field key对应的field value中最大值和最小值之差</a></h5>
<pre><code class="language-sql">&gt; SELECT SPREAD(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   spread_water_level
----                   ------------------
1970-01-01T00:00:00Z   10.574
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<h5 id="计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句">计算指定field key对应的field value中最大值和最小值之差并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(18) LIMIT 3 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   spread
----                   ------
2020-08-17T23:48:00Z   18
2020-08-18T00:00:00Z   0.052000000000000046
2020-08-18T00:12:00Z   0.09799999999999986
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中field key <code>water_level</code>对应的field value中最大值和最小值之差，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>18</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）</p>
<h3 id="stddev"><a class="header" href="#stddev">STDDEV()</a></h3>
<p>返回<code>field value</code>的标准差。</p>
<h4 id="语法-14"><a class="header" href="#语法-14">语法</a></h4>
<pre><code class="language-sql">SELECT STDDEV( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>STDDEV(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(*)</code>返回在measurement中每个field key对应的field value的标准差。</p>
<p><code>STDDEV()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<h5 id="计算指定field-key对应的field-value的标准差"><a class="header" href="#计算指定field-key对应的field-value的标准差">计算指定field key对应的field value的标准差</a></h5>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   stddev
----                   ------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的标准差。</p>
<h5 id="计算measurement中每个field-key对应的field-value的标准差"><a class="header" href="#计算measurement中每个field-key对应的field-value的标准差">计算measurement中每个field key对应的field value的标准差</a></h5>
<pre><code class="language-sql">&gt; SELECT STDDEV(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   stddev_water_level
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的标准差。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value的标准差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的标准差">计算与正则表达式匹配的每个field key对应的field value的标准差</a></h5>
<pre><code class="language-sql">&gt; SELECT STDDEV(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   stddev_water_level
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的标准差。</p>
<h5 id="计算指定field-key对应的field-value的标准差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的标准差并包含多个子句">计算指定field key对应的field value的标准差并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(18000) LIMIT 2 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   stddev
----                   ------
2020-08-17T23:48:00Z   18000
2020-08-18T00:00:00Z   0.03676955262170051
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的标准差，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为2和1，并将返回的series偏移一个（即第一个series的数据不返回）。</p>
<h3 id="sum"><a class="header" href="#sum">SUM()</a></h3>
<p>返回field value的总和。</p>
<h4 id="语法-15"><a class="header" href="#语法-15">语法</a></h4>
<pre><code>SELECT SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-4"><a class="header" href="#语法描述-4">语法描述</a></h4>
<p><code>SUM(field_key)</code>返回field key对应的field value的总和。</p>
<p><code>SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的总和。</p>
<p><code>SUM(*)</code>返回在measurement中每个field key对应的field value的总和。</p>
<p><code>SUM()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<h5 id="计算指定field-key对应的field-value的总和"><a class="header" href="#计算指定field-key对应的field-value的总和">计算指定field key对应的field value的总和</a></h5>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum
----                   ---
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的总和。</p>
<h5 id="计算measurement中每个field-key对应的field-value的总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的总和">计算measurement中每个field key对应的field value的总和</a></h5>
<pre><code class="language-sql">&gt; SELECT SUM(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum_water_level
----                   ---------------
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的总和。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value的总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的总和">计算与正则表达式匹配的每个field key对应的field value的总和</a></h5>
<pre><code class="language-sql">&gt; SELECT SUM(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum_water_level
----                   ---------------
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的总和。</p>
<h5 id="计算指定field-key对应的field-value的总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的总和并包含多个子句">计算指定field key对应的field value的总和并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(18000) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   sum
----                   ---
2020-08-17T23:48:00Z   18000
2020-08-18T00:00:00Z   16.125
2020-08-18T00:12:00Z   15.649
2020-08-18T00:24:00Z   15.135
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的总和，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<h2 id="选择函数"><a class="header" href="#选择函数">选择函数</a></h2>
<h3 id="bottom"><a class="header" href="#bottom">BOTTOM()</a></h3>
<p>返回最小的N个field value。</p>
<h4 id="语法-16"><a class="header" href="#语法-16">语法</a></h4>
<pre><code>SELECT BOTTOM(&lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-5"><a class="header" href="#语法描述-5">语法描述</a></h4>
<p><code>BOTTOM(field_key,N)</code>返回field key对应的最小的N个值。</p>
<p><code>BOTTOM(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最小值。</p>
<p><code>BOTTOM(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最小的N个值，以及相关的tag和/或field。</p>
<p><code>BOTTOM()</code>支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>如果最小值有两个或多个相等的值，<code>BOTTOM()</code>返回具有最早时间戳的field value。</li>
<li>当<code>BOTTOM()</code>函数与<code>INTO</code>子句一起使用时，<code>BOTTOM()</code>与其它cnosQL函数不同。请查看<code>BOTTOM()</code>的常见问题章节获得更多信息。</li>
</ul>
</blockquote>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<h5 id="选择指定field-key对应的最小的三个值"><a class="header" href="#选择指定field-key对应的最小的三个值">选择指定field key对应的最小的三个值</a></h5>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   bottom
----                   ------
2020-08-29T14:30:00Z   -0.61
2020-08-29T14:36:00Z   -0.591
2020-08-30T15:18:00Z   -0.594
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的最小的三个值。</p>
<h5 id="选择两个tag对应的field-key的最小值"><a class="header" href="#选择两个tag对应的field-key的最小值">选择两个tag对应的field key的最小值</a></h5>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,&quot;location&quot;,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   bottom   location
----                   ------   --------
2020-08-29T10:36:00Z   -0.243   santa_monica
2020-08-29T14:30:00Z   -0.61    coyote_creek
</code></pre>
<p>该查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最小值。</p>
<h5 id="选择指定field-key对应的最小的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最小的四个值以及相关的tag和field">选择指定field key对应的最小的四个值以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,4),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  bottom  location      level description
----                  ------  --------      -----------------
2020-08-29T14:24:00Z  -0.587  coyote_creek  below 3 feet
2020-08-29T14:30:00Z  -0.61   coyote_creek  below 3 feet
2020-08-29T14:36:00Z  -0.591  coyote_creek  below 3 feet
2020-08-30T15:18:00Z  -0.594  coyote_creek  below 3 feet
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的最小的四个值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<h5 id="选择指定field-key对应的最小的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最小的三个值并包含多个子句">选择指定field key对应的最小的三个值并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,3),&quot;location&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC

name: h2o_feet
time                  bottom  location
----                  ------  --------
2020-08-18T00:48:00Z  1.991   santa_monica
2020-08-18T00:54:00Z  2.054   santa_monica
2020-08-18T00:54:00Z  6.982   coyote_creek
2020-08-18T00:24:00Z  2.041   santa_monica
2020-08-18T00:30:00Z  2.051   santa_monica
2020-08-18T00:42:00Z  2.057   santa_monica
2020-08-18T00:00:00Z  2.064   santa_monica
2020-08-18T00:06:00Z  2.116   santa_monica
2020-08-18T00:12:00Z  2.028   santa_monica
</code></pre>
<p>该查询返回在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>water_level</code>对应的最小的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="bottom的常见问题"><a class="header" href="#bottom的常见问题"><code>BOTTOM()</code>的常见问题</a></h4>
<h5 id="bottom和group-by-time子句同时使用"><a class="header" href="#bottom和group-by-time子句同时使用"><code>BOTTOM()</code>和<code>GROUP BY time()</code>子句同时使用</a></h5>
<p>对于同时带有<code>BOTTOM()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>BOTTOM()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<h6 id="示例-12"><a class="header" href="#示例-12">示例</a></h6>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   bottom
----                   ------
                           __
2020-08-18T00:00:00Z  2.064 |
2020-08-18T00:12:00Z  2.028 | &lt;------- Smallest points for the first time interval
                           --
                           __
2020-08-18T00:24:00Z  2.041 |
2020-08-18T00:30:00Z  2.051 | &lt;------- Smallest points for the second time interval                      --
</code></pre>
<h5 id="bottom和具有少于n个tag-value的tag-key"><a class="header" href="#bottom和具有少于n个tag-value的tag-key"><code>BOTTOM()</code>和具有少于N个tag value的tag key</a></h5>
<p>使用语法<code>SELECT BOTTOM(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<h6 id="示例-13"><a class="header" href="#示例-13">示例</a></h6>
<p>以下查询请求的是tag key <code>location</code>的三个tag value对于的<code>water_level</code>的最小值。因为tag key <code>location</code>只有两个tag value(<code>santa_monica</code>和<code>coyote_creek</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,&quot;location&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   bottom   location
----                   ------   --------
2020-08-29T10:36:00Z   -0.243   santa_monica
2020-08-29T14:30:00Z   -0.61    coyote_creek
</code></pre>
<h5 id="bottomtag和into子句"><a class="header" href="#bottomtag和into子句"><code>BOTTOM()</code>、tag和<code>INTO</code>子句</a></h5>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>BOTTOM()</code>函数除非<code>BOTTOM()</code>中包含tag key作为参数：<code>BOTTOM(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<h6 id="示例-14"><a class="header" href="#示例-14">示例</a></h6>
<p>下面代码块中的第一个查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最小值，并且，它这些结果写入measurement <code>bottom_water_levels</code>中。第二个查询展示了cnosDB将tag <code>location</code>保留为measurement <code>bottom_water_levels</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,&quot;location&quot;,2) INTO &quot;bottom_water_levels&quot; FROM &quot;h2o_feet&quot;

name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;bottom_water_levels&quot;

name: bottom_water_levels
tagKey
------
location
</code></pre>
<h3 id="first"><a class="header" href="#first">FIRST()</a></h3>
<p>返回具有最早时间戳的field value。</p>
<h4 id="语法-17"><a class="header" href="#语法-17">语法</a></h4>
<pre><code>SELECT FIRST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-6"><a class="header" href="#语法描述-6">语法描述</a></h4>
<p><code>FIRST(field_key)</code>返回field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(*)</code>返回在measurement中每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最早时间戳的field value，以及相关的tag或field。</p>
<p><code>FIRST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例</a></h4>
<h5 id="选择指定field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value">选择指定field key对应的具有最早时间戳的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   first
----                   -----
2020-08-18T00:00:00Z   between 6 and 9 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最早时间戳的field value。</p>
<h5 id="选择measurement中每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最早时间戳的field-value">选择measurement中每个field key对应的具有最早时间戳的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   first_level description   first_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 6 and 9 feet      8.12
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的具有最早时间戳的field value。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<h5 id="选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最早时间戳的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT FIRST(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   first_level description   first_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 6 and 9 feet      8.12
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的具有最早时间戳的field value。</p>
<h5 id="选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最早时间戳的field value以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;level description&quot;),&quot;location&quot;,&quot;water_level&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  first                 location      water_level
----                  -----                 --------      -----------
2020-08-18T00:00:00Z  between 6 and 9 feet  coyote_creek  8.12
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最早时间戳的field value，以及相关的tag key <code>location</code>和field key <code>water_level</code>的值。</p>
<h5 id="选择指定field-key对应的具有最早时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value并包含多个子句">选择指定field key对应的具有最早时间戳的field value并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   first
----                   -----
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.12
2020-08-18T00:12:00Z   7.887
2020-08-18T00:24:00Z   7.635
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的具有最早时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
<h3 id="last"><a class="header" href="#last">LAST()</a></h3>
<p>返回具有最新时间戳的field value。</p>
<h4 id="语法-18"><a class="header" href="#语法-18">语法</a></h4>
<pre><code class="language-sql">SELECT LAST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_keys(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LAST(field_key)</code>返回field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(*)</code>返回在measurement中每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最新时间戳的field value，以及相关的tag或field。</p>
<p><code>LAST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-16"><a class="header" href="#示例-16">示例</a></h4>
<h5 id="选择指定field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value">选择指定field key对应的具有最新时间戳的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   last
----                   ----
2020-09-18T21:42:00Z   between 3 and 6 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最新时间戳的field value。</p>
<h5 id="选择measurement中每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最新时间戳的field-value">选择measurement中每个field key对应的具有最新时间戳的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT LAST(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   last_level description   last_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 3 and 6 feet      4.938
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的具有最新时间戳的field value。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<h5 id="选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最新时间戳的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT LAST(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   last_level description   last_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 3 and 6 feet      4.938
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的具有最新时间戳的field value。</p>
<h5 id="选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最新时间戳的field value以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;level description&quot;),&quot;location&quot;,&quot;water_level&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  last                  location      water_level
----                  ----                  --------      -----------
2020-09-18T21:42:00Z  between 3 and 6 feet  santa_monica  4.938
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最新时间戳的field value，以及相关的tag key <code>location</code>和field key <code>water_level</code>的值。</p>
<h5 id="选择指定field-key对应的具有最新时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value并包含多个子句">选择指定field key对应的具有最新时间戳的field value并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   last
----                   ----
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.005
2020-08-18T00:12:00Z   7.762
2020-08-18T00:24:00Z   7.5
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的具有最新时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
<h3 id="max"><a class="header" href="#max">MAX()</a></h3>
<p>返回field value的最大值。</p>
<h4 id="语法-19"><a class="header" href="#语法-19">语法</a></h4>
<pre><code>SELECT MAX(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field__key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MAX(field_key)</code>返回field key对应的field value的最大值。</p>
<p><code>MAX(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最大值。</p>
<p><code>MAX(*)</code>返回在measurement中每个field key对应的field value的最大值。</p>
<p><code>MAX(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最大值，以及相关的tag或field。</p>
<p><code>MAX()</code> 支持数据类型为int64和float64的field value。</p>
<h4 id="示例-17"><a class="header" href="#示例-17">示例</a></h4>
<h5 id="选择指定field-key对应的field-value的最大值"><a class="header" href="#选择指定field-key对应的field-value的最大值">选择指定field key对应的field value的最大值</a></h5>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   max
----                   ---
2020-08-29T07:24:00Z   9.964
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最大值。</p>
<h5 id="选择measurement中每个field-key对应的field-value的最大值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最大值">选择measurement中每个field key对应的field value的最大值</a></h5>
<pre><code class="language-sql">&gt; SELECT MAX(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   max_water_level
----                   ---------------
2020-08-29T07:24:00Z   9.964
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的最大值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="选择与正则表达式匹配的每个field-key对应的field-value的最大值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最大值">选择与正则表达式匹配的每个field key对应的field value的最大值</a></h5>
<pre><code class="language-sql">&gt; SELECT MAX(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   max_water_level
----                   ---------------
2020-08-29T07:24:00Z   9.964
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最大值。</p>
<h5 id="选择指定field-key对应的field-value的最大值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最大值以及相关的tag和field">选择指定field key对应的field value的最大值以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max    location      level description
----                  ---    --------      -----------------
2020-08-29T07:24:00Z  9.964  coyote_creek  at or greater than 9 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最大值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<h5 id="选择指定field-key对应的field-value的最大值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最大值并包含多个子句">选择指定field key对应的field value的最大值并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   max
----                   ---
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.12
2020-08-18T00:12:00Z   7.887
2020-08-18T00:24:00Z   7.635
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最大值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
<h3 id="min"><a class="header" href="#min">MIN()</a></h3>
<p>返回field value的最小值。</p>
<h4 id="语法-20"><a class="header" href="#语法-20">语法</a></h4>
<pre><code>SELECT MIN(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MIN(field_key)</code>返回field key对应的field value的最小值。</p>
<p><code>MIN(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最小值。</p>
<p><code>MIN(*)</code>返回在measurement中每个field key对应的field value的最小值。</p>
<p><code>MIN(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最小值，以及相关的tag和/或field。</p>
<p><code>MIN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<h5 id="选择指定field-key对应的field-value的最小值"><a class="header" href="#选择指定field-key对应的field-value的最小值">选择指定field key对应的field value的最小值</a></h5>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   min
----                   ---
2020-08-29T14:30:00Z   -0.61
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最小值。</p>
<h5 id="选择measurement中每个field-key对应的field-value的最小值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最小值">选择measurement中每个field key对应的field value的最小值</a></h5>
<pre><code class="language-sql">&gt; SELECT MIN(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   min_water_level
----                   ---------------
2020-08-29T14:30:00Z   -0.61
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的最小值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="选择与正则表达式匹配的每个field-key对应的field-value的最小值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最小值">选择与正则表达式匹配的每个field key对应的field value的最小值</a></h5>
<pre><code class="language-sql">&gt; SELECT MIN(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   min_water_level
----                   ---------------
2020-08-29T14:30:00Z   -0.61
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最小值。</p>
<h5 id="选择指定field-key对应的field-value的最小值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最小值以及相关的tag和field">选择指定field key对应的field value的最小值以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  min    location      level description
----                  ---    --------      -----------------
2020-08-29T14:30:00Z  -0.61  coyote_creek  below 3 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最小值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<h5 id="选择指定field-key对应的field-value的最小值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最小值并包含多个子句">选择指定field key对应的field value的最小值并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   min
----                   ---
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.005
2020-08-18T00:12:00Z   7.762
2020-08-18T00:24:00Z   7.5
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最小值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
<h3 id="percentile"><a class="header" href="#percentile">PERCENTILE()</a></h3>
<p>返回第N个百分位数的<code>field value</code></p>
<h4 id="语法-21"><a class="header" href="#语法-21">语法</a></h4>
<pre><code>SELECT PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>PERCENTILE(field_key,N)</code>返回指定field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(*,N)</code>返回在measurement中每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的第N个百分位数的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是0到100之间的整数或浮点数。</p>
<p><code>PERCENTILE()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-19"><a class="header" href="#示例-19">示例</a></h4>
<h5 id="选择指定field-key对应的第五个百分位数的field-value"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value">选择指定field key对应的第五个百分位数的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;water_level&quot;,5) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   percentile
----                   ----------
2020-08-31T03:42:00Z   1.122
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的所有field value中的百分之五。</p>
<h5 id="选择measurement中每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择measurement中每个field-key对应的第五个百分位数的field-value">选择measurement中每个field key对应的第五个百分位数的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(*,5) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   percentile_water_level
----                   ----------------------
2020-08-31T03:42:00Z   1.122
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中每个存储数值的field key对应的所有field value中的百分之五。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h5 id="选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value">选择与正则表达式匹配的每个field key对应的第五个百分位数的field value</a></h5>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(/level/,5) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   percentile_water_level
----                   ----------------------
2020-08-31T03:42:00Z   1.122
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的所有field value中的百分之五。</p>
<h5 id="选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field">选择指定field key对应的第五个百分位数的field value以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;water_level&quot;,5),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  percentile  location      level description
----                  ----------  --------      -----------------
2020-08-31T03:42:00Z  1.122       coyote_creek  below 3 feet
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的所有field value中的百分之五，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<h5 id="选择指定field-key对应的第20个百分位数的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的第20个百分位数的field-value并包含多个子句">选择指定field key对应的第20个百分位数的field value并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;water_level&quot;,20) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(24m) fill(15) LIMIT 2

name: h2o_feet
time                   percentile
----                   ----------
2020-08-17T23:36:00Z   15
2020-08-18T00:00:00Z   2.064
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的所有field value中的百分之二十，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按24分钟的时间间隔进行分组，同时，该查询用<code>15</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数限制为2。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每24分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:36:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:24:00Z</code>之间。</p>
<h4 id="percentile的常见问题"><a class="header" href="#percentile的常见问题"><code>PERCENTILE()</code>的常见问题</a></h4>
<h5 id="percentile-vs-其它cnosql函数"><a class="header" href="#percentile-vs-其它cnosql函数"><code>PERCENTILE()</code> vs 其它cnosQL函数</a></h5>
<ul>
<li><code>PERCENTILE(&lt;field_key&gt;,100)</code>相当于<code>MAX(&lt;field_key&gt;)</code>。</li>
<li><code>PERCENTILE(&lt;field_key&gt;, 50)</code>近似于<code>MEDIAN(&lt;field_key&gt;)</code>，除非field key包含的field value有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</li>
<li><code>PERCENTILE(&lt;field_key&gt;,0)</code>不等于<code>MIN(&lt;field_key&gt;)</code>，<code>PERCENTILE(&lt;field_key&gt;,0)</code>会返回<code>null</code>。</li>
</ul>
<h3 id="sample"><a class="header" href="#sample">SAMPLE()</a></h3>
<p>返回包含N个field value的随机样本。<code>SAMPLE()</code>使用<a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a>来生成随机<code>point</code>。</p>
<h4 id="语法-22"><a class="header" href="#语法-22">语法</a></h4>
<pre><code>SELECT SAMPLE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SAMPLE(field_key,N)</code>返回指定field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(*,N)</code>返回在measurement中每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的N个随机选择的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是整数。</p>
<p><code>SAMPLE()</code>支持所有数据类型的field value。</p>
<h4 id="示例-20"><a class="header" href="#示例-20">示例</a></h4>
<h5 id="选择指定field-key对应的field-value的随机样本"><a class="header" href="#选择指定field-key对应的field-value的随机样本">选择指定field key对应的field value的随机样本</a></h5>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sample
----                   ------
2020-09-09T21:48:00Z   5.659
2020-09-18T10:00:00Z   6.939
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的两个随机选择的<code>point</code>。</p>
<h5 id="选择measurement中每个field-key对应的field-value的随机样本"><a class="header" href="#选择measurement中每个field-key对应的field-value的随机样本">选择measurement中每个field key对应的field value的随机样本</a></h5>
<pre><code class="language-sql">&gt; SELECT SAMPLE(*,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sample_level description   sample_water_level
----                   ------------------------   ------------------
2020-08-25T17:06:00Z                              3.284
2020-09-03T04:30:00Z   below 3 feet
2020-09-03T20:06:00Z   between 3 and 6 feet
2020-09-08T21:54:00Z                              3.412
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的两个随机选择的<code>point</code>。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<h5 id="选择与正则表达式匹配的每个field-key对应的field-value的随机样本"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的随机样本">选择与正则表达式匹配的每个field key对应的field value的随机样本</a></h5>
<pre><code class="language-sql">&gt; SELECT SAMPLE(/level/,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sample_level description   sample_water_level
----                   ------------------------   ------------------
2020-08-30T05:54:00Z   between 6 and 9 feet
2020-09-07T01:18:00Z                              7.854
2020-09-09T20:30:00Z                              7.32
2020-09-13T19:18:00Z   between 3 and 6 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的两个随机选择的<code>point</code>。</p>
<h5 id="选择指定field-key对应的field-value的随机样本以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的随机样本以及相关的tag和field">选择指定field key对应的field value的随机样本以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,2),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  sample  location      level description
----                  ------  --------      -----------------
2020-08-29T10:54:00Z  5.689   coyote_creek  between 3 and 6 feet
2020-09-08T15:48:00Z  6.391   coyote_creek  between 6 and 9 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的两个随机选择的<code>point</code>，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<h5 id="选择指定field-key对应field-value的随机样本并包含多个子句"><a class="header" href="#选择指定field-key对应field-value的随机样本并包含多个子句">选择指定field key对应field value的随机样本并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,1) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   sample
----                   ------
2020-08-18T00:12:00Z   2.028
2020-08-18T00:30:00Z   2.051
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的一个随机选择的<code>point</code>，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并将查询结果按18分钟的时间间隔进行分组。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="sample的常见问题"><a class="header" href="#sample的常见问题"><code>SAMPLE()</code>的常见问题</a></h4>
<h5 id="sample和group-by-time子句同时使用"><a class="header" href="#sample和group-by-time子句同时使用"><code>SAMPLE()</code>和<code>GROUP BY time()</code>子句同时使用</a></h5>
<p>对于同时带有<code>SAMPLE()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数(<code>N</code>)的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>SAMPLE()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<h6 id="示例-21"><a class="header" href="#示例-21">示例</a></h6>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个随机选择的<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   sample
----                   ------
                           __
2020-08-18T00:06:00Z   2.116 |
2020-08-18T00:12:00Z   2.028 | &lt;------- Randomly-selected points for the first time interval
                           --
                           __
2020-08-18T00:18:00Z   2.126 |
2020-08-18T00:30:00Z   2.051 | &lt;------- Randomly-selected points for the second time interval
                           --
</code></pre>
<h3 id="top"><a class="header" href="#top">TOP()</a></h3>
<p>返回最大的N个field value</p>
<h4 id="语法-23"><a class="header" href="#语法-23">语法</a></h4>
<pre><code>SELECT TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TOP(field_key,N)</code>返回field key对应的最大的N个值。</p>
<p><code>TOP(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最大值。</p>
<p><code>TOP(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最大的N个值，以及相关的tag和/或field。</p>
<p><code>TOP()</code>支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong></p>
<ul>
<li>如果最大值有两个或多个并且它们之间有关联，<code>TOP()</code>返回具有最早时间戳的field value。</li>
</ul>
</blockquote>
<h4 id="示例-22"><a class="header" href="#示例-22">示例</a></h4>
<h5 id="选择指定field-key对应的最大的三个值"><a class="header" href="#选择指定field-key对应的最大的三个值">选择指定field key对应的最大的三个值</a></h5>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   top
----                   ---
2020-08-29T07:18:00Z   9.957
2020-08-29T07:24:00Z   9.964
2020-08-29T07:30:00Z   9.954
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的最大的三个值。</p>
<h5 id="选择两个tag对应的field-key的最大值"><a class="header" href="#选择两个tag对应的field-key的最大值">选择两个tag对应的field key的最大值</a></h5>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,&quot;location&quot;,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   top     location
----                   ---     --------
2020-08-29T03:54:00Z   7.205   santa_monica
2020-08-29T07:24:00Z   9.964   coyote_creek
</code></pre>
<p>该查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最大值。</p>
<h5 id="选择指定field-key对应的最大的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最大的四个值以及相关的tag和field">选择指定field key对应的最大的四个值以及相关的tag和field</a></h5>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,4),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  top    location      level description
----                  ---    --------      -----------------
2020-08-29T07:18:00Z  9.957  coyote_creek  at or greater than 9 feet
2020-08-29T07:24:00Z  9.964  coyote_creek  at or greater than 9 feet
2020-08-29T07:30:00Z  9.954  coyote_creek  at or greater than 9 feet
2020-08-29T07:36:00Z  9.941  coyote_creek  at or greater than 9 feet
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的最大的四个值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<h5 id="选择指定field-key对应的最大的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最大的三个值并包含多个子句">选择指定field key对应的最大的三个值并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,3),&quot;location&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC

name: h2o_feet
time                  top    location
----                  ---    --------
2020-08-18T00:48:00Z  7.11   coyote_creek
2020-08-18T00:54:00Z  6.982  coyote_creek
2020-08-18T00:54:00Z  2.054  santa_monica
2020-08-18T00:24:00Z  7.635  coyote_creek
2020-08-18T00:30:00Z  7.5    coyote_creek
2020-08-18T00:36:00Z  7.372  coyote_creek
2020-08-18T00:00:00Z  8.12   coyote_creek
2020-08-18T00:06:00Z  8.005  coyote_creek
2020-08-18T00:12:00Z  7.887  coyote_creek
</code></pre>
<p>该查询返回在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>water_level</code>对应的最大的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="top的常见问题"><a class="header" href="#top的常见问题"><code>TOP()</code>的常见问题</a></h4>
<h5 id="top和group-by-time子句同时使用"><a class="header" href="#top和group-by-time子句同时使用"><code>TOP()</code>和<code>GROUP BY time()</code>子句同时使用</a></h5>
<p>对于同时带有<code>TOP()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>TOP()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<h6 id="示例-23"><a class="header" href="#示例-23">示例</a></h6>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   top
----                   ------
                           __
2020-08-18T00:00:00Z  2.064 |
2020-08-18T00:06:00Z  2.116 | &lt;------- Greatest points for the first time interval
                           --
                           __
2020-08-18T00:18:00Z  2.126 |
2020-08-18T00:30:00Z  2.051 | &lt;------- Greatest points for the second time interval
                           --
</code></pre>
<h5 id="top和具有少于n个tag-value的tag-key"><a class="header" href="#top和具有少于n个tag-value的tag-key"><code>TOP()</code>和具有少于N个tag value的tag key</a></h5>
<p>使用语法<code>SELECT TOP(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<h6 id="示例-24"><a class="header" href="#示例-24">示例</a></h6>
<p>以下查询请求的是tag key <code>location</code>的三个tag value对于的<code>water_level</code>的最大值。因为tag key <code>location</code>只有两个tag value(<code>santa_monica</code>和<code>coyote_creek</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,&quot;location&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  top    location
----                  ---    --------
2020-08-29T03:54:00Z  7.205  santa_monica
2020-08-29T07:24:00Z  9.964  coyote_creek
</code></pre>
<h5 id="toptag和into子句"><a class="header" href="#toptag和into子句"><code>TOP()</code>、tag和<code>INTO</code>子句</a></h5>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>TOP()</code>函数，除非<code>TOP()</code>中包含tag key作为参数：<code>TOP(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<h6 id="示例-25"><a class="header" href="#示例-25">示例</a></h6>
<p>下面代码块中的第一个查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最大值，并且，它这些结果写入measurement <code>top_water_levels</code>中。第二个查询展示了cnosDB将tag <code>location</code>保留为measurement <code>top_water_levels</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,&quot;location&quot;,2) INTO &quot;top_water_levels&quot; FROM &quot;h2o_feet&quot;

name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;top_water_levels&quot;

name: top_water_levels
tagKey
------
location
</code></pre>
<h2 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h2>
<h3 id="abs"><a class="header" href="#abs">ABS()</a></h3>
<p>返回field value的绝对值</p>
<h4 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h4>
<pre><code class="language-sql">SELECT ABS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ABS(field_key)</code>返回field key对应的field value的绝对值。</p>
<p><code>ABS(*)</code>返回在measurement中每个field key对应的field value的绝对值。</p>
<p><code>ABS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ABS()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-26"><a class="header" href="#示例-26">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z'

name: data
time                 a                   b
----                 -                   -
1529841600000000000  1.33909108671076    -0.163643058925645
1529841660000000000  -0.774984088561186  0.137034364053949
1529841720000000000  -0.921037167720451  -0.482943221384294
1529841780000000000  -1.73880754843378   -0.0729732928756677
1529841840000000000  -0.905980032168252  1.77857552719844
1529841900000000000  -0.891164752631417  0.741147445214238
</code></pre>
<h6 id="计算指定field-key对应的field-value的绝对值"><a class="header" href="#计算指定field-key对应的field-value的绝对值">计算指定field key对应的field value的绝对值</a></h6>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;a&quot;) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z'

name: data
time                 abs
----                 ---
1529841600000000000  1.33909108671076
1529841660000000000  0.774984088561186
1529841720000000000  0.921037167720451
1529841780000000000  1.73880754843378
1529841840000000000  0.905980032168252
1529841900000000000  0.891164752631417
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值。</p>
<h6 id="计算measurement中每个field-key对应的field-value的绝对值"><a class="header" href="#计算measurement中每个field-key对应的field-value的绝对值">计算measurement中每个field key对应的field value的绝对值</a></h6>
<pre><code class="language-sql">&gt; SELECT ABS(*) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z'

name: data
time                 abs_a              abs_b
----                 -----              -----
1529841600000000000  1.33909108671076   0.163643058925645
1529841660000000000  0.774984088561186  0.137034364053949
1529841720000000000  0.921037167720451  0.482943221384294
1529841780000000000  1.73880754843378   0.0729732928756677
1529841840000000000  0.905980032168252  1.77857552719844
1529841900000000000  0.891164752631417  0.741147445214238
</code></pre>
<p>该查询返回measurement <code>data</code>中每个存储数值的field key对应的field value的绝对值。measurement <code>data</code>中有两个数值类型的field：<code>a</code>和<code>b</code>。</p>
<h6 id="计算指定field-key对应的field-value的绝对值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的绝对值并包含多个子句">计算指定field key对应的field value的绝对值并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;a&quot;) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: data
time                 abs
----                 ---
1529841780000000000  1.73880754843378
1529841720000000000  0.921037167720451
1529841660000000000  0.774984088561186
1529841600000000000  1.33909108671076
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值，它涵盖的时间范围在<code>2020-06-24T12:00:00Z</code>和<code>2020-06-24T12:05:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法"><a class="header" href="#高级语法">高级语法</a></h4>
<pre><code class="language-sql">SELECT ABS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的绝对值。</p>
<p><code>ABS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-27"><a class="header" href="#示例-27">示例</a></h5>
<h6 id="计算平均值的绝对值"><a class="header" href="#计算平均值的绝对值">计算平均值的绝对值</a></h6>
<pre><code class="language-sql">&gt; SELECT ABS(MEAN(&quot;a&quot;)) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T13:00:00Z' GROUP BY time(12m)

name: data
time                 abs
----                 ---
1529841600000000000  0.3960977256302787
1529842320000000000  0.0010541018316373302
1529843040000000000  0.04494733240283668
1529843760000000000  0.2553594777104415
1529844480000000000  0.20382988543108413
1529845200000000000  0.790836070736962
</code></pre>
<p>该查询返回field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值的绝对值。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ABS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;a&quot;) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T13:00:00Z' GROUP BY time(12m)

name: data
time                 mean
----                 ----
1529841600000000000  -0.3960977256302787
1529842320000000000  0.0010541018316373302
1529843040000000000  0.04494733240283668
1529843760000000000  0.2553594777104415
1529844480000000000  0.20382988543108413
1529845200000000000  -0.790836070736962
</code></pre>
<p>然后，cnosDB计算这些平均值的绝对值。</p>
<h3 id="acos"><a class="header" href="#acos">ACOS()</a></h3>
<p>返回field value的反余弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h4>
<pre><code>SELECT ACOS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ACOS(field_key)</code>返回field key对应的field value的反余弦。</p>
<p><code>ACOS(*)</code>返回在measurement中每个field key对应的field value的反余弦。</p>
<p><code>ACOS()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ACOS()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-28"><a class="header" href="#示例-28">示例</a></h5>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ACOS()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;of_capacity&quot; FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<h6 id="计算指定field-key对应的field-value的反余弦"><a class="header" href="#计算指定field-key对应的field-value的反余弦">计算指定field key对应的field value的反余弦</a></h6>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  acos
----                  ----
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反余弦。</p>
<h6 id="计算measurement中每个field-key对应的field-value的反余弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反余弦">计算measurement中每个field key对应的field value的反余弦</a></h6>
<pre><code class="language-sql">&gt; SELECT ACOS(*) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  acos_of_capacity
----                  -------------
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中每个存储数值的field key对应的field value的反余弦。measurement <code>park_occupancy</code>中只有一个数值类型的field：<code>of_capacity</code>。</p>
<h6 id="计算指定field-key对应的field-value的反余弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反余弦并包含多个子句">计算指定field key对应的field value的反余弦并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: park_occupancy
time                  acos
----                  ----
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-05T00:00:00Z  1.399966657665792
2020-05-04T00:00:00Z  1.3489818562981022
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反余弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-1"><a class="header" href="#高级语法-1">高级语法</a></h4>
<pre><code class="language-sql">SELECT ACOS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反余弦。</p>
<p>`ACOS()支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-29"><a class="header" href="#示例-29">示例</a></h5>
<h6 id="计算平均值的反余弦"><a class="header" href="#计算平均值的反余弦">计算平均值的反余弦</a></h6>
<pre><code class="language-sql">&gt; SELECT ACOS(MEAN(&quot;of_capacity&quot;)) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  acos
----                  ----
2020-04-30T00:00:00Z  0.9703630732143733
2020-05-03T00:00:00Z  1.1483422646081407
2020-05-06T00:00:00Z  0.7812981174487247
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值的反余弦。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ACOS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  mean
----                  ----
2020-04-30T00:00:00Z  0.565
2020-05-03T00:00:00Z  0.41
2020-05-06T00:00:00Z  0.71
2020-05-09T00:00:00Z  0.16
</code></pre>
<p>然后，cnosDB计算这些平均值的反余弦。</p>
<h3 id="asin"><a class="header" href="#asin">ASIN()</a></h3>
<p>返回field value的反正弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h4>
<pre><code>SELECT ASIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ASIN(field_key)</code>返回field key对应的field value的反正弦。</p>
<p><code>ASIN(*)</code>返回在measurement中每个field key对应的field value的反正弦。</p>
<p><code>ASIN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ASIN()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-30"><a class="header" href="#示例-30">示例</a></h5>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ASIN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;of_capacity&quot; FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<h6 id="计算指定field-key对应的field-value的反正弦"><a class="header" href="#计算指定field-key对应的field-value的反正弦">计算指定field key对应的field value的反正弦</a></h6>
<pre><code class="language-sql">&gt; SELECT ASIN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  asin
----                  ----
2020-05-01T00:00:00Z  0.9791076843683526
2020-05-02T00:00:00Z  0.3046926540153975
2020-05-03T00:00:00Z  0.9972832223717997
2020-05-04T00:00:00Z  0.22181447049679442
2020-05-05T00:00:00Z  0.1708296691291045
2020-05-06T00:00:00Z  0.8788411516685797
2020-05-07T00:00:00Z  0.6944982656265559
2020-05-08T00:00:00Z  0.8038023189330299
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正弦。</p>
<h6 id="计算measurement中每个field-key对应的field-value的反正弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正弦">计算measurement中每个field key对应的field value的反正弦</a></h6>
<pre><code class="language-sql">&gt; SELECT ASIN(*) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  asin_of_capacity
----                  -------------
2020-05-01T00:00:00Z  0.9791076843683526
2020-05-02T00:00:00Z  0.3046926540153975
2020-05-03T00:00:00Z  0.9972832223717997
2020-05-04T00:00:00Z  0.22181447049679442
2020-05-05T00:00:00Z  0.1708296691291045
2020-05-06T00:00:00Z  0.8788411516685797
2020-05-07T00:00:00Z  0.6944982656265559
2020-05-08T00:00:00Z  0.8038023189330299
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中每个存储数值的field key对应的field value的反正弦。measurement <code>park_occupancy</code>中只有一个数值类型的field：<code>of_capacity</code>。</p>
<h6 id="计算指定field-key对应的field-value的反正弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正弦并包含多个子句">计算指定field key对应的field value的反正弦并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT ASIN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: park_occupancy
time                  asin
----                  ----
2020-05-07T00:00:00Z  0.6944982656265559
2020-05-06T00:00:00Z  0.8788411516685797
2020-05-05T00:00:00Z  0.1708296691291045
2020-05-04T00:00:00Z  0.22181447049679442
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-2"><a class="header" href="#高级语法-2">高级语法</a></h4>
<pre><code class="language-sql">SELECT ASIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正弦。</p>
<p>ASIN()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a>, 
<a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h5 id="示例-31"><a class="header" href="#示例-31">示例</a></h5>
<h6 id="计算平均值的反正弦"><a class="header" href="#计算平均值的反正弦">计算平均值的反正弦</a></h6>
<pre><code class="language-sql">&gt; SELECT ASIN(MEAN(&quot;of_capacity&quot;)) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  asin
----                  ----
2020-04-30T00:00:00Z  0.6004332535805232
2020-05-03T00:00:00Z  0.42245406218675574
2020-05-06T00:00:00Z  0.7894982093461719
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值的反正弦。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ASIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  mean
----                  ----
2020-04-30T00:00:00Z  0.565
2020-05-03T00:00:00Z  0.41
2020-05-06T00:00:00Z  0.71
2020-05-09T00:00:00Z  0.16
</code></pre>
<p>然后，cnosDB计算这些平均值的反正弦。</p>
<h3 id="atan"><a class="header" href="#atan">ATAN()</a></h3>
<p>返回field value的反正切（以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h4>
<pre><code class="language-sql">SELECT ATAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN(field_key)</code>返回field key对应的field value的反正切。</p>
<p><code>ATAN(*)</code>返回在measurement中每个field key对应的field value的反正切。</p>
<p><code>ATAN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-32"><a class="header" href="#示例-32">示例</a></h5>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ATAN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;of_capacity&quot; FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<h6 id="计算指定field-key对应的field-value的反正切"><a class="header" href="#计算指定field-key对应的field-value的反正切">计算指定field key对应的field value的反正切</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  atan
----                  ----
2020-05-01T00:00:00Z  0.6927678353971222
2020-05-02T00:00:00Z  0.2914567944778671
2020-05-03T00:00:00Z  0.6986598247214632
2020-05-04T00:00:00Z  0.2165503049760893
2020-05-05T00:00:00Z  0.16839015714752992
2020-05-06T00:00:00Z  0.6561787179913948
2020-05-07T00:00:00Z  0.5693131911006619
2020-05-08T00:00:00Z  0.6240230529767568
2020-05-09T00:00:00Z  0.1586552621864014
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正切。</p>
<h6 id="计算measurement中每个field-key对应的field-value的反正切"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正切">计算measurement中每个field key对应的field value的反正切</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN(*) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  atan_of_capacity
----                  -------------
2020-05-01T00:00:00Z  0.6927678353971222
2020-05-02T00:00:00Z  0.2914567944778671
2020-05-03T00:00:00Z  0.6986598247214632
2020-05-04T00:00:00Z  0.2165503049760893
2020-05-05T00:00:00Z  0.16839015714752992
2020-05-06T00:00:00Z  0.6561787179913948
2020-05-07T00:00:00Z  0.5693131911006619
2020-05-08T00:00:00Z  0.6240230529767568
2020-05-09T00:00:00Z  0.1586552621864014
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中每个存储数值的field key对应的field value的反正切。measurement <code>park_occupancy</code>中只有一个数值类型的field：<code>of_capacity</code>。</p>
<h6 id="计算指定field-key对应的field-value的反正切并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正切并包含多个子句">计算指定field key对应的field value的反正切并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: park_occupancy
time                  atan
----                  ----
2020-05-07T00:00:00Z  0.5693131911006619
2020-05-06T00:00:00Z  0.6561787179913948
2020-05-05T00:00:00Z  0.16839015714752992
2020-05-04T00:00:00Z  0.2165503049760893
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-3"><a class="header" href="#高级语法-3">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切。</p>
<p><code>ATAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-33"><a class="header" href="#示例-33">示例</a></h5>
<h6 id="计算平均值的反正切"><a class="header" href="#计算平均值的反正切">计算平均值的反正切</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN(MEAN(&quot;of_capacity&quot;)) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                 atan
----                 ----
2020-04-30T00:00:00Z 0.5142865412694495
2020-05-03T00:00:00Z 0.3890972310552784
2020-05-06T00:00:00Z 0.6174058917515726
2020-05-09T00:00:00Z 0.1586552621864014
</code></pre>
<p>该查询返回field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值的反正切。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  mean
----                  ----
2020-04-30T00:00:00Z  0.565
2020-05-03T00:00:00Z  0.41
2020-05-06T00:00:00Z  0.71
2020-05-09T00:00:00Z  0.16
</code></pre>
<p>然后，cnosDB计算这些平均值的反正切。</p>
<h3 id="atan2"><a class="header" href="#atan2">ATAN2()</a></h3>
<p>返回以弧度表示的<code>y/x</code>的反正切。</p>
<h4 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h4>
<pre><code>SELECT ATAN2( [ * | &lt;field_key&gt; | num ], [ &lt;field_key&gt; | num ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN2(field_key_y, field_key_x)</code>返回field key “field_key_y”对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2(*, field_key_x)&lt;br /&gt;</code>返回在measurement中每个field key对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN2()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-34"><a class="header" href="#示例-34">示例</a></h5>
<p>下面的示例将使用如下模拟的飞行数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;altitude_ft&quot;, &quot;distance_ft&quot; FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z'

name: flight_data
time                  altitude_ft  distance_ft
----                  -----------  -----------
2020-05-16T12:01:00Z  1026         50094
2020-05-16T12:02:00Z  2549         53576
2020-05-16T12:03:00Z  4033         55208
2020-05-16T12:04:00Z  5579         58579
2020-05-16T12:05:00Z  7065         61213
2020-05-16T12:06:00Z  8589         64807
2020-05-16T12:07:00Z  10180        67707
2020-05-16T12:08:00Z  11777        69819
2020-05-16T12:09:00Z  13321        72452
2020-05-16T12:10:00Z  14885        75881
</code></pre>
<h6 id="计算field_key_y除以field_key_x的反正切"><a class="header" href="#计算field_key_y除以field_key_x的反正切">计算field_key_y除以field_key_x的反正切</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;altitude_ft&quot;, &quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z'

name: flight_data
time                  atan2
----                  -----
2020-05-16T12:01:00Z  0.020478631571881498
2020-05-16T12:02:00Z  0.04754142349303296
2020-05-16T12:03:00Z  0.07292147724575364
2020-05-16T12:04:00Z  0.09495251193874832
2020-05-16T12:05:00Z  0.11490822875441563
2020-05-16T12:06:00Z  0.13176409347584003
2020-05-16T12:07:00Z  0.14923587589682233
2020-05-16T12:08:00Z  0.1671059946640312
2020-05-16T12:09:00Z  0.18182893717409565
2020-05-16T12:10:00Z  0.1937028631495223
</code></pre>
<p>该查询返回field key <code>altitude_ft</code>对应的field value除以field key <code>distance_ft</code>对应的field value的反正切。这两个field key都在measurement <code>flight_data</code>中。</p>
<h6 id="计算measurement中每个field-key除以field_key_x的反正切"><a class="header" href="#计算measurement中每个field-key除以field_key_x的反正切">计算measurement中每个field key除以field_key_x的反正切</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN2(*, &quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z'

name: flight_data
time                  atan2_altitude_ft     atan2_distance_ft
----                  -----------------     -----------------
2020-05-16T12:01:00Z  0.020478631571881498  0.7853981633974483
2020-05-16T12:02:00Z  0.04754142349303296   0.7853981633974483
2020-05-16T12:03:00Z  0.07292147724575364   0.7853981633974483
2020-05-16T12:04:00Z  0.09495251193874832   0.7853981633974483
2020-05-16T12:05:00Z  0.11490822875441563   0.7853981633974483
2020-05-16T12:06:00Z  0.13176409347584003   0.7853981633974483
2020-05-16T12:07:00Z  0.14923587589682233   0.7853981633974483
2020-05-16T12:08:00Z  0.1671059946640312    0.7853981633974483
2020-05-16T12:09:00Z  0.18182893717409565   0.7853981633974483
2020-05-16T12:10:00Z  0.19370286314952234   0.7853981633974483
</code></pre>
<p>该查询返回measurement <code>flight_data</code>中每个存储数值的field key对应的field value除以field key <code>distance_ft</code>对应的field value的反正切。measurement <code>flight_data</code>中有两个数值类型的field：<code>altitude_ft</code>和<code>distance_ft</code>。</p>
<h6 id="计算field-value的反正切并包含多个子句"><a class="header" href="#计算field-value的反正切并包含多个子句">计算field value的反正切并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;altitude_ft&quot;, &quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: flight_data
time                  atan2
----                  -----
2020-05-16T12:08:00Z  0.1671059946640312
2020-05-16T12:07:00Z  0.14923587589682233
2020-05-16T12:06:00Z  0.13176409347584003
2020-05-16T12:05:00Z  0.11490822875441563
</code></pre>
<p>该查询返回field key <code>altitude_ft</code>对应的field value除以field key <code>distance_ft</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-16T12:10:00Z</code>和<code>2020-05-16T12:10:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-4"><a class="header" href="#高级语法-4">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN2(&lt;function()&gt;, &lt;function()&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切(<code>ATAN2()</code>)。</p>
<p>ATAN2()支持以下嵌套函数：</p>
<ul>
<li>COUNT()</li>
<li>MEAN()</li>
<li>MEDIAN()</li>
<li>MODE()</li>
<li>SUM()</li>
<li>FIRST()</li>
<li>LAST()</li>
<li>MIN()</li>
<li>MAX()</li>
<li>PERCENTILE()</li>
</ul>
<h5 id="示例-35"><a class="header" href="#示例-35">示例</a></h5>
<h6 id="计算平均值的反正切-1"><a class="header" href="#计算平均值的反正切-1">计算平均值的反正切</a></h6>
<pre><code class="language-sql">&gt; SELECT ATAN2(MEAN(&quot;altitude_ft&quot;), MEAN(&quot;distance_ft&quot;)) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T13:01:00Z' GROUP BY time(12m)

name: flight_data
time                  atan2
----                  -----
2020-05-16T12:00:00Z  0.133815587896842
2020-05-16T12:12:00Z  0.2662716308351908
2020-05-16T12:24:00Z  0.2958845306108965
2020-05-16T12:36:00Z  0.23783439588429497
2020-05-16T12:48:00Z  0.1906803720242831
2020-05-16T13:00:00Z  0.17291511946158172
</code></pre>
<p>该查询返回field key <code>altitude_ft</code>对应的field value的平均值除以field key <code>distance_ft</code>对应的field value的平均值的反正切。平均值是按每12分钟的时间间隔计算的。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>altitude_ft</code>和<code>distance_ft</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;altitude_ft&quot;), MEAN(&quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T13:01:00Z' GROUP BY time(12m)

name: flight_data
time                  mean                mean_1
----                  ----                ------
2020-05-16T12:00:00Z  8674                64433.181818181816
2020-05-16T12:12:00Z  26419.833333333332  96865.25
2020-05-16T12:24:00Z  40337.416666666664  132326.41666666666
2020-05-16T12:36:00Z  41149.583333333336  169743.16666666666
2020-05-16T12:48:00Z  41230.416666666664  213600.91666666666
2020-05-16T13:00:00Z  41184.5             235799
</code></pre>
<p>然后，cnosDB计算这些平均值的反正切。</p>
<h3 id="ceil"><a class="header" href="#ceil">CEIL()</a></h3>
<p>返回大于指定值的最小整数。</p>
<h4 id="基本语法-5"><a class="header" href="#基本语法-5">基本语法</a></h4>
<pre><code>SELECT CEIL( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CEIL(field_key)</code>返回field key对应的大于field value的最小整数。</p>
<p><code>CEIL(*)</code>返回在measurement中每个field key对应的大于field value的最小整数。</p>
<p><code>CEIL()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CEIL()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-36"><a class="header" href="#示例-36">示例</a></h5>
<p>下面的示例将使用<a href="content/cnosdb/0.10/cnosql/NOAA_water_database.txt"><code>NOAA_water_database</code>数据集</a>的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的大于field-value的最小整数"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数">计算指定field key对应的大于field value的最小整数</a></h6>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ceil
----                  ----
2020-08-18T00:00:00Z  3
2020-08-18T00:06:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:18:00Z  3
2020-08-18T00:24:00Z  3
2020-08-18T00:30:00Z  3
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的大于field value的最小整数。</p>
<h6 id="计算measurement中每个field-key对应的大于field-value的最小整数"><a class="header" href="#计算measurement中每个field-key对应的大于field-value的最小整数">计算measurement中每个field key对应的大于field value的最小整数</a></h6>
<pre><code class="language-sql">&gt; SELECT CEIL(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ceil_water_level
----                  ----------------
2020-08-18T00:00:00Z  3
2020-08-18T00:06:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:18:00Z  3
2020-08-18T00:24:00Z  3
2020-08-18T00:30:00Z  3
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的大于field value的最小整数。measurement <code>h2o_feet</code>只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的大于field-value的最小整数并包含多个子句"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数并包含多个子句">计算指定field key对应的大于field value的最小整数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  ceil
----                  ----
2020-08-18T00:18:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:06:00Z  3
2020-08-18T00:00:00Z  3
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的大于field value的最小整数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-5"><a class="header" href="#高级语法-5">高级语法</a></h4>
<pre><code>SELECT CEIL(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>CEIL()</code>应用于这些结果。</p>
<p><code>CEIL()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-37"><a class="header" href="#示例-37">示例</a></h5>
<h6 id="计算大于平均值的最小整数"><a class="header" href="#计算大于平均值的最小整数">计算大于平均值的最小整数</a></h6>
<pre><code class="language-sql">&gt; SELECT CEIL(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  ceil
----                  ----
2020-08-18T00:00:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:24:00Z  3
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的大于<code>water_level</code>平均值的最小整数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的大于<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CEIL()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算大于这些平均值的最小整数。</p>
<h3 id="cos"><a class="header" href="#cos">COS()</a></h3>
<p>返回field value的余弦值。</p>
<h4 id="基本语法-6"><a class="header" href="#基本语法-6">基本语法</a></h4>
<pre><code>SELECT COS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>COS(field_key)</code>返回field key对应的field value的余弦值。</p>
<p><code>COS(*)</code>返回在measurement中每个field key对应的field value的余弦值。</p>
<p><code>COS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>COS()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-38"><a class="header" href="#示例-38">示例</a></h5>
<h6 id="下面的示例将使用noaa_water_database数据集的如下数据"><a class="header" href="#下面的示例将使用noaa_water_database数据集的如下数据">下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</a></h6>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的余弦值"><a class="header" href="#计算指定field-key对应的field-value的余弦值">计算指定field key对应的field value的余弦值</a></h6>
<pre><code class="language-sql">&gt; SELECT COS(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  cos
----                  ---
2020-08-18T00:00:00Z  -0.47345017433543124
2020-08-18T00:06:00Z  -0.5185922462666872
2020-08-18T00:12:00Z  -0.4414407189100776
2020-08-18T00:18:00Z  -0.5271163912192579
2020-08-18T00:24:00Z  -0.45306786455514825
2020-08-18T00:30:00Z  -0.4619598230611262
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的余弦值。</p>
<h6 id="计算measurement中每个field-key对应的field-value的余弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的余弦值">计算measurement中每个field key对应的field value的余弦值</a></h6>
<pre><code class="language-sql">&gt; SELECT COS(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  cos_water_level
----                  ---------------
2020-08-18T00:00:00Z  -0.47345017433543124
2020-08-18T00:06:00Z  -0.5185922462666872
2020-08-18T00:12:00Z  -0.4414407189100776
2020-08-18T00:18:00Z  -0.5271163912192579
2020-08-18T00:24:00Z  -0.45306786455514825
2020-08-18T00:30:00Z  -0.4619598230611262
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的余弦值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的余弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的余弦值并包含多个子句">计算指定field key对应的field value的余弦值并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT COS(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  cos
----                  ---
2020-08-18T00:18:00Z  -0.5271163912192579
2020-08-18T00:12:00Z  -0.4414407189100776
2020-08-18T00:06:00Z  -0.5185922462666872
2020-08-18T00:00:00Z  -0.47345017433543124
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的余弦值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-6"><a class="header" href="#高级语法-6">高级语法</a></h4>
<pre><code>SELECT COS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的余弦值。</p>
<p><code>COS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-39"><a class="header" href="#示例-39">示例</a></h4>
<h6 id="计算平均值的余弦值"><a class="header" href="#计算平均值的余弦值">计算平均值的余弦值</a></h6>
<pre><code class="language-sql">&gt; SELECT COS(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  cos
----                  ---
2020-08-18T00:00:00Z  -0.49618891270599885
2020-08-18T00:12:00Z  -0.4848605136571181
2020-08-18T00:24:00Z  -0.4575195627907578
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的余弦值。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>COS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的余弦值。</p>
<h3 id="cumulative_sum"><a class="header" href="#cumulative_sum">CUMULATIVE_SUM()</a></h3>
<p>返回field value的累积总和。</p>
<h4 id="基本语法-7"><a class="header" href="#基本语法-7">基本语法</a></h4>
<pre><code>SELECT CUMULATIVE_SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CUMULATIVE_SUM(field_key)</code>返回field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(*)</code>返回在measurement中每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CUMULATIVE_SUM()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-40"><a class="header" href="#示例-40">示例</a></h5>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的累积总和"><a class="header" href="#计算指定field-key对应的field-value的累积总和">计算指定field key对应的field value的累积总和</a></h6>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   cumulative_sum
----                   --------------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   4.18
2020-08-18T00:12:00Z   6.208
2020-08-18T00:18:00Z   8.334
2020-08-18T00:24:00Z   10.375
2020-08-18T00:30:00Z   12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的累积总和。</p>
<h6 id="计算measurement中每个field-key对应的field-value的累积总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的累积总和">计算measurement中每个field key对应的field value的累积总和</a></h6>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   cumulative_sum_water_level
----                   --------------------------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   4.18
2020-08-18T00:12:00Z   6.208
2020-08-18T00:18:00Z   8.334
2020-08-18T00:24:00Z   10.375
2020-08-18T00:30:00Z   12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的累积总和。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算与正则表达式匹配的每个field-key对应的field-value的累积总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的累积总和">计算与正则表达式匹配的每个field key对应的field value的累积总和</a></h6>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(/water/) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   cumulative_sum_water_level
----                   --------------------------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   4.18
2020-08-18T00:12:00Z   6.208
2020-08-18T00:18:00Z   8.334
2020-08-18T00:24:00Z   10.375
2020-08-18T00:30:00Z   12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的累积总和。</p>
<h6 id="计算指定field-key对应的field-value的累积总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的累积总和并包含多个子句">计算指定field key对应的field value的累积总和并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  cumulative_sum
----                  --------------
2020-08-18T00:18:00Z  6.218
2020-08-18T00:12:00Z  8.246
2020-08-18T00:06:00Z  10.362
2020-08-18T00:00:00Z  12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的累积总和，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-7"><a class="header" href="#高级语法-7">高级语法</a></h4>
<pre><code class="language-sql">SELECT CUMULATIVE_SUM(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-41"><a class="header" href="#示例-41">示例</a></h5>
<h6 id="计算平均值的累积总和"><a class="header" href="#计算平均值的累积总和">计算平均值的累积总和</a></h6>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   cumulative_sum
----                   --------------
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   4.167
2020-08-18T00:24:00Z   6.213
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的累积总和。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CUMULATIVE_SUM()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的累积总和。最终查询结果中的第二个<code>point</code>(<code>4.167</code>)是<code>2.09</code>和<code>2.077</code>的总和，第三个<code>point</code>(<code>6.213</code>)是<code>2.09</code>、<code>2.077</code>和<code>2.0460000000000003</code>的总和。</p>
<h3 id="derivative"><a class="header" href="#derivative">DERIVATIVE()</a></h3>
<p>返回field value之间的变化率，即导数。</p>
<h4 id="基本语法-8"><a class="header" href="#基本语法-8">基本语法</a></h4>
<pre><code>SELECT DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>cnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>DERIVATIVE(field_key)</code>返回field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-42"><a class="header" href="#示例-42">示例</a></h5>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的导数"><a class="header" href="#计算指定field-key对应的field-value的导数">计算指定field key对应的field value的导数</a></h6>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:06:00Z   0.00014444444444444457
2020-08-18T00:12:00Z   -0.00024444444444444465
2020-08-18T00:18:00Z   0.0002722222222222218
2020-08-18T00:24:00Z   -0.000236111111111111
2020-08-18T00:30:00Z   2.777777777777842e-05
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的每秒变化率。</p>
<p>第一个结果(<code>0.00014444444444444457</code>)是原始数据中前两个field value在一秒内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率：</p>
<pre><code>(2.116 - 2.064) / (360s / 1s)
--------------    ----------
       |               |
       |          the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<h6 id="计算指定field-key对应的field-value的导数并指定unit"><a class="header" href="#计算指定field-key对应的field-value的导数并指定unit">计算指定field key对应的field value的导数并指定<code>unit</code></a></h6>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;water_level&quot;,6m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time			derivative
----			----------
2020-08-18T00:06:00Z	0.052000000000000046
2020-08-18T00:12:00Z	-0.08800000000000008
2020-08-18T00:18:00Z	0.09799999999999986
2020-08-18T00:24:00Z	-0.08499999999999996
2020-08-18T00:30:00Z	0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的每六分钟的变化率。</p>
<p>第一个结果(<code>0.052000000000000046</code>)是原始数据中前两个field value在六分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 6m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<h6 id="计算measurement中每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算measurement中每个field-key对应的field-value的导数并指定unit">计算measurement中每个field key对应的field value的导数并指定<code>unit</code></a></h6>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(*,3m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'


name: h2o_feet
time                   derivative_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.026000000000000023
2020-08-18T00:12:00Z   -0.04400000000000004
2020-08-18T00:18:00Z   0.04899999999999993
2020-08-18T00:24:00Z   -0.04249999999999998
2020-08-18T00:30:00Z   0.0050000000000001155
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的每三分钟的变化率。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<p>第一个结果(<code>0.026000000000000023</code>)是原始数据中前两个field value在三分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为三分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 3m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<h6 id="计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit">计算与正则表达式匹配的每个field key对应的field value的导数并指定<code>unit</code></a></h6>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(/water/,2m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   derivative_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.01733333333333335
2020-08-18T00:12:00Z   -0.02933333333333336
2020-08-18T00:18:00Z   0.03266666666666662
2020-08-18T00:24:00Z   -0.02833333333333332
2020-08-18T00:30:00Z   0.0033333333333334103
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的每两分钟的变化率。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<p>第一个结果(<code>0.01733333333333335</code>)是原始数据中前两个field value在两分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为两分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 2m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<h6 id="计算指定field-key对应的field-value的导数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的导数并包含多个子句">计算指定field key对应的field value的导数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' ORDER BY time DESC LIMIT 1 OFFSET 2

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:12:00Z   -0.0002722222222222218
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的每秒变化率，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<p>唯一的结果(<code>-0.0002722222222222218</code>)是原始数据中前两个field value在一秒内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率：</p>
<pre><code>(2.126 - 2.028) / (360s / 1s)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<h4 id="高级语法-8"><a class="header" href="#高级语法-8">高级语法</a></h4>
<pre><code>SELECT DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。</p>
<p><code>DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-43"><a class="header" href="#示例-43">示例</a></h5>
<h6 id="计算平均值的导数"><a class="header" href="#计算平均值的导数">计算平均值的导数</a></h6>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:12:00Z   -0.0129999999999999
2020-08-18T00:24:00Z   -0.030999999999999694
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的每12分钟变化率。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的每12分钟的变化率。第一个结果(<code>-0.0129999999999999</code>)是原始数据中前两个field value在12分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为12分钟的变化率：</p>
<pre><code>(2.077 - 2.09) / (12m / 12m)
-------------    ----------
       |               |
       |          the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<h6 id="计算平均值的导数并指定unit"><a class="header" href="#计算平均值的导数并指定unit">计算平均值的导数并指定<code>unit</code></a></h6>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;water_level&quot;),6m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:12:00Z   -0.00649999999999995
2020-08-18T00:24:00Z   -0.015499999999999847
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的每六分钟变化率。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的每六分钟的变化率。第一个结果(<code>-0.00649999999999995</code>)是原始数据中前两个field value在六分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code class="language-sql">(2.077 - 2.09) / (12m / 6m)
-------------    ----------
       |               |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<h3 id="difference"><a class="header" href="#difference">DIFFERENCE()</a></h3>
<p>返回field value之间的差值。</p>
<h4 id="基本语法-9"><a class="header" href="#基本语法-9">基本语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>DIFFERENCE(field_key)</code>返回field key对应的field value的差值。</p>
<p><code>DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-44"><a class="header" href="#示例-44">示例</a></h5>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的差值"><a class="header" href="#计算指定field-key对应的field-value的差值">计算指定field key对应的field value的差值</a></h6>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   difference
----                   ----------
2020-08-18T00:06:00Z   0.052000000000000046
2020-08-18T00:12:00Z   -0.08800000000000008
2020-08-18T00:18:00Z   0.09799999999999986
2020-08-18T00:24:00Z   -0.08499999999999996
2020-08-18T00:30:00Z   0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value之间的差值。</p>
<h6 id="计算measurement中每个field-key对应的field-value的差值"><a class="header" href="#计算measurement中每个field-key对应的field-value的差值">计算measurement中每个field key对应的field value的差值</a></h6>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   difference_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.052000000000000046
2020-08-18T00:12:00Z   -0.08800000000000008
2020-08-18T00:18:00Z   0.09799999999999986
2020-08-18T00:24:00Z   -0.08499999999999996
2020-08-18T00:30:00Z   0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value之间的差值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算与正则表达式匹配的每个field-key对应的field-value的差值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的差值">计算与正则表达式匹配的每个field key对应的field value的差值</a></h6>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(/water/) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   difference_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.052000000000000046
2020-08-18T00:12:00Z   -0.08800000000000008
2020-08-18T00:18:00Z   0.09799999999999986
2020-08-18T00:24:00Z   -0.08499999999999996
2020-08-18T00:30:00Z   0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value之间的差值。</p>
<h6 id="计算指定field-key对应的field-value的差值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的差值并包含多个子句">计算指定field key对应的field value的差值并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 2 OFFSET 2

name: h2o_feet
time                   difference
----                   ----------
2020-08-18T00:12:00Z   -0.09799999999999986
2020-08-18T00:06:00Z   0.08800000000000008
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value之间的差值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-9"><a class="header" href="#高级语法-9">高级语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的差值。</p>
<p>DIFFERENCE()支持以下嵌套函数：
<a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h5 id="示例-45"><a class="header" href="#示例-45">示例</a></h5>
<h6 id="计算最大值之间的差值"><a class="header" href="#计算最大值之间的差值">计算最大值之间的差值</a></h6>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(MAX(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   difference
----                   ----------
2020-08-18T00:12:00Z   0.009999999999999787
2020-08-18T00:24:00Z   -0.07499999999999973
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的最大值之间的差值。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DIFFERENCE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   max
----                   ---
2020-08-18T00:00:00Z   2.116
2020-08-18T00:12:00Z   2.126
2020-08-18T00:24:00Z   2.051
</code></pre>
<p>然后，cnosDB计算这些最大值之间的差值。最终查询结果中的第一个<code>point</code>(<code>0.009999999999999787</code>)是<code>2.126</code>和<code>2.116</code>的差，第二个<code>point</code>(<code>-0.07499999999999973</code>)是<code>2.051</code>和<code>2.126</code>的差。</p>
<h3 id="elapsed"><a class="header" href="#elapsed">ELAPSED()</a></h3>
<p>返回field value的时间戳之间的差值。</p>
<h4 id="语法-24"><a class="header" href="#语法-24">语法</a></h4>
<pre><code>SELECT ELAPSED( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>cnosDB计算时间戳之间的差值。参数<code>unit</code>的值是一个整数，后跟一个时间单位，它决定了返回的差值的单位。这个参数是可选的，不是必须要有的。如果没有指定<code>unit</code>的值，那么查询将返回以纳秒为单位的两个时间戳之间的差值。</p>
<p><code>ELAPSED(field_key)</code>返回field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(*)</code>返回在measurement中每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED()</code>支持所有数据类型的field value。</p>
<h4 id="示例-46"><a class="header" href="#示例-46">示例</a></h4>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
</code></pre>
<h5 id="计算指定field-key对应的field-value之间的时间间隔"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔">计算指定field key对应的field value之间的时间间隔</a></h5>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:06:00Z   360000000000
2020-08-18T00:12:00Z   360000000000
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的时间戳之间的差值(以纳秒为单位)。</p>
<h5 id="计算指定field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并指定unit">计算指定field key对应的field value之间的时间间隔并指定<code>unit</code></a></h5>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:06:00Z   6
2020-08-18T00:12:00Z   6
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的时间戳之间的差值(以分钟为单位)。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h5>
<pre><code class="language-sql">&gt; SELECT ELAPSED(*,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed_level description   elapsed_water_level
----                   -------------------------   -------------------
2020-08-18T00:06:00Z   6                           6
2020-08-18T00:12:00Z   6                           6
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<h5 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit-1"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit-1">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h5>
<pre><code class="language-sql">&gt; SELECT ELAPSED(/level/,1s) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed_level description   elapsed_water_level
----                   -------------------------   -------------------
2020-08-18T00:06:00Z   360                         360
2020-08-18T00:12:00Z   360                         360
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<h5 id="计算指定field-key对应的field-value之间的时间间隔并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并包含多个子句">计算指定field key对应的field value之间的时间间隔并包含多个子句</a></h5>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;,1ms) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z' ORDER BY time DESC LIMIT 1 OFFSET 1

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:00:00Z   -360000
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的时间戳之间的差值(以毫秒为单位)，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:12:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移一个（即前一个<code>point</code>不返回）。</p>
<p>请注意，查询结果是负数；因为<code>ORDER BY time DESC</code>子句按递减的顺序对时间戳进行排序，所以<code>ELAPSED()</code>以相反的顺序计算时间戳的差值。</p>
<h3 id="elapsed的常见问题"><a class="header" href="#elapsed的常见问题"><code>ELAPSED()</code>的常见问题</a></h3>
<h4 id="elapsed和大于经过时间的单位"><a class="header" href="#elapsed和大于经过时间的单位"><code>ELAPSED()</code>和大于经过时间的单位</a></h4>
<p>I如果<code>unit</code>的值大于时间戳之间的差值，那么cnosDB将会返回<code>0</code>。</p>
<h5 id="示例-47"><a class="header" href="#示例-47">示例</a></h5>
<p>measurement <code>h2o_feet</code>中每六分钟有一个<code>point</code>。如果查询将<code>unit</code>设置为一小时，cnosDB将会返回<code>0</code>：</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;,1h) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:06:00Z   0
2020-08-18T00:12:00Z   0
</code></pre>
<h4 id="elapsed和group-by-time子句同时使用"><a class="header" href="#elapsed和group-by-time子句同时使用"><code>ELAPSED()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
<p><code>ELAPSED()</code>函数支持<code>GROUP BY time()</code>子句，但是查询结果不是特别有用。目前，如果<code>ELAPSED()</code>查询包含一个嵌套的cnosQL函数和一个<code>GROUP BY time()</code>子句，那么只会返回指定<code>GROUP BY time()</code>子句中的时间间隔。</p>
<p><code>GROUP BY time()</code>子句决定了查询结果中的时间戳：每个时间戳表示时间间隔的开始时间。该行为也适用于嵌套的selector函数(例如<code>FIRST()</code>或<code>MAX()</code>)，而在其它的所有情况下，这些函数返回的是原始数据的特定时间戳。因为<code>GROUP BY time()</code>子句会覆盖原始时间戳，所以<code>ELAPSED()</code>始终返回与<code>GROUP BY time()</code>的时间间隔相同的时间戳。</p>
<h5 id="示例-48"><a class="header" href="#示例-48">示例</a></h5>
<p>下面代码块中的第一个查询尝试使用<code>ELAPSED()</code>和<code>GROUP BY time()</code>子句来查找最小的<code>water_level</code>的值之间经过的时间(以分钟为单位)。查询的两个时间间隔都返回了12分钟。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔的<code>water_level</code>的最小值。代码块中的第二个查询展示了这一步的结果。这一步跟同时使用<code>MIN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ELAPSED()</code>的情形一样。请注意，第二个查询返回的时间戳间隔12分钟。在原始数据中，第一个结果(<code>2.057</code>)发生在<code>2020-08-18T00:42:00Z</code>，但是<code>GROUP BY time()</code>子句覆盖了原始的时间戳。因为时间戳由<code>GROUP BY time()</code>的时间间隔(而不是原始数据)决定，所以<code>ELAPSED()</code>始终返回与GROUP BY time()的时间间隔相同的时间戳。</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(MIN(&quot;water_level&quot;),1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:36:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m)

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:36:00Z   12
2020-08-18T00:48:00Z   12

&gt; SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:36:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m)

name: h2o_feet
time                   min
----                   ---
2020-08-18T00:36:00Z   2.057    &lt;--- Actually occurs at 2020-08-18T00:42:00Z
2020-08-18T00:48:00Z   1.991
</code></pre>
<h3 id="exp"><a class="header" href="#exp">EXP()</a></h3>
<p>返回field value的指数。</p>
<h4 id="基本语法-10"><a class="header" href="#基本语法-10">基本语法</a></h4>
<pre><code>SELECT EXP( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>EXP(field_key)</code>返回field key对应的field value的指数。</p>
<p><code>EXP(*)</code>返回在measurement中每个field key对应的field value的指数。</p>
<p><code>EXP()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>EXP()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-49"><a class="header" href="#示例-49">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.85.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的指数"><a class="header" href="#计算指定field-key对应的field-value的指数">计算指定field key对应的field value的指数</a></h6>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  exp
----                  ---
2020-08-18T00:00:00Z  7.877416541092307
2020-08-18T00:06:00Z  8.297879498060171
2020-08-18T00:12:00Z  7.598873404088091
2020-08-18T00:18:00Z  8.381274573459967
2020-08-18T00:24:00Z  7.6983036546645645
2020-08-18T00:30:00Z  7.775672892658607
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的指数。</p>
<h6 id="计算measurement中每个field-key对应的field-value的指数"><a class="header" href="#计算measurement中每个field-key对应的field-value的指数">计算measurement中每个field key对应的field value的指数</a></h6>
<pre><code class="language-sql">&gt; SELECT EXP(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  exp_water_level
----                  ---------------
2020-08-18T00:00:00Z  7.877416541092307
2020-08-18T00:06:00Z  8.297879498060171
2020-08-18T00:12:00Z  7.598873404088091
2020-08-18T00:18:00Z  8.381274573459967
2020-08-18T00:24:00Z  7.6983036546645645
2020-08-18T00:30:00Z  7.775672892658607
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的指数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的指数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的指数并包含多个子句">计算指定field key对应的field value的指数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  exp
----                  ---
2020-08-18T00:18:00Z  8.381274573459967
2020-08-18T00:12:00Z  7.598873404088091
2020-08-18T00:06:00Z  8.297879498060171
2020-08-18T00:00:00Z  7.877416541092307
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的指数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-10"><a class="header" href="#高级语法-10">高级语法</a></h4>
<pre><code>SELECT EXP(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的指数。</p>
<p>EXP()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h5 id="示例-50"><a class="header" href="#示例-50">示例</a></h5>
<h6 id="计算平均值的指数"><a class="header" href="#计算平均值的指数">计算平均值的指数</a></h6>
<pre><code class="language-sql">&gt; SELECT EXP(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  exp
----                  ---
2020-08-18T00:00:00Z  8.084915164305059
2020-08-18T00:12:00Z  7.980491491670466
2020-08-18T00:24:00Z  7.736891562315577
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的绝对值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>EXP()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>.然后，cnosDB计算这些平均值的指数。</p>
<h3 id="floor"><a class="header" href="#floor">FLOOR()</a></h3>
<p>返回小于指定值的最大整数。</p>
<h4 id="基本语法-11"><a class="header" href="#基本语法-11">基本语法</a></h4>
<pre><code>SELECT FLOOR( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>FLOOR(field_key)</code>返回field key对应的小于field value的最大整数。</p>
<p><code>FLOOR(*)</code>返回在measurement中每个field key对应的小于field value的最大整数。</p>
<p><code>FLOOR()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>FLOOR()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-51"><a class="header" href="#示例-51">示例</a></h5>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的小于field-value的最大整数"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数">计算指定field key对应的小于field value的最大整数</a></h6>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  floor
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的小于field value的最大整数。</p>
<h6 id="计算measurement中每个field-key对应的小于field-value的最大整数"><a class="header" href="#计算measurement中每个field-key对应的小于field-value的最大整数">计算measurement中每个field key对应的小于field value的最大整数</a></h6>
<pre><code class="language-sql">&gt; SELECT FLOOR(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  floor_water_level
----                  -----------------
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的小于field value的最大整数。measurement <code>h2o_feet</code>只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的小于field-value的最大整数并包含多个子句"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数并包含多个子句">计算指定field key对应的小于field value的最大整数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  floor
----                  -----
2020-08-18T00:18:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:00:00Z  2
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的小于field value的最大整数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-11"><a class="header" href="#高级语法-11">高级语法</a></h4>
<pre><code>SELECT FLOOR(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>FLOOR()</code>应用于这些结果。</p>
<p><code>FLOOR()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-52"><a class="header" href="#示例-52">示例</a></h5>
<h6 id="计算小于平均值的最大整数"><a class="header" href="#计算小于平均值的最大整数">计算小于平均值的最大整数</a></h6>
<pre><code class="language-sql">&gt; SELECT FLOOR(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  floor
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:24:00Z  2
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的小于<code>water_level</code>平均值的最大整数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>FLOOR()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算小于这些平均值的最大整数。</p>
<h3 id="ln"><a class="header" href="#ln">LN()</a></h3>
<p>返回field value的自然对数。</p>
<h4 id="基本语法-12"><a class="header" href="#基本语法-12">基本语法</a></h4>
<pre><code>SELECT LN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LN(field_key)</code>返回field key对应的field value的自然对数。</p>
<p><code>LN(*)</code>返回在measurement中每个field key对应的field value的自然对数。</p>
<p><code>LN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LN()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-53"><a class="header" href="#示例-53">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.86.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的自然对数"><a class="header" href="#计算指定field-key对应的field-value的自然对数">计算指定field key对应的field value的自然对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ln
----                  --
2020-08-18T00:00:00Z  0.7246458476193163
2020-08-18T00:06:00Z  0.749527513996053
2020-08-18T00:12:00Z  0.7070500857289368
2020-08-18T00:18:00Z  0.7542422799197561
2020-08-18T00:24:00Z  0.7134398838277077
2020-08-18T00:30:00Z  0.7183274790902436
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的自然对数。</p>
<h6 id="计算measurement中每个field-key对应的field-value的自然对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的自然对数">计算measurement中每个field key对应的field value的自然对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LN(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ln_water_level
----                  --------------
2020-08-18T00:00:00Z  0.7246458476193163
2020-08-18T00:06:00Z  0.749527513996053
2020-08-18T00:12:00Z  0.7070500857289368
2020-08-18T00:18:00Z  0.7542422799197561
2020-08-18T00:24:00Z  0.7134398838277077
2020-08-18T00:30:00Z  0.7183274790902436
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的自然对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的自然对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的自然对数并包含多个子句">计算指定field key对应的field value的自然对数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT LN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  ln
----                  --
2020-08-18T00:18:00Z  0.7542422799197561
2020-08-18T00:12:00Z  0.7070500857289368
2020-08-18T00:06:00Z  0.749527513996053
2020-08-18T00:00:00Z  0.7246458476193163
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的自然对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-12"><a class="header" href="#高级语法-12">高级语法</a></h4>
<pre><code>SELECT LN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个 GROUP BY time() <code>和一个嵌套的cnosQL 函数. 该查询受限以指定</code>GROUP BY time()<code>间隔计算嵌套函数的结果 </code>LN()` .</p>
<p>LN()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h5 id="示例-54"><a class="header" href="#示例-54">示例</a></h5>
<h6 id="计算平均值的自然对数"><a class="header" href="#计算平均值的自然对数">计算平均值的自然对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LN(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  ln
----                  --
2020-08-18T00:00:00Z  0.7371640659767196
2020-08-18T00:12:00Z  0.7309245448939752
2020-08-18T00:24:00Z  0.7158866675294349
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的自然对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的自然对数。</p>
<h3 id="log"><a class="header" href="#log">LOG()</a></h3>
<p>返回field value的以<code>b</code>为底数的对数。</p>
<h4 id="基本语法-13"><a class="header" href="#基本语法-13">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG( [ * | &lt;field_key&gt; ], &lt;b&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG(field_key, b)</code>返回field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG(*, b)</code>返回在measurement中每个field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-55"><a class="header" href="#示例-55">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.87.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数">计算指定field key对应的field value的以4为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log
----                  ---
2020-08-18T00:00:00Z  0.5227214853805835
2020-08-18T00:06:00Z  0.5406698137259695
2020-08-18T00:12:00Z  0.5100288261706268
2020-08-18T00:18:00Z  0.5440707984345088
2020-08-18T00:24:00Z  0.5146380911853161
2020-08-18T00:30:00Z  0.5181637459088826
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以4为底数的对数。</p>
<h6 id="计算measurement中每个field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以4为底数的对数">计算measurement中每个field key对应的field value的以4为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG(*, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log_water_level
----                  ---------------
2020-08-18T00:00:00Z  0.5227214853805835
2020-08-18T00:06:00Z  0.5406698137259695
2020-08-18T00:12:00Z  0.5100288261706268
2020-08-18T00:18:00Z  0.5440707984345088
2020-08-18T00:24:00Z  0.5146380911853161
2020-08-18T00:30:00Z  0.5181637459088826
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的以4为底数的对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的以4为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数并包含多个子句">计算指定field key对应的field value的以4为底数的对数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  log
----                  ---
2020-08-18T00:18:00Z  0.5440707984345088
2020-08-18T00:12:00Z  0.5100288261706268
2020-08-18T00:06:00Z  0.5406698137259695
2020-08-18T00:00:00Z  0.5227214853805835
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以4为底数的对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-13"><a class="header" href="#高级语法-13">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;b&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的对数。</p>
<p><code>LOG()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-56"><a class="header" href="#示例-56">示例</a></h5>
<h6 id="计算平均值的以4为底数的对数"><a class="header" href="#计算平均值的以4为底数的对数">计算平均值的以4为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG(MEAN(&quot;water_level&quot;), 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  log
----                  ---
2020-08-18T00:00:00Z  0.531751471153079
2020-08-18T00:12:00Z  0.5272506080912802
2020-08-18T00:24:00Z  0.5164030725416209
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的以4为底数的对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的以4为底数的对数。</p>
<h3 id="log2"><a class="header" href="#log2">LOG2()</a></h3>
<p>返回field value的以2为底数的对数。</p>
<h4 id="基本语法-14"><a class="header" href="#基本语法-14">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG2( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG2(field_key)</code>返回field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2(*)</code>返回在measurement中每个field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG2()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-57"><a class="header" href="#示例-57">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.88.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数">计算指定field key对应的field value的以2为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log2
----                  ----
2020-08-18T00:00:00Z  1.045442970761167
2020-08-18T00:06:00Z  1.081339627451939
2020-08-18T00:12:00Z  1.0200576523412537
2020-08-18T00:18:00Z  1.0881415968690176
2020-08-18T00:24:00Z  1.0292761823706322
2020-08-18T00:30:00Z  1.0363274918177652
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以2为底数的对数。</p>
<h6 id="计算measurement中每个field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以2为底数的对数">计算measurement中每个field key对应的field value的以2为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG2(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log2_water_level
----                  ----------------
2020-08-18T00:00:00Z  1.045442970761167
2020-08-18T00:06:00Z  1.081339627451939
2020-08-18T00:12:00Z  1.0200576523412537
2020-08-18T00:18:00Z  1.0881415968690176
2020-08-18T00:24:00Z  1.0292761823706322
2020-08-18T00:30:00Z  1.0363274918177652
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的以2为底数的对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的以2为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数并包含多个子句">计算指定field key对应的field value的以2为底数的对数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  log2
----                  ----
2020-08-18T00:18:00Z  1.0881415968690176
2020-08-18T00:12:00Z  1.0200576523412537
2020-08-18T00:06:00Z  1.081339627451939
2020-08-18T00:00:00Z  1.045442970761167
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以2为底数的对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-14"><a class="header" href="#高级语法-14">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG2(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以2为底数的对数。</p>
<p><code>LOG2()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-58"><a class="header" href="#示例-58">示例</a></h5>
<h6 id="计算平均值的以2为底数的对数"><a class="header" href="#计算平均值的以2为底数的对数">计算平均值的以2为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG2(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  log2
----                  ----
2020-08-18T00:00:00Z  1.063502942306158
2020-08-18T00:12:00Z  1.0545012161825604
2020-08-18T00:24:00Z  1.0328061450832418
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的以2为底数的对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的以2为底数的对数。</p>
<h3 id="log10"><a class="header" href="#log10">LOG10()</a></h3>
<p>返回field value的以10为底数的对数。</p>
<h4 id="基本语法-15"><a class="header" href="#基本语法-15">基本语法</a></h4>
<pre><code>SELECT LOG10( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG10(field_key)</code>返回field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10(*)</code>返回在measurement中每个field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG10()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-59"><a class="header" href="#示例-59">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.89.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数">计算指定field key对应的field value的以10为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log10
----                  -----
2020-08-18T00:00:00Z  0.3147096929551737
2020-08-18T00:06:00Z  0.32551566336314813
2020-08-18T00:12:00Z  0.3070679506612984
2020-08-18T00:18:00Z  0.32756326018727794
2020-08-18T00:24:00Z  0.3098430047160705
2020-08-18T00:30:00Z  0.3119656603683663
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以10为底数的对数。</p>
<h6 id="计算measurement中每个field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以10为底数的对数">计算measurement中每个field key对应的field value的以10为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG10(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log10_water_level
----                  -----------------
2020-08-18T00:00:00Z  0.3147096929551737
2020-08-18T00:06:00Z  0.32551566336314813
2020-08-18T00:12:00Z  0.3070679506612984
2020-08-18T00:18:00Z  0.32756326018727794
2020-08-18T00:24:00Z  0.3098430047160705
2020-08-18T00:30:00Z  0.3119656603683663
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的以10为底数的对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的以10为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数并包含多个子句">计算指定field key对应的field value的以10为底数的对数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  log10
----                  -----
2020-08-18T00:18:00Z  0.32756326018727794
2020-08-18T00:12:00Z  0.3070679506612984
2020-08-18T00:06:00Z  0.32551566336314813
2020-08-18T00:00:00Z  0.3147096929551737
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以10为底数的对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-15"><a class="header" href="#高级语法-15">高级语法</a></h4>
<pre><code>SELECT LOG10(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以10为底数的对数。</p>
<p><code>LOG10()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-60"><a class="header" href="#示例-60">示例</a></h5>
<h6 id="计算平均值的以10为底数的对数"><a class="header" href="#计算平均值的以10为底数的对数">计算平均值的以10为底数的对数</a></h6>
<pre><code class="language-sql">&gt; SELECT LOG10(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  log10
----                  -----
2020-08-18T00:00:00Z  0.32014628611105395
2020-08-18T00:12:00Z  0.3174364965350991
2020-08-18T00:24:00Z  0.3109056293761414
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的以10为底数的对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG10()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的以10为底数的对数。</p>
<h3 id="moving_average"><a class="header" href="#moving_average">MOVING_AVERAGE()</a></h3>
<p>返回field value窗口的滚动平均值。</p>
<h4 id="基本语法-16"><a class="header" href="#基本语法-16">基本语法</a></h4>
<pre><code class="language-sql">SELECT MOVING_AVERAGE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] , &lt;N&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MOVING_AVERAGE()</code>计算包含<code>N</code>个连续field value的窗口的滚动平均值。参数<code>N</code>是一个整数，并且它是必须的。</p>
<p><code>MOVING_AVERAGE(field_key,N)</code>返回field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(*,N)</code>返回在measurement中每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>MOVING_AVERAGE()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-61"><a class="header" href="#示例-61">示例</a></h5>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的滚动平均值"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值">计算指定field key对应的field value的滚动平均值</a></h6>
<pre><code>&gt; SELECT MOVING_AVERAGE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   moving_average
----                   --------------
2020-08-18T00:06:00Z   2.09
2020-08-18T00:12:00Z   2.072
2020-08-18T00:18:00Z   2.077
2020-08-18T00:24:00Z   2.0835
2020-08-18T00:30:00Z   2.0460000000000003
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的窗口大小为两个field value的滚动平均值。第一个结果(<code>2.09</code>)是原始数据中前两个field value的平均值：(2.064 + 2.116) / 2。第二个结果(<code>2.072</code>)是原始数据中第二和第三个field value的平均值：(2.116 + 2.028) / 2。</p>
<h6 id="计算measurement中每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的滚动平均值">计算measurement中每个field key对应的field value的滚动平均值</a></h6>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(*,3) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   moving_average_water_level
----                   --------------------------
2020-08-18T00:12:00Z   2.0693333333333332
2020-08-18T00:18:00Z   2.09
2020-08-18T00:24:00Z   2.065
2020-08-18T00:30:00Z   2.0726666666666667
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的窗口大小为三个field value的滚动平均值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值">计算与正则表达式匹配的每个field key对应的field value的滚动平均值</a></h6>
<pre><code>&gt; SELECT MOVING_AVERAGE(/level/,4) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                    moving_average_water_level
----                    --------------------------
2020-08-18T00:18:00Z    2.0835
2020-08-18T00:24:00Z    2.07775
2020-08-18T00:30:00Z    2.0615
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>level</code>的field key对应的窗口大小为四个field value的滚动平均值。</p>
<h6 id="计算指定field-key对应的field-value的滚动平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值并包含多个子句">计算指定field key对应的field value的滚动平均值并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' ORDER BY time DESC LIMIT 2 OFFSET 3

name: h2o_feet
time                   moving_average
----                   --------------
2020-08-18T00:06:00Z   2.072
2020-08-18T00:00:00Z   2.09
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的窗口大小为两个field value的滚动平均值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移三个(即前三个<code>point</code>不返回）。</p>
<h4 id="高级语法-16"><a class="header" href="#高级语法-16">高级语法</a></h4>
<pre><code>SELECT MOVING_AVERAGE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) , N ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-62"><a class="header" href="#示例-62">示例</a></h5>
<h6 id="计算最大值的滚动平均值"><a class="header" href="#计算最大值的滚动平均值">计算最大值的滚动平均值</a></h6>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(MAX(&quot;water_level&quot;),2) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   moving_average
----                   --------------
2020-08-18T00:12:00Z   2.121
2020-08-18T00:24:00Z   2.0885
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的最大值的窗口大小为两个值的滚动平均值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>MOVING_AVERAGE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   max
----                   ---
2020-08-18T00:00:00Z   2.116
2020-08-18T00:12:00Z   2.126
2020-08-18T00:24:00Z   2.051
</code></pre>
<p>然后，cnosDB计算这些最大值的窗口大小为两个值的滚动平均值。最终查询结果中的第一个<code>point</code>(<code>2.121</code>)是前两个最大值的平均值(<code>(2.116 + 2.126) / 2</code>)。</p>
<h3 id="non_negative_derivative"><a class="header" href="#non_negative_derivative">NON_NEGATIVE_DERIVATIVE()</a></h3>
<p>返回field value之间的非负变化率。非负变化率包括正的变化率和等于0的变化率。</p>
<h4 id="基本语法-17"><a class="header" href="#基本语法-17">基本语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>cnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(field_key)</code>返回field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-63"><a class="header" href="#示例-63">示例</a></h5>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
<h4 id="高级语法-17"><a class="header" href="#高级语法-17">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的非负导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-64"><a class="header" href="#示例-64">示例</a></h5>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
<h3 id="non_negative_difference"><a class="header" href="#non_negative_difference">NON_NEGATIVE_DIFFERENCE()</a></h3>
<p>返回field value之间的非负差值。非负差值包括正的差值和等于0的差值。</p>
<h4 id="基本语法-18"><a class="header" href="#基本语法-18">基本语法</a></h4>
<pre><code>SELECT NON_NEGATIVE_DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>NON_NEGATIVE_DIFFERENCE(field_key)</code>返回field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-65"><a class="header" href="#示例-65">示例</a></h5>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
<h4 id="高级语法-18"><a class="header" href="#高级语法-18">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的非负差值。</p>
<p>`NON_NEGATIVE_DIFFERENCE()支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-66"><a class="header" href="#示例-66">示例</a></h5>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
<h3 id="pow"><a class="header" href="#pow">POW()</a></h3>
<p>返回field value的<code>x</code>次方。</p>
<h4 id="基本语法-19"><a class="header" href="#基本语法-19">基本语法</a></h4>
<pre><code>SELECT POW( [ * | &lt;field_key&gt; ], &lt;x&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>POW(field_key, x)</code>返回field key对应的field value的<code>x</code>次方。</p>
<p><code>POW(*, x)</code>返回在measurement中每个field key对应的field value的<code>x</code>次方。</p>
<p><code>POW()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>POW()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-67"><a class="header" href="#示例-67">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.90.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的4次方"><a class="header" href="#计算指定field-key对应的field-value的4次方">计算指定field key对应的field value的4次方</a></h6>
<pre><code class="language-sql">&gt; SELECT POW(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  pow
----                  ---
2020-08-18T00:00:00Z  18.148417929216
2020-08-18T00:06:00Z  20.047612231936
2020-08-18T00:12:00Z  16.914992230656004
2020-08-18T00:18:00Z  20.429279055375993
2020-08-18T00:24:00Z  17.352898193760993
2020-08-18T00:30:00Z  17.69549197320101
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的4次方。</p>
<h6 id="计算measurement中每个field-key对应的field-value的4次方"><a class="header" href="#计算measurement中每个field-key对应的field-value的4次方">计算measurement中每个field key对应的field value的4次方</a></h6>
<pre><code class="language-sql">&gt; SELECT POW(*, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  pow_water_level
----                  ---------------
2020-08-18T00:00:00Z  18.148417929216
2020-08-18T00:06:00Z  20.047612231936
2020-08-18T00:12:00Z  16.914992230656004
2020-08-18T00:18:00Z  20.429279055375993
2020-08-18T00:24:00Z  17.352898193760993
2020-08-18T00:30:00Z  17.69549197320101
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的4次方。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的4次方并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的4次方并包含多个子句">计算指定field key对应的field value的4次方并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT POW(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  pow
----                  ---
2020-08-18T00:18:00Z  20.429279055375993
2020-08-18T00:12:00Z  16.914992230656004
2020-08-18T00:06:00Z  20.047612231936
2020-08-18T00:00:00Z  18.148417929216
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的4次方，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-19"><a class="header" href="#高级语法-19">高级语法</a></h4>
<pre><code class="language-sql">SELECT POW(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;x&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的<code>x</code>次方。</p>
<p><code>POW()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-68"><a class="header" href="#示例-68">示例</a></h5>
<h6 id="计算平均值的4次方"><a class="header" href="#计算平均值的4次方">计算平均值的4次方</a></h6>
<pre><code class="language-sql">&gt; SELECT POW(MEAN(&quot;water_level&quot;), 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  pow
----                  ---
2020-08-18T00:00:00Z  19.08029760999999
2020-08-18T00:12:00Z  18.609983417041
2020-08-18T00:24:00Z  17.523567165456008
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的4次方。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>POW()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的4次方。</p>
<h3 id="round"><a class="header" href="#round">ROUND()</a></h3>
<p>返回指定值的四舍五入后的整数。</p>
<h4 id="基本语法-20"><a class="header" href="#基本语法-20">基本语法</a></h4>
<pre><code>SELECT ROUND( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ROUND(field_key)</code>返回field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND(*)</code>返回在measurement中每个field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ROUND()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-69"><a class="header" href="#示例-69">示例</a></h5>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.91.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数">计算指定field key对应的field value四舍五入后的整数</a></h6>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  round
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value四舍五入后的整数。</p>
<h6 id="计算measurement中每个field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算measurement中每个field-key对应的field-value四舍五入后的整数">计算measurement中每个field key对应的field value四舍五入后的整数</a></h6>
<pre><code class="language-sql">&gt; SELECT ROUND(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  round_water_level
----                  -----------------
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<h6 id="计算指定field-key对应的field-value四舍五入后的整数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数并包含多个子句">计算指定field key对应的field value四舍五入后的整数并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  round
----                  -----
2020-08-18T00:18:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:00:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value四舍五入后的整数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-20"><a class="header" href="#高级语法-20">高级语法</a></h4>
<pre><code class="language-sql">SELECT ROUND(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果四舍五入后的整数。</p>
<p><code>ROUND()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-70"><a class="header" href="#示例-70">示例</a></h5>
<h6 id="计算平均值四舍五入后的整数"><a class="header" href="#计算平均值四舍五入后的整数">计算平均值四舍五入后的整数</a></h6>
<pre><code class="language-sql">&gt; SELECT ROUND(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  round
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:24:00Z  2
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值四舍五入后的整数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ROUND()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值四舍五入后的整数。</p>
<h3 id="sin"><a class="header" href="#sin">SIN()</a></h3>
<p>返回field value的正弦值。</p>
<h4 id="基本语法-21"><a class="header" href="#基本语法-21">基本语法</a></h4>
<pre><code class="language-sql">SELECT SIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SIN(field_key)</code>返回field key对应的field value的正弦值。</p>
<p><code>SIN(*)</code>返回在measurement中每个field key对应的field value的正弦值。</p>
<p><code>SIN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SIN()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-71"><a class="header" href="#示例-71">示例</a></h5>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的正弦值"><a class="header" href="#计算指定field-key对应的field-value的正弦值">计算指定field key对应的field value的正弦值</a></h6>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sin
----                  ---
2020-08-18T00:00:00Z  0.8808206017241819
2020-08-18T00:06:00Z  0.8550216851706579
2020-08-18T00:12:00Z  0.8972904165810275
2020-08-18T00:18:00Z  0.8497930984115993
2020-08-18T00:24:00Z  0.8914760289023131
2020-08-18T00:30:00Z  0.8869008523376968
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正弦值。</p>
<h6 id="计算measurement中每个field-key对应的field-value的正弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正弦值">计算measurement中每个field key对应的field value的正弦值</a></h6>
<pre><code class="language-sql">&gt; SELECT SIN(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sin_water_level
----                  ---------------
2020-08-18T00:00:00Z  0.8808206017241819
2020-08-18T00:06:00Z  0.8550216851706579
2020-08-18T00:12:00Z  0.8972904165810275
2020-08-18T00:18:00Z  0.8497930984115993
2020-08-18T00:24:00Z  0.8914760289023131
2020-08-18T00:30:00Z  0.8869008523376968
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的正弦值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的正弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正弦值并包含多个子句">计算指定field key对应的field value的正弦值并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  sin
----                  ---
2020-08-18T00:18:00Z  0.8497930984115993
2020-08-18T00:12:00Z  0.8972904165810275
2020-08-18T00:06:00Z  0.8550216851706579
2020-08-18T00:00:00Z  0.8808206017241819
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正弦值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-21"><a class="header" href="#高级语法-21">高级语法</a></h4>
<pre><code class="language-sql">SELECT SIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正弦值。</p>
<p><code>SIN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-72"><a class="header" href="#示例-72">示例</a></h5>
<h6 id="计算平均值的正弦值"><a class="header" href="#计算平均值的正弦值">计算平均值的正弦值</a></h6>
<pre><code class="language-sql">&gt; SELECT SIN(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  sin

----                  ---
2020-08-18T00:00:00Z  0.8682145834456126
2020-08-18T00:12:00Z  0.8745914945253902
2020-08-18T00:24:00Z  0.8891995555912935
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的正弦值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的正弦值。</p>
<h3 id="sqrt"><a class="header" href="#sqrt">SQRT()</a></h3>
<p>返回field value的平方根。</p>
<h4 id="基本语法-22"><a class="header" href="#基本语法-22">基本语法</a></h4>
<pre><code>SELECT SQRT( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SQRT(field_key)</code>返回field key对应的field value的平方根。</p>
<p><code>SQRT(*)</code>返回在measurement中每个field key对应的field value的平方根。</p>
<p><code>SQRT()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SQRT()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-73"><a class="header" href="#示例-73">示例</a></h5>
<p>下面的示例将使用”NOAA_water_database”数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的平方根"><a class="header" href="#计算指定field-key对应的field-value的平方根">计算指定field key对应的field value的平方根</a></h6>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sqrt
----                  ----
2020-08-18T00:00:00Z  1.4366627996854378
2020-08-18T00:06:00Z  1.4546477236774544
2020-08-18T00:12:00Z  1.4240786495134319
2020-08-18T00:18:00Z  1.4580809305384939
2020-08-18T00:24:00Z  1.4286357128393508
2020-08-18T00:30:00Z  1.4321312788986909
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的平方根。</p>
<h6 id="计算measurement中每个field-key对应的field-value的平方根"><a class="header" href="#计算measurement中每个field-key对应的field-value的平方根">计算measurement中每个field key对应的field value的平方根</a></h6>
<pre><code class="language-sql">&gt; SELECT SQRT(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sqrt_water_level
----                  ----------------
2020-08-18T00:00:00Z  1.4366627996854378
2020-08-18T00:06:00Z  1.4546477236774544
2020-08-18T00:12:00Z  1.4240786495134319
2020-08-18T00:18:00Z  1.4580809305384939
2020-08-18T00:24:00Z  1.4286357128393508
2020-08-18T00:30:00Z  1.4321312788986909
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的平方根。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的平方根并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平方根并包含多个子句">计算指定field key对应的field value的平方根并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  sqrt
----                  ----
2020-08-18T00:18:00Z  1.4580809305384939
2020-08-18T00:12:00Z  1.4240786495134319
2020-08-18T00:06:00Z  1.4546477236774544
2020-08-18T00:00:00Z  1.4366627996854378
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的平方根，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-22"><a class="header" href="#高级语法-22">高级语法</a></h4>
<pre><code>SELECT SQRT(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的平方根。</p>
<p><code>SQRT()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-74"><a class="header" href="#示例-74">示例</a></h5>
<h6 id="计算平均值的平方根"><a class="header" href="#计算平均值的平方根">计算平均值的平方根</a></h6>
<pre><code class="language-sql">&gt; SELECT SQRT(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  sqrt
----                  ----
2020-08-18T00:00:00Z  1.445683229480096
2020-08-18T00:12:00Z  1.4411800720243115
2020-08-18T00:24:00Z  1.430384563675098
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的平方根。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SQRT()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的平方根。</p>
<h3 id="tan"><a class="header" href="#tan">TAN()</a></h3>
<p>返回field value的正切值。</p>
<h4 id="基本语法-23"><a class="header" href="#基本语法-23">基本语法</a></h4>
<pre><code>SELECT TAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TAN(field_key)</code>返回field key对应的field value的正切值。</p>
<p><code>TAN(*)</code>返回在measurement中每个field key对应的field value的正切值。</p>
<p><code>TAN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>TAN()</code>和<code>GROUP BY time()</code>子句。</p>
<h5 id="示例-75"><a class="header" href="#示例-75">示例</a></h5>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<h6 id="计算指定field-key对应的field-value的正切值"><a class="header" href="#计算指定field-key对应的field-value的正切值">计算指定field key对应的field value的正切值</a></h6>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  tan
----                  ---
2020-08-18T00:00:00Z  -1.8604293534384375
2020-08-18T00:06:00Z  -1.6487359603347427
2020-08-18T00:12:00Z  -2.0326408012302273
2020-08-18T00:18:00Z  -1.6121545688343464
2020-08-18T00:24:00Z  -1.9676434782626282
2020-08-18T00:30:00Z  -1.9198657720074992
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正切值。</p>
<h6 id="计算measurement中每个field-key对应的field-value的正切值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正切值">计算measurement中每个field key对应的field value的正切值</a></h6>
<pre><code class="language-sql">&gt; SELECT TAN(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  tan_water_level
----                  ---------------
2020-08-18T00:00:00Z  -1.8604293534384375
2020-08-18T00:06:00Z  -1.6487359603347427
2020-08-18T00:12:00Z  -2.0326408012302273
2020-08-18T00:18:00Z  -1.6121545688343464
2020-08-18T00:24:00Z  -1.9676434782626282
2020-08-18T00:30:00Z  -1.9198657720074992
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的正切值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<h6 id="计算指定field-key对应的field-value的正切值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正切值并包含多个子句">计算指定field key对应的field value的正切值并包含多个子句</a></h6>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  tan
----                  ---
2020-08-18T00:18:00Z  -1.6121545688343464
2020-08-18T00:12:00Z  -2.0326408012302273
2020-08-18T00:06:00Z  -1.6487359603347427
2020-08-18T00:00:00Z  -1.8604293534384375
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正切值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-23"><a class="header" href="#高级语法-23">高级语法</a></h4>
<pre><code class="language-sql">SELECT TAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正切值。</p>
<p><code>TAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h5 id="示例-76"><a class="header" href="#示例-76">示例</a></h5>
<h6 id="计算平均值的正弦值-1"><a class="header" href="#计算平均值的正弦值-1">计算平均值的正弦值</a></h6>
<pre><code class="language-sql">&gt; SELECT TAN(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  tan
----                  ---
2020-08-18T00:00:00Z  -1.7497661902817365
2020-08-18T00:12:00Z  -1.8038002062256624
2020-08-18T00:24:00Z  -1.9435224805850773
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的正切值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>TAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的正切值。</p>
<h2 id="预测函数"><a class="header" href="#预测函数">预测函数</a></h2>
<h3 id="holt_winters"><a class="header" href="#holt_winters">HOLT_WINTERS()</a></h3>
<ul>
<li>
<p>使用<a href="https://www.otexts.org/fpp/7/5?spm=a2c4g.11186623.2.92.41fc3ee27HC1R6">Holt-Winters</a>的季节性方法返回N个预测的field value。</p>
<p><code>HOLT_WINTERS()</code>可用于：</p>
<ul>
<li>预测时间什么时候会超过给定的阈值</li>
<li>将预测值与实际值进行比较，检测数据中的异常</li>
</ul>
</li>
</ul>
<h4 id="语法-25"><a class="header" href="#语法-25">语法</a></h4>
<pre><code>SELECT HOLT_WINTERS[_WITH-FIT](&lt;function&gt;(&lt;field_key&gt;),&lt;N&gt;,&lt;S&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>HOLT_WINTERS(function(field_key),N,S)</code>返回field key对应的<code>N</code>个季节性调整的预测field value。</p>
<p><code>N</code>个预测值出现的时间间隔跟group by time时间间隔相同。如果您的<code>GROUP BY time()</code>时间间隔是<code>6m</code>并且<code>N</code>等于<code>3</code>，那么您将会得到3个时间间隔为6分钟的预测值。</p>
<p><code>S</code>是一个季节性模式参数，并且根据<code>GROUP BY time()</code>时间间隔限定一个季节性模式的长度。如果您的<code>GROUP BY time()</code>时间间隔是<code>2m</code>并且<code>S</code>等于<code>3</code>，那么这个季节性模式每六分钟出现一次，也就是每三个<code>point</code>。如果您不希望季节性调整您的预测值，请将<code>S</code>设置为<code>0</code>或<code>1</code>。</p>
<p><code>HOLT_WINTERS_WITH_FIT(function(field_key),N,S)</code>除了返回field key对应的<code>N</code>个季节性调整的预测field value，还返回拟合值。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>处理以相同的时间间隔出现的数据；嵌套的cnosQL函数和<code>GROUP BY time()</code>子句确保Holt-Winters函数能够对常规数据进行操作。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-77"><a class="header" href="#示例-77">示例</a></h4>
<h5 id="预测指定field-key的field-value"><a class="header" href="#预测指定field-key的field-value">预测指定field key的field value</a></h5>
<h6 id="原始数据"><a class="header" href="#原始数据">原始数据</a></h6>
<p>该示例重点关注<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">SELECT &quot;water_level&quot; FROM &quot;NOAA_water_database&quot;.&quot;autogen&quot;.&quot;h2o_feet&quot; WHERE &quot;location&quot;='santa_monica' AND time &gt;= '2020-08-22 22:12:00' AND time &lt;= '2020-08-28 03:00:00'
</code></pre>
<h6 id="步骤一匹配原始数据的趋势"><a class="header" href="#步骤一匹配原始数据的趋势">步骤一：匹配原始数据的趋势</a></h6>
<p>编写一个<code>GROUP BY time()</code>查询，使得它匹配原始<code>water_level</code>数据的总体趋势。这里，我们使用了<code>FIRST()</code>函数：</p>
<pre><code class="language-sql">SELECT FIRST(&quot;water_level&quot;) FROM &quot;NOAA_water_database&quot;.&quot;autogen&quot;.&quot;h2o_feet&quot; WHERE &quot;location&quot;='santa_monica' and time &gt;= '2020-08-22 22:12:00' and time &lt;= '2020-08-28 03:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>GROUP BY time()</code>子句中，第一个参数(<code>379m</code>)匹配<code>water_level</code>数据中每个波峰和波谷之间发生的时间长度，第二个参数(<code>348m</code>)是一个偏移间隔，它通过改变cnosDB的默认<code>GROUP BY time()</code>边界来匹配原始数据的时间范围。</p>
<h6 id="步骤二确定季节性模式"><a class="header" href="#步骤二确定季节性模式">步骤二：确定季节性模式</a></h6>
<p>使用步骤一中查询的信息确定数据中的季节性模式。</p>
<h6 id="步骤三应用holt_winters函数"><a class="header" href="#步骤三应用holt_winters函数">步骤三：应用<code>HOLT_WINTERS()</code>函数</a></h6>
<p>在查询中加入Holt-Winters函数。这里，我们使用<code>HOLT_WINTERS_WITH_FIT()</code>来查看拟合值和预测值：</p>
<pre><code class="language-sql">SELECT HOLT_WINTERS_WITH_FIT(FIRST(&quot;water_level&quot;),10,4) FROM &quot;NOAA_water_database&quot;.&quot;autogen&quot;.&quot;h2o_feet&quot; WHERE &quot;location&quot;='santa_monica' AND time &gt;= '2020-08-22 22:12:00' AND time &lt;= '2020-08-28 03:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>HOLT_WINTERS_WITH_FIT()</code>函数中，第一个参数(<code>10</code>)请求10个预测的field value。每个预测的<code>point</code>相距<code>379m</code>，与<code>GROUP BY time()</code>子句中的第一个参数相同。<code>HOLT_WINTERS_WITH_FIT()</code>函数中的第二个参数(<code>4</code>)是我们在上一步骤中确定的季节性模式。</p>
<h4 id="holt_winters的常见问题"><a class="header" href="#holt_winters的常见问题"><code>HOLT_WINTERS()</code>的常见问题</a></h4>
<h5 id="holt_winters和收到的point少于n个"><a class="header" href="#holt_winters和收到的point少于n个"><code>HOLT_WINTERS()</code>和收到的<code>point</code>少于”N”个</a></h5>
<p>在某些情况下，用户可能会收到比参数<code>N</code>请求的更少的预测<code>point</code>。当数学计算不稳定和不能预测更多<code>point</code>时，这种情况就会发生。这意味着该数据集不适合使用<code>HOLT_WINTERS()</code>，或者，季节性调整参数是无效的并且是算法混乱。</p>
<h2 id="分析函数"><a class="header" href="#分析函数">分析函数</a></h2>
<p>下面技术分析的函数将广泛使用的算法应用在您的数据中。虽然这些函数主要应用在金融和投资领域，但是它们也适用于其它行业和用例。</p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></p>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>除了field key，技术分析函数还接受以下参数：</p>
<h4 id="period"><a class="header" href="#period"><code>PERIOD</code></a></h4>
<p><strong>必需，整数，min=1</strong></p>
<p>算法的样本大小。这基本上是对算法的输出有显著影响的历史样本的数量。例如，<code>2</code>表示当前的<code>point</code>和前一个<code>point</code>。算法使用指数衰减率来决定历史<code>point</code>的权重，通常称为<code>alpha(α)</code>。参数<code>PERIOD</code>控制衰减率。</p>
<blockquote>
<p>请注意，历史<code>point</code>仍然可以产生影响。</p>
</blockquote>
<h4 id="hold_period"><a class="header" href="#hold_period"><code>HOLD_PERIOD</code></a></h4>
<p><strong>整数，min=-1</strong></p>
<p>算法需要多少个样本才会开始发送结果。默认值<code>-1</code>表示该参数的值基于算法、<code>PERIOD</code>和<code>WARMUP_TYPE</code>，但是这是一个可以使算法发送有意义的结果的值。</p>
<p><strong>默认的Hold Periods：</strong></p>
<p>对于大多数提供的技术分析，<code>HOLD_PERIOD</code>的默认值由您使用的技术分析算法和<code>WARMUP_TYPE</code>决定。</p>
<table><thead><tr><th>算法 \ Warmup Type</th><th>simple</th><th>exponential</th><th style="text-align: center">none</th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE</a></td><td>PERIOD - 1</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 2</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 3</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE</a></td><td>( PERIOD - 1 ) * 3 + 1</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center">PERIOD - 1</td></tr>
</tbody></table>
<p><em><strong>Kaufman算法默认的Hold Periods：</strong></em></p>
<table><thead><tr><th>算法</th><th>默认的Hold Period</th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></td><td>PERIOD</td></tr>
<tr><td><a href="content/cnosdb/0.10/cnosql/function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></td><td>PERIOD</td></tr>
</tbody></table>
<h4 id="warmup_type"><a class="header" href="#warmup_type"><code>WARMUP_TYPE</code></a></h4>
<p><strong>默认=”exponential”</strong></p>
<p>这个参数控制算法如何为第一个<code>PERIOD</code>样本初始化自身，它本质上是具有不完整样本集的持续时间。</p>
<p><code>simple</code>
第一个<code>PERIOD</code>样本的简单移动平均值(simple moving average，SMA)。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.106.41fc3ee27HC1R6">ta-lib</a>使用的方法。</p>
<p><code>exponential</code>
具有缩放alpha(α)的指数移动平均值(exponential moving average，EMA)。基本上是这样使用EMA：<code>PERIOD=1</code>用于第一个点，<code>PERIOD=2</code>用于第二个点，以此类推，直至算法已经消耗了<code>PERIOD</code>个<code>point</code>。由于算法一开始就使用了EMA，当使用此方法并且没有指定<code>HOLD_PERIOD</code>的值或<code>HOLD_PERIOD</code>的值为<code>-1</code>时，算法可能会在比<code>simple</code>小得多的样本大小的情况下开始发送<code>point</code>。</p>
<p><code>none</code>
算法不执行任何的平滑操作。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.107.41fc3ee27HC1R6">ta-lib</a>使用的方法。当使用此方法并且没有指定<code>HOLD_PERIOD</code>时，<code>HOLD_PERIOD</code>的默认值是<code>PERIOD - 1</code>。</p>
<blockquote>
<p>类型<code>none</code>仅适用于<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数。</p>
</blockquote>
<h3 id="chande_momentum_oscillator"><a class="header" href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></h3>
<p>Chande Momentum Oscillator (CMO)是由Tushar Chande开发的一个技术动量指标。通过计算所有最近较高<code>point</code>的总和与所有最近较低<code>point</code>的总和的差值，然后将结果除以给定时间范围内的所有数据变动的总和来创建CMO指标。将结果乘以100可以得到一个从-100到+100的范围。
<sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo" target="\_blank">Source</a></p>
<h4 id="基本语法-24"><a class="header" href="#基本语法-24">基本语法</a></h4>
<pre><code>CHANDE_MOMENTUM_OSCILLATOR([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;, [warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup-type">hold_period</a> （可选项）
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 2)</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 10, 9, 'none')</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>none</code>。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用CMO算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(/regular_expression/, 2)</code>返回使用CMO算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(*, 2)</code>返回使用CMO算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR()</code> 支持数据类型为int64和float64的field value。</p>
<h3 id="exponential_moving_average"><a class="header" href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>指数移动平均值 (Exponential Moving Average，EMA)类似于简单移动平均值，不同的是，指数移动平均值对最新数据给予更多的权重，它也被称为”指数加权移动平均值”。与简单移动平均值相比，这种类型的移动平均值对最近数据的变化反应更快。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/e/ema.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-25"><a class="header" href="#基本语法-25">基本语法</a></h4>
<pre><code>EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用EMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用EMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用EMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE()</code> 支持数据类型为int64和float64的field value。</p>
<h3 id="double_exponential_moving_average"><a class="header" href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>双重指数移动平均值 (Double Exponential Moving Average，DEMA)通过增加最近数据的权重，尝试消除与移动平均值相关的固有滞后。该名字似乎表明这是通过双重指数平滑来实现的，然而事实并非如此，它表示的是将EMA的值翻倍。为了使它与实际数据保持一致，也为了消除滞后，从之前两倍EMA的值中把”EMA of EMA”的值减去，公式为：DEMA = 2 * EMA - EMA(EMA)。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Double_exponential_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-26"><a class="header" href="#基本语法-26">基本语法</a></h4>
<pre><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用DEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用DEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用DEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<h3 id="kaufmans_efficiency_ratio"><a class="header" href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></h3>
<p>Kaufman效率比 (Kaufman’s Efficiency Ration)，或简称为效率比 (Efficiency Ratio，ER)，它的计算方法是：将一段时间内的数据变化除以实现该变化所发生的数据变动的绝对值的总和。得出的比率在0和1之间，比率越高，表示市场越有效率或越有趋势。</p>
<p>ER跟Chande Momentum Oscillator (CMO)非常类似。不同的是，CMO将市场方向考虑在内，但是如果您将CMO的绝对值除以100，就可以得到ER。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://etfhq.com/blog/2011/02/07/kaufmans-efficiency-ratio/" target="\_blank">Source</a></p>
<h4 id="基本语法-27"><a class="header" href="#基本语法-27">基本语法</a></h4>
<pre><code class="language-sql">KAUFMANS_EFFICIENCY_RATIO([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 2)</code>返回使用效率指数(Efficiency Index)算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 10, 10)</code>返回使用效率指数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用效率指数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_EFFICIENCY_RATIO()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_EFFICIENCY_RATIO(/regular_expression/, 2)</code>返回使用效率指数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(*, 2)</code>返回使用效率指数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO()</code>支持数据类型为int64和float64的field value。</p>
<h3 id="kaufmans_adaptive_moving_average"><a class="header" href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></h3>
<p>Kaufman自适应移动平均值 (Kaufman’s Adaptive Moving Average，KAMA)，是一个用于计算样本噪音或波动率的移动平均值。当数据波动相对较小并且噪音较低时，KAMA会密切关注<code>point</code>。当数据波动较大时，KAMA会进行调整，平滑噪音。该趋势跟踪指标可用于识别总体趋势、时间转折点和过滤价格变动。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:kaufman_s_adaptive_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-28"><a class="header" href="#基本语法-28">基本语法</a></h4>
<pre><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong>
<a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 2)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 10, 10)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用KAMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用KAMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(*, 2)</code>返回使用KAMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<h3 id="triple_exponential_moving_average"><a class="header" href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>三重指数移动平均值 (Triple Exponential Moving Average，TEMA)，旨在过滤常规移动平均值的波动。该名字似乎表明这是通过三重指数平滑来实现的，然而事实并非如此，它实际上是包含指数移动平均值、双重指数移动平均值和三重指数移动平均值的复合函数。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/t/triple-exponential-moving-average.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-29"><a class="header" href="#基本语法-29">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用TEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用TEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用TEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<h3 id="triple_exponential_derivative"><a class="header" href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></h3>
<p>三重指数导数指标 (Triple Exponential Derivative Indicator)，通常称为”TRIX”，是一种用于识别超卖和超买市场的振荡器，也可用作动量指标。TRIX计算一段时间内输入数据的对数的三重指数移动平均值。从当前的值中减去之前的值，这可以防止指标考虑比规定期间短的周期。</p>
<p>跟很多振荡器一样，TRIX围绕着零线震荡。当它用作振荡器时，正数表示炒买超买市场，而负数表示超卖市场。当它用作动量指标时，正数表示动量在增加，而负数表示动量在减少。很多分析师认为，当TRIX超过零线时，它会给出买入信号，当低于零线时，它会给出卖出信号。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/articles/technical/02/092402.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-30"><a class="header" href="#基本语法-30">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_DERIVATIVE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 2)</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 10, 10, 'exponential')</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用三重指数导数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(/regular_expression/, 2)</code>返回使用三重指数导数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(*, 2)</code>返回使用三重指数导数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<h3 id="relative_strength_index"><a class="header" href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></h3>
<p>相对强弱指数 (Relative Strength Index，RSI)是一个动量指标，用于比较在指定时间段内最近数据增大和减小的幅度，以便measurement数据变动的速度和变化。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/r/rsi.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-31"><a class="header" href="#基本语法-31">基本语法</a></h4>
<pre><code>RELATIVE_STRENGTH_INDEX([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="content/cnosdb/0.10/cnosql/function.html#period">period</a>
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/0.10/cnosql/function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 2)</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 10, 10, 'exponential')</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>RELATIVE_STRENGTH_INDEX(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用RSI算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>RELATIVE_STRENGTH_INDEX()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>RELATIVE_STRENGTH_INDEX(/regular_expression/, 2)</code>返回使用RSI算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(*, 2)</code>返回使用RSI算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX()</code>支持数据类型为int64和float64的field value。</p>
<h2 id="其它"><a class="header" href="#其它">其它</a></h2>
<h3 id="示例数据"><a class="header" href="#示例数据">示例数据</a></h3>
<p>本文档使用的数据可在<a href="content/cnosdb/0.10/cnosql/NOAA_water_database.txt">示例数据</a>中下载。</p>
<h3 id="函数的通用语法"><a class="header" href="#函数的通用语法">函数的通用语法</a></h3>
<h4 id="在select中指定多个函数"><a class="header" href="#在select中指定多个函数">在<code>SELECT</code>中指定多个函数</a></h4>
<h5 id="语法-26"><a class="header" href="#语法-26">语法</a></h5>
<pre><code>SELECT &lt;function&gt;(),&lt;function&gt;() FROM_clause [...]
</code></pre>
<p>使用逗号(<code>,</code>)将<code>SELECT</code>语句中的多个函数分开。该语法适用于除<code>TOP()</code>和<code>BOTTOM()</code>之外的所有cnosQL函数。<code>SELECT</code>子句不支持<code>TOP()</code>或<code>BOTTOM()</code>和其它函数同时使用。</p>
<h5 id="示例-78"><a class="header" href="#示例-78">示例</a></h5>
<h6 id="在一个查询中计算field-value的平均值和平均数"><a class="header" href="#在一个查询中计算field-value的平均值和平均数">在一个查询中计算field value的平均值和平均数</a></h6>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;),MEDIAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  mean               median
----                  ----               ------
1970-01-01T00:00:00Z  4.442107025822522  4.124
</code></pre>
<p>该查询返回<code>water_level</code>的平均值和平均数。</p>
<h6 id="在一个查询中计算两个field的mode"><a class="header" href="#在一个查询中计算两个field的mode">在一个查询中计算两个field的mode</a></h6>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;water_level&quot;),MODE(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  mode  mode_1
----                  ----  ------
1970-01-01T00:00:00Z  2.69  between 3 and 6 feet
</code></pre>
<p>该查询返回<code>water_level</code>中出现频率最高的field value和<code>level description</code>中出现频率最高的field value。<code>water_level</code>对应的值在列<code>mode</code>中，<code>level description</code>对应的值在列<code>mode_1</code>中。因为系统不能返回多个具有相同名字的列，所以它将第二个列<code>mode</code>重命名为<code>mode_1</code>。</p>
<h6 id="在一个查询中计算field-value的最小值和最大值"><a class="header" href="#在一个查询中计算field-value的最小值和最大值">在一个查询中计算field value的最小值和最大值</a></h6>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;), MAX(&quot;water_level&quot;) [...]

name: h2o_feet
time                  min    max
----                  ---    ---
1970-01-01T00:00:00Z  -0.61  9.964
</code></pre>
<p>该查询返回<code>water_level</code>的最小值和最大值。</p>
<p>请注意，该查询返回<code>1970-01-01T00:00:00Z</code>作为时间戳，这是cnosDB的空时间戳。<code>MIN()</code>和<code>MAX()</code>是selector函数；当selector函数是<code>SELECT</code>子句中的唯一函数时，它返回一个特定的时间戳。因为<code>MIN()</code>和<code>MAX()</code>返回两个不同的时间戳（见下面的例子），所以系统会用空时间戳覆盖这些时间戳。</p>
<pre><code class="language-sql">&gt;  SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  min
----                  ---
2020-08-29T14:30:00Z  -0.61    &lt;--- Timestamp 1

&gt;  SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964    &lt;--- Timestamp 2
</code></pre>
<h4 id="重命名查询结果字段"><a class="header" href="#重命名查询结果字段">重命名查询结果字段</a></h4>
<h5 id="语法-27"><a class="header" href="#语法-27">语法</a></h5>
<pre><code>SELECT &lt;function&gt;() AS &lt;field_key&gt; [...]
</code></pre>
<p>默认情况下，函数返回的结果在与函数名称匹配的field key下面。使用<code>AS</code>子句可以指定输出的field key的名字。</p>
<h5 id="示例-79"><a class="header" href="#示例-79">示例</a></h5>
<h6 id="指定输出的field-key"><a class="header" href="#指定输出的field-key">指定输出的field key</a></h6>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) AS &quot;dream_name&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  dream_name
----                  ----------
1970-01-01T00:00:00Z  4.442107025822522
</code></pre>
<p>该查询返回<code>water_level</code>的平均值，并将输出的field key重命名为<code>dream_name</code>。如果没有<code>AS</code>子句，那么查询会返回<code>mean</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  mean
----                  ----
1970-01-01T00:00:00Z  4.442107025822522
</code></pre>
<h6 id="为多个函数指定输出的field-key"><a class="header" href="#为多个函数指定输出的field-key">为多个函数指定输出的field key</a></h6>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;) AS &quot;med_wat&quot;,MODE(&quot;water_level&quot;) AS &quot;mode_wat&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  med_wat  mode_wat
----                  -------  --------
1970-01-01T00:00:00Z  4.124    2.69
</code></pre>
<p>该查询返回<code>water_level</code>的平均数和<code>water_level</code>中出现频率最高的field value，并将输出的field key分别重命名为<code>med_wat</code>和<code>mode_wat</code>。如果没有<code>AS</code>子句，那么查询会返回<code>median</code>和<code>mode</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;),MODE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  median  mode
----                  ------  ----
1970-01-01T00:00:00Z  4.124   2.69
</code></pre>
<h4 id="改变不含数据的时间间隔的返回值"><a class="header" href="#改变不含数据的时间间隔的返回值">改变不含数据的时间间隔的返回值</a></h4>
<p>默认情况下，包含cnosQL函数和<code>GROUP BY time()</code>子句的查询对不包含数据的时间间隔返回空值。在<code>GROUP BY</code>子句后面加上<code>fill()</code>可以更改这个值。关于<code>fill()</code>的详细讨论，请查看数据探索。</p>
<h3 id="函数的常见问题"><a class="header" href="#函数的常见问题">函数的常见问题</a></h3>
<p>以下部分描述了所有函数、聚合函数和选择函数的常见混淆来源，有关单个功能的常见问题，请参见以下特定文档：</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#common-issues-with-distinct">DISTINCT()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#common-issues-with-bottom">BOTTOM()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#common-issues-with-percentile">PERCENTILE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#common-issues-with-sample">SAMPLE()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#common-issues-with-top">TOP()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#common-issues-with-elapsed">ELAPSED()</a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#common-issues-with-holt-winters">HOLT_WINTERS()</a></li>
</ul>
<h4 id="所有函数"><a class="header" href="#所有函数">所有函数</a></h4>
<h5 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h5>
<p>某些cnosQL 函数支持 <a href="content/cnosdb/0.10/cnosql//cnosdb/v1.8/query_language/explore-data/#select-clause"><code>SELECT</code> clause</a>中嵌套:</p>
<ul>
<li><a href="content/cnosdb/0.10/cnosql/function.html#count"><code>COUNT()</code></a> with <a href="content/cnosdb/0.10/cnosql/function.html#distinct"><code>DISTINCT()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#cumulative-sum"><code>CUMULATIVE_SUM()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#derivative"><code>DERIVATIVE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#difference"><code>DIFFERENCE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#elapsed"><code>ELAPSED()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#moving-average"><code>MOVING_AVERAGE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#non-negative-derivative"><code>NON_NEGATIVE_DERIVATIVE()</code></a></li>
<li><a href="content/cnosdb/0.10/cnosql/function.html#holt-winters"><code>HOLT_WINTERS()</code></a> and <a href="content/cnosdb/0.10/cnosql/function.html#holt-winters"><code>HOLT_WINTERS_WITH_FIT()</code></a></li>
</ul>
<h5 id="查询在now之后的时间范围"><a class="header" href="#查询在now之后的时间范围">查询在now()之后的时间范围</a></h5>
<p>大多数<code>SELECT</code>语句的默认时间范围在<code>1677-09-21 00:12:43.145224194</code> UTC和<code>2262-04-11T23:47:16.854775806Z</code> UTC之间。对于包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询，默认的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。</p>
<p>如果要查询时间戳发生在<code>now()</code>之后的数据，那么包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询必须在<code>WHERE</code>子句中提供一个时间上限。请查看常见问题。</p>
<h4 id="聚合函数-1"><a class="header" href="#聚合函数-1">聚合函数</a></h4>
<h5 id="理解返回的时间戳"><a class="header" href="#理解返回的时间戳">理解返回的时间戳</a></h5>
<p>子句中具有 <a href="content/cnosdb/0.10/cnosql/function.html#aggregations">聚合函数</a> 且 <code>WHERE</code>没有时间范围的查询讲返回 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间戳.
cnosDB 使用 epoch 0 作为等效的空时间戳.
带有聚合函数的查询，如果 <code>WHERE</code> 子句中包含时间范围，将返回时间下限作为时间戳.</p>
<h5 id="示例-80"><a class="header" href="#示例-80">示例</a></h5>
<h6 id="使用聚合函数并且没有指定时间范围"><a class="header" href="#使用聚合函数并且没有指定时间范围">使用聚合函数并且没有指定时间范围</a></h6>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum
----                   ---
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询将cnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为时间戳返回。<code>SUM()</code>将多个<code>point</code>聚合，没有单个时间戳可以返回。</p>
<h6 id="使用聚合函数并且指定时间范围"><a class="header" href="#使用聚合函数并且指定时间范围">使用聚合函数并且指定时间范围</a></h6>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z'

name: h2o_feet
time                  sum
----                  ---
2020-08-18T00:00:00Z  67777.66900000004
</code></pre>
<p>该查询将时间范围的下界(<code>WHERE time &gt;= '2020-08-18T00:00:00Z'</code>)作为时间戳返回。</p>
<h6 id="使用聚合函数并且指定时间范围和使用group-by-time子句"><a class="header" href="#使用聚合函数并且指定时间范围和使用group-by-time子句">使用聚合函数并且指定时间范围和使用GROUP BY time()子句</a></h6>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:18:00Z' GROUP BY time(12m)

name: h2o_feet
time                  sum
----                  ---
2020-08-18T00:00:00Z  20.305
2020-08-18T00:12:00Z  19.802999999999997
</code></pre>
<p>该查询将每个<code>GROUP BY time()</code>间隔的时间下界作为时间戳返回。</p>
<h6 id="将聚合函数和不聚合的数据混合使用"><a class="header" href="#将聚合函数和不聚合的数据混合使用">将聚合函数和不聚合的数据混合使用</a></h6>
<p>聚合函数不支持在<code>SELECT</code>语句中指定不使用聚合函数的单独的field key或tag key。聚合函数返回一个计算结果，对于没有被聚合的field或tag，没有明显的单个值可以返回。当<code>SELECT</code>语句同时包含聚合函数和单独的field key或tag key时，会返回错误：</p>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;),&quot;location&quot; FROM &quot;h2o_feet&quot;

ERR: error parsing query: mixing aggregate and non-aggregate queries is not supported
</code></pre>
<h5 id="得到略有不同的结果"><a class="header" href="#得到略有不同的结果">得到略有不同的结果</a></h5>
<p>对于某些聚合函数，在相同的<code>point</code>（数据类型为float64)上执行相同的函数，可能会产生稍微不同的结果。在应用聚合函数之间，cnosDB不会将<code>point</code>进行排序；该行为可能会导致查询结果中出现小小的差异。</p>
<h4 id="selector函数"><a class="header" href="#selector函数">Selector函数</a></h4>
<h5 id="理解返回的时间戳-1"><a class="header" href="#理解返回的时间戳-1">理解返回的时间戳</a></h5>
<p>selector函数返回的时间戳依赖查询中函数的数量和查询中的其它子句：</p>
<p>带有单个选择器函数，单个 field key 参数和无 <code>GROUP BY time()</code> 的查询返回原始数据中出现的point时间戳.
具有单个 selector 函数, 多个 <code>field key</code> 参数的查询, <code>GROUP BY time()</code> 返回原始数据中出现的point 时间戳，或与空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>)等价的cnosDB.</p>
<p><code>WHERE</code>子句中有多个函数且没有时间范围的查询将返回相当于空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>).
在 <code>WHERE</code>子句中包含多个函数和时间范围的查询将时间下限作为时间戳返回 </p>
<p>带有 selector 函数和  <code>GROUP BY time()</code> 子句的查询返回每个 <code>GROUP BY time()</code>间隔的时间下限.</p>
<h5 id="示例-81"><a class="header" href="#示例-81">示例</a></h5>
<h6 id="使用单个selector函数和单个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和单个field-key并且没有指定时间范围">使用单个selector函数和单个field key，并且没有指定时间范围</a></h6>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964

&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z'

name: h2o_feet
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964
</code></pre>
<p>该查询返回原始数据中具有<code>最大</code>值的<code>point</code>的时间戳。</p>
<h6 id="使用单个selector函数和多个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和多个field-key并且没有指定时间范围">使用单个selector函数和多个field key，并且没有指定时间范围</a></h6>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  first_level description  first_water_level
----                  -----------------------  -----------------
1970-01-01T00:00:00Z  between 6 and 9 feet     8.12

&gt; SELECT MAX(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max_water_level
----                  ---------------
2020-08-29T07:24:00Z  9.964
</code></pre>
<p>第一个查询返回cnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>FIRST(*)</code>返回两个时间戳（对应measurement <code>h2o_feet</code>中的每个field key），所以系统使用空时间戳覆盖这两个时间戳。</p>
<p>第二个查询返回原始数据中具有最大值的<code>point</code>的时间戳。因为<code>MAX(*)</code>只返回一个时间戳(measurement <code>h2o_feet</code>中只有一个数值类型的field)，所以系统不会覆盖原始时间戳。</p>
<h6 id="使用多个selector函数并且没有指定时间范围"><a class="header" href="#使用多个selector函数并且没有指定时间范围">使用多个selector函数，并且没有指定时间范围</a></h6>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;),MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max    min
----                  ---    ---
1970-01-01T00:00:00Z  9.964  -0.61
</code></pre>
<p>该查询返回cnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>MAX()</code>和<code>MIN()</code>函数返回不同的时间戳，所以系统没有单个时间戳可以返回。</p>
<h6 id="使用多个selector函数并且指定时间范围"><a class="header" href="#使用多个selector函数并且指定时间范围">使用多个selector函数，并且指定时间范围</a></h6>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;),MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z'

name: h2o_feet
time                  max    min
----                  ---    ---
2020-08-18T00:00:00Z  9.964  -0.61
</code></pre>
<p>该查询返回时间范围的下界(<code>WHERE time &gt;= '2020-08-18T00:00:00Z'</code>)作为查询结果中的时间戳。</p>
<h6 id="使用单个selector函数并且指定时间范围"><a class="header" href="#使用单个selector函数并且指定时间范围">使用单个selector函数，并且指定时间范围</a></h6>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:18:00Z' GROUP BY time(12m)

name: h2o_feet
time                  max
----                  ---
2020-08-18T00:00:00Z  8.12
2020-08-18T00:12:00Z  7.887
</code></pre>
<p>该查询返回每个<code>GROUP BY time()</code>间隔的时间下限作为查询结果中的时间戳。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连续查询"><a class="header" href="#连续查询">连续查询</a></h1>
<table><thead><tr><th><a href="content/cnosdb/0.10/cnosql/countine_query.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></th><th><a href="content/cnosdb/0.10/cnosql/countine_query.html#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95">高级语法</a></th><th><a href="content/cnosdb/0.10/cnosql/countine_query.html#%E7%AE%A1%E7%90%86CQ">管理CQ</a></th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/0.10/cnosql/countine_query.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">基本语法示例</a></td><td><a href="content/cnosdb/0.10/cnosql/countine_query.html#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">高级语法示例</a></td><td></td></tr>
</tbody></table>
<h2 id="语法-28"><a class="header" href="#语法-28">语法</a></h2>
<h3 id="基本语法-32"><a class="header" href="#基本语法-32">基本语法</a></h3>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<p><strong>语法描述</strong></p>
<p>CQ查询必须包含一个函数，一个<code>INTO</code>子句和一个<code>GROUP BY time()</code>子句：</p>
<pre><code class="language-sql">SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</code></pre>
<blockquote>
<p>在<code>WHERE</code>子句中，不需要指定时间范围，CQ查询会为语句自动匹配时间范围</p>
</blockquote>
<h3 id="基本语法示例"><a class="header" href="#基本语法示例">基本语法示例</a></h3>
<p>以下示例使用数据库<code>transportation</code>中的示例数据，<code>bus_data</code>中存储的数据是公交车乘客数量和投诉数量的15分钟数：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers   complaints
2020-08-28T07:00:00Z   5            9
2020-08-28T07:15:00Z   8            9
2020-08-28T07:30:00Z   8            9
2020-08-28T07:45:00Z   7            9
2020-08-28T08:00:00Z   8            9
2020-08-28T08:15:00Z   15           7
2020-08-28T08:30:00Z   15           7
2020-08-28T08:45:00Z   17           7
2020-08-28T09:00:00Z   20           7
</code></pre>
<p><strong>自动采样数据</strong></p>
<p>使用CQ自动从单个字段下采样数据，并将结果写入到同一个数据库的另一个<code>measurement</code>中：</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>自动采样数据并将结果保存到另一个保留策略中</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_rp&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>使用通配符自动下采样数据</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_br&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(*) INTO &quot;downsampled_transportation&quot;.&quot;autogen&quot;.:MEASUREMENT FROM /.*/ GROUP BY time(30m),*
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;downsampled_transportation.&quot;autogen&quot;.&quot;bus_data&quot;
name: bus_data
--------------
time                   mean_complaints   mean_passengers
2020-08-28T07:00:00Z   9                 6.5
2020-08-28T07:30:00Z   9                 7.5
2020-08-28T08:00:00Z   8                 11.5
2020-08-28T08:30:00Z   7                 16
</code></pre>
<p><strong>自动采样数据并配置CQ的时间边界</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_offset&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h,15m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:15:00Z   7.75
2020-08-28T08:15:00Z   16.75
</code></pre>
<h3 id="高级语法-24"><a class="header" href="#高级语法-24">高级语法</a></h3>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<h5 id="高级语法示例"><a class="header" href="#高级语法示例">高级语法示例</a></h5>
<p>示例数据如下：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers
2020-08-28T06:30:00Z   2
2020-08-28T06:45:00Z   4
2020-08-28T07:00:00Z   5
2020-08-28T07:15:00Z   8
2020-08-28T07:30:00Z   8
2020-08-28T07:45:00Z   7
2020-08-28T08:00:00Z   8
2020-08-28T08:15:00Z   15
2020-08-28T08:30:00Z   15
2020-08-28T08:45:00Z   17
2020-08-28T09:00:00Z   20
</code></pre>
<p><strong>配置时间间隔</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>EVERY</code>来指明CQ的执行间隔</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 30m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>配置CQ的重采样时间范围</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>FOR</code>来指明CQ的时间间隔的长度</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for&quot; ON &quot;transportation&quot;
RESAMPLE FOR 1h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置执行间隔和CQ时间范围</strong></p>
<p>在<code>RESAMPLE</code>子句中使用<code>EVERY</code>和<code>FOR</code>来指定CQ的执行间隔和CQ的时间范围长度。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every_for&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 1h FOR 90m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T06:30:00Z   3
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置CQ的时间范围并填充空值</strong></p>
<p>使用<code>FOR</code>间隔和<code>fill()</code>来更改不含数据的时间间隔值。请注意，至少有一个数据点必须在<code>fill()</code>运行的<code>FOR</code>间隔内。 如果没有数据落在<code>FOR</code>间隔内，则CQ不会将任何数据写入目标<code>measurement</code>。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for_fill&quot; ON &quot;transportation&quot;
RESAMPLE FOR 2h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h) fill(1000)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T05:00:00Z   1000
2020-08-28T06:00:00Z   3
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
2020-08-28T09:00:00Z   20
2020-08-28T10:00:00Z   1000
</code></pre>
<h2 id="管理cq"><a class="header" href="#管理cq">管理CQ</a></h2>
<blockquote>
<p>CQ不能<code>update</code>，只能<code>dorp</code>和<code>create</code></p>
</blockquote>
<p><strong>列出所有CQ</strong></p>
<pre><code class="language-sql">SHOW CONTINUOUS QUERIES
</code></pre>
<p><strong>删除CQ</strong></p>
<pre><code class="language-sql">DROP CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集群版简介"><a class="header" href="#集群版简介">集群版简介</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<p>CnosDB由两组软件组成，<code>data</code>节点和<code>meta</code>节点，集群内的通讯如下所示：</p>
<p><code>meta</code>节点使用<code>tcp</code>和<code>raft</code>协议进行通信，<code>meta</code>节点之间使用默认端口<code>8091</code>通信，多个<code>meta</code>节点需要互相能够访问，用来维持<code>meta</code>集群的一致性。同时<code>8091</code>端口也用来和外界通信，比如<code>cnosd-ctl</code>或<code>data</code>节点等。</p>
<p><code>data</code>节点通过<code>tcp</code>的8088端口互相通信，并且通过<code>8091</code>访问<code>meta</code>节点的API，使状态保持同步。</p>
<p><code>meta</code>节点数量必须为大于等于3的奇数，这样可以保证集群能够保持选举稳定。</p>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<blockquote>
<p>配置文件的<code>hostname</code>需要其他的<code>meta node</code>和<code>data node</code>节点都能够访问<br />
配置文件可以通过<code>cnosdb-meta config &gt; config_path</code>获得</p>
</blockquote>
<h3 id="启动meta节点"><a class="header" href="#启动meta节点">启动<code>meta</code>节点</a></h3>
<pre><code>./cnosdb-meta --config [cnosdb_meta_config_path]
</code></pre>
<h3 id="将meta加入到集群"><a class="header" href="#将meta加入到集群">将<code>meta</code>加入到集群</a></h3>
<blockquote>
<p>添加完后会提示：Added meta node x at cnosdb-meta-0x:8091</p>
</blockquote>
<pre><code>cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-01:8091
cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-02:8091
cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-03:8091
</code></pre>
<p>3个节点都添加完输入<code>cnosdb-ctl show</code>查看集群状态</p>
<pre><code>Data Nodes:
==========


Meta Nodes:
==========

1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
<p>请注意，一但没有出现3个节点，不要进行下一步。</p>
<h3 id="启动data节点"><a class="header" href="#启动data节点">启动<code>data</code>节点</a></h3>
<blockquote>
<p>启动前将配置文件中的<code>cluster</code>改为<code>true</code></p>
</blockquote>
<pre><code> cnosdb --config [cnosdb_config_path]
</code></pre>
<h3 id="将data节点加入到集群"><a class="header" href="#将data节点加入到集群">将<code>data</code>节点加入到集群</a></h3>
<blockquote>
<p>添加完后会提示：Added data node x at cnosdb-data-0x:8088</p>
</blockquote>
<pre><code>cnosdb-ctl --bind cnosdb-data-01:8091 add-data cnosdb-data-01:8088
cnosdb-ctl --bind cnosdb-data-01:8091 add-data cnosdb-data-02:8088
</code></pre>
<p>2个节点都添加完输入<code>cnosdb-ctl show</code>查看集群状态</p>
<pre><code>Data Nodes:
==========

4      cnosdb-data-01:8088
5      cnosdb-data-02:8088
Meta Nodes:
==========

1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他"><a class="header" href="#其他">其他</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用kubernetes部署cnosdb"><a class="header" href="#使用kubernetes部署cnosdb">使用Kubernetes部署CnosDB</a></h1>
<h2 id="创建namespace"><a class="header" href="#创建namespace">创建namespace</a></h2>
<pre><code class="language-shell">NAMESPACE=cnosdb-prod
kubectl create namespace $NAMESPACE
</code></pre>
<h2 id="创建配置文件"><a class="header" href="#创建配置文件">创建配置文件</a></h2>
<pre><code class="language-shell">wget -O cnosdb.conf https://cnosdb.github.io/content/cnosdb/0.9/other/cnosdb.sample.toml
kubectl create configmap cnosdb-config --from-file cnosdb.conf -n $NAMESPACE
</code></pre>
<h2 id="编写deployment文件"><a class="header" href="#编写deployment文件">编写Deployment文件</a></h2>
<pre><code class="language-shell">$ cat cnosdb-deployment.yaml
apiVersion: v1
kind: Deployment
metadata:
  name: cnosdb-deployment
  labels:
    app: cnosdb
spec:
  replicas: 1
  selector:
    matchLabels:
      app: cnosdb
  template:
    metadata:
      labels:
        app: cnosdb
    spec:
      containers:
      - name: cnosdb
        image: cnosdb/cnosdb:latest
        ports:
        - name: cnosdb
          containerPort: 8086
          protocol: TCP
        volumeMounts:
        - name: cnosdbvolume
          mountPath: /cnosdb
      volumes:
      - name: cnosdbvolume
        hostPath:
          path: /opt/data
      - name: cnosdb-config
        configMap:
          name: cnosdb-config
</code></pre>
<h2 id="编写service文件"><a class="header" href="#编写service文件">编写Service文件</a></h2>
<pre><code class="language-shell">$ cat cnosdb-service.yaml
apiVersion: v1
kind: Service
metadata:
  labels:
    app: cnosdb
  name: cnosdb-service
spec:
  ports:
  - port: 32085
    nodePort: 32086
    protocol: TCP
  selector:
    app: cnosdb
  type: NodePort
</code></pre>
<h2 id="创建deployment和service"><a class="header" href="#创建deployment和service">创建Deployment和Service</a></h2>
<pre><code class="language-shell">kubectl apply -f cnosdb-deployment.yaml -n $NAMESPACE
kubectl apply -f cnosdb-service.yaml -n $NAMESPACE
</code></pre>
<h2 id="测试是否正确安装"><a class="header" href="#测试是否正确安装">测试是否正确安装</a></h2>
<pre><code class="language-shell">$ kubectl get pods -n $NAMESPACE
NAME                                 READY   STATUS    RESTARTS   AGE
cnosdb-deployment-855c7f4c59-6xl67   1/1     Running   0          5m24s
$
$ kubectl get svc -n $NAMESPACE
NAME             TYPE       CLUSTER-IP      EXTERNAL-IP   PORT(S)           AGE
cnosdb-service   NodePort   10.100.125.92   &lt;none&gt;        30085:32086/TCP   49m

$ curl -i -XPOST http://&lt;nodeIP&gt;:32086/query --data-urlencode &quot;q=CREATE DATABASE test_db&quot;
HTTP/1.1 200 OK
Content-Type: application/json
X-Request-Id: 41e2329b-6945-11ec-8001-0242ac110007
Date: Thu, 30 Dec 2021 07:51:12 GMT
Transfer-Encoding: chunked

{&quot;results&quot;:[{&quot;statement_id&quot;:0}]}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="使用kubernetes部署cnosdb集群"><a class="header" href="#使用kubernetes部署cnosdb集群">使用Kubernetes部署CnosDB集群</a></h1>
<h2 id="创建一个kubernetes-cnosdb部署文件"><a class="header" href="#创建一个kubernetes-cnosdb部署文件">创建一个Kubernetes CnosDB部署文件</a></h2>
<blockquote>
<p>下面的清单中包含两个<a href="https://kubernetes.io/zh/docs/concepts/services-networking/service/">Service</a>，两个<a href="https://kubernetes.io/zh/docs/concepts/configuration/configmap/https://kubernetes.io/zh/docs/concepts/configuration/configmap/">ConfigMap</a>，和两个<a href="https://kubernetes.io/zh/docs/concepts/workloads/controllers/statefulset/">StatefulSet</a>
本教程假设你的集群配置为动态的提供 PersistentVolumes。 如果你的集群没有配置成这样，在开始本教程前，你需要手动准备三个 20 GiB 和两个 2GiB 的卷。</p>
</blockquote>
<pre><code class="language-yaml">apiVersion: v1
kind: Service
metadata:
  name: cnosdb-meta
  labels:
    app: cnosdb-meta
spec:
  ports:
  - port: 8091
    name: meta
  selector:
    app: cnosdb-meta
---
apiVersion: v1
kind: Service
metadata:
  name: cnosdb-data
  labels:
    app: cnosdb-data
spec:
  type: LoadBalancer
  ports:
  - port: 8088
    name: data
  - port: 8086
    targetPort: 8086
    nodePort: 31086
    name: data-access
  selector:
    app: cnosdb-data
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: cnosdb-meta-pdb
spec:
  selector:
    matchLabels:
      app: cnosdb-meta
  maxUnavailable: 2
---
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: cnosdb-data-pdb
spec:
  selector:
    matchLabels:
      app: cnosdb-data
  maxUnavailable: 1
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cnosdb-meta-config
  labels:
    app: cnosdb-meta
data:
  cnosdb-meta.conf: |+
    dir = &quot;/var/lib/cnosdb/meta&quot;
    retention-autocreate = true
    hostname = &quot;&quot;
    [HTTPD]
      logging-enabled = true
      http-bind-address = &quot;:8091&quot;
      https-enabled = false
      https-certificate = &quot;&quot;
      election-timeout = &quot;1s&quot;
      heartbeat-timeout = &quot;1s&quot;
      leader-lease-timeout = &quot;500ms&quot;
      commit-timeout = &quot;50ms&quot;
      cluster-tracing = false
      lease-duration = &quot;1m0s&quot;
    [Log]
      level = &quot;INFO&quot;
      format = &quot;text&quot;
      disable-timestamp = false
      development = false
      disable-caller = false
      disable-stacktrace = false
      disable-error-verbose = false
    [Log.file]
      filename = &quot;&quot;
      max-size = 0
      max-days = 0
      max-backups = 0
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: cnosdb-data-config
  labels:
    app: cnosdb-data
data:
  cnosdb-data.conf: |+
    bind-address = &quot;:8088&quot;
    cluster = true
    hostname = &quot;&quot;

    [Meta]
      dir = &quot;/var/lib/cnosdb/meta&quot;
      retention-autocreate = true

    [Data]
      dir = &quot;/var/lib/cnosdb/data&quot;
      index-version = &quot;tsi1&quot;
      wal-dir = &quot;/var/lib/cnosdb/wal&quot;
      wal-fsync-delay = &quot;0s&quot;
      validate-keys = false
      query-log-enabled = true
      cache-max-memory-size = 1073741824
      cache-snapshot-memory-size = 26214400
      cache-snapshot-write-cold-duration = &quot;10m0s&quot;
      compact-full-write-cold-duration = &quot;4h0m0s&quot;
      compact-throughput = 50331648
      compact-throughput-burst = 50331648
      max-series-per-database = 1000000
      max-values-per-tag = 100000
      max-concurrent-compactions = 0
      max-index-log-file-size = 1048576
      series-id-set-cache-size = 100
      trace-logging-enabled = false
      tsm-use-madv-willneed = false

    [Coordinator]
      force-remote-mapping = false
      write-timeout = &quot;10s&quot;
      shard-writer-timeout = &quot;5s&quot;
      max-remote-write-connections = 3
      shard-mapper-timeout = &quot;5s&quot;
      max-concurrent-queries = 0
      query-timeout = &quot;0s&quot;
      log-queries-after = &quot;0s&quot;
      max-select-point = 0
      max-select-series = 0
      max-select-buckets = 0

    [RetentionPolicy]
      enabled = true
      check-interval = &quot;30m0s&quot;

    [Precreator]
      enabled = true
      check-interval = &quot;10m0s&quot;
      advance-period = &quot;30m0s&quot;

    [Monitor]
      store-enabled = true
      store-database = &quot;_internal&quot;
      store-interval = &quot;10s&quot;

    [Subscriber]
      enabled = false
      http-timeout = &quot;0s&quot;
      insecure-skip-verify = false
      ca-certs = &quot;&quot;
      write-concurrency = 0
      write-buffer-size = 0

    [HTTPD]
      enabled = true
      bind-address = &quot;:8086&quot;
      auth-enabled = false
      log-enabled = true
      suppress-write-log = false
      write-tracing = false
      pprof-enabled = true
      debug-pprof-enabled = false
      https-enabled = false
      https-certificate = &quot;/etc/ssl/cnosdb.pem&quot;
      https-private-key = &quot;&quot;
      max-row-limit = 0
      max-connection-limit = 0
      shared-secret = &quot;&quot;
      realm = &quot;CnosDB&quot;
      unix-socket-enabled = false
      unix-socket-permissions = &quot;0777&quot;
      bind-socket = &quot;/var/run/cnosdb.sock&quot;
      max-body-size = 25000000
      access-log-path = &quot;&quot;
      max-concurrent-write-limit = 0
      max-enqueued-write-limit = 0
      enqueued-write-timeout = 30000000000

    [Log]
      level = &quot;INFO&quot;
      format = &quot;text&quot;
      disable-timestamp = false
      development = false
      disable-caller = false
      disable-stacktrace = false
      disable-error-verbose = false
    [Log.file]
      filename = &quot;&quot;
      max-size = 0
      max-days = 0
      max-backups = 0

    [ContinuousQuery]
      log-enabled = true
      enabled = true
      query-stats-enabled = false
      run-interval = &quot;1s&quot;

    [HintedHandoff]
      enabled = false
      dir = &quot;&quot;
      max-size = 0
      max-age = &quot;0s&quot;
      retry-rate-limit = 0
      retry-interval = &quot;0s&quot;
      retry-max-interval = &quot;0s&quot;
      purge-interval = &quot;0s&quot;

    [TLS]
      min-version = &quot;&quot;
      max-version = &quot;&quot;
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cnosdb-meta
spec:
  selector:
    matchLabels:
      app: cnosdb-meta
  serviceName: cnosdb-meta
  replicas: 3
  updateStrategy:
    type: RollingUpdate
  podManagementPolicy: OrderedReady
  template:
    metadata:
      labels:
        app: cnosdb-meta
    spec:
      containers:
      - name: kubernetes-cnosdb-meta
        imagePullPolicy: Always
        image: &quot;cnosdb/cnosdb-meta:latest&quot;
        resources:
          requests:
            memory: &quot;2Gi&quot;
            cpu: &quot;2&quot;
        ports:
        - containerPort: 8091
          name: meta
        volumeMounts:
        - name: metadir
          mountPath: /var/lib/cnosdb
        - name: meta-config-volume
          mountPath: /etc/cnosdb/
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: CNOSDB_HOSTNAME
          value: &quot;$(POD_NAME).cnosdb-meta&quot;
      volumes:
        - name: meta-config-volume
          configMap:
            name: cnosdb-meta-config
  volumeClaimTemplates:
    - metadata:
        name: metadir
      spec:
        accessModes: [ &quot;ReadWriteOnce&quot; ]
        resources:
          requests:
            storage: 2Gi
---
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cnosdb-data
spec:
  selector:
    matchLabels:
      app: cnosdb-data
  serviceName: cnosdb-data
  replicas: 2
  updateStrategy:
    type: RollingUpdate
  podManagementPolicy: OrderedReady
  template:
    metadata:
      labels:
        app: cnosdb-data
    spec:
      containers:
      - name: kubernetes-cnosdb-data
        imagePullPolicy: Always
        image: &quot;cnosdb/cnosdb-data:latest&quot;
        resources:
          requests:
            memory: &quot;8Gi&quot;
            cpu: &quot;4&quot;
        ports:
        - containerPort: 8088
          name: cnosdb-data
        - containerPort: 8086
          name: data-access
        volumeMounts:
        - name: datadir
          mountPath: /var/lib/cnosdb
        - name: data-config-volume
          mountPath: /etc/cnosdb/
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: CNOSDB_HOSTNAME
          value: &quot;$(POD_NAME).cnosdb-data&quot;
      volumes:
        - name: data-config-volume
          configMap:
            name: cnosdb-data-config
  volumeClaimTemplates:
    - metadata:
        name: datadir
      spec:
        accessModes: [ &quot;ReadWriteOnce&quot; ]
        resources:
          requests:
            storage: 20Gi
</code></pre>
<h2 id="按照清单部署应用"><a class="header" href="#按照清单部署应用">按照清单部署应用</a></h2>
<pre><code class="language-shell">kubectl apply -f cnosdb-cluster.yaml
</code></pre>
<h2 id="将meta-node加入到集群"><a class="header" href="#将meta-node加入到集群">将<code>meta node</code>加入到集群</a></h2>
<blockquote>
<p>使用<code>kubectl get pod</code>查看，当所有pod都处于Running时</p>
</blockquote>
<pre><code class="language-shell">for i in 0 1 2; do kubectl exec cnosdb-meta-0 -- cnosdb-ctl add-meta  cnosdb-meta-$i.cnosdb-meta:8091; done
</code></pre>
<h2 id="如果以上命令执行成功"><a class="header" href="#如果以上命令执行成功">如果以上命令执行成功</a></h2>
<pre><code class="language-shell">kubectl exec cnosdb-meta-0 -- cnosdb-ctl show
Data Nodes:
==========

Meta Nodes:
==========

1      cnosdb-meta-0.cnosdb-meta:8091
2      cnosdb-meta-1.cnosdb-meta:8091
3      cnosdb-meta-2.cnosdb-meta:8091

</code></pre>
<h2 id="将data-node加入到集群"><a class="header" href="#将data-node加入到集群">将<code>data node</code>加入到集群</a></h2>
<pre><code class="language-shell">for i in 0 1; do kubectl exec cnosdb-meta-0 -- cnosdb-ctl add-data  cnosdb-data-$i.cnosdb-data:8088; done
</code></pre>
<h2 id="如果以上命令执行成功-1"><a class="header" href="#如果以上命令执行成功-1">如果以上命令执行成功</a></h2>
<pre><code class="language-shell">kubectl exec cnosdb-meta-0 -n cnosdb-test -- cnosdb-ctl show
Data Nodes:
==========

4      cnosdb-data-0.cnosdb-data:8088
5      cnosdb-data-1.cnosdb-data:8088

Meta Nodes:
==========

1      cnosdb-meta-0.cnosdb-meta:8091
2      cnosdb-meta-1.cnosdb-meta:8091
3      cnosdb-meta-2.cnosdb-meta:8091

</code></pre>
<h2 id="测试服务是否可用"><a class="header" href="#测试服务是否可用">测试服务是否可用</a></h2>
<pre><code class="language-shell">curl -i -XPOST http://&lt;nodeIP&gt;:31086/query --data-urlencode &quot;q=CREATE DATABASE test_db&quot;
HTTP/1.1 200 OK
Content-Type: application/json
X-Request-Id: 41e2329b-6945-11ec-8001-0242ac110007
Date: Thu, 30 Dec 2021 07:51:12 GMT
Transfer-Encoding: chunked

{&quot;results&quot;:[{&quot;statement_id&quot;:0}]}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
