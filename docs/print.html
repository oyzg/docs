<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CnosDB</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="content/cnosdb/latest/about.html"><strong aria-hidden="true">1.</strong> 关于CnosDB</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/index.html"><strong aria-hidden="true">2.</strong> 快速上手</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/install.html"><strong aria-hidden="true">2.1.</strong> 下载与安装</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/cnosdb-cli.html"><strong aria-hidden="true">2.2.</strong> 命令行终端</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/introduction/quick-start.html"><strong aria-hidden="true">2.3.</strong> 快速开始</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/index.html"><strong aria-hidden="true">3.</strong> 应用编程接口</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/line_protocol.html"><strong aria-hidden="true">3.1.</strong> CnosDB Line Protocol</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/write_api.html"><strong aria-hidden="true">3.2.</strong> CnosDB Write API</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/query_api.html"><strong aria-hidden="true">3.3.</strong> CnosDB Query API</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/prometheus.html"><strong aria-hidden="true">3.4.</strong> Prometheus</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/protocol/goland.html"><strong aria-hidden="true">3.5.</strong> Golang</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/index.html"><strong aria-hidden="true">4.</strong> 运维管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/export_import.html"><strong aria-hidden="true">4.1.</strong> 导入和导出</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/backup_restore.html"><strong aria-hidden="true">4.2.</strong> 备份和还原</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/managerment/configuration.html"><strong aria-hidden="true">4.3.</strong> CnosDB配置</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/sandboxmanagement.html"><strong aria-hidden="true">4.4.</strong> 集群管理</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/index.html"><strong aria-hidden="true">4.5.</strong> 运维工具介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/cnosdb.html"><strong aria-hidden="true">4.5.1.</strong> cnosdb</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-cli.html"><strong aria-hidden="true">4.5.2.</strong> cnosdb-cli</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html"><strong aria-hidden="true">4.5.3.</strong> cnosdb-inspect</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/index.html"><strong aria-hidden="true">5.</strong> 语法参考手册</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_sample.html"><strong aria-hidden="true">5.1.</strong> 示例数据</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_syntax.html"><strong aria-hidden="true">5.2.</strong> 数据查询</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_management.html"><strong aria-hidden="true">5.3.</strong> 数据库管理和模式查询</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_function.html"><strong aria-hidden="true">5.4.</strong> 函数</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/continuous_queries.html"><strong aria-hidden="true">5.5.</strong> 连续查询</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/math_operators.html"><strong aria-hidden="true">5.6.</strong> 数学运算符</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/cnosql/cnosql_spect.html"><strong aria-hidden="true">5.7.</strong> 语法约定</a></li></ol></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/other/index.html"><strong aria-hidden="true">6.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="content/cnosdb/latest/other/version_manager.html"><strong aria-hidden="true">6.1.</strong> 发行版本说明</a></li><li class="chapter-item expanded "><a href="content/cnosdb/latest/other/tsdb-comparisions.html"><strong aria-hidden="true">6.2.</strong> CnosDB性能比较</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CnosDB</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cnosdb"><a class="header" href="#cnosdb">CnosDB</a></h1>
<p>CnosDB是一个由社区驱动的开源时间序列数据库。</p>
<h2 id="产品特性"><a class="header" href="#产品特性">产品特性</a></h2>
<ul>
<li>全面与InfluxDB 1.X 稳定版兼容。</li>
<li>类sql查询语言，易于查询聚合数据</li>
<li>开源分布式集群，产品永久免费。</li>
<li>24*7全球开源社区支持。</li>
<li>实时时序数据库：可将您的离线监控平台提升为一个实时决策系统</li>
<li>支持海量时间序列线：在海量标签、海量时间序列线的情况下，依然能够高效实现分布式迭代器及查询优化</li>
<li>低成本/碳中和：高效的存储引擎可充分发挥硬件性能，并在高效压缩存储的同时保障查询效率</li>
<li>强大完整的生态：可集成市面上主流的采集、存储、分析、可视化等工具</li>
</ul>
<h2 id="使用场景"><a class="header" href="#使用场景">使用场景</a></h2>
<blockquote>
<p>作为一款专注于时序数据场景的时序型数据库，CnosDB适用于监控服务器指标、应用程序指标、性能指标、函数接口调用指标、网络流量数据、探测器数据、日志、市场交易记录等的各种时序场景。</p>
</blockquote>
<h3 id="devops监控"><a class="header" href="#devops监控">DevOps监控</a></h3>
<p>通过监控基础设施（服务器、容器、数据库、微服务、云服务等）的核心指标来及时发现问题并在影响关键业务之前解决问题，尽管一些新兴技术提升了基础设施的DevOps监控的复杂性，但CnosDB都能很好地适应。CnosDB通过灵活的插件的形式，采集指标或者从第三方服务（如StatsD或Kafka）拉取数据，并通过自定义配置按需上报给外部存储系统。</p>
<h3 id="iot监控"><a class="header" href="#iot监控">IoT监控</a></h3>
<p>主要用于接收和处理来自IoT设备的海量数据，并进行实时分析，在无人工干预的情况下，执行预定义操作，IoT设备无处不在，公路摄像头、智能网联车、手机、冰箱都有它的身影，不过IoT设备的硬件性能和缓存能力有限，数据往往是以流式方式实时上报，所以需要一个弹性、扩展性强的高性能时序后台来应对突发流量的挑战。CnosDB的水平扩展、实时分析等能力是专门针对这类场景来设计的，具有足够的读写性能和容量弹性。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速上手"><a class="header" href="#快速上手">快速上手</a></h1>
<ul>
<li><a href="content/cnosdb/latest/introduction/./install.html">下载与安装</a></li>
<li><a href="content/cnosdb/latest/introduction/./cnosdb-cli.html">命令行终端</a></li>
<li><a href="content/cnosdb/latest/introduction/./quick-start.html">快速开始</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="安装"><a class="header" href="#安装">安装</a></h1>
<p>摘要：本指南介绍如何安装CnosDB</p>
<blockquote>
<p>历史版本和其他操作系统软件安装包，请访问<a href="https://github.com/cnosdb/cnosdb/releases">GitHub Releases</a></p>
</blockquote>
<h2 id="ubuntu--debian"><a class="header" href="#ubuntu--debian">Ubuntu &amp; Debian</a></h2>
<ol>
<li>
<p>使用<code>wget</code>命令从官网下载获得deb安装包<code>cnosdb_1.0.1_amd64.deb</code></p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v1.0.1/cnosdb_1.0.1_amd64.deb
</code></pre>
</li>
<li>
<p>进入<code>cnosdb_1.0.1_amd64.deb</code>所在目录，使用<code>dpkg</code>命令进行安装</p>
<pre><code class="language-shell">sudo dpkg -i cnosdb_1.0.1_amd64.deb
</code></pre>
</li>
<li>
<p>安装成功后即可启动，执行以下命令进行启动</p>
<pre><code class="language-shell">sudo systemctl start cnosdb
</code></pre>
<p>启动后可使用以下命令验证是否启动成功：</p>
<pre><code># sudo systemctl status cnosdb
● cnosdb.service - CnosDB is an open-source, disributed, time series database
   Loaded: loaded (/usr/lib/systemd/system/cnosdb.service; enabled; vendor preset: disabled)
   Active: active (running) since Thu 2022-05-19 11:16:59 CST; 1s ago
     Docs: https://www.cnosdb.com
 Main PID: 16942 (cnosdb)
   CGroup: /system.slice/cnosdb.service
           └─16942 /usr/bin/cnosdb --config /etc/cnosdb/cnosdb.conf

May 19 11:16:59 iZ2ze48dce3wds62w0b6vrZ systemd[1]: Started CnosDB is an open-source, disributed, time series database.
May 19 11:16:59 iZ2ze48dce3wds62w0b6vrZ cnosdb[16942]: [2022/05/19 11:16:59.255 +08:00] [INFO] [run.go:94] [&quot;Loading configuration file&quot;] [path=/etc/cnosdb/cnosdb.conf]
May 19 11:16:59 iZ2ze48dce3wds62w0b6vrZ cnosdb[16942]: open server: listen: listen tcp 127.0.0.1:8086: bind: address already in use  
</code></pre>
</li>
</ol>
<h2 id="red-hat--centos"><a class="header" href="#red-hat--centos">Red Hat &amp; CentOS</a></h2>
<ol>
<li>
<p>使用<code>wget</code>命令从官网下载获得rpm安装包<code>cnosdb-1.0.1.x86_64.rpm</code></p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v1.0.1/cnosdb-1.0.1.x86_64.rpm
</code></pre>
</li>
<li>
<p>进入<code>cnosdb-1.0.1.x86_64.rpm</code>所在目录，使用<code>yum</code>命令进行安装</p>
<pre><code class="language-shell">sudo yum localinstall cnosdb-1.0.1.x86_64.rpm
</code></pre>
</li>
<li>
<p>安装成功后即可启动，执行以下命令进行启动</p>
<pre><code class="language-shell">sudo systemctl start cnosdb
</code></pre>
<p>启动后可使用以下命令验证是否启动成功：</p>
<pre><code># sudo systemctl status cnosdb
● cnosdb.service - CnosDB is an open-source, disributed, time series database
   Loaded: loaded (/usr/lib/systemd/system/cnosdb.service; enabled; vendor preset: disabled)
   Active: active (running) since Thu 2022-05-19 11:16:59 CST; 1s ago
     Docs: https://www.cnosdb.com
 Main PID: 16942 (cnosdb)
   CGroup: /system.slice/cnosdb.service
           └─16942 /usr/bin/cnosdb --config /etc/cnosdb/cnosdb.conf

May 19 11:16:59 iZ2ze48dce3wds62w0b6vrZ systemd[1]: Started CnosDB is an open-source, disributed, time series database.
May 19 11:16:59 iZ2ze48dce3wds62w0b6vrZ cnosdb[16942]: [2022/05/19 11:16:59.255 +08:00] [INFO] [run.go:94] [&quot;Loading configuration file&quot;] [path=/etc/cnosdb/cnosdb.conf]
May 19 11:16:59 iZ2ze48dce3wds62w0b6vrZ cnosdb[16942]: open server: listen: listen tcp 127.0.0.1:8086: bind: address already in use  
</code></pre>
</li>
</ol>
<h2 id="在windows安装"><a class="header" href="#在windows安装">在Windows安装</a></h2>
<blockquote>
<p>以下命令请使用Windows PowerShell执行</p>
</blockquote>
<ol>
<li>
<p>下载安装包</p>
<pre><code class="language-shell">wget https://github.com/cnosdb/cnosdb/releases/download/v1.0.1/cnosdb-1.0.1_windows_amd64.zip -UseBasicParsing -OutFile cnosdb-1.0.1_windows_amd64.zip
</code></pre>
</li>
<li>
<p>解压并安装</p>
<pre><code class="language-shell">Expand-Archive .\cnosdb-1.0.1_windows_amd64.zip -DestinationPath 'C:\Program Files\cnosdb\'
</code></pre>
</li>
<li>
<p>将配置到环境变量
先查看目录上一步的解压目录</p>
<pre><code class="language-shell">PS C:\Users\Administrator&gt; ls  'C:\Program Files\cnosdb\'


 目录: C:\Program Files\cnosdb


Mode                 LastWriteTime         Length Name
----                 -------------         ------ ----
d-----         2022/5/19     15:58                cnosdb-1.0.1-1
</code></pre>
</li>
<li>
<p>将安装目录配置到环境变量</p>
<pre><code class="language-shell">setx PATH &quot;%PATH%;C:\Program Files\cnosdb\cnosdb-1.0.1-1\&quot;
</code></pre>
</li>
<li>
<p>打开Windows中的命令提示符程序，执行以下命令(这里不在PowerShell中执行)</p>
<pre><code class="language-shell">cnosdb
</code></pre>
<p>将返回以下内容：</p>
<pre><code class="language-shell">C:\Users\Administrator&gt;cnosdb
[2022-05-19T16:11:00.252173+08:00] [INFO] [run.go:81] [&quot;No configuration provided, using default settings&quot;] [log_id=0aYqlV70000]
[2022-05-19T16:11:00.262211+08:00] [INFO] [store.go:214] [&quot;Using data dir&quot;] [log_id=0aYqlV7l000] [service=store] [path=&quot;C:\Users\Administrator\.cnosdb\data&quot;]
[2022-05-19T16:11:00.262211+08:00] [INFO] [store.go:287] [&quot;Compaction settings&quot;] [log_id=0aYqlV7l000] [service=store] [max_concurrent_compactions=3] [throughput_bytes_per_second=50331648] [throughput_bytes_per_second_burst=50331648]
[2022-05-19T16:11:00.262211+08:00] [INFO] [fields.go:108] [&quot;Open store (start)&quot;] [log_id=0aYqlV7l000] [service=store] [trace_id=0aYqlV9W000] [op_name=tsdb_open] [op_event=start]
[2022-05-19T16:11:00.262211+08:00] [INFO] [fields.go:110] [&quot;Open store (end)&quot;] [log_id=0aYqlV7l000] [service=store] [trace_id=0aYqlV9W000] [op_name=tsdb_open] [op_event=end] [op_elapsed=0.000ms]
[2022-05-19T16:11:00.263212+08:00] [INFO] [http_handler.go:241] [&quot;opened HTTP access log&quot;] [log_id=0aYqlV7l000] [path=stderr]
[2022-05-19T16:11:00.263850+08:00] [INFO] [service.go:76] [&quot;Starting cluster service&quot;] [log_id=0aYqlV7l000] [service=coordinator]
[2022-05-19T16:11:00.263850+08:00] [INFO] [service.go:68] [&quot;Starting snapshot service&quot;] [log_id=0aYqlV7l000] [service=snapshot]
[2022-05-19T16:11:00.263850+08:00] [INFO] [service.go:121] [&quot;Starting continuous query service&quot;] [log_id=0aYqlV7l000] [service=continuous_querier]
</code></pre>
</li>
</ol>
<h2 id="docker"><a class="header" href="#docker">Docker</a></h2>
<ol>
<li>
<p>拉取镜像</p>
<pre><code class="language-shell">docker pull cnosdb/cnosdb:latest
</code></pre>
<p>如需其他版本，可在<a href="https://hub.docker.com/r/cnosdb/cnosdb/tags">Docker Hub</a> 查找指定版本</p>
</li>
<li>
<p>启动容器</p>
<pre><code class="language-shell">docker run -itd -p 8086:8086 cnosdb/cnosdb:latest
</code></pre>
<p>使用以下命令确定该容器已经启动并且在正常运行</p>
<pre><code class="language-shell">docker ps
</code></pre>
<p>使用以下命令可进入该容器并执行 bash</p>
<pre><code class="language-shell">docker exec -it &lt;container name&gt; bash
</code></pre>
</li>
</ol>
<h2 id="验证下载二进制文件的真实性可选"><a class="header" href="#验证下载二进制文件的真实性可选">验证下载二进制文件的真实性（可选）</a></h2>
<p>为了验证安全性，请按照以下步骤验证您下载的CnosDB的<code>gpg</code>签名（大多数系统默认包含<code>gpg</code>命令，如果<code>gpg</code>不可用，请参阅<a href="https://gnupg.org/download">Gun主页</a> 获取安装说明。)</p>
<ol>
<li>下载并导入CnosDB公钥</li>
</ol>
<pre><code>curl -s https://www.cnosdb.com/cnosdb.key | gpg --import
</code></pre>
<ol start="2">
<li>通过在URL上添加<code>.asc</code>来下载指定版本的签名文件</li>
</ol>
<pre><code class="language-shell"> wget https://github.com/cnosdb/cnosdb/releases/download/v1.0.1/cnosdb-1.0.1_linux_amd64.tar.gz
</code></pre>
<ol start="3">
<li>验证签名 <code>gpg --verify</code></li>
</ol>
<pre><code class="language-shell"> gpg --verify cnosdb-1.0.1_linux_amd64.tar.gz.asc cnosdb-1.0.1_linux_amd64.tar.gz
</code></pre>
<p>此命令应该输出：</p>
<pre><code class="language-shell">gpg: Good signature from &quot;CnosDB &lt;contact@cnosdb.com&gt;&quot; [unknown]
</code></pre>
<p>如果您已成功完成本指南，则您已安装 CnosDB 并准备好连接到您的CnosDB实例并开始插入数据。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-cli"><a class="header" href="#cnosdb-cli">cnosdb-cli</a></h1>
<blockquote>
<p>使用cnosdb-cli交互式命令行工具操作CnosDB。</p>
</blockquote>
<ul>
<li><a href="content/cnosdb/latest/introduction/cnosdb-cli.html#%E5%BC%80%E5%A7%8Bcnosdb-cli">开始使用cnosdb-cli</a></li>
<li><a href="content/cnosdb/latest/introduction/cnosdb-cli.html#cnosdb-cli%E5%8F%82%E6%95%B0">cnosdb-cli参数</a></li>
<li><a href="content/cnosdb/latest/introduction/cnosdb-cli.html#cnosdb-cli%E5%91%BD%E4%BB%A4">cnosdb-cli命令</a></li>
</ul>
<h2 id="开始使用cnosdb-cli"><a class="header" href="#开始使用cnosdb-cli">开始使用cnosdb-cli</a></h2>
<p>如果使用cnosdb-cli，则需要先启动cnosdb进程，然后在终端启动cnosdb-cli，如果成功连接，您将看到以下输出：</p>
<pre><code>$ cnosdb-cli
CnosDB shell version: v1.0.1
&gt;
</code></pre>
<p>您可以在终端输入<code>help</code>命令，查询有效的命令。CnosQL的语法请查看<a href="content/cnosdb/latest/introduction/../cnosql/index.html">语法参考手册</a></p>
<h2 id="cnosdb-cli参数"><a class="header" href="#cnosdb-cli参数">cnosdb-cli参数</a></h2>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td>--host</td><td>连接的 cnosdb HTTP 协议地址 (default: http://localhost:8086)</td></tr>
<tr><td>--port</td><td>连接的 cnosdb 的端口号</td></tr>
<tr><td>--password</td><td>连接服务时使用的密码</td></tr>
<tr><td>--username</td><td>连接服务时使用的用户名</td></tr>
<tr><td>--ssl</td><td>连接时使用 HTTPS 协议</td></tr>
<tr><td>--format</td><td>指定打印 cnosdb 服务的响应内容的格式: json, csv, or column</td></tr>
<tr><td>--precision</td><td>指定时间戳的格式: rfc3339, h, m, s, ms, u or ns</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="快速入门"><a class="header" href="#快速入门">快速入门</a></h1>
<p>如果您已经拥有了一个CnosDB实例（如果您还没有，请查看<a href="content/cnosdb/latest/introduction/./install.html">下载和安装</a>）。下面来学习一下CnosDB的查询语言CnosQL，CnosDB并不是传统意义上的SQL数据库，使用的是类SQL的CnosQL语言对数据库进行操作 ，同时CnosQL查询语言的简洁程度完全可以媲美标准SQL，以下是一些简单的描述，可以让您迅速学会CnosQL查询语言</p>
<h2 id="启动实例"><a class="header" href="#启动实例">启动实例</a></h2>
<p>请查看<a href="content/cnosdb/latest/introduction/./install.html">下载和安装</a></p>
<p>CnosDB包含两个重要的程序：<code>cnosdb</code>和<code>cnosdb-cli</code>
cnosdb是CnosDB的服务端程序，<code>cnosdb-cli</code>是CnosDB的命令行客户端。
使用<code>cnosdb-cli</code>连接CnosDB的服务端，可以执行以下命令：</p>
<pre><code class="language-shell">$ cnosdb-cli
</code></pre>
<p>连接成功后会提示客户端的版本：</p>
<pre><code class="language-shell">CnosDB shell version: vunknown
&gt;
</code></pre>
<h2 id="创建数据库"><a class="header" href="#创建数据库">创建数据库</a></h2>
<p>创建一个名称为<code>oceanic_station</code>的数据库</p>
<pre><code class="language-sql">&gt; CREATE DATABASE oceanic_station
</code></pre>
<p>创建一个数据库oceanic_station
创建成功后，并不会返回任何结果，不过不必担心，没有结果才是最好的结果，您已经成功创建了数据库</p>
<p>可以使用<code>SHOW DATABASES</code>来进行查看：</p>
<pre><code class="language-shell">SHOW DATABASES
</code></pre>
<p>返回的结果如下：</p>
<pre><code>name: databases
name
----
oceanic_station
</code></pre>
<p><code>oceanic_station</code>就是刚刚创建的数据库</p>
<h2 id="使用数据库"><a class="header" href="#使用数据库">使用数据库</a></h2>
<p><code>USE &lt;db-name&gt;</code>后，后面所有操作都是在这个DB中进行</p>
<pre><code class="language-sql">&gt; use oceanic_station
</code></pre>
<p>成功会返回如下提示：</p>
<pre><code>Using database oceanic_station
Using rp autogen
</code></pre>
<h2 id="写入数据"><a class="header" href="#写入数据">写入数据</a></h2>
<p>CnosDB通过insert语句写入数据，现在向数据库中写入一条语句，数据的格式必须符合<code>line protocol</code>格式</p>
<pre><code class="language-sql">&gt; insert test_air,station=XiaoMaiDao visibility=68,temperature=79,pressure=75 
&gt; insert test_air,station=LianYunGang visibility=71,temperature=63,pressure=78
&gt; insert test_air,station=LianYunGang visibility=71,temperature=63,pressure=79
&gt; insert test_air,station=LianYunGang visibility=71,temperature=53,pressure=79
&gt; insert test_air,station=LianYunGang visibility=71,temperature=63,pressure=90
&gt; insert test_air,station=XiaoMaiDao visibility=78,temperature=79,pressure=75 
&gt; insert test_air,station=XiaoMaiDao visibility=78,temperature=77,pressure=75 
&gt; 
</code></pre>
<p>我们新建了test_air这个measurement，并插入了7条数据，每条数据包含1个tag，3个field</p>
<p>CnosDB中的数据预先是不需要建立Schema的，<code>test_air</code>会自动变成<code>measurement</code>，具体的定义请查看<a href="content/cnosdb/latest/introduction/../protocol/line_protocol.html">CnosDB Line Protocol</a></p>
<h2 id="查询数据"><a class="header" href="#查询数据">查询数据</a></h2>
<p>查询表中的所有数据，和SQL的语法是一样的</p>
<pre><code class="language-sql">&gt; select * from test_air
</code></pre>
<p>返回结果如下：</p>
<pre><code>name: test_air
time                        pressure station     temperature visibility
----                        -------- -------     ----------- ----------
2022-05-05T06:55:24.596027Z 75       XiaoMaiDao  79          68
2022-05-05T06:55:24.698504Z 78       LianYunGang 63          71
2022-05-05T06:55:24.735811Z 79       LianYunGang 63          71
2022-05-05T06:55:24.757501Z 79       LianYunGang 53          71
2022-05-05T06:55:24.777992Z 90       LianYunGang 63          71
2022-05-05T06:55:24.798981Z 75       XiaoMaiDao  79          78
2022-05-05T06:55:24.818872Z 75       XiaoMaiDao  77          78
</code></pre>
<p>此处可以查询到7条数据，其中time为时间戳，station为tag，其他3列为field</p>
<p>查询某一个字段，并对其进行聚合计算</p>
<pre><code>&gt; select count(temperature) from test_air
</code></pre>
<p>返回结果如下：</p>
<pre><code>name: test_air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
&gt;
</code></pre>
<p>如果您完成了以上内容，恭喜您已经初步掌握了CnosDB和CnosQL的使用</p>
<p>但是CnosQL和标准SQL还是有一些不同的</p>
<p>比如我们通常把SQL语言分为DQL，DML，DDL，DCL，但是这在CnosQL中是不一样的</p>
<ol>
<li>DQL，这在CnosQL中对应的模块是<a href="content/cnosdb/latest/introduction/../cnosql/cnosql_queries.html">数据查询</a>，但CnosQL中还有一些其他的查询如<a href="content/cnosdb/latest/introduction/../cnosql/cnosql_management.html">数据库管理和模式查询</a>中<code>SHOW</code>关键词的使用</li>
<li>DML，首先CnosQL是不支持UPDATE的，<code>time</code>和<code>tag set</code>相同的数据将覆盖，INSERT我们在<a href="content/cnosdb/latest/introduction/quick-start.html#%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE">写入数据</a>的时候已经演示过了，对于删除，我们只支持大片数据的删除，您可以查看<a href="content/cnosdb/latest/introduction/../cnosql/cnosql_management.html">数据库管理和模式查询</a>中的<code>DROP</code>和<code>DELETE</code>语句</li>
<li>DDL，因为CnosDB是无模式的数据库，数据不需要提前定义，所以不支持数据定义语言</li>
<li>DCL，CnosDB支持<code>GRANT</code>关键字，可以对用户授于数据的访问权限，但这是测试性功能，计划在未来对用户开放</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="应用编程接口"><a class="header" href="#应用编程接口">应用编程接口</a></h1>
<ul>
<li><a href="content/cnosdb/latest/protocol/./ine_protocol.html">CnosDB Line Protocol</a></li>
<li><a href="content/cnosdb/latest/protocol/./write_api.html">CnosDB Write API</a></li>
<li><a href="content/cnosdb/latest/protocol/./query_api.html">CnosDB Query API</a></li>
<li><a href="content/cnosdb/latest/protocol/./prometheus.html">Prometheus</a></li>
<li><a href="content/cnosdb/latest/protocol/./goland.html">Golang</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-line-protocol"><a class="header" href="#cnosdb-line-protocol">CnosDB line Protocol</a></h1>
<p>CnosDB行协议是一种基于文本格式将点写入CnosDB的行协议。</p>
<h2 id="cnosdb行协议参考"><a class="header" href="#cnosdb行协议参考">CnosDB行协议参考</a></h2>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<pre><code class="language-sql">&lt;measurement&gt;[,&lt;tag_key&gt;=&lt;tag_value&gt;[,&lt;tag_key&gt;=&lt;tag_value&gt;]] &lt;field_key&gt;=&lt;field_value&gt;[,&lt;field_key&gt;=&lt;field_value&gt;] [&lt;timestamp&gt;]
</code></pre>
<p>行协议接受换行符<code>\n</code>，对空格敏感。</p>
<blockquote>
<p>注意：行协议不支持在标签值或字段值中使用换行符<code>\n</code>。</p>
</blockquote>
<h3 id="语法描述"><a class="header" href="#语法描述">语法描述</a></h3>
<table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody>
<tr><td>measurement</td><td>必须。是measurement项的名字。CnosDB接受每一个点的measurement值。为string类型。</td></tr>
<tr><td>tag set</td><td>可选。为该点所有的标记键值对。tag keys和tag values都是string类型。</td></tr>
<tr><td>field set</td><td>必须。每一个点必须要有一个field。是该点所有的字段键值对。可以是任何类型。</td></tr>
<tr><td>timestamp</td><td>可选。如果时间戳没有包含在点中，则CnosDB将在UTC中使用服务器的本地纳秒时间戳。</td></tr>
</tbody></table>
<h3 id="性能优化小提示"><a class="header" href="#性能优化小提示">性能优化小提示</a></h3>
<ul>
<li>将数据发送到CnosDB之前，请使用<a href="https://pkg.go.dev/bytes#Compare">Go bytes.Compare function</a>对数据根据tag key排序。</li>
<li>要显著改善压缩，请对时间戳使用尽可能粗糙的精度。</li>
<li>使用NTP (Network Time Protocol)同步主机时间。CnosDB使用UTC格式的主机本地时间为数据分配时间戳。如果主机的时钟没有与NTP同步，则主机写入到CnosDB的数据可能有不准确的时间戳。</li>
</ul>
<h3 id="例子"><a class="header" href="#例子">例子</a></h3>
<ul>
<li>
<p>将field值<code>-1.234456e+78</code>作为浮点数写入CnosDB</p>
<pre><code>INSERT mydb value=-1.234456e+78
</code></pre>
</li>
</ul>
<p>CnosDB支持用类型符号指定的字段值。</p>
<ul>
<li>
<p>将field值<code>1.0</code>作为浮点数写入CnosDB</p>
<p><code>INSERT mydb value=1.0</code></p>
</li>
<li>
<p>将field值<code>1</code>作为浮点数写入CnosDB</p>
<p><code>INSERT mydb value=1</code></p>
</li>
<li>
<p>将field值<code>1.0</code>作为整数写入CnosDB，在字段值后附加i，告诉CnosDB将数字存储为整数。</p>
<p><code>INSERT mydb value=1i</code></p>
</li>
<li>
<p>将field值<code>string exapmple</code>作为字符串写入CnosDB</p>
<p><code>INSERT mydb value=&quot;stringing along&quot;</code></p>
</li>
<li>
<p>将field值<code>true</code>作为布尔值写入CnosDB</p>
<p><code>INSERT mydb value=true</code></p>
</li>
<li>
<p>尝试将字符串写入先前接收浮点数的字段</p>
<p>如果float和string的时间戳存储在同一个分片中:</p>
<pre><code>INSERT mydb value=3 1465934559000000000
INSERT mydb value=&quot;stringing example&quot; 1465934559000000001
ERR: {&quot;error&quot;:&quot;field type conflict: input field \&quot;value\&quot; on measurement \&quot;mymeas\&quot; is type string, already exists as type float&quot;}
</code></pre>
<p>如果float和string的时间戳没有存储在同一个分片中:</p>
<pre><code>INSERT mymeas value=3 1465934559000000000
INSERT mymeas value=&quot;stringing example&quot; 1466625759000000000
</code></pre>
</li>
</ul>
<h2 id="cnosdb行协议教程"><a class="header" href="#cnosdb行协议教程">CnosDB行协议教程</a></h2>
<pre><code>CnosDB行协议是一种将点写入数据库的基于文本的格式。点必须是行协议格式，以便CnosDB成功解析和写入点。
</code></pre>
<h3 id="语法-1"><a class="header" href="#语法-1">语法</a></h3>
<blockquote>
<p>行协议格式中的一行文本表示CnosDB中的一个数据点。它将点的measurement value、tag set、field set和timestamp告知CnosDB。下面的代码块显示了一个行协议的示例，并将其分解为独立的组件:</p>
</blockquote>
<pre><code>    air,station=LianYunGang temperature=74 1642176540000000000
    |    -------------------- -----------------  |
    |              |              |              |
    |              |              |              |
    +-----------+--------+-+---------+-+---------+
    |measurement|,tag_set| |field_set| |timestamp|
    +-----------+--------+-+---------+-+---------+
</code></pre>
<p><strong><code>measurement</code></strong></p>
<ul>
<li><code>measurement</code> - 要将数据写入的measurement的名字。measurement需符合行协议。在本例子中，measurement为weather。</li>
<li><code>tag set</code> - 标记集。包含在数据点中的标记。tag在行协议中是可选的。需要注意的是，tag set和measurement之间由逗号分隔，没有空格。用等号<code>=</code>分隔标签的键值对时，不需要插入空格，如:<code>&lt;tag_key&gt;=&lt;tag_value&gt;</code>。多个标记值对之间用逗号分隔，不能有空格。在本例子中，标记集由标记<code>station=LianYunGang</code>组成。 
当在标记集中使用引号时，行协议支持单引号和双引号，如下表所示:</li>
<li><code>空格 I</code> - 将度量和字段集分开，或者，如果您在数据点中包含一个标记集，则使用空格将标记集和字段集分开。在行协议中需要空格。例如，没有tag set的有效行协议<code>air temperature=75 1642176360000000000</code>。</li>
<li><code>field set</code> - 您的数据点的字段。每个行协议中的数据点至少需要一个字段。用等号=分隔字段的键值对，并且没有空格，比如：<code>&lt;field_key&gt;=&lt;field_value&gt;</code>。多个字段值对用逗号分隔，不能用空格，如：<code>&lt;field_key&gt;=&lt;field_value&gt;,&lt;field_key&gt;=&lt;field_value&gt;</code>。</li>
<li><code>空格 II</code> - 用空格分隔field set和时间戳。如果包含时间戳，则行协议中需要空格。</li>
<li><code>timestamp</code> - 数据点的时间戳，以纳秒级Unix时间为单位。时间戳在行协议中是可选的。如果没有为数据点指定时间戳，则CnosDB将在UTC中使用服务器的本地纳秒时间戳。</li>
</ul>
<h3 id="数据类型"><a class="header" href="#数据类型">数据类型</a></h3>
<ul>
<li>measurements, tag keys, tag values和field keys总是字符串。</li>
<li>时间戳为UNIX时间戳。最小时间戳为<code>-9223372036854775806</code>或<code>1677-09-21T00:12:43.145224194Z</code>。最大时间戳为<code>9223372036854775806</code>或<code>2262-04-11T23:47:16.854775806Z</code>。如上所述，根据默认配置，CnosDB假设时间戳具有纳秒精度。</li>
<li>field value可以是浮点数、整数、字符串或布尔值。在默认情况下，CnosDB假设所有的field value都是浮点数。</li>
<li>在一个measurement中，一个分片中的字段类型不能不同。但多个分片中的字段类型可以不同。例如，如果InfluxDB试图将整数存储在与浮点数相同的分片中，则将整数写入之前接受的浮点数字段将失败:
<pre><code>&gt; INSERT air,station=LianYunGang temperature=72 1642176180000000000
&gt; INSERT air,station=LianYunGang temperature=79i 1642176540000000000
ERR: {&quot;error&quot;:&quot;field type conflict: input field \&quot;temperature\&quot; on measurement \&quot;air\&quot; is type int64, already exists as type float&quot;}
</code></pre>
</li>
</ul>
<h3 id="引号"><a class="header" href="#引号">引号</a></h3>
<ul>
<li>不要对时间戳使用双引号或单引号，这不是有效的行协议。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature=72 &quot;1642176180000000000&quot;
ERR: {&quot;error&quot;:&quot;unable to parse 'air,station=LianYunGang temperature=72 \&quot;1642176180000000000\&quot;': bad timestamp&quot;}
</code></pre>
</li>
<li>永远不要给字段值(即使它们是字符串)加单引号，这也不是有效的行协议。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature='72' 1642176180000000000
ERR: {&quot;error&quot;:&quot;unable to parse 'air,station=LianYunGang temperature='72'': invalid boolean&quot;} 
</code></pre>
</li>
<li>不要用双引号或单引号引用measurement名称、tag key、tag value和field key。这是有效的行协议，但CnosDB假定引用是名称的一部分。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature=72 1642176180000000000
&gt; INSERT &quot;air&quot;,station=LianYunGang temperature=79 1642176540000000000
&gt; SHOW MEASUREMENTS
name: measurements
------------------
name
&quot;air&quot;
air
</code></pre>
</li>
<li>要查询&quot;air&quot;中的数据，需要使用双引号，并使用正确的转义字符。
<pre><code>&gt; SELECT * FROM &quot;\&quot;air\&quot;&quot;
name: &quot;air&quot;
time                 station     temperature
----                 -------     -----------
2022-01-14T16:09:00Z LianYunGang 79

</code></pre>
</li>
<li>不要对浮点型、整型或布尔型字段值使用双引号。CnosDB将假定这些值是字符串。例如：
<pre><code>&gt; INSERT air,station=LianYunGang temperature=&quot;72&quot;
&gt; SELECT * FROM air WHERE temperature &gt;= 70
&gt;
</code></pre>
对类型为字符串的字段值使用双引号。
<pre><code>&gt; INSERT air,station=LianYunGang temperature=&quot;too warm&quot;
&gt; SELECT * FROM air
name: air
-------------
time				            station	 temperature
2022-01-14T16:09:00Z	LianYunGang	 too warm
</code></pre>
</li>
</ul>
<h3 id="特殊字符和关键字"><a class="header" href="#特殊字符和关键字">特殊字符和关键字</a></h3>
<p>对于tag keys,tag values,measurement,字符串类型的field values以及field keys总是使用反斜杠字符<code>\</code>进行转义。</p>
<ul>
<li>逗号<code>,</code>：
<pre><code>wind,station=Lian\,YunGang visibility=59,temperature=59,pressure=56 1649664217071649000
</code></pre>
</li>
<li>等号<code>=</code>：
<pre><code>wind,station=LianYunGang vis\=ibility=59,temperature=59,pressure=56 1649664217071649000
</code></pre>
</li>
<li>空格<code> </code>：
<pre><code>wind,stat\ ion=LianYunGang visibility=59,temperature=59,pressure=56 1649664217071649000
</code></pre>
</li>
<li>emojis 🥰： CnosDB的行协议支持emojis表情的输入，并且无需使用转义字符转义。例如：
<pre><code>&gt; INSERT 🌤,⛪️=LianYunGang 🌡=23
&gt; SELECT * FROM &quot;🌤&quot;
name: 🌤
time                        ⛪️          🌡
----                        ------      ----
2022-04-14T03:50:01.705037Z LianYunGang 23

</code></pre>
</li>
<li>关键字:行协议接受CnosQL关键字作为标识符名称。我们一般建议避免在模式中使用CnosQL关键字，因为它可能会在查询数据时造成混乱。 但关键字<code>time</code>是一种特殊情况。<code>time</code>可以是连续查询名称、数据库名称、measurement名称、保留策略名称和用户名称。在这些情况下，<code>time</code>不需要在查询中使用双引号。<code>time</code>不能是字段键或标记键;CnosDB拒绝以<code>time</code>作为字段键或标记键的写操作，并返回错误。</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-write-api"><a class="header" href="#cnosdb-write-api">CnosDB Write API</a></h1>
<h2 id="使用cnosdb-api创建数据库"><a class="header" href="#使用cnosdb-api创建数据库">使用CnosDB API创建数据库</a></h2>
<p>要创建数据库，先向<code>/query</code>端点发送<code>POST</code>请求，并将URL参数中的<code>q</code>设置为<code>CREATE DATABASE &lt;new_database_name&gt;</code>。例如,在CnosDB中创建一个名为&quot;oceanic_station&quot;的数据库。</p>
<pre><code>curl -i -XPOST http://localhost:8086/query --data-urlencode &quot;q=CREATE DATABASE oceanic_station&quot;
</code></pre>
<h2 id="使用cnosdb-api写入数据"><a class="header" href="#使用cnosdb-api写入数据">使用CnosDB API写入数据</a></h2>
<h3 id="分隔规则"><a class="header" href="#分隔规则">分隔规则</a></h3>
<blockquote>
<p><code>measurement</code>与<code>tag</code>之间使用逗号分隔</p>
<p><code>tag</code>组合可以有多个，<code>tag</code>之间使用逗号分隔</p>
<p><code>tag</code>与<code>field</code>之间使用空格分隔</p>
<p><code>field</code>组合可以有多个，<code>field</code>之间使用逗号分隔</p>
<p><code>field</code>与时间戳使用空格分隔</p>
</blockquote>
<h3 id="写入规则"><a class="header" href="#写入规则">写入规则</a></h3>
<p>使用CnosDB API写入数据，向/write端点发送POST请求。例如，向&quot;oceanic_station&quot;写入一个点。此数据的组成为：measurement为<code>wind</code>，field key为<code>speed</code>和<code>direction</code>，field values分别为<code>75</code>和<code>65</code>，timestamp为<code>1649664217085031000</code>。</p>
<pre><code>curl -i -XPOST 'http://localhost:8086/write?db=oceanic_station' --data-binary 'wind,station=LianYunGang speed=75,direction=65 1649664217085031000'
</code></pre>
<p>写入点时，必须在<code>db</code>查询参数中指定一个已存在的数据库。如果你不通过<code>rp</code>查询参数提供保留策略，点将被写入数据库的默认保留策略。</p>
<h2 id="写入多点"><a class="header" href="#写入多点">写入多点</a></h2>
<p>将多个<code>Points</code>同时Post到多个序列，每个<code>Points</code>用一个新行分开,以这种方式批处理<code>Points</code>可以提高性能。</p>
<p>通过用换行分隔每个<code>Points</code>，将多个<code>Points</code>同时写入到多个<code>series</code>中，以这种方式批处理<code>Points</code>可以提高性能。</p>
<p>下面的示例将三个<code>Points</code>写入数据库<code>oceanic_station</code>:</p>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?db=oceanic_station' --data-binary 'wind,station=LianYunGang speed=75,direction=65 1649664217085027000
wind,station=LianYunGang speed=75,direction=65 1649664217085031000
wind,station=XiaoMaiDao speed=70,direction=63 1649664217085036000'
</code></pre>
<h2 id="配置gzip压缩"><a class="header" href="#配置gzip压缩">配置gzip压缩</a></h2>
<p>cnosdb支持gzip压缩，要减少网络流量，需优先考虑以下选项</p>
<ul>
<li>
<p>要接受来自cnosdb的压缩数据，请将<code>Accept-Encoding：gzip</code>heade信息添加到cnosdb API请求中</p>
</li>
<li>
<p>要在将数据发送到cnosdb之前压缩数据，将<code>Content-Encoding:gzip</code>heade信息添加到cnosdb API请求中</p>
</li>
</ul>
<h2 id="从文件写入points"><a class="header" href="#从文件写入points">从文件写入Points</a></h2>
<p>通过传递<code>@filename</code>到文件来写入文件中的数据</p>
<p>格式正确的文件（<code>data.txt</code>）的示例：</p>
<p>写入数据data.txt到oceanic_station数据库</p>
<pre><code class="language-bash">curl -i -XPOST 'http://localhost:8086/write?oceanic_station' --data-binary @data.txt
</code></pre>
<p>注意：如果您的数据文件具有超过5000个Points，则可能有必要将该文件拆分为多个文件，以便将数据批量写入cnosdb，默认情况下，HTTP请求在五秒后超时，超时后，cnosdb仍然将尝试写入这些点，但是不会确认它们已经成功写入</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-query-api"><a class="header" href="#cnosdb-query-api">CnosDB Query API</a></h1>
<h2 id="单条查询语句"><a class="header" href="#单条查询语句">单条查询语句</a></h2>
<p>CnosDB API 是在 CnosDB中查询数据的主要方式。</p>
<p>如果需要执行查询请求，需要将GET请求发送到/query端点，将URL参数db设置为目标数据库，并将参数q设置为查询语句。还可以通过发送相同的参数作为URL参数或作为带有<code>application/x-www-form-urlencoded</code>的正文的一部分来使用POST请求。</p>
<p>示例：</p>
<pre><code>curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode &quot;db=oceanic_station&quot; --data-urlencode &quot;q=SELECT \&quot;speed\&quot; FROM \&quot;wind\&quot; WHERE \&quot;station\&quot;='LianYunGang'&quot;
</code></pre>
<p>其结果为：</p>
<pre><code>{
&quot;results&quot;: [
    {_
        &quot;statement_id&quot;: 0,
        &quot;series&quot;: [
            {
                &quot;name&quot;: &quot;wind&quot;,
                &quot;columns&quot;: [
                    &quot;time&quot;,
                    &quot;speed&quot;
                ],
                &quot;values&quot;: [
                    [
                        &quot;2022-04-11T08:03:37.085027Z&quot;,
                        75
                    ],
                    [
                        &quot;2022-04-11T08:03:37.085031Z&quot;,
                        75
                    ]
                  ]  
                }
            ]
        }
    ]
}

</code></pre>
<h2 id="返回错误"><a class="header" href="#返回错误">返回错误</a></h2>
<p>CnosDB返回JSON，查询的结果会在<code>results</code>数组中，如果发生错误，CnosDB会设置一个带有<code>error</code>的key</p>
<h2 id="多条查询语句"><a class="header" href="#多条查询语句">多条查询语句</a></h2>
<p>多条查询语句需要用<code>;</code>分隔</p>
<pre><code class="language-shell">curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode &quot;db=oceanic_station&quot; --data-urlencode &quot;q=SELECT speed FROM wind WHERE station = 'XiaoMaiDao';SELECT temperature FROM air WHERE station = 'XiaoMaiDao'&quot;
</code></pre>
<h2 id="时间精度"><a class="header" href="#时间精度">时间精度</a></h2>
<p>CnosDB中的所有内容都以UTC存储和输出。默认情况下，时间戳以RFC3339格式返回，例如 2015-08-04T19:05:00Z；如果想要Unix纪元格式的时间戳，则需要在请求中添加字符串参数：epoch=[h, m, s, ms, u, ns]</p>
<pre><code class="language-shell">curl -G 'http://localhost:8086/query?pretty=true' --data-urlencode &quot;db=oceanic_station&quot; --data-urlencode &quot;epoch=s&quot; --data-urlencode &quot;q=SELECT temperature FROM air WHERE station = 'XiaoMaiDao'&quot;
</code></pre>
<h2 id="最大行限制"><a class="header" href="#最大行限制">最大行限制</a></h2>
<p><code>max-row-limit</code>配置选项允许用于限制返回结果最大数量，以防止CnosDB在聚合结果时耗尽内存，<code>max-row-limit</code>配置选项默认设置为0，该默认设置允许每个请求返回无限数量的行。
最大行限制适用于非块查询，分块查询可以返回无限数量的points。</p>
<h2 id="chunking"><a class="header" href="#chunking">Chunking</a></h2>
<p>通过设置查询字符串参数chunked=true，可以使用分块以流式批处理而不是作为单个响应返回结果。响应将按series或每10000point分块，以先发生者为准。要将最大块大小更改为不同的值，需要将查询字符串chunk_size设置为不同的值</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prometheus"><a class="header" href="#prometheus">Prometheus</a></h1>
<p>CnosDB对Prometheus远程读写的支持是将以下HTTP端点添加到CnosDB。</p>
<ul>
<li>/api/v1/prom/read</li>
<li>/api/v1/prom/write</li>
</ul>
<p>此外，还有一个<code>/metrics</code>端点被配置为以Prometheus度量格式生成默认的Go度量。</p>
<h2 id="创建目标数据库"><a class="header" href="#创建目标数据库">创建目标数据库</a></h2>
<p>在您的CnosDB中创建一个数据库来存放从Prometheus发送的数据。在下面的示例中，我们使用prometheus作为数据库名。</p>
<pre><code class="language-sql">CREATE DATABASE &quot;prometheus&quot;
</code></pre>
<h2 id="配置"><a class="header" href="#配置">配置</a></h2>
<p>若要在CnosDB中使用Prometheus远程读写API，请在Prometheus配置文件中的以下设置中添加URL值:</p>
<ul>
<li><code>remote_write</code></li>
<li><code>remote_read</code></li>
</ul>
<p>这些URL必须可以从运行的Prometheus服务器解析，并使用运行CnosDB的端口(默认情况下为8086)。还要使用包含数据库名称的<code>db= </code>查询参数。</p>
<p>例如：</p>
<pre><code>remote_write:
- url: &quot;http://localhost:8086/api/v1/prom/write?db=prometheus&quot;

remote_read:
- url: &quot;http://localhost:8086/api/v1/prom/read?db=prometheus&quot;
</code></pre>
<h2 id="如何在cnosdb中解析prometheus度量"><a class="header" href="#如何在cnosdb中解析prometheus度量">如何在CnosDB中解析Prometheus度量</a></h2>
<ul>
<li>将Prometheus度量名称作为CnosDB的measurement名称。</li>
<li>将Prometheus的样本值作为CnosDB的字段键及字段值。通常是浮点数形式。</li>
<li>将Prometheus的标签作为CnosDB的tags。</li>
<li>所有的<code># HELP </code>和<code># TYPE </code>行被忽略。</li>
</ul>
<pre><code>  # Prometheus 
  example_metric{queue=&quot;0:http://example:8086/api/v1/prom/write?db=prometheus&quot;,le=&quot;0.005&quot;} 308
  
  # CnosDB
  measurement
  example_metric
  tags
  queue = &quot;0:http://example:8086/api/v1/prom/write?db=prometheus&quot;
  le = &quot;0.005&quot;
  job = &quot;prometheus&quot;
  instance = &quot;localhost:9090&quot;
  __name__ = &quot;example_metric&quot;
  fields
  value = 308
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="golang"><a class="header" href="#golang">Golang</a></h1>
<p>学习使用CnosDB Golang SDK 操作CnosDB</p>
<ul>
<li>
<h2 id="使用ping查看cnosdb状态"><a class="header" href="#使用ping查看cnosdb状态">使用<code>/ping</code>查看cnosdb状态</a></h2>
<pre><code>func ExampleClient_Ping() {

    c, err := client.NewHTTPClient(client.HTTPConfig{
        Addr: &quot;http://localhost:8086&quot;,
    })
    if err != nil {
        fmt.Println(&quot;Error creating CnosDB Client: &quot;, err.Error())
    }
    defer c.Close()

    _, rs, err := c.Ping(0)
    fmt.Println(&quot;version:&quot;, rs)
    if err != nil {
        fmt.Println(&quot;Error pinging CnosDB: &quot;, err.Error())
    }
}
</code></pre>
</li>
<li>
<h2 id="使用http-client写入一个point"><a class="header" href="#使用http-client写入一个point">使用http client写入一个point</a></h2>
<pre><code>func ExampleClient_write() {
    // Make client
    c, err := client.NewHTTPClient(client.HTTPConfig{
        Addr: &quot;http://localhost:8086&quot;,
    })
    if err != nil {
        fmt.Println(&quot;Error creating CnosDB Client: &quot;, err.Error())
    }
    defer c.Close()

    // Create a new point batch
    bp, _ := client.NewBatchPoints(client.BatchPointsConfig{
        Database:  &quot;oceanic_station&quot;,
        Precision: &quot;s&quot;,
    })

    // Create a point and add to batch
    tags := map[string]string{&quot;station&quot;: &quot;XiaoMaiDao&quot;}
    fields := map[string]interface{}{
        &quot;temperature&quot;: 67,
        &quot;visibility&quot;:  58,
    }
    pt, err := client.NewPoint(&quot;air&quot;, tags, fields, time.Now())
    if err != nil {
        fmt.Println(&quot;Error: &quot;, err.Error())
    }
    bp.AddPoint(pt)

    // Write the batch
    c.Write(bp)
}
</code></pre>
</li>
<li>
<h2 id="创建一个batchpoint并添加一个point"><a class="header" href="#创建一个batchpoint并添加一个point">创建一个BatchPoint，并添加一个Point</a></h2>
<pre><code>func ExampleBatchPoints() {
    // Create a new point batch
    bp, _ := client.NewBatchPoints(client.BatchPointsConfig{
        Database:  &quot;oceanic_station&quot;,
        Precision: &quot;s&quot;,
    })

    // Create a point and add to batch
    tags := map[string]string{&quot;station&quot;: &quot;XiaoMaiDao&quot;}
    fields := map[string]interface{}{
        &quot;temperature&quot;: 67,
        &quot;visibility&quot;:  58,
    }
    pt, err := client.NewPoint(&quot;air&quot;, tags, fields, time.Now())
    if err != nil {
        fmt.Println(&quot;Error: &quot;, err.Error())
    }
    bp.AddPoint(pt)
}
</code></pre>
</li>
<li>
<h2 id="使用batchpoint的setter方法"><a class="header" href="#使用batchpoint的setter方法">使用BatchPoint的setter方法</a></h2>
<pre><code>func ExampleBatchPoints_setters() {
    // Create a new point batch
    bp, _ := client.NewBatchPoints(client.BatchPointsConfig{})
    bp.SetDatabase(&quot;oceanic_station&quot;)
    bp.SetPrecision(&quot;ms&quot;)

    // Create a point and add to batch
    tags := map[string]string{&quot;station&quot;: &quot;XiaoMaiDao&quot;}
    fields := map[string]interface{}{
        &quot;temperature&quot;: 67,
        &quot;visibility&quot;:  58,
    }
    pt, err := client.NewPoint(&quot;air&quot;, tags, fields, time.Now())
    if err != nil {
        fmt.Println(&quot;Error: &quot;, err.Error())
    }
    bp.AddPoint(pt)
}
</code></pre>
</li>
<li>
<h2 id="创建一个point并设置时间戳"><a class="header" href="#创建一个point并设置时间戳">创建一个point并设置时间戳</a></h2>
<pre><code>func ExamplePoint() {
    tags := map[string]string{&quot;station&quot;: &quot;XiaoMaiDao&quot;}
    fields := map[string]interface{}{
        &quot;temperature&quot;: 67,
        &quot;visibility&quot;:  58,
    }
    pt, err := client.NewPoint(&quot;air&quot;, tags, fields, time.Now())
    if err == nil {
        fmt.Println(&quot;We created a point: &quot;, pt.String())
    }
}
</code></pre>
</li>
<li>
<h2 id="创建一个没有时间戳的point"><a class="header" href="#创建一个没有时间戳的point">创建一个没有时间戳的point</a></h2>
<pre><code>func ExamplePoint_withoutTime() {
    tags := map[string]string{&quot;station&quot;: &quot;XiaoMaiDao&quot;}
    fields := map[string]interface{}{
        &quot;temperature&quot;: 67,
        &quot;visibility&quot;:  58,
    }
    pt, err := client.NewPoint(&quot;air&quot;, tags, fields)
    if err == nil {
        fmt.Println(&quot;We created a point w/o time: &quot;, pt.String())
    }
}
</code></pre>
</li>
<li>
<h2 id="创建一个查询请求"><a class="header" href="#创建一个查询请求">创建一个查询请求</a></h2>
<pre><code>func ExampleClient_query() {
    // Make client
    c, err := client.NewHTTPClient(client.HTTPConfig{
        Addr: &quot;http://localhost:8086&quot;,
    })
    if err != nil {
        fmt.Println(&quot;Error creating CnosDB Client: &quot;, err.Error())
    }
    defer c.Close()

    q := client.NewQuery(&quot;SELECT temperature FROM air limit 10&quot;, &quot;oceanic_station&quot;, &quot;ns&quot;)
    if response, err := c.Query(q); err == nil &amp;&amp; response.Error() == nil {
        fmt.Println(response.Results)
    }
}
</code></pre>
</li>
<li>
<h2 id="创建数据库-1"><a class="header" href="#创建数据库-1">创建数据库</a></h2>
<pre><code>func ExampleClient_createDatabase() {
    // Make client
    c, err := client.NewHTTPClient(client.HTTPConfig{
        Addr: &quot;http://localhost:8086&quot;,
    })
    if err != nil {
        fmt.Println(&quot;Error creating CnosDB Client: &quot;, err.Error())
    }
    defer c.Close()

    q := client.NewQuery(&quot;CREATE DATABASE mydb&quot;, &quot;&quot;, &quot;&quot;)
    if response, err := c.Query(q); err == nil &amp;&amp; response.Error() == nil {
        fmt.Println(response.Results)
    }
}

</code></pre>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运维管理"><a class="header" href="#运维管理">运维管理</a></h1>
<ul>
<li><a href="content/cnosdb/latest/managerment/./export_import.html">导入和导出</a></li>
<li><a href="content/cnosdb/latest/managerment/./backup_restore.html">备份和还原</a></li>
<li><a href="content/cnosdb/latest/managerment/./configuration.html">CnosDB配置</a></li>
<li><a href="content/cnosdb/latest/managerment/../sandboxmanagement.html">集群管理</a></li>
<li><a href="content/cnosdb/latest/managerment/">运维工具介绍</a>
<ul>
<li><a href="content/cnosdb/latest/managerment/../cnosdb_tools/cnosdb.html">cnosdb</a></li>
<li><a href="content/cnosdb/latest/managerment/../cnosdb_tools/cnosdb-cli.html">cnosdb-cli</a></li>
<li><a href="content/cnosdb/latest/managerment/../cnosdb_tools/cnosdb-inspect.html">cnosdb-inspect</a></li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="导入和导出"><a class="header" href="#导入和导出">导入和导出</a></h1>
<h2 id="导入"><a class="header" href="#导入">导入</a></h2>
<pre><code>cnosdb-cli import --path &lt;path&gt; [arguments]
</code></pre>
<h3 id="参数用法"><a class="header" href="#参数用法">参数用法</a></h3>
<table><thead><tr><th>Flag</th><th style="text-align: center">Description</th></tr></thead><tbody>
<tr><td>--compressed</td><td style="text-align: center">假如导入文件是被压缩的，需设置此值。</td></tr>
<tr><td>--consistency</td><td style="text-align: center">写入并发等级：&quot;any&quot;，&quot;one&quot;，&quot;quorum&quot;，或者&quot;all&quot;（默认&quot;all&quot;）。</td></tr>
<tr><td>--host</td><td style="text-align: center">主机地址（默认localhost）。</td></tr>
<tr><td>--password</td><td style="text-align: center">登录服务器的密码（默认为空字符串）。</td></tr>
<tr><td>--path</td><td style="text-align: center">导入文件的路径。</td></tr>
<tr><td>--port</td><td style="text-align: center">主机端口，默认为8086。</td></tr>
<tr><td>--pps</td><td style="text-align: center">允许每秒钟导入多少points，默认为0，不限制导入速度。</td></tr>
<tr><td>--ssl</td><td style="text-align: center">使用https连接集群。</td></tr>
<tr><td>--username</td><td style="text-align: center">登录服务器的用户名。</td></tr>
</tbody></table>
<h3 id="示例"><a class="header" href="#示例">示例</a></h3>
<p>将<code>./import/in.txt</code>导入到cnosdb中</p>
<pre><code>&gt;cnosdb-cli import --path ./import/in.txt
2022/05/18 18:42:15 Processed 100000 lines.  Time elapsed: 586.1847ms.  Points per second (PPS): 170594
2022/05/18 18:42:16 Processed 200000 lines.  Time elapsed: 1.1997508s.  Points per second (PPS): 166701
2022/05/18 18:42:16 Processed 2 commands
2022/05/18 18:42:16 Processed 200000 inserts
2022/05/18 18:42:16 Failed 0 inserts
</code></pre>
<h2 id="导出"><a class="header" href="#导出">导出</a></h2>
<pre><code>cnosdb-inspect export [arguments]
</code></pre>
<h3 id="参数用法-1"><a class="header" href="#参数用法-1">参数用法</a></h3>
<table><thead><tr><th>Flags</th><th style="text-align: center">Description</th></tr></thead><tbody>
<tr><td>--compress</td><td style="text-align: center">压缩导出文件。</td></tr>
<tr><td>--database</td><td style="text-align: center">可选：指定需要导出的数据库。</td></tr>
<tr><td>--datadir</td><td style="text-align: center">指定数据存储路径。</td></tr>
<tr><td>--end</td><td style="text-align: center">可选：导出数据的最小时间戳(RFC3339 format)。</td></tr>
<tr><td>--out</td><td style="text-align: center">指定导出文件的路径(默认&quot;/.cnosdb/export&quot;)。</td></tr>
<tr><td>--rp</td><td style="text-align: center">可选：指定导出的retention policy（需要--database参数）。</td></tr>
<tr><td>--start</td><td style="text-align: center">可选：导出数据数据的最大时间戳(RFC3339 format)。</td></tr>
<tr><td>--waldir</td><td style="text-align: center">指定WAL存储路径。</td></tr>
</tbody></table>
<h3 id="示例-1"><a class="header" href="#示例-1">示例</a></h3>
<p>导出数据到<code>./.cnosdb/export/out.txt</code></p>
<pre><code>&gt;cnosdb-inspect export --out ./.cnosdb/export/out.txt
writing out tsm file data for db\rp...complete.
writing out tsm file data for mydb\rp...complete.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="备份和还原"><a class="header" href="#备份和还原">备份和还原</a></h1>
<h2 id="备份"><a class="header" href="#备份">备份</a></h2>
<p>从指定数据节点创建数据库快照，并保存到 PATH 对应目录。</p>
<pre><code class="language-shell">cnosdb backup [flags] PATH
</code></pre>
<h3 id="参数介绍"><a class="header" href="#参数介绍">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>数据库名称；可选；如果未指定则备份所有数据库。</td></tr>
<tr><td><code>--rp</code></td><td>数据保留策略；可选；如果未指定则备份所有数据保留策略。</td></tr>
<tr><td><code>--shard</code></td><td>分片编号；可选；如果需要使用该参数，则需要同时使用 <code>-rp</code> 参数。</td></tr>
<tr><td><code>--start</code></td><td>备份中包含的数据的最小时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--end</code></td><td>备份中包含的数据的最大时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--skip-errors</code></td><td>创建某分片的备份时，若发生错误，继续创建剩余分片的备份。</td></tr>
</tbody></table>
<h2 id="还原"><a class="header" href="#还原">还原</a></h2>
<p>从指定的备份目录中恢复数据和元数据。恢复开始时，服务将被关闭。</p>
<pre><code>cnosdb restore [flags]
</code></pre>
<h3 id="参数介绍-1"><a class="header" href="#参数介绍-1">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>从备份数据中恢复的数据库名称。</td></tr>
<tr><td><code>--newdb</code></td><td>创建新数据库以导入备份数据；可选；如果未指定，则使用 <code>--db &lt;db_name&gt;</code> 中指定的数据库名称。该参数指定的数据库名称在目标系统中不能重复。</td></tr>
<tr><td><code>--rp</code></td><td>从备份数据中恢复的数据库保留策略名称；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 参数。</td></tr>
<tr><td><code>--newrp</code></td><td>将备份数据导入其他的数据保留策略；可选；如果未指定，则使用 <code>--rp</code> 中指定的数据保留策略名称。</td></tr>
<tr><td><code>--shard</code></td><td>从备份数据中恢复的分片编号；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 和 <code>--rp</code> 参数。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb配置"><a class="header" href="#cnosdb配置">CnosDB配置</a></h1>
<h3 id="配置概述"><a class="header" href="#配置概述">配置概述</a></h3>
<p>通过配置文件(<code>cnosdb.conf</code>)和环境变量配置CnosDB。如果不取消注释配置选项，系统将使用其默认设置。本文档中的配置均为系统默认配置。</p>
<h3 id="环境变量"><a class="header" href="#环境变量">环境变量</a></h3>
<p>配置文件中的所有配置设置可以在配置文件中指定，也可以在环境变量中指定。环境变量覆盖配置文件中的等效选项。如果配置文件或环境变量中没有指定配置选项，则CnosDB使用其内部默认配置。</p>
<h3 id="使用配置文件"><a class="header" href="#使用配置文件">使用配置文件</a></h3>
<p>CnosDB系统对配置文件中的所有设置都有内部默认值。如果需要查看默认配置，使用命令cnosdb config。</p>
<p>本地CnosDB配置文件位于这里:
- Linux: /etc/cnosdb/cnosdb.conf
- macOS: /usr/local/etc/cnosdb.conf</p>
<p>注释掉的设置设置为系统内部默认值。未加注释的设置覆盖内部默认值。注意，本地配置文件不需要包含每个配置设置。</p>
<p>使用<code>--config</code>指令将配置文件导入CnosDB</p>
<p><code>cnosdb --config /etc/cnosdb/cnosdb.conf</code></p>
<p>将环境变量CNOSDB_CONFIG_PATH设置为配置文件的路径，并启动进程。例如:</p>
<pre><code>echo $CNOSDB_CONFIG_PATH
/etc/cnosdb/cnosdb.conf

cnosdb
</code></pre>
<h3 id="全局配置"><a class="header" href="#全局配置">全局配置</a></h3>
<h4 id="bind-address--1270018088"><a class="header" href="#bind-address--1270018088">bind-address = &quot;127.0.0.1:8088&quot;</a></h4>
<p>用于备份和恢复的RPC服务的绑定地址。环境变量为：<code>CNOSDB_BIND_ADDRESS</code></p>
<h4 id="cluster--true"><a class="header" href="#cluster--true">cluster = true</a></h4>
<p>是否开启集群模式；true：开启，false：关闭 </p>
<h3 id="port"><a class="header" href="#port">Port</a></h3>
<h4 id="可用端口"><a class="header" href="#可用端口">可用端口：</a></h4>
<p><code>8086</code>：提供cnosdb http服务的默认端口</p>
<p><code>8088</code>：提供cnosdb 内部RPC服务以及备份恢复的默认端口</p>
<h3 id="meta-元信息"><a class="header" href="#meta-元信息">[Meta]-元信息</a></h3>
<h4 id="dir--varlibcnosdbmeta"><a class="header" href="#dir--varlibcnosdbmeta">dir = &quot;/var/lib/cnosdb/meta&quot;</a></h4>
<p>元数据/raft数据库所在的目录。meta目录中的文件包括meta.db、CnosDB metastore文件。环境变量为:<code>CNOSDB_META_DIR</code></p>
<h4 id="retention-autocreate--true"><a class="header" href="#retention-autocreate--true">retention-autocreate = true</a></h4>
<p>启用此设置，在创建数据库时自动创建DEFAULT保留策略autogen。保留策略autogen具有无限的持续时间，也被设置为数据库的DEFAULT保留策略，当写入或查询没有指定保留策略时使用该保留策略。禁用此设置，可以防止在创建数据库时创建此保留策略。环境变量:<code>CNOSDB_META_RETENTION_AUTOCREATE</code></p>
<h4 id="logging-enabled--true"><a class="header" href="#logging-enabled--true">logging-enabled = true</a></h4>
<p>启用记录来自元服务的消息。 环境变量:<code>CNOSDB_META_LOGGING_ENABLED</code></p>
<h3 id="data-数据相关"><a class="header" href="#data-数据相关">[Data]-数据相关</a></h3>
<h4 id="dir--varlibcnosdbdata"><a class="header" href="#dir--varlibcnosdbdata">dir = &quot;/var/lib/cnosdb/data&quot;</a></h4>
<p>TSM引擎存储TSM文件的CnosDB目录。该目录可以被修改。环境变量:CNOSDB_DATA_DIR</p>
<h4 id="wal-dir--varlibcnosdbwal"><a class="header" href="#wal-dir--varlibcnosdbwal">wal-dir = &quot;/var/lib/cnosdb/wal&quot;</a></h4>
<p>存放预写日志(WAL)文件的目录位置。 环境变量:CNOSDB_DATA_WAL_DIR</p>
<h4 id="wal-fsync-delay--0s"><a class="header" href="#wal-fsync-delay--0s">wal-fsync-delay = &quot;0s&quot;</a></h4>
<p>同步之前写操作等待的时间。使用大于0的持续时间批量处理多个fsync调用。这对于较慢的磁盘或遇到WAL写争用时非常有用。0的默认值为每次写入WAL时同步。环境变量:<code>CNOSDB_DATA_WAL_FSYNC_DELAY</code></p>
<h4 id="index-version--inmem"><a class="header" href="#index-version--inmem">index-version = &quot;inmem&quot;</a></h4>
<p><code>tsi1. </code>用于新分片的分片索引类型。默认的(<code>inmem</code>)索引是在启动时重新创建的内存索引。如果需要启用基于磁盘的TSI (Time Series Index)索引，请将该值设置为<code>tsi1</code>。环境变量:<code>CNOSDB_DATA_INDEX_VERSION</code></p>
<h4 id="trace-logging-enabled--false"><a class="header" href="#trace-logging-enabled--false">trace-logging-enabled = false</a></h4>
<p>在TSM引擎和WAL中启用附加调试信息的详细日志记录。跟踪日志为调试TSM引擎问题提供了更有用的输出。 环境变量:<code>CNOSDB_DATA_TRACE_LOGGING_ENABLED</code></p>
<h4 id="query-log-enabled--true"><a class="header" href="#query-log-enabled--true">query-log-enabled = true</a></h4>
<p>在执行之前启用解析查询的日志记录。查询日志对于故障排除很有用，但会记录查询中包含的任何敏感数据。 环境变量:<code>CNOSDB_DATA_QUERY_LOG_ENABLED</code></p>
<h4 id="validate-keys--false"><a class="header" href="#validate-keys--false">validate-keys = false</a></h4>
<p>验证传入的写入以确保键只有有效的Unicode字符。这个设置将产生一个小开销，因为必须检查每个键。</p>
<h4 id="cache-max-memory-size--1g"><a class="header" href="#cache-max-memory-size--1g">cache-max-memory-size = &quot;1g&quot;</a></h4>
<p>分片缓存在开始拒绝写操作之前所能达到的最大大小。有效的内存大小后缀是:k、m或g。没有大小后缀的值以字节为单位。环境变量:<code>CNOSDB_DATA_CACHE_MAX_MEMORY_SIZE</code></p>
<h4 id="cache-snapshot-memory-size--25m"><a class="header" href="#cache-snapshot-memory-size--25m">cache-snapshot-memory-size = &quot;25m&quot;</a></h4>
<p>引擎快照缓存并将其写入TSM文件的大小，以释放内存。有效的内存大小后缀是:k、m或g。没有大小后缀的值以字节为单位。环境变量:<code>CNOSDB_DATA_CACHE_SNAPSHOT_MEMORY_SIZE</code></p>
<h4 id="cache-snapshot-write-cold-duration--10m"><a class="header" href="#cache-snapshot-write-cold-duration--10m">cache-snapshot-write-cold-duration = &quot;10m&quot;</a></h4>
<p>如果分片还没有收到写或删除，引擎将快照缓存并将其写入新的TSM文件的时间间隔。环境变量:<code>CNOSDB_DATA_CACHE_SNAPSHOT_WRITE_COLD_DURATION</code></p>
<h4 id="compact-full-write-cold-duration--4h"><a class="header" href="#compact-full-write-cold-duration--4h">compact-full-write-cold-duration = &quot;4h&quot;</a></h4>
<p>如果没有收到写或删除，TSM引擎将在一个分片中压缩所有TSM文件的时间间隔。环境变量:<code>CNOSDB_DATA_COMPACT_FULL_WRITE_COLD_DURATION</code></p>
<h4 id="max-concurrent-compactions--0"><a class="header" href="#max-concurrent-compactions--0">max-concurrent-compactions = 0</a></h4>
<p>一次可以运行的并发全量和级别压缩的最大数目。默认值0会导致运行时将50%的CPU内核用于压缩。如果显式设置，则用于压缩的内核数量将被限制为指定的值。该设置不适用于缓存快照。环境变量:<code>CNOSDB_DATA_MAX_CONCURRENT_COMPACTIONS</code></p>
<h4 id="compact-throughput--48m"><a class="header" href="#compact-throughput--48m">compact-throughput = &quot;48m&quot;</a></h4>
<p>允许TSM压缩写入磁盘的速率限制(以每秒字节为单位)。请注意，允许短突发以一个可能更大的值发生，该值由<code>compact-throughput-burst</code>设置。环境变量:<code>CNOSDB_DATA_COMPACT_THROUGHPUT</code></p>
<h4 id="compact-throughput-burst--48m"><a class="header" href="#compact-throughput-burst--48m">compact-throughput-burst = &quot;48m&quot;</a></h4>
<p>允许TSM压缩写入磁盘的速率限制(以每秒字节为单位)。环境变量:<code>CNOSDB_DATA_COMPACT_THROUGHPUT_BURST</code></p>
<h4 id="tsm-use-madv-willneed--false"><a class="header" href="#tsm-use-madv-willneed--false">tsm-use-madv-willneed = false</a></h4>
<p>如果为<code>true</code>，那么MMap Advise值<code>MADV_WILLNEED</code>就输入/输出分页方面向内核建议如何处理映射内存区域，以及如何期望在不久的将来访问映射内存区域(与TSM文件有关)。因为这个设置在一些内核(包括CentOS和RHEL)上有问题，所以默认值是<code>false</code>。在某些情况下，将该值更改为<code>true</code>可能对磁盘速度较慢的用户有所帮助。环境变量:<code>CNOSDB_DATA_TSM_USE_MADV_WILLNEED</code></p>
<h4 id="max-series-per-database--1000000"><a class="header" href="#max-series-per-database--1000000">max-series-per-database = 1000000</a></h4>
<p>在删除写操作之前，每个数据库允许的最大序列数。默认设置为1000000(100万)。将该设置更改为0，以允许每个数据库无限数量的序列。如果某个点导致数据库中序列的数量超过max-series-per-database，则CnosDB将不会写入该点，并返回500，并出现以下错误:</p>
<p><code>{&quot;error&quot;:&quot;max series per database exceeded: &lt;series&gt;&quot;}</code></p>
<p>环境变量:<code>CNOSDB_DATA_MAX_SERIES_PER_DATABASE</code></p>
<h4 id="max-values-per-tag--100000"><a class="header" href="#max-values-per-tag--100000">max-values-per-tag = 100000</a></h4>
<p>每个标记键允许的标记值的最大数目。缺省值为100000(100,000)。将设置更改为0，以允许每个标记键的标记值数量不限。如果标记值导致标记键的标记值数量超过<code>max-values-per-tag</code>，则CnosDB将不写入该点，并返回部分写入错误。</p>
<p>任何标签值超过<code>max-values-per-tag</code>的现有标签键将继续接受写操作，但创建新标签值的写操作将失败。</p>
<p>环境变量:<code>CNOSDB_DATA_MAX_VALUES_PER_TAG</code></p>
<h4 id="max-index-log-file-size--1m"><a class="header" href="#max-index-log-file-size--1m">max-index-log-file-size = &quot;1m&quot;</a></h4>
<p>当索引预写日志(WAL)文件压缩为索引文件时，以字节为单位的阈值。阈值较低将导致日志文件被更快地压缩，并以写吞吐量为代价减少堆的使用。阈值较高将导致日志文件更少地被压缩，在内存中存储更多的系列，并提供更高的写吞吐量。有效的大小后缀是k、m或g(不区分大小写，1024 = 1k)。没有大小后缀的值以字节为单位。环境变量:<code>CNOSDB_DATA_MAX_INDEX_LOG_FILE_SIZE</code></p>
<h4 id="series-id-set-cache-size--100"><a class="header" href="#series-id-set-cache-size--100">series-id-set-cache-size = 100</a></h4>
<p>指定要为TSI索引缓存的系列ID集的数量(默认为100)。集合中的系列id指的是在同一个索引谓词(标记过滤器)上匹配的序列。序列ID集是一个LRU缓存，所以一旦缓存满了，最近最少使用的集就会被驱逐。缓存的结果可以快速返回，因为当执行带有匹配标记过滤器的后续查询时，它们不需要重新计算。</p>
<p>我们建议使用默认设置。将此值更改为0将禁用缓存，这可能会导致查询性能问题。只有当您知道数据库的所有度量的标记键值大于100时，才会增加这个值。增加缓存大小可能会导致堆使用的增加。</p>
<p>环境变量:<code>CNOSDB_DATA_SERIES_ID_SET_CACHE_SIZE</code></p>
<h3 id="coordinator-查询管理"><a class="header" href="#coordinator-查询管理">[Coordinator]-查询管理</a></h3>
<h4 id="write-timeout--10s"><a class="header" href="#write-timeout--10s">write-timeout = &quot;10s&quot;</a></h4>
<p>写请求等待的时间，直到一个“超时”错误返回给调用者。默认值是10秒。环境变量:<code>CNOSDB_COORDINATOR_WRITE_TIMEOUT</code></p>
<h4 id="max-concurrent-queries--0"><a class="header" href="#max-concurrent-queries--0">max-concurrent-queries = 0</a></h4>
<p>在您的实例上允许运行查询的最大数量。默认设置(0)允许无限次查询。环境变量:<code>CNOSDB_COORDINATOR_MAX_CONCURRENT_QUERIES</code></p>
<h4 id="query-timeout--0s"><a class="header" href="#query-timeout--0s">query-timeout = &quot;0s&quot;</a></h4>
<p>在CnosDB终止查询之前，允许执行查询的最大持续时间。默认设置(0)允许查询在没有时间限制的情况下运行。此设置是一个持续时间。环境变量:<code>CNOSDB_COORDINATOR_QUERY_TIMEOUT</code></p>
<h4 id="log-queries-after--0s"><a class="header" href="#log-queries-after--0s">log-queries-after = &quot;0s&quot;</a></h4>
<p>在CnosDB用检测到的慢速查询消息记录查询之前，查询所能持续的最长时间。默认设置(“0”)将永远不会告诉CnosDB记录查询。此设置是一个持续时间。环境变量:<code>CNOSDB_COORDINATOR_LOG_QUERIES_AFTER</code></p>
<h4 id="max-select-point--0"><a class="header" href="#max-select-point--0">max-select-point = 0</a></h4>
<p>一个SELECT语句可以处理的最大点数。默认设置(0)允许SELECT语句处理无限数量的点。环境变量:<code>CNOSDB_COORDINATOR_MAX_SELECT_POINT</code></p>
<h3 id="max-select-series--0"><a class="header" href="#max-select-series--0">max-select-series = 0</a></h3>
<p>一个SELECT语句可以处理的最大序列数。默认设置(0)允许SELECT语句处理无限数量的序列。环境变量:<code>CNOSDB_COORDINATOR_MAX_SELECT_SERIES</code></p>
<h4 id="max-select-buckets--0"><a class="header" href="#max-select-buckets--0">max-select-buckets = 0</a></h4>
<p>一个查询可以处理的GROUP BY time()桶的最大数量。默认设置(0)允许查询处理无限数量的桶。 环境变量:<code>CNOSDB_COORDINATOR_MAX_SELECT_BUCKETS</code></p>
<h3 id="retentionpolicy-保留策略"><a class="header" href="#retentionpolicy-保留策略">[RetentionPolicy]-保留策略</a></h3>
<h4 id="enabled--true"><a class="header" href="#enabled--true">enabled = true</a></h4>
<p>设置为<code>false</code>可防止CnosDB强制执行保留策略。环境变量：<code>CNOSDB_RETENTION_ENABLED</code></p>
<h4 id="check-interval--30m0s"><a class="header" href="#check-interval--30m0s">check-interval = &quot;30m0s&quot;</a></h4>
<p>CnosDB检查以强制执行保留策略的时间间隔。环境变量:<code>CNOSDB_RETENTION_CHECK_INTERVAL</code></p>
<h3 id="precreator-分片"><a class="header" href="#precreator-分片">[Precreator]-分片</a></h3>
<h4 id="enabled--true-1"><a class="header" href="#enabled--true-1">enabled = true</a></h4>
<p>判断是否开启分片预创建服务。环境变量:<code>CNOSDB_SHARD_PRECREATION_ENABLED</code></p>
<h4 id="check-interval--10m"><a class="header" href="#check-interval--10m">check-interval = &quot;10m&quot;</a></h4>
<p>运行预创建新分片检查的时间间隔。环境变量:<code>CNOSDB_SHARD_PRECREATION_CHECK_INTERVAL</code></p>
<h4 id="advance-period--30m"><a class="header" href="#advance-period--30m">advance-period = &quot;30m&quot;</a></h4>
<p>未来CnosDB预先创建分片的最长时间。30m的默认值应该适用于大多数系统。在未来将此设置增加得太久可能会导致效率低下。环境变量:<code>CNOSDB_SHARD_PRECREATION_ADVANCE_PERIOD</code></p>
<h3 id="monitor-监控"><a class="header" href="#monitor-监控">[Monitor]-监控</a></h3>
<p>默认情况下，CnosDB将数据写入_internal数据库。如果该数据库不存在，则CnosDB自动创建它。_internal数据库的默认保留策略是7天。如果需要使用7天保留策略以外的其他策略，必须先创建该策略。</p>
<h4 id="store-enabled--true"><a class="header" href="#store-enabled--true">store-enabled = true</a></h4>
<p>设置为<code>false</code>在内部禁用记录统计。如果设置为<code>false</code>，它将大大增加诊断安装问题的难度。环境变量:<code>CNOSDB_MONITOR_STORE_ENABLED</code></p>
<h4 id="store-database--_internal"><a class="header" href="#store-database--_internal">store-database = &quot;_internal&quot;</a></h4>
<p>用于记录统计信息的目标数据库。环境变量:<code>CNOSDB_MONITOR_STORE_DATABASE</code></p>
<h4 id="store-interval--10s"><a class="header" href="#store-interval--10s">store-interval = &quot;10s&quot;</a></h4>
<p>CnosDB记录统计信息的时间间隔。默认值是每10秒一次。环境变量:<code>CNOSDB_MONITOR_STORE_INTERVAL</code></p>
<h3 id="httpd-http端点"><a class="header" href="#httpd-http端点">[HTTPD]-HTTP端点</a></h3>
<p>[http]部分设置控制CnosDB如何配置http端点。这些是进出CnosDB的主要机制。编辑此部分中的设置以启用HTTPS和身份验证。</p>
<h4 id="enabled--true-2"><a class="header" href="#enabled--true-2">enabled = true</a></h4>
<p>确定是否启用HTTP端点。如果要禁用对HTTP端点的访问，请将该值设置为false。请注意，CnosDB命令行接口(CLI)使用CnosDB API连接到数据库。环境变量:<code>CNOSDB_HTTP_ENABLED</code></p>
<h4 id="bind-address--8086"><a class="header" href="#bind-address--8086">bind-address = &quot;:8086&quot;</a></h4>
<p>HTTP服务使用的绑定地址(端口)。环境变量:<code>CNOSDB_HTTP_BIND_ADDRESS</code></p>
<h4 id="auth-enabled--false"><a class="header" href="#auth-enabled--false">auth-enabled = false</a></h4>
<p>确定是否通过HTTP和HTTPS启用用户认证。如果需要身份验证，请将该值设置为<code>true</code>。环境变量:<code>CNOSDB_HTTP_AUTH_ENABLED</code></p>
<h4 id="log-enabled--true"><a class="header" href="#log-enabled--true">log-enabled = true</a></h4>
<p>确定是否启用HTTP请求日志记录。若要禁用日志记录，请将该值设置为<code>false</code>。环境变量:<code>CNOSDB_HTTP_LOG_ENABLED</code></p>
<h4 id="suppress-write-log--false"><a class="header" href="#suppress-write-log--false">suppress-write-log = false</a></h4>
<p>确定启用日志时是否应该抑制HTTP写请求日志。</p>
<h4 id="access-log-path-"><a class="header" href="#access-log-path-">access-log-path = &quot;&quot;</a></h4>
<p>访问日志的路径，它决定是否使用<code>log-enabled = true</code>启用详细的写日志记录。指定启用时是否将HTTP请求日志写入指定的路径。如果cnosdb无法访问指定的路径，它将记录错误并退回到stderr。当启用HTTP请求日志记录时，此选项指定应该写入日志条目的路径。如果未指定，默认值是写入stderr，这会将HTTP日志与内部的CnosDB日志混合在一起。如果cnosdb无法访问指定的路径，它将记录一个错误，并退回到将请求日志写入stderr。环境变量:<code>CNOSDB_HTTP_ACCESS_LOG_PATH</code></p>
<h4 id="access-log-status-filters--"><a class="header" href="#access-log-status-filters--">access-log-status-filters = []</a></h4>
<p>筛选应该记录的请求。每个过滤器的模式为nnn、nnx或nxx，其中n是一个数字，x是任何数字的通配符。要过滤所有5xx响应，请使用字符串5xx。如果使用多个过滤器，则只需要匹配一个。默认值是没有过滤器，每个请求都会被打印出来。环境变量:<code>CNOSDB_HTTP_ACCESS_LOG_STATUS_FILTERS_x</code></p>
<h4 id="write-tracing--false"><a class="header" href="#write-tracing--false">write-tracing = false</a></h4>
<p>确定是否启用详细的写日志记录。设置为<code>true</code>为写负载启用日志记录。如果设置为<code>true</code>，这将复制日志中的每个写语句，因此不建议在一般情况下使用。环境变量:<code>CNOSDB_HTTP_WRITE_TRACING</code></p>
<h4 id="pprof-enabled--true"><a class="header" href="#pprof-enabled--true">pprof-enabled = true</a></h4>
<p>确定是否启用/net/http/pprof HTTP端点。用于故障排除和监视。环境变量:<code>CNOSDB_HTTP_PPROF_ENABLED</code></p>
<h4 id="pprof-auth-enabled--false"><a class="header" href="#pprof-auth-enabled--false">pprof-auth-enabled = false</a></h4>
<pre><code>- /debug/pprof
- /debug/requests
- /debug/vars
</code></pre>
<p>如果<code>auth-enabled</code>或<code>pprofessor -enabled</code>设置为<code>false</code>，则此设置无效。环境变量:<code>CNOSDB_HTTP_PPROF_AUTH_ENABLED</code></p>
<h4 id="debug-pprof-enabled--false"><a class="header" href="#debug-pprof-enabled--false">debug-pprof-enabled = false</a></h4>
<p>启用默认<code>/pprof</code>端点并绑定到<code>localhost:6060</code>。用于调试启动性能问题。环境变量:<code>CNOSDB_HTTP_DEBUG_PPROF_ENABLED</code></p>
<h4 id="ping-auth-enabled--false"><a class="header" href="#ping-auth-enabled--false">ping-auth-enabled = false</a></h4>
<p>启用<code>/ping</code>、<code>/metrics</code>和<code>/status</code>端点的身份验证。如果<code>auth-enabled</code>设置为<code>false</code>，则此设置无效。环境变量:<code>CNOSDB_HTTP_PING_AUTH_ENABLED</code></p>
<h4 id="https-enabled--false"><a class="header" href="#https-enabled--false">https-enabled = false</a></h4>
<p>HTTPS是否启用。如果启用HTTPS协议，请将该值设置为<code>true</code>。环境变量:<code>CNOSDB_HTTP_HTTPS_ENABLED</code></p>
<h4 id="https-certificate--etcsslcnosdbpem"><a class="header" href="#https-certificate--etcsslcnosdbpem">https-certificate = &quot;/etc/ssl/cnosdb.pem&quot;</a></h4>
<p>启用HTTPS时使用的SSL证书文件的路径。环境变量:<code>CNOSDB_HTTP_HTTPS_CERTIFICATE</code></p>
<h4 id="https-private-key-"><a class="header" href="#https-private-key-">https-private-key = &quot;&quot;</a></h4>
<p>使用单独的私钥位置。如果只指定了<code>https-certificate</code>, httpd服务将尝试从<code>https-certificate</code>文件中加载私钥。如果指定了一个单独的<code>https-private-key</code>文件，httpd服务将从<code>https-private-key</code>文件加载私钥。环境变量:<code>CNOSDB_HTTP_HTTPS_PRIVATE_KEY</code></p>
<h4 id="shared-secret-"><a class="header" href="#shared-secret-">shared-secret = &quot;&quot;</a></h4>
<p>用于使用JWT令牌验证公共API请求的共享秘密。环境变量:<code>CNOSDB_HTTP_SHARED_SECRET</code></p>
<h4 id="max-row-limit--0"><a class="header" href="#max-row-limit--0">max-row-limit = 0</a></h4>
<p>系统在非分块查询中可以返回的最大行数。默认设置(0)允许无限的行数。如果查询结果超过指定值，则CnosDB在响应体中包含一个“partial”:true标记。环境变量:<code>CNOSDB_HTTP_MAX_ROW_LIMIT</code></p>
<h4 id="max-connection-limit--0"><a class="header" href="#max-connection-limit--0">max-connection-limit = 0</a></h4>
<p>可以同时打开的最大连接数。超过限制的新连接将被删除。默认值<code>0</code>禁用限制。环境变量:<code>CNOSDB_HTTP_MAX_CONNECTION_LIMIT</code></p>
<h4 id="unix-socket-enabled--false"><a class="header" href="#unix-socket-enabled--false">unix-socket-enabled = false</a></h4>
<p>通过UNIX域套接字启用HTTP服务。如果需要通过UNIX域套接字开启HTTP服务，请将该值设置为true。环境变量:<code>CNOSDB_HTTP_UNIX_SOCKET_ENABLED</code></p>
<h4 id="bind-socket--varruncnosdbsock"><a class="header" href="#bind-socket--varruncnosdbsock">bind-socket = &quot;/var/run/cnosdb.sock&quot;</a></h4>
<p>UNIX域套接字的路径。环境变量:<code>CNOSDB_HTTP_UNIX_BIND_SOCKET</code></p>
<h4 id="max-body-size--25000000"><a class="header" href="#max-body-size--25000000">max-body-size = 25000000</a></h4>
<p>客户端请求体的最大大小(以字节为单位)。当HTTP客户端发送的数据超过配置的最大大小时，会返回<code>413 Request Entity Too Large HTTP</code>响应。若要禁用该限制，请将该值设置为0。环境变量:<code>CNOSDB_HTTP_MAX_BODY_SIZE</code></p>
<h4 id="max-concurrent-write-limit--0"><a class="header" href="#max-concurrent-write-limit--0">max-concurrent-write-limit = 0</a></h4>
<p>并发处理的最大写操作数。若要禁用该限制，请将该值设置为0。环境变量:<code>CNOSDB_HTTP_MAX_CONCURRENT_WRITE_LIMIT</code></p>
<h4 id="max-enqueued-write-limit--0"><a class="header" href="#max-enqueued-write-limit--0">max-enqueued-write-limit = 0</a></h4>
<p>排队等待处理的最大写操作数。若要禁用该限制，请将该值设置为0。环境变量:<code>CNOSDB_HTTP_MAX_ENQUEUED_WRITE_LIMIT</code></p>
<h4 id="enqueued-write-timeout--0"><a class="header" href="#enqueued-write-timeout--0">enqueued-write-timeout = 0</a></h4>
<p>在等待处理的队列中等待写操作的最大持续时间。如果要禁用该限制，请将该值设置为0或将<code>max-concurrent-write-limit</code>值设置为0。环境变量:<code>CNOSDB_HTTP_ENQUEUED_WRITE_TIMEOUT</code></p>
<h3 id="log-日志"><a class="header" href="#log-日志">[Log]-日志</a></h3>
<h4 id="format--auto"><a class="header" href="#format--auto">format = &quot;auto&quot;</a></h4>
<p>确定要为日志使用哪个日志编码器。有效值为<code>auto</code>(默认值)、<code>logfmt</code>和<code>json</code>。使用默认的自动选项，如果输出到TTY设备(例如，终端)，则使用更友好的控制台编码。如果输出是<code>files</code>，则<code>auto</code>选项使用<code>logfmt</code>编码。<code>logfmt</code>和<code>json</code>选项对于与外部工具集成非常有用。环境变量:<code>CNOSDB_LOGGING_FORMAT</code></p>
<h4 id="level--info"><a class="header" href="#level--info">level = &quot;info&quot;</a></h4>
<p>要发出的日志级别。有效值为<code>error</code>、<code>warn</code>、<code>info</code>(默认值)和<code>debug</code>。等于或高于指定级别的日志将被触发。环境变量:<code>CNOSDB_LOGGING_LEVEL</code></p>
<h4 id="suppress-logo--false"><a class="header" href="#suppress-logo--false">suppress-logo = false</a></h4>
<p>抑制程序启动时打印的标志输出。如果STDOUT不是TTY，则标识总是被抑制的。环境变量:<code>CNOSDB_LOGGING_SUPPRESS_LOGO</code></p>
<h3 id="subscriber-订阅"><a class="header" href="#subscriber-订阅">[Subscriber]-订阅</a></h3>
<h4 id="enabled--true-3"><a class="header" href="#enabled--true-3">enabled = true</a></h4>
<p>确定是否启用用户服务。如果需要关闭用户服务，请将该值设置为<code>false</code>。环境变量:<code>CNOSDB_SUBSCRIBER_ENABLED</code></p>
<h4 id="http-timeout--30s"><a class="header" href="#http-timeout--30s">http-timeout = &quot;30s&quot;</a></h4>
<p>HTTP写入到订阅服务器直至超时的持续时间。环境变量:<code>CNOSDB_SUBSCRIBER_HTTP_TIMEOUT</code></p>
<h4 id="insecure-skip-verify--false"><a class="header" href="#insecure-skip-verify--false">insecure-skip-verify = false</a></h4>
<p>确定是否允许到订阅者的不安全的HTTPS连接。这在测试自签名证书时非常有用。环境变量:<code>CNOSDB_SUBSCRIBER_INSECURE_SKIP_VERIFY</code></p>
<h4 id="ca-certs-"><a class="header" href="#ca-certs-">ca-certs = &quot;&quot;</a></h4>
<p>pem编码的CA certs文件的路径。如果为空字符串<code>“”</code>，则使用系统默认证书。环境变量:<code>CNOSDB_SUBSCRIBER_CA_CERTS</code></p>
<h4 id="write-concurrency--40"><a class="header" href="#write-concurrency--40">write-concurrency = 40</a></h4>
<p>处理写通道的写入程序的数量。环境变量:<code>CNOSDB_SUBSCRIBER_WRITE_CONCURRENCY</code></p>
<h4 id="write-buffer-size--1000"><a class="header" href="#write-buffer-size--1000">write-buffer-size = 1000</a></h4>
<p>写通道中缓冲的正在写的次数。环境变量:<code>CNOSDB_SUBSCRIBER_WRITE_BUFFER_SIZE</code></p>
<h3 id="continuousquery-连续查询"><a class="header" href="#continuousquery-连续查询">[ContinuousQuery]-连续查询</a></h3>
<h4 id="enabled--true-4"><a class="header" href="#enabled--true-4">enabled = true</a></h4>
<p>设置为<code>false</code>，禁用CQs。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_ENABLED</code></p>
<h4 id="log-enabled--true-1"><a class="header" href="#log-enabled--true-1">log-enabled = true</a></h4>
<p>设置为<code>false</code>，禁用CQ事件的日志记录。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_LOG_ENABLED</code></p>
<h4 id="query-stats-enabled--false"><a class="header" href="#query-stats-enabled--false">query-stats-enabled = false</a></h4>
<p>当设置为<code>true</code>时，连续查询执行统计信息将被写入默认监视存储区。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_QUERY_STATS_ENABLED</code></p>
<h4 id="run-interval--1s"><a class="header" href="#run-interval--1s">run-interval = &quot;1s&quot;</a></h4>
<p>CnosDB检查CQ是否需要运行的时间间隔。将此选项设置为CQs运行的最低时间间隔。例如，如果你最频繁的CQ每分钟运行，设置运行间隔为1米。环境变量:<code>CNOSDB_CONTINUOUS_QUERIES_RUN_INTERVAL</code></p>
<h3 id="tls-传输层安全"><a class="header" href="#tls-传输层安全">[TLS]-传输层安全</a></h3>
<p>如果没有指定TLS配置设置，则根据用于构建CnosDB的Go<code>crypto/tls</code>包文档中的常量部分，CnosDB支持列出的所有加密套件id和实现的所有TLS版本。使用<code>SHOW DIAGNOSTICS</code>命令查看用于构建CnosDB的Go版本。</p>
<h4 id="min-version--tls10"><a class="header" href="#min-version--tls10">min-version = &quot;tls1.0&quot;</a></h4>
<p>即将协商的TLS协议的最小版本。有效值包括:<code>tls1.0</code>、<code>tls1.1</code>、<code>tls1.2</code>。如果不指定，则<code>min-version</code>为Go<code>crypto/TLS</code>包中指定的TLS最小版本。在本例中，<code>tls1.0</code>将最小版本指定为<code>tls1.0</code>。环境变量:<code>CNOSDB_TLS_MIN_VERSION</code></p>
<h4 id="max-version--tls12"><a class="header" href="#max-version--tls12">max-version = &quot;tls1.2&quot;</a></h4>
<p>即将协商的TLS协议的最大版本。有效值包括:<code>tls1.0</code>、<code>tls1.1</code>、<code>tls1.2</code>。<code>max-version</code>为Go<code>crypto/TLS</code>包中指定的最大TLS版本号。在本例中，tls1.2将最大版本指定为TLS 1.2。环境变量:<code>CNOSDB_TLS_MAX_VERSION</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="集群管理"><a class="header" href="#集群管理">集群管理</a></h1>
<h2 id="介绍"><a class="header" href="#介绍">介绍</a></h2>
<p>CnosDB由两组软件组成，<code>data</code>节点和<code>meta</code>节点，集群内的通讯如下所示：</p>
<p><code>meta</code>节点使用<code>tcp</code>和<code>raft</code>协议进行通信，<code>meta</code>节点之间使用默认端口<code>8091</code>通信，多个<code>meta</code>节点需要互相能够访问，用来维持<code>meta</code>集群的一致性。同时<code>8091</code>端口也用来和外界通信，比如<code>cnosd-ctl</code>或<code>data</code>节点等。</p>
<p><code>data</code>节点通过<code>tcp</code>的8088端口互相通信，并且通过<code>8091</code>访问<code>meta</code>节点的API，使状态保持同步。</p>
<p><code>meta</code>节点数量必须为大于等于3的奇数，这样可以保证集群能够保持选举稳定。</p>
<h2 id="安装-1"><a class="header" href="#安装-1">安装</a></h2>
<p>配置文件的<code>hostname</code>需要其他的<code>meta node</code>和<code>data node</code>节点都能够访问。</p>
<p>配置文件可以通过<code>cnosdb-meta config &gt; config_path</code>获得。</p>
<h3 id="启动meta节点"><a class="header" href="#启动meta节点">启动<code>meta</code>节点</a></h3>
<pre><code>./cnosdb-meta --config [cnosdb_meta_config_path]
</code></pre>
<h3 id="将meta加入到集群"><a class="header" href="#将meta加入到集群">将<code>meta</code>加入到集群</a></h3>
<blockquote>
<p>添加完后会提示：Added meta node x at cnosdb-meta-0x:8091</p>
</blockquote>
<pre><code>cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-01:8091
cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-02:8091
cnosdb-ctl --bind cnosdb-meta-01:8091 add-meta cnosdb-meta-03:8091
</code></pre>
<p>3个节点都添加完输入<code>cnosdb-ctl show</code>查看集群状态</p>
<pre><code>Data Nodes:
==========


Meta Nodes:
==========

1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
<p>请注意，一但没有出现3个节点，不要进行下一步。</p>
<h3 id="启动data节点"><a class="header" href="#启动data节点">启动<code>data</code>节点</a></h3>
<blockquote>
<p>启动前将配置文件中的<code>cluster</code>改为<code>true</code></p>
</blockquote>
<pre><code> cnosdb --config [cnosdb_config_path]
</code></pre>
<h3 id="将data节点加入到集群"><a class="header" href="#将data节点加入到集群">将<code>data</code>节点加入到集群</a></h3>
<blockquote>
<p>添加完后会提示：Added data node x at cnosdb-data-0x:8088</p>
</blockquote>
<pre><code>cnosdb-ctl --bind cnosdb-data-01:8091 add-data cnosdb-data-01:8088
cnosdb-ctl --bind cnosdb-data-01:8091 add-data cnosdb-data-02:8088
</code></pre>
<p>2个节点都添加完输入<code>cnosdb-ctl show</code>查看集群状态</p>
<pre><code>Data Nodes:
==========

4      cnosdb-data-01:8088
5      cnosdb-data-02:8088
Meta Nodes:
==========

1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
<h2 id="distributed-sandbox"><a class="header" href="#distributed-sandbox">Distributed-sandbox</a></h2>
<p>可以使用<code>Distributed-sandbox</code>工具快速生产分布式集群</p>
<h3 id="要求"><a class="header" href="#要求">要求</a></h3>
<p>本地上要有<code>Docker</code></p>
<h3 id="克隆项目"><a class="header" href="#克隆项目">克隆项目</a></h3>
<pre><code>git clone https://github.com/cnosdb/distributed-sandbox.git
</code></pre>
<h3 id="运行"><a class="header" href="#运行">运行</a></h3>
<pre><code>docker-compose up -d
chmod 777 cluster.sh
./cluster.sh
</code></pre>
<p>运行成功后可看到如下结果</p>
<pre><code>Joining meta nodes to cluster...
Added meta node 1 at cnosdb-meta-01:8091
Added meta node 2 at cnosdb-meta-02:8091
Added meta node 3 at cnosdb-meta-03:8091
Data Nodes:
==========
4      cnosdb-data-01:8088
5      cnosdb-data-02:8088

Meta Nodes:
==========
1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091

Joining data nodes to cluster...
EOF
EOF
Cluster successfully created
Data Nodes:
==========
4      cnosdb-data-01:8088
5      cnosdb-data-02:8088

Meta Nodes:
==========
1      cnosdb-meta-01:8091
2      cnosdb-meta-02:8091
3      cnosdb-meta-03:8091
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="运维工具"><a class="header" href="#运维工具">运维工具</a></h1>
<ul>
<li><a href="content/cnosdb/latest/cnosdb_tools/./cnosdb.html">cnosdb</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/./cnosdb-cli.html">cnosdb-cli</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/./cnosdb-inspect.html">cnosdb-inspect</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-1"><a class="header" href="#cnosdb-1">cnosdb</a></h1>
<p><code>cnosdb</code>命令用于启动 CnosDB 服务或相关功能。</p>
<h2 id="命令介绍"><a class="header" href="#命令介绍">命令介绍</a></h2>
<table><thead><tr><th>命令</th><th>功能</th></tr></thead><tbody>
<tr><td>backup</td><td>创建数据节点的备份</td></tr>
<tr><td>config</td><td>显示默认配置项</td></tr>
<tr><td>help</td><td>显示帮助信息</td></tr>
<tr><td>restore</td><td>使用数据节点的备份进行恢复</td></tr>
<tr><td>run</td><td>启动服务</td></tr>
<tr><td>version</td><td>显示版本信息</td></tr>
</tbody></table>
<h3 id="cnosdb-run"><a class="header" href="#cnosdb-run"><code>cnosdb [run]</code></a></h3>
<p>启动服务。</p>
<pre><code>cnosdb [run] [flags]
</code></pre>
<h3 id="参数介绍-2"><a class="header" href="#参数介绍-2"><em>参数介绍</em></a></h3>
<table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody>
<tr><td><code>--config</code></td><td>配置文件路径</td></tr>
<tr><td><code>--pidfile</code></td><td>将进程 ID 写入指定文件</td></tr>
<tr><td><code>--cpuprofile</code></td><td>将 CPU 信息写入指定文件</td></tr>
<tr><td><code>--memprofile</code></td><td>将内存使用记录写入指定文件</td></tr>
</tbody></table>
<h3 id="cnosdb-backup"><a class="header" href="#cnosdb-backup"><code>cnosdb backup</code></a></h3>
<p>从指定数据节点创建数据库快照，并保存到 PATH 对应目录。</p>
<pre><code>cnosdb backup [flags] PATH
</code></pre>
<h3 id="参数介绍-3"><a class="header" href="#参数介绍-3">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>数据库名称；可选；如果未指定则备份所有数据库。</td></tr>
<tr><td><code>--rp</code></td><td>数据保留策略；可选；如果未指定则备份所有数据保留策略。</td></tr>
<tr><td><code>--shard</code></td><td>分片编号；可选；如果需要使用该参数，则需要同时使用 <code>-rp</code> 参数。</td></tr>
<tr><td><code>--start</code></td><td>备份中包含的数据的最小时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--end</code></td><td>备份中包含的数据的最大时间戳 (RFC3339 format) 。</td></tr>
<tr><td><code>--skip-errors</code></td><td>创建某分片的备份时，若发生错误，继续创建剩余分片的备份。</td></tr>
</tbody></table>
<h3 id="cnosdb-restore"><a class="header" href="#cnosdb-restore"><code>cnosdb restore</code></a></h3>
<p>从指定的备份目录中恢复数据和元数据。恢复开始时，服务将被关闭。</p>
<pre><code>cnosdb restore [flags]
</code></pre>
<h3 id="参数介绍-4"><a class="header" href="#参数介绍-4">参数介绍</a></h3>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>地址；可选；默认值为 127.0.0.1:8088 。</td></tr>
<tr><td><code>--db</code></td><td>从备份数据中恢复的数据库名称。</td></tr>
<tr><td><code>--newdb</code></td><td>创建新数据库以导入备份数据；可选；如果未指定，则使用 <code>--db &lt;db_name&gt;</code> 中指定的数据库名称。该参数指定的数据库名称在目标系统中不能重复。</td></tr>
<tr><td><code>--rp</code></td><td>从备份数据中恢复的数据库保留策略名称；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 参数。</td></tr>
<tr><td><code>--newrp</code></td><td>将备份数据导入其他的数据保留策略；可选；如果未指定，则使用 <code>--rp</code> 中指定的数据保留策略名称。</td></tr>
<tr><td><code>--shard</code></td><td>从备份数据中恢复的分片编号；可选；如果需要使用该参数，则需要同时使用 <code>--db</code> 和 <code>--rp</code> 参数。</td></tr>
</tbody></table>
<h3 id="cnosdb-config"><a class="header" href="#cnosdb-config"><code>cnosdb config</code></a></h3>
<p>显示服务运行时的默认配置。</p>
<pre><code>cnosdb config [flags]
</code></pre>
<h3 id="参数介绍-5"><a class="header" href="#参数介绍-5">参数介绍</a></h3>
<table><thead><tr><th style="text-align: left">Flag</th><th style="text-align: left"></th><th>Description</th></tr></thead><tbody>
<tr><td style="text-align: left"></td><td style="text-align: left"><code>--config</code></td><td>指定配置文件路径。若需要禁止从文件中加载配置项，可将该值设为 <code>/dev/null</code> 。</td></tr>
<tr><td style="text-align: left"><code>-h</code></td><td style="text-align: left"><code>--help</code></td><td>显示 <code>cnosdb config</code> 的帮助信息。</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb-cli-1"><a class="header" href="#cnosdb-cli-1"><strong>cnosdb-cli</strong></a></h1>
<p>启动交互式命令行程序并连接 <code>cnosdb</code> 服务，以实现数据的写入、查询。</p>
<pre><code>cnosdb-cli [flags]
</code></pre>
<h2 id="参数介绍-6"><a class="header" href="#参数介绍-6">参数介绍</a></h2>
<table><thead><tr><th>Flag</th><th>Description</th></tr></thead><tbody>
<tr><td><code>--host</code></td><td>连接的 cnosdb HTTP 协议地址 (default: <code>http://localhost:8086</code>)</td></tr>
<tr><td><code>--port</code></td><td>连接的 cnosdb 的端口号</td></tr>
<tr><td><code>--password</code></td><td>连接服务时使用的密码</td></tr>
<tr><td><code>--username</code></td><td>连接服务时使用的用户名</td></tr>
<tr><td><code>--ssl</code></td><td>连接时使用 HTTPS 协议</td></tr>
<tr><td><code>--format</code></td><td>指定打印 cnosdb 服务的响应内容的格式: json, csv, or column</td></tr>
<tr><td><code>--precision</code></td><td>指定时间戳的格式: rfc3339, h, m, s, ms, u or ns</td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb_inspect"><a class="header" href="#cnosdb_inspect">cnosdb_inspect</a></h1>
<p>CnosDB Inspect 是一个磁盘数据检查工具，可用于：</p>
<ul>
<li>查看有关磁盘分片的详细信息。</li>
<li>将数据从分片导出到可以插入回数据库的CnosDB 线路协议。</li>
<li>将 TSM 索引分片转换为 TSI 索引分片。</li>
</ul>
<p><strong>语法</strong></p>
<pre><code>cnosdb_inspect [ [ command ] [ options ] ]
</code></pre>
<ul>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#deletetsm">deletetsm</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#dumptsm">dumptsm</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#dumptsi">dumptsi</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#buildtsi">buildtsi</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#dumptsmwal">dumptsmwal</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#report-disk">report-disk</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#report">report</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#reporttsi">reporttsi</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#verify">verify</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#verify-seriesfile">verify-seriesfile</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#verify-tombstone">verify-tombstone</a></li>
<li><a href="content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html#export">export</a></li>
</ul>
<h2 id="deletetsm"><a class="header" href="#deletetsm"><code>deletetsm</code></a></h2>
<h3 id="cnosdb_inspect-deletetsm"><a class="header" href="#cnosdb_inspect-deletetsm"><code>cnosdb_inspect deletetsm</code></a></h3>
<p>批量从原始 <code>TSM</code> 文件中删除<code>measurement</code>数据</p>
<h3 id="注意仅当您的cnosdb离线cnosdb服务未运行-时才使用deletetsm"><a class="header" href="#注意仅当您的cnosdb离线cnosdb服务未运行-时才使用deletetsm">注意：仅当您的<code>CnosDB</code>离线（<code>CnosDB</code>服务未运行） 时才使用<code>deletetsm</code>。</a></h3>
<h3 id="语法-2"><a class="header" href="#语法-2">语法</a></h3>
<pre><code>cnosdb_inspect deletetsm --measurement &lt;measurement_name&gt; [ arguments ] &lt;path&gt;
</code></pre>
<p><code>&lt;path&gt;</code></p>
<p>文件的路径<code>.tsm</code>，默认位于<code>data</code>目录中。</p>
<p>指定路径时，通配符 (<code>*</code>) 可以替换一个或多个字符。</p>
<h3 id="选项"><a class="header" href="#选项">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>--measurement</code></p>
<p>要从 TSM 文件中删除的<code>measurement</code>的名称。</p>
<p><code>[ --sanitize]</code></p>
<p>标记以删除包含不可打印的 <code>Unicode </code>字符的所有键。</p>
<p><code>[--v]</code></p>
<p>标记以启用详细日志记录。</p>
<h3 id="例子-1"><a class="header" href="#例子-1">例子</a></h3>
<p>从单个<code>shard</code>中删除一个<code>measurement</code></p>
<pre><code>./cnosdb_inspect deletetsm --sanitize /cnosdb/data/location/autogen/1384/*.tsm
</code></pre>
<p>从数据库中的所有<code>shard</code>中删除<code>measurement</code></p>
<pre><code>./cnosdb_inspect deletetsm --sanitize /cnosdb/data/location/autogen/*/*.tsm
</code></pre>
<h2 id="dumptsm"><a class="header" href="#dumptsm"><code>dumptsm</code></a></h2>
<h3 id="cnosdb_inspect-dumptsm"><a class="header" href="#cnosdb_inspect-dumptsm"><code>cnosdb_inspect dumptsm</code></a></h3>
<p>转储<code>tsm1</code>文件的底层细节，包括<code>TSM</code>文件和<code>WAL</code>文件</p>
<h3 id="语法-3"><a class="header" href="#语法-3">语法</a></h3>
<p><code>cnosdb_inspect dumptsm [ options ] &lt;path&gt;</code></p>
<p><code>&lt;path&gt;</code></p>
<p>文件的路径<code>.tsm</code>，默认位于<code>data</code>目录中。</p>
<h3 id="选项-1"><a class="header" href="#选项-1">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ --index ]</code></p>
<p>用于转储原始索引数据的标志。默认值为<code>false</code>。</p>
<p><code>[ --blocks ]</code></p>
<p>转储原始块数据的标志。默认值为<code>false</code>。</p>
<p><code>[ --all ]</code></p>
<p>标志转储所有数据。注意：这可能会打印很多信息。默认值为<code>false</code>。</p>
<p><code>[ --filter-key &lt;key_name&gt; ]</code></p>
<p>仅显示与此键子字符串匹配的索引数据和块数据。默认值为<code>&quot;&quot;</code>。</p>
<h2 id="dumptsi"><a class="header" href="#dumptsi"><code>dumptsi</code></a></h2>
<h3 id="cnosdb_inspect-dumptsi"><a class="header" href="#cnosdb_inspect-dumptsi"><code>cnosdb_inspect dumptsi</code></a></h3>
<p>转储有关<code>TSI</code>文件的底层信息，包括<code>.tsl</code>日志文件和<code>.tsi</code>文件</p>
<h3 id="语法-4"><a class="header" href="#语法-4">语法</a></h3>
<p><code>cnosdb_inspect dumptsi [ options ] &lt;index_path&gt;</code></p>
<p>若未指定任何选项，则会为每个文件提供汇总信息。</p>
<h3 id="选项-2"><a class="header" href="#选项-2">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>--series-file &lt;series_path&gt;</code></p>
<p><code>_series</code>数据库目录下的目录路径<code>data</code>。必须要有。</p>
<p><code>[ --series]</code></p>
<p>转储原始系列数据。</p>
<p><code>[ --measurements]</code></p>
<p>转储原始测量数据。
<code> [ --tag-keys]</code></p>
<p>转储原始标签键。</p>
<p><code>[ --tag-values]</code></p>
<p>转储原始标签值。</p>
<p><code>[ --tag-value-series]</code></p>
<p>为每个标签值转储原始系列。</p>
<p><code>[ --measurement-filter &lt;regular_expression&gt;]</code></p>
<p>通过测量正则表达式过滤数据。</p>
<p><code>[ --tag-key-filter &lt;regular_expression&gt;]</code></p>
<p>按标签键正则表达式过滤数据。</p>
<p><code>[ --tag-value-filter &lt;regular_expresssion&gt;]</code></p>
<p>按标签值正则表达式过滤数据。</p>
<h3 id="例子-2"><a class="header" href="#例子-2">例子</a></h3>
<p>指定_series和index目录的路径</p>
<p><code>cnsodb_inspect dumptsi --series-file /path/to/db/_series /path/to/index</code></p>
<p>指定_series目录和index文件的路径</p>
<p><code>cnosdb_inspect dumptsi --series-file /path/to/db/_series /path/to/index/file0</code></p>
<p>指定_series目录和多个index文件的路径</p>
<pre><code>cnosdb_inspect dumptsi --series-file /path/to/db/_series /path/to/index/file0 /path/to/index/file1 ...
</code></pre>
<h2 id="buildtsi"><a class="header" href="#buildtsi"><code>buildtsi</code></a></h2>
<h3 id="cnosdb_inspect-buildtsi"><a class="header" href="#cnosdb_inspect-buildtsi"><code>cnosdb_inspect buildtsi</code></a></h3>
<p>构建基于 TSI（时间序列索引）磁盘的分片索引文件和关联的序列文件。索引被写入一个临时位置直到完成，然后移动到一个永久位置。如果发生错误，则此操作将回退到原始内存索引。</p>
<h3 id="注意-仅适用于离线转换-启用-tsi-后新分片使用-tsi-索引现有分片继续作为基于-tsm-的分片直到离线转换"><a class="header" href="#注意-仅适用于离线转换-启用-tsi-后新分片使用-tsi-索引现有分片继续作为基于-tsm-的分片直到离线转换">注意： 仅适用于离线转换。 启用 TSI 后，新分片使用 TSI 索引。现有分片继续作为基于 TSM 的分片，直到离线转换。</a></h3>
<h3 id="语法-5"><a class="header" href="#语法-5">语法</a></h3>
<pre><code>cnosdb_inspect buildtsi [ options ] -datadir &lt;data_dir&gt; -waldir &lt;wal_dir&gt; [ options ]
</code></pre>
<h4 id="注意将buildtsi命令与您要运行数据库的用户帐户一起使用或者在运行命令后确保权限匹配"><a class="header" href="#注意将buildtsi命令与您要运行数据库的用户帐户一起使用或者在运行命令后确保权限匹配">注意：将buildtsi命令与您要运行数据库的用户帐户一起使用，或者在运行命令后确保权限匹配。</a></h4>
<h3 id="选项-3"><a class="header" href="#选项-3">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ --batch-size ]</code></p>
<p>写入索引的批次大小。默认值为<code>10000</code>。设置此值会对性能和堆大小产生不利影响。</p>
<p><code>[ --compact-series-file]</code></p>
<p>压缩现有<code>series</code>文件，包括离线<code>series</code>。迭代每个<code>segment</code>中的<code>series</code>并将<code>Index</code>中的<code>non-tombstoned series</code>重写到旁边的新 <code>.tmp </code>文件。转换所有<code>segment</code>后，临时文件将覆盖原始段。</p>
<p><code>[ --concurrency ]</code></p>
<p>专用于分片索引的工作人员数量。默认值为<code>GOMAXPROCS</code>。</p>
<p><code>[ --database &lt;db_name&gt; ]</code></p>
<p>数据库的名称。</p>
<p><code>--datadir &lt;data_dir&gt;</code></p>
<p><code>data</code>的文件路径。</p>
<p><code>[ --max-cache-size ]</code></p>
<p>开始拒绝写入之前缓存的最大大小。此值覆盖的配置设置 <code>[data] cache-max-memory-size</code>。默认值为<code>1073741824</code>。</p>
<p><code>[ --max-log-file-size ]</code></p>
<p>日志文件的最大大小。默认值为<code>1048576</code>。</p>
<p><code>[ --retention &lt;rp_name&gt; ]</code></p>
<p>保留策略的名称。</p>
<p><code>[ --shard &lt;shard_ID&gt; ]</code></p>
<p>分片的标识符。</p>
<p><code>[ --v ]</code></p>
<p>以详细模式启用输出的标志。
<code> --waldir &lt;wal_dir&gt;</code></p>
<p><code>WAL</code>（预写日志）文件的目录。</p>
<h3 id="例子-3"><a class="header" href="#例子-3">例子</a></h3>
<p>转换节点上的所有<code>shard</code></p>
<p><code>cnosdb_inspect buildtsi --datadir ~/.cnosdb/data --waldir ~/.cnosdb/wal</code></p>
<p>转换数据库的所有<code>shard</code></p>
<p><code>cnosdb_inspect buildtsi --database mydb --datadir ~/.cnosdb/data --waldir ~/.cnosdb/wal</code></p>
<p>转换特定<code>shard</code></p>
<pre><code>cnodb_inspect buildtsi --database stress -shard 1 --datadir ~/.cnosdb/data --waldir ~/.cnosdb/wal
</code></pre>
<h2 id="dumptsmwal"><a class="header" href="#dumptsmwal"><code>dumptsmwal</code></a></h2>
<h3 id="cnosdb_inspect-dumptsmwal"><a class="header" href="#cnosdb_inspect-dumptsmwal"><code>cnosdb_inspect dumptsmwal</code></a></h3>
<p>仅转储一个或多个 WAL ( <code>.wal</code>) 文件中的所有条目，并排除 TSM ( <code>.tsm</code>) 文件</p>
<h3 id="语法-6"><a class="header" href="#语法-6">语法</a></h3>
<pre><code>cnosdb_inspect dumptsmwal [ options ] &lt;wal_dir&gt;
</code></pre>
<h3 id="选项-4"><a class="header" href="#选项-4">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ --show-duplicates]</code></p>
<p>标记以显示具有重复或无序<code>timestamp</code>的<code>key</code>。如果用户使用客户端设置的<code>timestamp</code>写入点，则可以写入具有相同<code>timestamp</code>（或具有时间降序<code>timestamp</code>）的多个点。</p>
<h2 id="report-disk"><a class="header" href="#report-disk"><code>report-disk</code></a></h2>
<h3 id="cnosdb_inspect-report"><a class="header" href="#cnosdb_inspect-report"><code>cnosdb_inspect report</code></a></h3>
<p>使用<code>report-disk</code>命令查看指定目录下的<code>TSM</code>文件的<code>shards</code>和<code>measurements</code>的磁盘使用情况。</p>
<h3 id="语法-7"><a class="header" href="#语法-7">语法</a></h3>
<p><code>cnosdb_inspect report-disk [ options ]</code></p>
<h3 id="选项-5"><a class="header" href="#选项-5">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ --detailed]</code></p>
<p>包括<code>flag</code>来报告<code>measurements</code>的磁盘使用情况。</p>
<h2 id="report"><a class="header" href="#report"><code>report</code></a></h2>
<h3 id="cnosdb_inspect-report-1"><a class="header" href="#cnosdb_inspect-report-1"><code>cnosdb_inspect report</code></a></h3>
<p>显示所有<code>shard</code>的系列元数据。默认位置是<code>$HOME/.cnosdb</code>。</p>
<h3 id="语法-8"><a class="header" href="#语法-8">语法</a></h3>
<p><code>cnosdb_inspect report [ options ]</code></p>
<h3 id="选项-6"><a class="header" href="#选项-6">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ --pattern &quot;&lt;regular expression/wildcard&gt;&quot;]</code></p>
<p>匹配包含文件的正则表达式或通配符模式。默认值为<code>&quot;&quot;</code>。</p>
<p><code>[ --detailed]</code></p>
<p>报告详细基数估计的标志。默认值为<code>false</code>。</p>
<p><code>[ --exact]</code></p>
<p>报告确切基数而不是估计值的标志。默认值为<code>false</code>。注意：这会占用大量内存。</p>
<h2 id="reporttsi"><a class="header" href="#reporttsi"><code>reporttsi</code></a></h2>
<h3 id="cnosdb_inspect-reporttsi"><a class="header" href="#cnosdb_inspect-reporttsi"><code>cnosdb_inspect reporttsi</code></a></h3>
<ul>
<li>计算数据库中的总精确<code>series</code>基数。</li>
<li>通过<code>measurements</code>分割<code>series</code>，并发出这些<code>series</code>值。</li>
<li>为数据库中的每个<code>shard</code>发出总的精确基数。</li>
<li>每个<code>shard</code>的<code>segment</code>是<code>shard</code>中每个<code>measurement</code>的确切基数。</li>
<li>可以选择将每个<code>shard</code>中的结果限制为“前 n 个”。</li>
</ul>
<h3 id="语法-9"><a class="header" href="#语法-9">语法</a></h3>
<p><code>cnosdb_inspect reporttsi --db-path &lt;path-to-db&gt; [ options ]</code></p>
<h3 id="选项-7"><a class="header" href="#选项-7">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>-db-path &lt;path-to-db&gt;</code></p>
<p>数据库的路径。</p>
<p><code>[ -top &lt;n&gt;]</code></p>
<p>将结果限制为每个<code>shard</code>中指定的数字。</p>
<h2 id="verify"><a class="header" href="#verify"><code>verify</code></a></h2>
<h3 id="cnosdb_inspect-verify"><a class="header" href="#cnosdb_inspect-verify"><code>cnosdb_inspect verify</code></a></h3>
<p>验证 <code>TSM</code>文件的完整性。</p>
<h3 id="语法-10"><a class="header" href="#语法-10">语法</a></h3>
<p><code>cnosdb_inspect verify [ options ]</code></p>
<h3 id="选项-8"><a class="header" href="#选项-8">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>--dir &lt;storage_root&gt;</code>
存储根目录的路径。默认值为&quot;<code>/root/.cnosdb</code>&quot;.</p>
<h2 id="verify-seriesfile"><a class="header" href="#verify-seriesfile"><code>verify-seriesfile</code></a></h2>
<h3 id="cnosdb_inspect-verify-seriesfile"><a class="header" href="#cnosdb_inspect-verify-seriesfile"><code>cnosdb_inspect verify-seriesfile</code></a></h3>
<p>验证 <code>series</code>文件的完整性。</p>
<h3 id="语法-11"><a class="header" href="#语法-11">语法</a></h3>
<p><code>cnosdb_inspect verify-series [ options ]</code></p>
<h3 id="选项-9"><a class="header" href="#选项-9">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ --c &lt;number&gt;]</code></p>
<p>指定要为此命令运行的并发工作人员的数量。默认值等于 GOMAXPROCS 的值。如果性能受到不利影响，您可以设置一个较低的值。</p>
<p><code>[ --dir &lt;path&gt;]</code></p>
<p>指定根数据路径。默认为<code>~/.cnosdb/data</code>.</p>
<p><code>[ --db &lt;db_name&gt;]</code></p>
<p>将验证系列文件限制为数据目录中的指定数据库。</p>
<p><code>[ --series-file &lt;path&gt;]</code></p>
<p>特定系列文件的路径；覆盖-<code>db</code>和<code>-dir</code>.</p>
<p><code>[ --v]</code></p>
<p>启用详细日志记录。</p>
<h2 id="verify-tombstone"><a class="header" href="#verify-tombstone"><code>verify-tombstone</code></a></h2>
<h3 id="cnosdb_inspect-verify-tombstone"><a class="header" href="#cnosdb_inspect-verify-tombstone"><code>cnosdb_inspect verify-tombstone</code></a></h3>
<p>验证 <code>tombstone</code>文件的完整性。</p>
<h3 id="语法-12"><a class="header" href="#语法-12">语法</a></h3>
<p><code>cnosdb_inspect verify-tombstone [ options ]</code></p>
<h3 id="选项-10"><a class="header" href="#选项-10">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ -dir &lt;path&gt;]</code></p>
<p>指定根数据路径。默认为<code>~/.cnosdb/data</code>. 该路径可以是任意的，例如，它不需要是<code>CnosDB</code>数据目录。</p>
<p><code>[ --v]</code></p>
<p>启用详细日志记录。确认正在验证文件并每500万条<code>tombstone</code>条目显示进度。</p>
<p><code>[ --vv]</code></p>
<p>启用非常详细的日志记录。显示<code>tombstone</code>文件中每个<code>series key</code>和时间范围。自(1970-01-01T00:00:00Z)以来的时间戳以纳秒为单位显示。</p>
<p><code>[ --vvv]</code></p>
<p>启用非常非常详细的日志记录。显示<code>tombstone</code>文件中每个<code>series key</code>和时间范围。时间戳以<code>RFC3339</code>格式显示，精度为纳秒。</p>
<h2 id="export"><a class="header" href="#export"><code>export</code></a></h2>
<h3 id="cnosdb_inspect-export"><a class="header" href="#cnosdb_inspect-export"><code>cnosdb_inspect export</code></a></h3>
<p>以 <code>CnosDB</code> 线路协议数据格式导出所有 <code>TSM</code> 文件。为所有 <code>WAL</code> 文件写入数据<code>_internal/monitor</code>。可以使用<code>cnosdb</code>命令导入此输出文件。</p>
<h3 id="语法-13"><a class="header" href="#语法-13">语法</a></h3>
<p><code>cnosdb_inspect export [ options ]</code></p>
<h3 id="选项-11"><a class="header" href="#选项-11">选项</a></h3>
<p>可选参数在括号中</p>
<p><code>[ --compress]</code></p>
<p>使用 gzip 压缩来压缩输出的标志。默认值为<code>false</code>。</p>
<p><code>[ --database &lt;db_name&gt;]</code></p>
<p>要导出的数据库的名称。默认值为<code>&quot;&quot;</code>.</p>
<p><code>--datadir &lt;data_dir&gt;</code></p>
<p>目录的路径<code>data</code>。默认值为&quot;<code>$HOME/.cnosdb/data</code>&quot;。</p>
<p><code>[ --end &lt;timestamp&gt;]</code></p>
<p>时间范围结束的时间戳。必须是<code>RFC3339 </code>格式。</p>
<p>RFC3339 需要非常具体的格式。例如，要指示没有时区偏移 (UTC+0)，您必须在秒后包含 Z 或 +00:00。有效 RFC3339 格式的示例包括：</p>
<h3 id="无偏移"><a class="header" href="#无偏移"><code>无偏移</code></a></h3>
<blockquote>
<p>YYYY-MM-DDTHH:MM:SS+00:00</p>
<p>YYYY-MM-DDTHH:MM:SSZ</p>
<p>YYYY-MM-DDTHH:MM:SS.nnnnnnZ (fractional seconds (.nnnnnn) are optional)</p>
</blockquote>
<h3 id="带偏移"><a class="header" href="#带偏移"><code>带偏移</code></a></h3>
<blockquote>
<p>YYYY-MM-DDTHH:MM:SS-08:00</p>
<p>YYYY-MM-DDTHH:MM:SS+07:00</p>
</blockquote>
<p><code>[ --out &lt;export_dir&gt;]</code>
导出文件的位置。默认值为&quot;<code>$HOME/.cnosdb/export</code>&quot;。</p>
<p><code>[ --retention &lt;rp_name&gt; ]</code>
要导出的保留策略的名称。默认值为<code>&quot;&quot;</code>。</p>
<p><code>[ --start &lt;timestamp&gt;]</code>
时间范围开始的时间戳。时间戳字符串必须采用<code>RFC3339 </code>格式。</p>
<p><code>[ --waldir &lt;wal_dir&gt;]</code>
<code>WAL</code>目录的路径。默认值为&quot;<code>$HOME/.cnosdb/wal</code>&quot;。</p>
<h3 id="例子-4"><a class="header" href="#例子-4">例子</a></h3>
<p>导出所有数据库并压缩输出</p>
<p><code>cnosdb_inspect export --compress</code></p>
<p>从特定数据库和保留策略中导出数据</p>
<p><code>cnosdb_inspect export --database mydb -retention autogen</code></p>
<p>输出文件</p>
<pre><code>#DDL
CREATE DATABASE MY_DB_NAME

CREATE RETENTION POLICY autogen ON MY_DB_NAME DURATION inf REPLICATION 1

# DML

# CONTEXT-DATABASE:MY_DB_NAME

# CONTEXT-RETENTION-POLICY:autogen

randset value=97.9296104805 1439856000000000000

randset value=25.3849066842 1439856100000000000

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="语法参考手册"><a class="header" href="#语法参考手册">语法参考手册</a></h1>
<ul>
<li><a href="content/cnosdb/latest/cnosql/./cnosql_sample.html">示例数据</a></li>
<li><a href="content/cnosdb/latest/cnosql/./cnosql_syntax.html">数据查询</a></li>
<li><a href="content/cnosdb/latest/cnosql/./cnosql_management.html">数据库管理和模式查询</a></li>
<li><a href="content/cnosdb/latest/cnosql/./cnosql_function.html">函数</a></li>
<li><a href="content/cnosdb/latest/cnosql/./continuous_queries.html">连续查询</a></li>
<li><a href="content/cnosdb/latest/cnosql/./math_operators.html">数学运算符</a></li>
<li><a href="content/cnosdb/latest/cnosql/./cnosql_spect.html">语法约定</a></li>
<li><a href="content/cnosdb/latest/cnosql/./other.html">其他</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h2 id="示例数据"><a class="header" href="#示例数据">示例数据</a></h2>
<p>为了进一步学习CnosQL，本节将提供示例数据供您下载，并教您如何将数据导入数据库。后面章节中引用的数据源都来自此示例数据。</p>
<h3 id="下载数据"><a class="header" href="#下载数据">下载数据</a></h3>
<p>执行以下命令将在本地生成一个名称为<code>oceanic_station</code>的<a href="content/cnosdb/latest/cnosql/../protocol/line_protocol.html">Line Protocol</a>格式的数据文件</p>
<pre><code class="language-shell">wget https://gist.githubusercontent.com/cnos-db/9839ac8e78e45b0ee50d2803de4acfd8/raw/818b19d0dd3c80befe636b60ee569451ac2ca4b1/oceanic_station
</code></pre>
<h3 id="导入数据"><a class="header" href="#导入数据">导入数据</a></h3>
<p>通过命令行将数据导入CnosDB</p>
<pre><code class="language-shell">cnosdb-cli import --path oceanic_station
</code></pre>
<p>会在CnosDB中生成一个名称为<code>oceanic_station</code>的数据库</p>
<pre><code class="language-shell">&gt; SHOW DATABASES
name: databases
name
----
oceanic_station
</code></pre>
<h3 id="数据来源说明"><a class="header" href="#数据来源说明">数据来源说明</a></h3>
<p>示例数据（oceanic_station）是<a href="http://mds.nmdis.org.cn/pages/dataViewDetail.html?dataSetId=4-1">中国海洋观测站</a>的公开数据，数据包括在2022年1月14日到4月15日期间，在两个站点XiaoMaiDao和LianYunGang上收集到的海洋观测值，这些数据每3分钟收集一次，总共87360条观测值。 请注意，air、sea、wind中包含虚拟数据，这些数据用于阐述CnosDB中的查询功能。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosql-数据查询"><a class="header" href="#cnosql-数据查询">CnosQL 数据查询</a></h1>
<p>CnosDB查询语法类似于SQL，使用SELECT语句从特定的measurement中查询数据，但又不完全一样；当前所有支持查询结构如下。</p>
<h2 id="语法结构"><a class="header" href="#语法结构">语法结构</a></h2>
<pre><code class="language-sql">
SELECT &lt;field_key&gt;[,
         &lt;field_key&gt;,
         &lt;tag_key&gt;,
         &lt;function&gt;(&lt;field_key&gt;)
FROM &lt;measurement_name&gt;[,&lt;measurement_name&gt;]
WHERE &lt;conditional_expression&gt; [(AND|OR) &lt;conditional_expression&gt; [&lt;time_range&gt;...]]
GROUP BY  [* | &lt;tag_key&gt;[,&lt;tag_key],time(&lt;time_interval&gt;,&lt;offset_interval&gt;)]
ORDER BY  time DESC LIMIT N1 OFFSET N2 SLIMIT N3 SOFFSET N4
</code></pre>
<h2 id="元素说明"><a class="header" href="#元素说明">元素说明</a></h2>
<table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody>
<tr><td>SELECT</td><td>SELECT查询语句</td></tr>
<tr><td>field_key</td><td>field key</td></tr>
<tr><td>tag_key</td><td>tag key</td></tr>
<tr><td>FROM</td><td>查询数据来源，指明来自哪个measurement</td></tr>
<tr><td>conditional_expression</td><td>查询条件，查询结果中只会包含满足条件数据</td></tr>
<tr><td>function</td><td>内置函数，详细用法可以参考函数一节</td></tr>
<tr><td>WHERE</td><td>WHERE条件查询字句，查询结果只包含满足条件数据</td></tr>
<tr><td>time_range</td><td>时间范围</td></tr>
<tr><td>time_interval</td><td>时间间隔粒度</td></tr>
<tr><td>GROUP_BY</td><td>GROUP BY子句，用于分组查询</td></tr>
<tr><td>ORDER_BY</td><td>ORDER BY 子句，用于对返回结果数据进行排序</td></tr>
<tr><td>LIMIT N</td><td>从指定的measurement中返回前N个数据点</td></tr>
<tr><td>SLIMIT N</td><td>返回指定measurement的前N个series中的每一个点</td></tr>
<tr><td>OFFSET N</td><td>从查询结果中返回分页的N个数据点</td></tr>
<tr><td>SOFFSET N</td><td>从查询结果中返回分页的N个series</td></tr>
</tbody></table>
<h3 id="例1基本的select查询用法"><a class="header" href="#例1基本的select查询用法">例1：基本的SELECT查询用法</a></h3>
<p>select查询的基本用法</p>
<pre><code class="language-sql">&gt; select * from air
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-08-31T16:00:00Z 78       LianYunGang 63          71
2021-08-31T16:00:00Z 75       XiaoMaiDao  79          68
2021-08-31T16:03:00Z 50       LianYunGang 52          53
2021-08-31T16:03:00Z 73       XiaoMaiDao  70          55
2021-08-31T16:06:00Z 60       LianYunGang 52          75
2021-08-31T16:06:00Z 58       XiaoMaiDao  77          79
2021-08-31T16:09:00Z 58       LianYunGang 73          65
2021-08-31T16:09:00Z 63       XiaoMaiDao  54          70
2021-08-31T16:12:00Z 50       LianYunGang 73          69
2021-08-31T16:12:00Z 73       XiaoMaiDao  77          63
......

</code></pre>
<p>该查询从air这个measurement中查询所有tag、 field并返回</p>
<h4 id="其他用法及其注意事项"><a class="header" href="#其他用法及其注意事项">其他用法及其注意事项</a></h4>
<ul>
<li>*::field用于标识所有field字段：select *::field from air limit 10</li>
<li>可以显示指定字段名称：select temperature,station from air limit 10</li>
<li>可以进行基本运算：select visibility*100 from air limit 10</li>
<li>查询字段名不可以只含tag，否则无数据返回</li>
</ul>
<h3 id="例2where条件查询"><a class="header" href="#例2where条件查询">例2：WHERE条件查询</a></h3>
<p>WHERE条件用于对返回数据进行过滤，只返回满足条件的数据</p>
<pre><code class="language-sql">
&gt; select * from air where visibility &gt; 70
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-08-31T16:00:00Z 78       LianYunGang 63          71
2021-08-31T16:06:00Z 58       XiaoMaiDao  77          79
2021-08-31T16:06:00Z 60       LianYunGang 52          75
2021-08-31T16:15:00Z 72       LianYunGang 71          80
2021-08-31T16:18:00Z 60       LianYunGang 52          76
2021-08-31T16:21:00Z 72       XiaoMaiDao  79          72
2021-08-31T16:24:00Z 59       LianYunGang 55          76
2021-08-31T16:27:00Z 78       LianYunGang 59          78
2021-08-31T16:30:00Z 53       XiaoMaiDao  57          74
2021-08-31T16:33:00Z 60       XiaoMaiDao  52          79
......

</code></pre>
<p>查询返回数据要求： visibility &gt; 70</p>
<h4 id="其他用法及其注意事项-1"><a class="header" href="#其他用法及其注意事项-1">其他用法及其注意事项</a></h4>
<ul>
<li>条件可以有多个用AND、OR拼接</li>
<li>运算符支持 =、&gt;、 &lt;、 &gt;=、 &lt;= 、!= </li>
</ul>
<h3 id="例3-group-by分组用法"><a class="header" href="#例3-group-by分组用法">例3: GROUP BY分组用法</a></h3>
<p>GROUP BY用于数据分组查询</p>
<pre><code class="language-sql">
&gt; select mean(temperature) from air  group by station
name: air
tags: station=LianYunGang
time                 mean
----                 ----
1970-01-01T00:00:00Z 64.97175340724525

name: air
tags: station=XiaoMaiDao
time                 mean
----                 ----
1970-01-01T00:00:00Z 64.92691194124708

</code></pre>
<p>上面查询根据station进行分组，求取temperature的平均值，用到了mean平均值函数。</p>
<h4 id="其他用法及其注意事项-2"><a class="header" href="#其他用法及其注意事项-2">其他用法及其注意事项</a></h4>
<ul>
<li>分组字段可以根据多个字段进行，用逗号隔开</li>
<li>根据时间分组time(30m)：30分钟一个分组， time(1d)：1天一个分组</li>
</ul>
<h3 id="例4-into子句用法"><a class="header" href="#例4-into子句用法">例4: INTO子句用法</a></h3>
<p>INTO子句用于将查询的结果写入到一个measurement中</p>
<pre><code class="language-sql">
&gt; select mean(temperature) into temp_result from air  group by station
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2
&gt; 
&gt; select * from temp_result
name: temp_result
time                 mean              station
----                 ----              -------
1970-01-01T00:00:00Z 64.97175340724525 LianYunGang
1970-01-01T00:00:00Z 64.92691194124708 XiaoMaiDao

</code></pre>
<p>上面例子将分组以后查询结果写入一个名字为temp_result的新measurement中。</p>
<h4 id="其他用法及其注意事项-3"><a class="header" href="#其他用法及其注意事项-3">其他用法及其注意事项</a></h4>
<ul>
<li>可以使用select into语法重命名measurement，移动数据到其他databases等。</li>
<li>INTO子句也可以写入一个已经存在的measurement</li>
</ul>
<h3 id="例5-order-by子句用法"><a class="header" href="#例5-order-by子句用法">例5: ORDER BY子句用法</a></h3>
<p>ORDER BY用于对返回结果进行排序</p>
<pre><code class="language-sql">
&gt; select * from air  order by time desc
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-09-30T04:00:00Z 52       XiaoMaiDao  59          78
2021-09-30T04:00:00Z 65       LianYunGang 50          76
2021-09-30T03:57:00Z 65       XiaoMaiDao  76          75
2021-09-30T03:57:00Z 57       LianYunGang 70          58
2021-09-30T03:54:00Z 51       XiaoMaiDao  69          69
2021-09-30T03:54:00Z 53       LianYunGang 79          60
2021-09-30T03:51:00Z 59       XiaoMaiDao  55          69
2021-09-30T03:51:00Z 69       LianYunGang 73          69
2021-09-30T03:48:00Z 79       XiaoMaiDao  77          69
2021-09-30T03:48:00Z 50       LianYunGang 57          52
......

</code></pre>
<p>上面例子按照时间先新后旧排序返回数据</p>
<h4 id="其他用法及其注意事项-4"><a class="header" href="#其他用法及其注意事项-4">其他用法及其注意事项</a></h4>
<ul>
<li>系统默认返回数据按照先旧后新，如若需要先新后旧可以使用：order by time desc</li>
<li>只支持按照time字段排序，不支持按照其他字段排序</li>
</ul>
<h3 id="例6-limit-slimit子句用法"><a class="header" href="#例6-limit-slimit子句用法">例6: LIMIT SLIMIT子句用法</a></h3>
<p>限制返回的数据量</p>
<pre><code class="language-sql">
&gt; select * from air group by * LIMIT 5 SLIMIT 1
name: air
tags: station=LianYunGang
time                 pressure temperature visibility
----                 -------- ----------- ----------
2021-08-31T16:00:00Z 78       63          71
2021-08-31T16:03:00Z 50       52          53
2021-08-31T16:06:00Z 60       52          75
2021-08-31T16:09:00Z 58       73          65
2021-08-31T16:12:00Z 50       73          69
&gt; 
&gt; select * from air group by * LIMIT 5 SLIMIT 2
name: air
tags: station=LianYunGang
time                 pressure temperature visibility
----                 -------- ----------- ----------
2021-08-31T16:00:00Z 78       63          71
2021-08-31T16:03:00Z 50       52          53
2021-08-31T16:06:00Z 60       52          75
2021-08-31T16:09:00Z 58       73          65
2021-08-31T16:12:00Z 50       73          69

name: air
tags: station=XiaoMaiDao
time                 pressure temperature visibility
----                 -------- ----------- ----------
2021-08-31T16:00:00Z 75       79          68
2021-08-31T16:03:00Z 73       70          55
2021-08-31T16:06:00Z 58       77          79
2021-08-31T16:09:00Z 63       54          70
2021-08-31T16:12:00Z 73       77          63

</code></pre>
<p>LIMIT、SLIMIT都是限制返回的数据数量，LIMIT用于控制返回的points的数量，SLIMIT用于控制返回的series数量</p>
<h4 id="其他用法及其注意事项-5"><a class="header" href="#其他用法及其注意事项-5">其他用法及其注意事项</a></h4>
<ul>
<li>LIMIT 与SLIMIT 既可以单独使用，也可以一起使用</li>
<li>一起使用时，表示的意思是查询指定measurement前N个series的前N个point</li>
<li>LIMIT 与SLIMIT 一起使用时，sql中必须包含group by *</li>
</ul>
<h3 id="例7-offset-soffset子句用法"><a class="header" href="#例7-offset-soffset子句用法">例7: OFFSET SOFFSET子句用法</a></h3>
<p>OFFSET SOFFSET用于分页查询</p>
<pre><code class="language-sql">
&gt; select * from air LIMIT 10
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-08-31T16:00:00Z 78       LianYunGang 63          71
2021-08-31T16:00:00Z 75       XiaoMaiDao  79          68
2021-08-31T16:03:00Z 50       LianYunGang 52          53
2021-08-31T16:03:00Z 73       XiaoMaiDao  70          55
2021-08-31T16:06:00Z 60       LianYunGang 52          75
2021-08-31T16:06:00Z 58       XiaoMaiDao  77          79
2021-08-31T16:09:00Z 58       LianYunGang 73          65
2021-08-31T16:09:00Z 63       XiaoMaiDao  54          70
2021-08-31T16:12:00Z 50       LianYunGang 73          69
2021-08-31T16:12:00Z 73       XiaoMaiDao  77          63
&gt;
&gt; select * from air LIMIT 3 offset 5
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-08-31T16:06:00Z 58       XiaoMaiDao  77          79
2021-08-31T16:09:00Z 58       LianYunGang 73          65
2021-08-31T16:09:00Z 63       XiaoMaiDao  54          70
</code></pre>
<p>上面例子中LIMIT 3控制返回数据条目为3条，OFFSET 5进行分页过滤掉前面5条</p>
<h4 id="其他用法及其注意事项-6"><a class="header" href="#其他用法及其注意事项-6">其他用法及其注意事项</a></h4>
<ul>
<li>SOFFSET N从查询结果中返回分页的N个series</li>
<li>OFFSET用于对point分页，SOFFSET是对series分页</li>
<li>通常OFFSET与LIMIT配合使用，SOFFSET与SLIMIT配合使用</li>
<li>两者可以一起使用如：select * from air group by * LIMIT 3 OFFSET 5 SLIMIT 1 SOFFSET 1</li>
</ul>
<h3 id="例8-正则表达式"><a class="header" href="#例8-正则表达式">例8: 正则表达式</a></h3>
<p>正则表达式前后用斜杠/引起来，并且使用Golang正则表达式语法</p>
<pre><code class="language-sql">
&gt; select /p/ from /ai/ where station =~ /Lian/
name: air
time                 pressure temperature
----                 -------- -----------
2021-08-31T16:00:00Z 78       63
2021-08-31T16:03:00Z 50       52
2021-08-31T16:06:00Z 60       52
2021-08-31T16:09:00Z 58       73
2021-08-31T16:12:00Z 50       73
2021-08-31T16:15:00Z 72       71
2021-08-31T16:18:00Z 60       52
2021-08-31T16:21:00Z 74       79
2021-08-31T16:24:00Z 59       55
2021-08-31T16:27:00Z 78       59
......

</code></pre>
<p>上面例子筛选出含有p字符的字段名字，measurement中含有ai字符串，station字段包含字段Lian</p>
<h4 id="其他用法及其注意事项-7"><a class="header" href="#其他用法及其注意事项-7">其他用法及其注意事项</a></h4>
<ul>
<li>支持如下场景的正则表达式：SELECT中的field key和tag key、FROM中的measurement、WHERE中的tag value和字符串类型的field value、GROUP BY中的tag key</li>
<li>=~ ：匹配、!~ ：不匹配</li>
</ul>
<h3 id="例9-子查询"><a class="header" href="#例9-子查询">例9: 子查询</a></h3>
<p>子查询是一种嵌套查询，使用子查询将查询结果作为条件应用于其他查询中</p>
<pre><code class="language-sql">
&gt; select sum(mean) from ( select mean(temperature) from air group by station )
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 129.89866534849233

#############################################################
&gt; select mean(temperature) from air group by station
name: air
tags: station=LianYunGang
time                 mean
----                 ----
1970-01-01T00:00:00Z 64.97175340724525

name: air
tags: station=XiaoMaiDao
time                 mean
----                 ----
1970-01-01T00:00:00Z 64.92691194124708
&gt; 

</code></pre>
<p>上面例子根据station分组求取temperature平均值，然后再求和。执行过程是先执行内层子语句，再执行外层语句。</p>
<h4 id="其他用法及其注意事项-8"><a class="header" href="#其他用法及其注意事项-8">其他用法及其注意事项</a></h4>
<ul>
<li>CnosDB支持多层嵌套查询</li>
<li>每个子查询要用小括号()包裹起来</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="数据库管理和模式查询"><a class="header" href="#数据库管理和模式查询">数据库管理和模式查询</a></h1>
<h2 id="show"><a class="header" href="#show">SHOW</a></h2>
<h3 id="show-databases-statement"><a class="header" href="#show-databases-statement">SHOW DATABASES Statement</a></h3>
<p>显示数据库的名称</p>
<h4 id="syntax"><a class="header" href="#syntax">Syntax</a></h4>
<pre><code class="language-sql">SHOW DATABASES
</code></pre>
<h4 id="例1显示数据库"><a class="header" href="#例1显示数据库">例1：显示数据库</a></h4>
<pre><code class="language-sql">&gt; SHOW DATABASES

name: databases
name
----
oceanic_station
</code></pre>
<h3 id="show-retention-policies-statement"><a class="header" href="#show-retention-policies-statement">SHOW RETENTION POLICIES Statement</a></h3>
<p>显示retention policies</p>
<table><thead><tr><th>元素</th><th>说明</th></tr></thead><tbody>
<tr><td>name</td><td>名称</td></tr>
<tr><td>duration</td><td>持续时间</td></tr>
<tr><td>groupDuration</td><td>组持续时间</td></tr>
<tr><td>replicaN</td><td>冗余数（默认是1）</td></tr>
<tr><td>default</td><td>是否是默认的保留策略</td></tr>
</tbody></table>
<h4 id="syntax-1"><a class="header" href="#syntax-1">Syntax</a></h4>
<pre><code class="language-sql">SHOW RETENTION POLICIES
[ON &lt;database_name&gt;]
</code></pre>
<h4 id="例1显示retention-policy"><a class="header" href="#例1显示retention-policy">例1：显示retention policy</a></h4>
<pre><code class="language-sql">&gt; SHOW RETENTION POLICIES ON oceanic_station
name    duration groupDuration replicaN default
----    -------- ------------- -------- -------
autogen 0s       168h0m0s      1        true
</code></pre>
<p>OR</p>
<pre><code class="language-sql">&gt; use oceanic_station
Using database oceanic_station
Using rp autogen
&gt; SHOW RETENTION POLICIES
name    duration groupDuration replicaN default
----    -------- ------------- -------- -------
autogen 0s       168h0m0s      1        true
</code></pre>
<h3 id="show-shards-statement"><a class="header" href="#show-shards-statement">SHOW SHARDS Statement</a></h3>
<p>显示shard相关信息，包括id，所属数据库，retention policy以及所在的shard（相对应的开始时间，结束时间和过期时间）</p>
<h4 id="syntax-2"><a class="header" href="#syntax-2">Syntax</a></h4>
<pre><code class="language-sql">SHOW SHARDS
</code></pre>
<h4 id="例1显示shards"><a class="header" href="#例1显示shards">例1：显示SHARDS</a></h4>
<pre><code class="language-sql">&gt; SHOW SHARDS

name: oceanic_station
id database        rp      shard_group start_time           end_time             expiry_time          owners
-- --------        --      ----------- ----------           --------             -----------          ------
4  oceanic_station autogen 2           2021-08-30T00:00:00Z 2021-09-06T00:00:00Z 2021-09-06T00:00:00Z 0
6  oceanic_station autogen 3           2021-09-06T00:00:00Z 2021-09-13T00:00:00Z 2021-09-13T00:00:00Z 0
8  oceanic_station autogen 4           2021-09-13T00:00:00Z 2021-09-20T00:00:00Z 2021-09-20T00:00:00Z 0
10 oceanic_station autogen 5           2021-09-20T00:00:00Z 2021-09-27T00:00:00Z 2021-09-27T00:00:00Z 0
12 oceanic_station autogen 6           2021-09-27T00:00:00Z 2021-10-04T00:00:00Z 2021-10-04T00:00:00Z 0
</code></pre>
<h3 id="show-series-statement"><a class="header" href="#show-series-statement">SHOW SERIES Statement</a></h3>
<p>显示series</p>
<h4 id="syntax-3"><a class="header" href="#syntax-3">Syntax</a></h4>
<pre><code class="language-sql">SHOW SERIES
[ON &lt;database_name&gt;] 
[FROM_clause] 
[WHERE &lt;tag_key&gt; &lt;operator&gt; [ '&lt;tag_value&gt;' | &lt;regular_expression&gt;]]
[LIMIT_clause] 
[OFFSET_clause]
</code></pre>
<h4 id="例1显示数据库的索引"><a class="header" href="#例1显示数据库的索引">例1：显示数据库的索引</a></h4>
<pre><code class="language-sql">&gt; SHOW SERIES ON oceanic_station
key
---
air,station=LianYunGang
air,station=XiaoMaiDao
sea,station=LianYunGang
sea,station=XiaoMaiDao
wind,station=LianYunGang
wind,station=XiaoMaiDao
</code></pre>
<h4 id="例2附加where条件对返回结果过滤并限制输出条目数量"><a class="header" href="#例2附加where条件对返回结果过滤并限制输出条目数量">例2：附加WHERE条件，对返回结果过滤，并限制输出条目数量</a></h4>
<pre><code class="language-sql">&gt; SHOW SERIES ON oceanic_station FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' LIMIT 1
key
---
air,station=LianYunGang
</code></pre>
<h4 id="例3通过time对返回结果过滤"><a class="header" href="#例3通过time对返回结果过滤">例3：通过time对返回结果过滤</a></h4>
<pre><code class="language-sql">&gt; SHOW SERIES ON oceanic_station WHERE time &lt; now() - 1m
key
---
air,station=LianYunGang
air,station=XiaoMaiDao
sea,station=LianYunGang
sea,station=XiaoMaiDao
wind,station=LianYunGang
wind,station=XiaoMaiDao
</code></pre>
<h3 id="show-measurements-statement"><a class="header" href="#show-measurements-statement">SHOW MEASUREMENTS Statement</a></h3>
<p>显示数据库对应的measurements</p>
<h4 id="syntax-4"><a class="header" href="#syntax-4">Syntax</a></h4>
<pre><code class="language-sql">SHOW MEASUREMENTS 
[ON &lt;database_name&gt;]
[WITH MEASUREMENT &lt;operator&gt; ['&lt;measurement_name&gt;' | &lt;regular_expression&gt;]]
[WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] 
[LIMIT_clause]
[OFFSET_clause]
</code></pre>
<p>用法及注意事项：</p>
<ul>
<li>可用WITH语句附加正则表达式</li>
<li>可用WHERE语句对tag_key操作</li>
<li>可用LIMIT和OFFSET控制输出</li>
</ul>
<h4 id="例1显示measurements"><a class="header" href="#例1显示measurements">例1：显示measurements</a></h4>
<pre><code class="language-sql">&gt; SHOW MEASUREMENTS ON oceanic_station
name: measurements
name
----
air
sea
wind
</code></pre>
<p>OR</p>
<pre><code class="language-sql">&gt; USE oceanic_station
Using database oceanic_station
Using rp autogen
&gt; SHOW MEASUREMENTS
name: measurements
name
----
air
sea
wind
</code></pre>
<h4 id="例2附加正则表达式"><a class="header" href="#例2附加正则表达式">例2：附加正则表达式</a></h4>
<pre><code class="language-sql">&gt; SHOW MEASUREMENTS ON &quot;oceanic_station&quot; WITH MEASUREMENT =~ /air*/
name: measurements
name
----
air
</code></pre>
<h3 id="show-tag-keys-statement"><a class="header" href="#show-tag-keys-statement">SHOW TAG KEYS Statement</a></h3>
<p>显示Tag Keys，Tag Keys类似于MySQL中带索引的字段</p>
<h4 id="syntax-5"><a class="header" href="#syntax-5">Syntax</a></h4>
<pre><code class="language-sql">SHOW TAG KEYS
[ON &lt;database_name&gt;] 
[FROM_clause] 
[WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] 
[LIMIT_clause]
[OFFSET_clause]
</code></pre>
<h4 id="例1显示tag-keys"><a class="header" href="#例1显示tag-keys">例1：显示Tag Keys</a></h4>
<pre><code class="language-sql">&gt; SHOW TAG KEYS ON &quot;oceanic_station&quot;
name: air
tagKey
------
station

name: sea
tagKey
------
station

name: wind
tagKey
------
station
</code></pre>
<p>OR</p>
<pre><code class="language-sql">&gt; USE oceanic_station
Using database oceanic_station
Using rp autogen
&gt; SHOW TAG KEYS
name: air
tagKey
------
station

name: sea
tagKey
------
station

name: wind
tagKey
------
station
</code></pre>
<h4 id="例2显示指定数据库及measurement上的tag-keys"><a class="header" href="#例2显示指定数据库及measurement上的tag-keys">例2：显示指定数据库及measurement上的Tag Keys</a></h4>
<pre><code class="language-sql">&gt; SHOW TAG KEYS ON &quot;oceanic_station&quot; FROM &quot;air&quot; LIMIT 1
name: air
tagKey
------
station
</code></pre>
<h3 id="show-tag-values-statement"><a class="header" href="#show-tag-values-statement">SHOW TAG VALUES Statement</a></h3>
<p>显示Tag Values</p>
<h4 id="syntax-6"><a class="header" href="#syntax-6">Syntax</a></h4>
<pre><code class="language-sql">SHOW TAG VALUES
[ON &lt;database_name&gt;]
[FROM_clause] 
WITH KEY [[&lt;operator&gt; &quot;&lt;tag_key&gt;&quot; | &lt;regular_expression&gt;] | [IN (&quot;&lt;tag_key1&gt;&quot;,&quot;&lt;tag_key2&quot;)]] 
[WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]]
[LIMIT_clause]
[OFFSET_clause]
</code></pre>
<h4 id="例1指定数据库及tag-key显示对应的tag-values"><a class="header" href="#例1指定数据库及tag-key显示对应的tag-values">例1：指定数据库及Tag Key，显示对应的Tag Values</a></h4>
<pre><code class="language-sql">&gt;  SHOW TAG VALUES ON &quot;oceanic_station&quot; WITH KEY = &quot;station&quot;
name: air
key     value
---     -----
station LianYunGang
station XiaoMaiDao

name: sea
key     value
---     -----
station LianYunGang
station XiaoMaiDao

name: wind
key     value
---     -----
station LianYunGang
station XiaoMaiDao
</code></pre>
<h4 id="例2附加正则表达式-1"><a class="header" href="#例2附加正则表达式-1">例2：附加正则表达式</a></h4>
<pre><code class="language-sql">&gt; SHOW TAG VALUES ON &quot;oceanic_station&quot; WITH KEY IN (&quot;station&quot;) WHERE &quot;station&quot; =~ /./ LIMIT 3
name: air
key     value
---     -----
station LianYunGang
station XiaoMaiDao

name: sea
key     value
---     -----
station LianYunGang
station XiaoMaiDao

name: wind
key     value
---     -----
station LianYunGang
station XiaoMaiDao
</code></pre>
<h3 id="show-field-keys-statement"><a class="header" href="#show-field-keys-statement">SHOW FIELD KEYS Statement</a></h3>
<p>显示Field Keys，类似于MySQL中不带索引的字段</p>
<h4 id="syntax-7"><a class="header" href="#syntax-7">Syntax</a></h4>
<pre><code class="language-sql">SHOW FIELD KEYS
[ON &lt;database_name&gt;]
[FROM &lt;measurement_name&gt;]
</code></pre>
<h4 id="例1指定数据库显示field-keys"><a class="header" href="#例1指定数据库显示field-keys">例1：指定数据库，显示Field Keys</a></h4>
<pre><code class="language-sql">&gt; SHOW FIELD KEYS ON &quot;oceanic_station&quot;
name: air
fieldKey    fieldType
--------    ---------
pressure    float
temperature float
visibility  float

name: sea
fieldKey    fieldType
--------    ---------
temperature float

name: wind
fieldKey  fieldType
--------  ---------
direction float
speed     float
</code></pre>
<p>OR</p>
<pre><code class="language-sql">&gt; USE oceanic_station
Using database oceanic_station
Using rp autogen
&gt; SHOW FIELD KEYS
name: air
fieldKey    fieldType
--------    ---------
pressure    float
temperature float
visibility  float

name: sea
fieldKey    fieldType
--------    ---------
temperature float

name: wind
fieldKey  fieldType
--------  ---------
direction float
speed     float
</code></pre>
<h4 id="例2指定measurement"><a class="header" href="#例2指定measurement">例2：指定measurement</a></h4>
<pre><code class="language-sql">&gt; SHOW FIELD KEYS ON &quot;oceanic_station&quot; FROM &quot;sea&quot;
name: sea
fieldKey    fieldType
--------    ---------
temperature float
</code></pre>
<h2 id="delete"><a class="header" href="#delete">DELETE</a></h2>
<h3 id="delete-series-statement"><a class="header" href="#delete-series-statement">DELETE SERIES Statement</a></h3>
<p>从指定的measurement中删除series，可使用Where Clause附加条件</p>
<h4 id="syntax-8"><a class="header" href="#syntax-8">Syntax</a></h4>
<pre><code class="language-sql">DELETE FROM &lt;measurement_name&gt; 
WHERE [&lt;tag_key&gt;='&lt;tag_value&gt;'] | [&lt;time interval&gt;]
</code></pre>
<h4 id="例1删除measurement下所有series"><a class="header" href="#例1删除measurement下所有series">例1：删除measurement下所有series</a></h4>
<pre><code class="language-sql">DELETE FROM &quot;air&quot;
</code></pre>
<h4 id="例2附加where对tag-keys筛选"><a class="header" href="#例2附加where对tag-keys筛选">例2：附加WHERE，对Tag Keys筛选</a></h4>
<pre><code class="language-sql">DELETE FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao'
</code></pre>
<h4 id="例3附加where对时间筛选"><a class="header" href="#例3附加where对时间筛选">例3：附加WHERE，对时间筛选</a></h4>
<pre><code class="language-sql">DELETE WHERE time &lt; '2021-09-01'
</code></pre>
<h2 id="create"><a class="header" href="#create">CREATE</a></h2>
<h3 id="create-database-statement"><a class="header" href="#create-database-statement">CREATE DATABASE Statement</a></h3>
<p>创建数据库，可附带创建retention policy，如果不指定retention policy，则默认使用&quot;autogen&quot;作为retention policy</p>
<h4 id="syntax-9"><a class="header" href="#syntax-9">Syntax</a></h4>
<pre><code class="language-sql">CREATE DATABASE &lt;database_name&gt;
[WITH
[DURATION &lt;duration&gt;] 
[REPLICATION &lt;n&gt;] 
[SHARD DURATION &lt;duration&gt;] 
[NAME &lt;retention-policy-name&gt;]]
</code></pre>
<h4 id="例1创建数据库"><a class="header" href="#例1创建数据库">例1：创建数据库</a></h4>
<pre><code class="language-sql">&gt; CREATE DATABASE &quot;cnos&quot;
</code></pre>
<h4 id="例2附加自定义的retention-policy"><a class="header" href="#例2附加自定义的retention-policy">例2：附加自定义的retention policy</a></h4>
<pre><code class="language-sql">&gt; CREATE DATABASE &quot;cnos&quot; WITH DURATION 1d REPLICATION 1 SHARD DURATION 1h NAME &quot;1d_events&quot;
</code></pre>
<h3 id="create-retention-policy-statement"><a class="header" href="#create-retention-policy-statement">CREATE RETENTION POLICY Statement</a></h3>
<p>创建retention policy，需指定retention policy的名称，duration，replication以及shard duration，最后可指定当前创建的retention policy是否是该数据库默认的retention policy</p>
<h4 id="syntax-10"><a class="header" href="#syntax-10">Syntax</a></h4>
<pre><code class="language-sql">CREATE RETENTION POLICY &lt;retention_policy_name&gt; 
ON &lt;database_name&gt;
DURATION &lt;duration&gt; 
REPLICATION &lt;n&gt; 
[SHARD DURATION &lt;duration&gt;]
[DEFAULT]
</code></pre>
<h4 id="例1创建retention-policy"><a class="header" href="#例1创建retention-policy">例1：创建retention policy</a></h4>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 1d REPLICATION 1
</code></pre>
<h4 id="例2添加default作为数据库默认retention-policy"><a class="header" href="#例2添加default作为数据库默认retention-policy">例2：添加DEFAULT，作为数据库默认retention policy</a></h4>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 23h60m REPLICATION 1 DEFAULT
</code></pre>
<h2 id="drop"><a class="header" href="#drop">DROP</a></h2>
<h3 id="drop-database-statement"><a class="header" href="#drop-database-statement">DROP DATABASE Statement</a></h3>
<p>删除数据库</p>
<h4 id="syntax-11"><a class="header" href="#syntax-11">Syntax</a></h4>
<pre><code class="language-sql">DROP DATABASE &lt;database_name&gt;
</code></pre>
<h4 id="例1删除数据库"><a class="header" href="#例1删除数据库">例1：删除数据库</a></h4>
<pre><code class="language-sql">&gt; DROP DATABASE &quot;oceanic_station&quot;
</code></pre>
<h3 id="drop-series-statement"><a class="header" href="#drop-series-statement">DROP SERIES Statement</a></h3>
<p>删除指定表的索引，可使用Where Clause附加条件</p>
<h4 id="syntax-12"><a class="header" href="#syntax-12">Syntax</a></h4>
<pre><code class="language-sql">DROP SERIES
FROM &lt;measurement_name[,measurement_name]&gt;
WHERE &lt;tag_key&gt;='&lt;tag_value&gt;'
</code></pre>
<h4 id="例1指定measurement删除series"><a class="header" href="#例1指定measurement删除series">例1：指定measurement，删除series</a></h4>
<pre><code class="language-sql">&gt; DROP SERIES FROM &quot;air&quot;
</code></pre>
<h3 id="drop-measurement-statement"><a class="header" href="#drop-measurement-statement">DROP MEASUREMENT Statement</a></h3>
<p>删除measurement，可使用Where Clause附加条件</p>
<h4 id="syntax-13"><a class="header" href="#syntax-13">Syntax</a></h4>
<pre><code class="language-sql">DROP MEASUREMENT &lt;measurement_name&gt;
</code></pre>
<h4 id="例1删除measurement"><a class="header" href="#例1删除measurement">例1：删除measurement</a></h4>
<pre><code class="language-sql">&gt; DROP MEASUREMENT &quot;air&quot;
</code></pre>
<h4 id="例2附加where-clause通过tag-keys筛选需删除的数据"><a class="header" href="#例2附加where-clause通过tag-keys筛选需删除的数据">例2：附加WHERE Clause，通过Tag Keys筛选需删除的数据</a></h4>
<pre><code class="language-sql">&gt; DROP SERIES FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao'
</code></pre>
<h3 id="drop-shard-statement"><a class="header" href="#drop-shard-statement">DROP SHARD Statement</a></h3>
<p>根据shard_id删除特定的shard</p>
<h4 id="syntax-14"><a class="header" href="#syntax-14">Syntax</a></h4>
<pre><code class="language-sql">DROP SHARD &lt;shard_id_number&gt;
</code></pre>
<h4 id="例1删除shard"><a class="header" href="#例1删除shard">例1：删除SHARD</a></h4>
<pre><code class="language-sql">&gt; DROP SHARD 1
</code></pre>
<h3 id="drop-retention-policy-statement"><a class="header" href="#drop-retention-policy-statement">DROP RETENTION POLICY Statement</a></h3>
<p>删除retention policy</p>
<h4 id="syntax-15"><a class="header" href="#syntax-15">Syntax</a></h4>
<pre><code class="language-sql">DROP RETENTION POLICY &lt;retention_policy_name&gt;
ON &lt;database_name&gt;
</code></pre>
<h4 id="例1指定数据库删除retention-policy"><a class="header" href="#例1指定数据库删除retention-policy">例1：指定数据库，删除retention policy</a></h4>
<pre><code class="language-sql">&gt; DROP RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot;
</code></pre>
<h2 id="alter"><a class="header" href="#alter">ALTER</a></h2>
<h3 id="alter-retention-policy-statement"><a class="header" href="#alter-retention-policy-statement">ALTER RETENTION POLICY Statement</a></h3>
<p>修改retention policy，与创建时的语法类似，不再赘述</p>
<h4 id="syntax-16"><a class="header" href="#syntax-16">Syntax</a></h4>
<pre><code class="language-sql">ALTER RETENTION POLICY &lt;retention_policy_name&gt;
ON &lt;database_name&gt; 
DURATION &lt;duration&gt; 
REPLICATION &lt;n&gt; 
SHARD DURATION &lt;duration&gt;
DEFAULT
</code></pre>
<h4 id="例1修改retention-policy"><a class="header" href="#例1修改retention-policy">例1：修改retention policy</a></h4>
<pre><code class="language-sql">&gt; ALTER RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 7 SHARD DURATION 1d DEFAULT
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="cnosql函数"><a class="header" href="#cnosql函数">CnosQL函数</a></h2>
<ul>
<li>
<h3 id="目录"><a class="header" href="#目录">目录</a></h3>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count">COUNT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#distinct">DISTINCT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#integral">INTEGRAL()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean">MEAN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median">MEDIAN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode">MODE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#spread">SPREAD()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#stddev">STDDEV()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum">SUM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0">选择函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#bottom">BOTTOM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first">FIRST()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last">LAST()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max">MAX()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min">MIN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile">PERCENTILE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sample">SAMPLE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#top">TOP()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">转换函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#abs">ABS()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#acos">ACOS()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#asin">ASIN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#atan">ATAN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#atan2">ATAN2()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#ceil">CEIL()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#cos">COS()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#cumulative-sum">CUMULATIVE_SUM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#derivative">DERIVATIVE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#difference">DIFFERENCE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#elapsed">ELAPSED()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exp">EXP()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#floor">FLOOR()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#histogram">HISTOGRAM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#ln">LN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#log">LOG()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#log2">LOG2()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#log10">LOG10()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#moving-average">MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#non-negative-derivative">NON_NEGATIVE_DERIVATIVE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#non-negative-difference">NON_NEGATIVE_DIFFERENCE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#pow">POW()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#round">ROUND()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sin">SIN()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sqrt">SQRT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#tan">TAN()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E9%A2%84%E6%B5%8B%E5%87%BD%E6%95%B0">预测函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#holt_winters">HOLT_WINTERS()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0">分析函数</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#other">其他</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE">示例数据</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95">函数的通用语法</a>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%9C%A8SELECT%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">在<code>SELECT</code>中指定多个函数</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%AD%97%E6%AE%B5">重命名查询结果字段</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E6%94%B9%E5%8F%98%E4%B8%8D%E5%90%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">改变不含数据的时间间隔的返回值</a></li>
</ul>
</li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">函数常见问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h3>
<ul>
<li>
<h3 id="count"><a class="header" href="#count">COUNT()</a></h3>
<p>返回非空值 field values数量</p>
<h4 id="语法-14"><a class="header" href="#语法-14">语法</a></h4>
<pre><code class="language-sql">SELECT COUNT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法"><a class="header" href="#嵌套语法">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<p><code>COUNT(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT()</code>支持所有数据类型的<code>field value</code>。CnosQL支持将<a href="content/cnosdb/latest/cnosql/cnosql_function.html#distinct"><code>DISTINCT()</code></a>函数嵌套在<code>COUNT()</code>函数里。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key的field-value的数目"><a class="header" href="#计算指定field-key的field-value的数目">计算指定field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回measurement<code>air</code>中的<code>temperature</code>的非空field value的数量。</p>
<ul>
<li>
<h4 id="计数measurement中每个field-key关联的field-value的数量"><a class="header" href="#计数measurement中每个field-key关联的field-value的数量">计数measurement中每个field key关联的field value的数量</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(*) FROM &quot;air&quot;
name: air
time                 count_pressure count_temperature count_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 3334           3334              3334
</code></pre>
<p>该查询返回与measurement<code>air</code>相关联的每个field key的非空field value的数量。<code>air</code>有3个field keys：<code>count_pressure</code> <code>count_temperature</code> <code>count_visibility</code></p>
<ul>
<li>
<h4 id="计算匹配一个正则表达式的每个field-key关联的field-value的数目"><a class="header" href="#计算匹配一个正则表达式的每个field-key关联的field-value的数目">计算匹配一个正则表达式的每个field key关联的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(/.*pre.*/) FROM &quot;air&quot;
name: air
time                 count_pressure
----                 --------------
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回measurement<code>air</code>中包含<code>pre</code>的每个field key的非空字段值的数量。</p>
<ul>
<li>
<h4 id="计数包括多个子句的field-key的field-value的数目"><a class="header" href="#计数包括多个子句的field-key的field-value的数目">计数包括多个子句的field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;  SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1ms),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                     count
----                     -----
2022-04-11T08:03:37.071Z 108
2022-04-11T08:03:37.072Z 193
2022-04-11T08:03:37.073Z 207
2022-04-11T08:03:37.074Z 209
2022-04-11T08:03:37.075Z 209
2022-04-11T08:03:37.076Z 218
2022-04-11T08:03:37.077Z 216
</code></pre>
<p>该查询返回<code>pressure</code>field key中的非空field value的数量。它涵盖<code>now()</code>之间的<code>时间段</code>，并将结果分组为1ms的时间间隔和每个tag(表示为以上代码中的<code>*</code>)。并用<code>-1</code>填充空的时间间隔，并返回7个<code>point</code>，表格返回1。</p>
<ul>
<li>
<h4 id="计算一个field-key的distinct的field-value的数量"><a class="header" href="#计算一个field-key的distinct的field-value的数量">计算一个field key的distinct的field value的数量</a></h4>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
</li>
</ul>
<p>该查询返回measurement为<code>air</code>field为<code>pressure</code> 的唯一field value的数量。</p>
</li>
</ul>
<h4 id="count的常见问题"><a class="header" href="#count的常见问题"><code>COUNT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="count和fill"><a class="header" href="#count和fill"><code>COUNT()</code>和<code>fill()</code></a></h4>
</li>
</ul>
<p>大多数CnosQL函数对于没有数据的时间间隔返回<code>null</code>值，<code>fill(&lt;fill_option&gt;)</code>将该<code>null</code>值替换为<code>fill_option</code>。 <code>COUNT()</code>针对没有数据的时间间隔返回<code>0</code>，<code>fill(&lt;fill_option&gt;)</code>用<code>fill_option</code>替换0值。</p>
<p><em>示例</em></p>
<p>下面的代码块中的第一个查询不包括<code>fill()</code>。最后一个时间间隔没有数据，因此该时间间隔的值返回为零。第二个查询包括<code>fill(-1)</code>; 它将最后一个间隔中的零替换为<code>-1</code>。</p>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),*  LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z 0
2022-04-11T08:03:39Z 0
2022-04-11T08:03:40Z 0
2022-04-11T08:03:41Z 0
2022-04-11T08:03:42Z 0
2022-04-11T08:03:43Z 0

&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z -1
2022-04-11T08:03:39Z -1
2022-04-11T08:03:40Z -1
2022-04-11T08:03:41Z -1
2022-04-11T08:03:42Z -1
2022-04-11T08:03:43Z -1
</code></pre>
<ul>
<li>
<h3 id="distinct"><a class="header" href="#distinct"><code>DISTINCT()</code></a></h3>
<p>返回<code>field value</code>的不重复值列表。</p>
<h4 id="语法-15"><a class="header" href="#语法-15">语法</a></h4>
<pre><code class="language-sql">SELECT DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法-1"><a class="header" href="#嵌套语法-1">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<h4 id="语法描述-1"><a class="header" href="#语法描述-1">语法描述</a></h4>
<p><code>DISTINCT(field_key)</code> 返回<code>field key</code>对应的不同<code>field values</code>。</p>
<p><code>DISTINCT()</code> 支持所有数据类型的<code>field value</code>，CnosQL支持<a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>嵌套<code>DISTINCT()</code>。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例</a></h4>
<ul>
<li>
<h4 id="列出一个field-key的不同的field-value"><a class="header" href="#列出一个field-key的不同的field-value">列出一个<code>field key</code>的不同的<code>field value</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 57
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 60
</code></pre>
<p>该查询返回<code>air</code> measurement中<code>temperature</code>field 关键字中唯一<code>field values</code>的列表</p>
</li>
</ul>
<ul>
<li>
<h4 id="列出包含多个子句的field-key关联的不同值的列表"><a class="header" href="#列出包含多个子句的field-key关联的不同值的列表">列出包含多个子句的field key关联的不同值的列表</a></h4>
<pre><code class="language-sql">&gt;SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE  time &lt;now() GROUP BY time(12m),* SLIMIT 1
name: air
tags: station=LianYunGang
time                 distinct
----                 --------
2022-04-11T08:00:00Z 58
2022-04-11T08:00:00Z 56
2022-04-11T08:00:00Z 59
2022-04-11T08:00:00Z 57
2022-04-11T08:00:00Z 62
2022-04-11T08:00:00Z 60
2022-04-11T08:00:00Z 61
</code></pre>
</li>
</ul>
<p>该查询返回<code>pressure</code>field key中不同field value的列表。它涵盖now()之前的时间段，并将结果按12分钟的时间间隔和每个tag分组。查询限制（SLIMIT）返回一个series。</p>
<ul>
<li>
<h4 id="对一个字段的不同值进行计算"><a class="header" href="#对一个字段的不同值进行计算">对一个字段的不同值进行计算</a></h4>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
</li>
</ul>
<p>查询返回<code>air</code>这个measurement中字段<code>pressure</code>的不同值的数目。</p>
<h4 id="distinct的常见问题"><a class="header" href="#distinct的常见问题"><code>DISTINCT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="distinct-和-into-子句"><a class="header" href="#distinct-和-into-子句"><code>DISTINCT()</code> 和 <code>INTO</code> 子句</a></h4>
</li>
</ul>
<p>在<code>INTO</code>子句中使用<code>DISTINCT()</code>可能会导致CnosDB覆盖目标measurement中的<code>points</code>。<code>DISTINCT()</code>通常返回多个具有相同时间戳的结果；CnosDB假设在相同series中并具有相同时间戳的<code>point</code>是重复<code>point</code>，并简单地用目标measurement中最新的<code>point</code>覆盖重复<code>point</code>。</p>
<p>####示例</p>
<p>下面代码块中的第一个查询使用了<code>DISTINCT()</code>，并返回7个结果。请注意，每个结果都有相同的时间戳。第二个查询将<code>INTO</code>子句添加到查询中，并将查询结果写入measurement <code>distincts</code>。最后一个查询选择measurement <code>distincts</code>中所有数据。
因为原来的四个结果是重复的(它们在相同的series，有相同的时间戳)，所以最后一个查询只返回一个<code>point</code>。当系统遇到重复数据<code>point</code>，它会用最近的<code>point</code>覆盖之前的<code>point</code>。</p>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 60
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 57

&gt; SELECT DISTINCT(&quot;pressure&quot;) INTO &quot;distincts&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 7 

&gt; SELECT * FROM &quot;distincts&quot;
name: distincts
time                 distinct
----                 --------
1970-01-01T00:00:00Z 57
</code></pre>
<ul>
<li>
<h3 id="integral"><a class="header" href="#integral"><code>INTEGRAL()</code></a></h3>
<p>返回<code>field value</code>曲线下的面积，即关于<code>field value</code>的积分。</p>
<h4 id="语法-16"><a class="header" href="#语法-16">语法</a></h4>
<pre><code>SELECT INTEGRAL( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ]  ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-2"><a class="header" href="#语法描述-2">语法描述</a></h4>
<p>CnosDB计算field value曲线下的面积，并将这些结果转换为每个<code>unit</code>的总面积。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>INTEGRAL(field_key)</code>返回field key关联的值之下的面积。</p>
<p><code>INTEGRAL(/regular_expression/)</code>返回满足正则表达式的每个field key关联的值之下的面积。</p>
<p><code>INTEGRAL(*)</code>返回<code>measurement</code>中每个<code>field key</code>关联的值之下的面积。</p>
<p><code>INTEGRAL()</code>不支持<code>fill()</code>，<code>INTEGRAL()</code>支持int64和float64两个数据类型。</p>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<p>下面的五个例子，使用数据库<a href="content/cnosdb/latest/cnosql/oceanic_station.txt"><code>oceanic_station</code>中的数据</a>：</p>
<pre><code class="language-sql">&gt;  SELECT  temperature  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                        temperature
----                        -----------
2022-04-11T08:03:37.07132Z  58
2022-04-11T08:03:37.071378Z 62
2022-04-11T08:03:37.071385Z 58
2022-04-11T08:03:37.071391Z 56
2022-04-11T08:03:37.071394Z 56
2022-04-11T08:03:37.071401Z 59
2022-04-11T08:03:37.071403Z 57
2022-04-11T08:03:37.071406Z 62
2022-04-11T08:03:37.071409Z 59
2022-04-11T08:03:37.071411Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定的field-key的值得积分"><a class="header" href="#计算指定的field-key的值得积分">计算指定的field key的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;SELECT  INTEGRAL(temperature)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10 
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 0.4677579999999999
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以秒为单位）。</p>
<ul>
<li>
<h4 id="计算指定的field-key和时间单位的值的积分"><a class="header" href="#计算指定的field-key和时间单位的值的积分">计算指定的field key和时间单位的值的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以1ms为单位）。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中每个field-key在指定时间单位的值得积分">计算measurement中每个field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(*,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_pressure  integral_temperature integral_visibility
----                 -----------------  -------------------- -------------------
1970-01-01T00:00:00Z 467.22900000000413 467.7580000000045    491.2000000000007
</code></pre>
<p>查询返回measurement<code>air</code>中存储的每个数值字段相关的字段值的曲线下面积（以1ms为单位）</p>
<ul>
<li>
<h4 id="计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分">计算measurement中匹配正则表达式的field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(/temp/,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_temperature
----                 --------------------
1970-01-01T00:00:00Z 467.7580000000045

</code></pre>
<p>查询返回field key包括单词<code>water</code>的每个数值类型的字段相关联的字段值的曲线下的区域（以分钟为单位）。</p>
<ul>
<li>
<h4 id="在含有多个子句中计算指定字段的积分"><a class="header" href="#在含有多个子句中计算指定字段的积分">在含有多个子句中计算指定字段的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now() GROUP BY time(12m) LIMIT 1
name: air
time                 integral_temperature
----                 --------------------
2022-04-11T08:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的field value曲线下的面积(以分钟为单位)，它涵盖的时间范围在now()之前，并将查询结果按12分钟的时间间隔进行分组，同时，该查询将返回的<code>point</code>个数限制为1。</p>
</li>
<li>
<h3 id="mean"><a class="header" href="#mean"><code>MEAN()</code></a></h3>
<p>返回field value的平均值。</p>
<h4 id="语法-17"><a class="header" href="#语法-17">语法</a></h4>
<pre><code>SELECT MEAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MEAN(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的field value的平均值。</p>
<p><code>MEAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值"><a class="header" href="#计算指定field-key对应的field-value的平均值">计算指定field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                   mean
----                   ----
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均值">计算measurement中每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(*) FROM &quot;air&quot; 
name: air
time                 mean_pressure     mean_temperature  mean_visibility
----                 -------------     ----------------  ---------------
1970-01-01T00:00:00Z 59.00689862027595 59.04949010197961 62.01889622075585
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均值">计算与正则表达式匹配的每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(/temp/) FROM &quot;air&quot; 
name: air
time                   mean_temperature
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822523
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均值并包含多个子句">计算指定field key对应的field value的平均值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(9.01) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 mean
----                 ----
2022-04-11T08:00:00Z 59.06864564007421
2022-04-11T08:12:00Z 9.01
2022-04-11T08:24:00Z 9.01
2022-04-11T08:36:00Z 9.01
2022-04-11T08:48:00Z 9.01
2022-04-11T09:00:00Z 9.01
2022-04-11T09:12:00Z 9.01 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value的平均值，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为7和1。</p>
</li>
<li>
<h3 id="median"><a class="header" href="#median">MEDIAN()</a></h3>
<p>返回<code>field value</code>的计算中值。</p>
<h4 id="语法-18"><a class="header" href="#语法-18">语法</a></h4>
<pre><code>SELECT MEDIAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-3"><a class="header" href="#语法描述-3">语法描述</a></h4>
<p><code>MEDIAN(field_key)</code>返回与<code>field key</code>对应的field value的中值。</p>
<p><code>MEDIAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN()</code> 支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong><code>MEDIAN()</code>近似于<code>PERCENTILE(field_key, 50)</code>，除非<code>field key</code>包含的<code>field value</code>有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</p>
</blockquote>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值"><a class="header" href="#计算指定field-key对应的field-value的中值">计算指定field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 median
----                 ------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>pressure</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的中值"><a class="header" href="#计算measurement中每个field-key对应的field-value的中值">计算measurement中每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(*) FROM &quot;air&quot;
name: air
time                 median_pressure median_temperature median_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 59              59                 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的中值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的中值">计算与正则表达式匹配的每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(/temp/) FROM &quot;air&quot;
name: air
time                 median_temperature
----                 ------------------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的中值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的中值并包含多个子句">计算指定field key对应的field value的中值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE  time&lt;now()  GROUP BY time(1m),* fill(-1) LIMIT 7 SLIMIT 3 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 median
----                 ------
2022-04-11T08:03:00Z 59
2022-04-11T08:04:00Z -1
2022-04-11T08:05:00Z -1
2022-04-11T08:06:00Z -1
2022-04-11T08:07:00Z -1
2022-04-11T08:08:00Z -1
2022-04-11T08:09:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均数，它涵盖的时间范围在now()之前，并将查询结果按1分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="mode"><a class="header" href="#mode">MODE()</a></h3>
<p>返回<code>field value</code>中出现频率最高的值。</p>
<h4 id="语法-19"><a class="header" href="#语法-19">语法</a></h4>
<pre><code>SELECT MODE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MODE(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE()</code> 支持所有数据类型的<code>field value</code>。</p>
<blockquote>
<p>**注意：**如果出现频率最高的值有两个或多个并且它们之间有关联，那么<code>MODE()</code>返回具有最早时间戳的<code>field value</code>。</p>
</blockquote>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值">计算指定field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mode
----                 ----
1970-01-01T00:00:00Z 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中某个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算measurement中每个field-key对应的field-value中出现频率最高的值">计算measurement中每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(*) FROM &quot;air&quot;
name: air
time                 mode_pressure mode_temperature mode_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 57            62               61
</code></pre>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值">计算与正则表达式匹配的每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT MODE(/temp/) FROM &quot;air&quot;
name: air
time                 mode_temperature
----                 ----------------
1970-01-01T00:00:00Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值并包含多个子句">计算指定field key对应的field value中出现频率最高的值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 mode
----                 ----
2022-04-11T08:00:00Z 59
2022-04-11T08:12:00Z 
2022-04-11T08:24:00Z 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>temperature</code>中出现频率最高的值，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="spread"><a class="header" href="#spread">SPREAD()</a></h3>
<p>返回<code>field value</code>中最大值和最小值之差。</p>
<h4 id="语法-20"><a class="header" href="#语法-20">语法</a></h4>
<pre><code class="language-sql">SELECT SPREAD( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-4"><a class="header" href="#语法描述-4">语法描述</a></h4>
<p><code>SPREAD(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD()</code>支持数据类型为int64和float64的<code>field value</code>。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差">计算指定field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 spread
----                 ------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算measurement中每个field-key对应的field-value中最大值和最小值之差">计算measurement中每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(*) FROM &quot;air&quot;
name: air
time                 spread_pressure spread_temperature spread_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 6               6                  6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差">计算与正则表达式匹配的每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(/tem/) FROM &quot;air&quot;
name: air
time                 spread_temperature
----                 ------------------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句">计算指定field key对应的field value中最大值和最小值之差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(-1) LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 spread
----                 ------
2022-04-11T08:00:00Z 6
2022-04-11T08:12:00Z -1
2022-04-11T08:24:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value中最大值和最小值之差，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）</p>
</li>
<li>
<h3 id="stddev"><a class="header" href="#stddev">STDDEV()</a></h3>
<p>返回<code>field value</code>的标准差。</p>
<h4 id="语法-21"><a class="header" href="#语法-21">语法</a></h4>
<pre><code class="language-sql">SELECT STDDEV( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>STDDEV(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(*)</code>返回在measurement中每个field key对应的field value的标准差。</p>
<p><code>STDDEV()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差"><a class="header" href="#计算指定field-key对应的field-value的标准差">计算指定field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 stddev
----                 ------
1970-01-01T00:00:00Z 1.9933006709246002
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的标准差"><a class="header" href="#计算measurement中每个field-key对应的field-value的标准差">计算measurement中每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(*) FROM &quot;air&quot;
name: air
time                 stddev_pressure    stddev_temperature stddev_visibility
----                 ---------------    ------------------ -----------------
1970-01-01T00:00:00Z 2.0234776612813525 1.9933006709246002 1.9942769555619093
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的标准差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的标准差">计算与正则表达式匹配的每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(/temp/) FROM &quot;air&quot;
name: air
time                   stddev_temperature
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的标准差并包含多个子句">计算指定field key对应的field value的标准差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 2 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 stddev
----                 ------
2022-04-11T08:00:00Z 1.9988781365491315
2022-04-11T08:12:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为2和1，并将返回的series偏移一个（即第一个series的数据不返回）。</p>
</li>
<li>
<h3 id="sum"><a class="header" href="#sum">SUM()</a></h3>
<p>返回field value的总和。</p>
<h4 id="语法-22"><a class="header" href="#语法-22">语法</a></h4>
<pre><code>SELECT SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-5"><a class="header" href="#语法描述-5">语法描述</a></h4>
<p><code>SUM(field_key)</code>返回field key对应的field value的总和。</p>
<p><code>SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的总和。</p>
<p><code>SUM(*)</code>返回在measurement中每个field key对应的field value的总和。</p>
<p><code>SUM()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和"><a class="header" href="#计算指定field-key对应的field-value的总和">计算指定field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的总和">计算measurement中每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(*) FROM &quot;air&quot;
name: air
time                 sum_pressure sum_temperature sum_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 196729       196871          206771
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的总和">计算与正则表达式匹配的每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(/temp/) FROM &quot;air&quot;
name: air
time                 sum_temperature
----                 ---------------
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的总和并包含多个子句">计算指定field key对应的field value的总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 sum
----                 ---
2022-04-11T08:00:00Z 95514
2022-04-11T08:12:00Z 18000
2022-04-11T08:24:00Z 18000
2022-04-11T08:36:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
</li>
</ul>
<h2 id="选择函数"><a class="header" href="#选择函数">选择函数</a></h2>
<ul>
<li>
<h3 id="bottom"><a class="header" href="#bottom">BOTTOM()</a></h3>
<p>返回最小的N个field value。</p>
<h4 id="语法-23"><a class="header" href="#语法-23">语法</a></h4>
<pre><code>SELECT BOTTOM(&lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-6"><a class="header" href="#语法描述-6">语法描述</a></h4>
<p><code>BOTTOM(field_key,N)</code>返回field key对应的最小的N个值。</p>
<p><code>BOTTOM(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最小值。</p>
<p><code>BOTTOM(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最小的N个值，以及相关的tag和/或field。</p>
<p><code>BOTTOM()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最小值有两个或多个相等的值，<code>BOTTOM()</code>返回具有最早时间戳的field value。</li>
<li>当<code>BOTTOM()</code>函数与<code>INTO</code>子句一起使用时，<code>BOTTOM()</code>与其它CnosQL函数不同。请查看<code>BOTTOM()</code>的常见问题章节获得更多信息。</li>
</ul>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值"><a class="header" href="#选择指定field-key对应的最小的三个值">选择指定field key对应的最小的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom
----                 ------
2021-08-31T16:18:00Z 50
2021-08-31T17:09:00Z 50
2021-08-31T18:39:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最小的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最小值"><a class="header" href="#选择两个tag对应的field-key的最小值">选择两个tag对应的field key的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最小的四个值以及相关的tag和field">选择指定field key对应的最小的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 bottom station     pressure
----                 ------ -------     --------
2021-08-31T16:18:00Z 50     XiaoMaiDao  55
2021-08-31T17:09:00Z 50     XiaoMaiDao  63
2021-08-31T18:39:00Z 50     LianYunGang 64
2021-08-31T19:51:00Z 50     LianYunGang 62
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最小的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最小的三个值并包含多个子句">选择指定field key对应的最小的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 bottom station
----                 ------ -------
2021-09-18T00:54:00Z 69     LianYunGang
2021-09-18T00:51:00Z 65     LianYunGang
2021-09-18T00:48:00Z 68     XiaoMaiDao
2021-09-18T00:39:00Z 53     XiaoMaiDao
2021-09-18T00:36:00Z 52     LianYunGang
2021-09-18T00:33:00Z 50     LianYunGang
2021-09-18T00:06:00Z 55     LianYunGang
2021-09-18T00:03:00Z 53     XiaoMaiDao
2021-09-18T00:00:00Z 51     LianYunGang
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最小的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="bottom的常见问题"><a class="header" href="#bottom的常见问题"><code>BOTTOM()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="bottom和group-by-time子句同时使用"><a class="header" href="#bottom和group-by-time子句同时使用"><code>BOTTOM()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>BOTTOM()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>BOTTOM()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   bottom
----                   ------
                           __
2021-09-28T00:00:00Z  2.064 |
2021-09-18T00:12:00Z  2.028 | &lt;------- Smallest points for the first time interval
                           --
                           __
2021-09-18T00:24:00Z  2.041 |
2021-09-18T00:30:00Z  2.051 | &lt;------- Smallest points for the second time interval                      --
</code></pre>
<ul>
<li>
<h4 id="bottom和具有少于n个tag-value的tag-key"><a class="header" href="#bottom和具有少于n个tag-value的tag-key"><code>BOTTOM()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT BOTTOM(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最小值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<ul>
<li>
<h4 id="bottomtag和into子句"><a class="header" href="#bottomtag和into子句"><code>BOTTOM()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数CnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>BOTTOM()</code>函数除非<code>BOTTOM()</code>中包含tag key作为参数：<code>BOTTOM(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值，并且，它这些结果写入measurement <code>bottom_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>bottom_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;bottom_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;air&quot;
name: air
tagKey
------
station
</code></pre>
</li>
<li>
<h3 id="first"><a class="header" href="#first">FIRST()</a></h3>
<p>返回具有最早时间戳的field value。</p>
<h4 id="语法-24"><a class="header" href="#语法-24">语法</a></h4>
<pre><code>SELECT FIRST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-7"><a class="header" href="#语法描述-7">语法描述</a></h4>
<p><code>FIRST(field_key)</code>返回field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(*)</code>返回在measurement中每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最早时间戳的field value，以及相关的tag或field。</p>
<p><code>FIRST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value">选择指定field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 first
----                 -----
2021-08-31T16:00:00Z 78
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最早时间戳的field-value">选择measurement中每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;

name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最早时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(/temp/) FROM &quot;air&quot;

name: air
time                 first_temperature
----                 -----------------
2021-08-31T16:00:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最早时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 first station     temperature
----                 ----- -------     -----------
2021-08-31T16:00:00Z 78    LianYunGang 63
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value并包含多个子句">选择指定field key对应的具有最早时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 first
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 70
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最早时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="last"><a class="header" href="#last">LAST()</a></h3>
<p>返回具有最新时间戳的field value。</p>
<h4 id="语法-25"><a class="header" href="#语法-25">语法</a></h4>
<pre><code class="language-sql">SELECT LAST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_keys(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LAST(field_key)</code>返回field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(*)</code>返回在measurement中每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最新时间戳的field value，以及相关的tag或field。</p>
<p><code>LAST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-13"><a class="header" href="#示例-13">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value">选择指定field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 last
----                 ----
2021-09-30T04:00:00Z 65
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最新时间戳的field-value">选择measurement中每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(*) FROM &quot;air&quot;
name: air
time                 last_pressure last_temperature last_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 65            59               78
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最新时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(/temp/) FROM &quot;air&quot;
name: air
time                 last_temperature
----                 ----------------
2021-09-30T04:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最新时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 last station     temperature
----                 ---- -------     -----------
2021-09-30T04:00:00Z 65   LianYunGang 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value并包含多个子句">选择指定field key对应的具有最新时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 last
----                 ----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 68
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 58
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最新时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="max"><a class="header" href="#max">MAX()</a></h3>
<p>返回field value的最大值。</p>
<h4 id="语法-26"><a class="header" href="#语法-26">语法</a></h4>
<pre><code>SELECT MAX(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field__key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MAX(field_key)</code>返回field key对应的field value的最大值。</p>
<p><code>MAX(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最大值。</p>
<p><code>MAX(*)</code>返回在measurement中每个field key对应的field value的最大值。</p>
<p><code>MAX(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最大值，以及相关的tag或field。</p>
<p><code>MAX()</code> 支持数据类型为int64和float64的field value。</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值"><a class="header" href="#选择指定field-key对应的field-value的最大值">选择指定field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max
----                 ---
2021-08-31T18:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最大值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最大值">选择measurement中每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最大值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最大值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最大值">选择与正则表达式匹配的每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(/pres/) FROM &quot;air&quot;
name: air
time                 max_pressure
----                 ------------
2021-08-31T17:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最大值以及相关的tag和field">选择指定field key对应的field value的最大值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 max station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最大值并包含多个子句">选择指定field key对应的field value的最大值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
2021-09-18T00:36:00Z 70
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="min"><a class="header" href="#min">MIN()</a></h3>
<p>返回field value的最小值。</p>
<h4 id="语法-27"><a class="header" href="#语法-27">语法</a></h4>
<pre><code>SELECT MIN(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MIN(field_key)</code>返回field key对应的field value的最小值。</p>
<p><code>MIN(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最小值。</p>
<p><code>MIN(*)</code>返回在measurement中每个field key对应的field value的最小值。</p>
<p><code>MIN(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最小值，以及相关的tag和/或field。</p>
<p><code>MIN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值"><a class="header" href="#选择指定field-key对应的field-value的最小值">选择指定field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min
----                 ---
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最小值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最小值">选择measurement中每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(*) FROM &quot;air&quot;

name: air
time                 min_pressure min_temperature min_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 50           50              50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最小值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最小值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最小值">选择与正则表达式匹配的每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(/temp/) FROM &quot;air&quot;

name: air
time                 min_temperature
----                 ---------------
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最小值以及相关的tag和field">选择指定field key对应的field value的最小值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 min station    pressure
----                 --- -------    --------
2021-08-31T16:18:00Z 50  XiaoMaiDao 55
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最小值并包含多个子句">选择指定field key对应的field value的最小值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 min
----                 ---
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="percentile"><a class="header" href="#percentile">PERCENTILE()</a></h3>
<p>返回第N个百分位数的<code>field value</code></p>
<h4 id="语法-28"><a class="header" href="#语法-28">语法</a></h4>
<pre><code>SELECT PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>PERCENTILE(field_key,N)</code>返回指定field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(*,N)</code>返回在measurement中每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的第N个百分位数的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是0到100之间的整数或浮点数。</p>
<p><code>PERCENTILE()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-16"><a class="header" href="#示例-16">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value">选择指定field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5) FROM &quot;air&quot;

name: air
time                 percentile
----                 ----------
2021-09-03T23:51:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择measurement中每个field-key对应的第五个百分位数的field-value">选择measurement中每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(*,5) FROM &quot;air&quot;

name: air
time                 percentile_pressure percentile_temperature percentile_visibility
----                 ------------------- ---------------------- ---------------------
1970-01-01T00:00:00Z 51                  51                     51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值的field key对应的所有field value中的百分之五。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value">选择与正则表达式匹配的每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(/visi/,5) FROM &quot;air&quot;
name: air
time                 percentile_visibility
----                 ---------------------
2021-09-29T09:54:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field">选择指定field key对应的第五个百分位数的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 percentile station    pressure
----                 ---------- -------    --------
2021-09-03T23:51:00Z 51         XiaoMaiDao 65
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第20个百分位数的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的第20个百分位数的field-value并包含多个子句">选择指定field key对应的第20个百分位数的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,20) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(24m) fill(15) LIMIT 2
name: air
time                 percentile
----                 ----------
2020-08-17T23:36:00Z 15
2020-08-18T00:00:00Z 15
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之二十，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按24分钟的时间间隔进行分组，同时，该查询用<code>15</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数限制为2。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每24分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:36:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:24:00Z</code>之间。</p>
<h4 id="percentile的常见问题"><a class="header" href="#percentile的常见问题"><code>PERCENTILE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="percentile-vs-其它cnosql函数"><a class="header" href="#percentile-vs-其它cnosql函数"><code>PERCENTILE()</code> vs 其它CnosQL函数</a></h4>
</li>
</ul>
<ul>
<li><code>PERCENTILE(&lt;field_key&gt;,100)</code>相当于<code>MAX(&lt;field_key&gt;)</code>。</li>
<li><code>PERCENTILE(&lt;field_key&gt;, 50)</code>近似于<code>MEDIAN(&lt;field_key&gt;)</code>，除非field key包含的field value有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</li>
<li><code>PERCENTILE(&lt;field_key&gt;,0)</code>不等于<code>MIN(&lt;field_key&gt;)</code>，<code>PERCENTILE(&lt;field_key&gt;,0)</code>会返回<code>null</code>。</li>
</ul>
</li>
<li>
<h3 id="sample"><a class="header" href="#sample">SAMPLE()</a></h3>
<p>返回包含N个field value的随机样本。<code>SAMPLE()</code>使用<a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a>来生成随机<code>point</code>。</p>
<h4 id="语法-29"><a class="header" href="#语法-29">语法</a></h4>
<pre><code>SELECT SAMPLE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SAMPLE(field_key,N)</code>返回指定field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(*,N)</code>返回在measurement中每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的N个随机选择的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是整数。</p>
<p><code>SAMPLE()</code>支持所有数据类型的field value。</p>
<h4 id="示例-17"><a class="header" href="#示例-17">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本"><a class="header" href="#选择指定field-key对应的field-value的随机样本">选择指定field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot;
name: air
time                 sample
----                 ------
2021-09-07T02:18:00Z 77
2021-09-13T12:00:00Z 62
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的随机样本"><a class="header" href="#选择measurement中每个field-key对应的field-value的随机样本">选择measurement中每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(*,2) FROM &quot;air&quot;
name: air
time                 sample_pressure sample_temperature sample_visibility
----                 --------------- ------------------ -----------------
2021-08-31T16:18:00Z                 52                 
2021-09-03T14:33:00Z 74                                 
2021-09-12T19:39:00Z 59                                 
2021-09-17T11:33:00Z                 51                 
2021-09-20T04:09:00Z                                    50
2021-09-22T19:15:00Z                                    80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的两个随机选择的<code>point</code>。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的随机样本"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的随机样本">选择与正则表达式匹配的每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(/pres/,2) FROM &quot;air&quot;
name: air
time                 sample_pressure
----                 ---------------
2021-09-25T20:27:00Z 77
2021-09-26T20:33:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的随机样本以及相关的tag和field">选择指定field key对应的field value的随机样本以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 sample station     pressure
----                 ------ -------     --------
2021-09-09T00:03:00Z 71     LianYunGang 61
2021-09-11T01:39:00Z 53     LianYunGang 51
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应field-value的随机样本并包含多个子句"><a class="header" href="#选择指定field-key对应field-value的随机样本并包含多个子句">选择指定field key对应field value的随机样本并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,1) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                 sample
----                 ------
2021-09-18T00:09:00Z 55
2021-09-18T00:27:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的一个随机选择的<code>point</code>，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并将查询结果按18分钟的时间间隔进行分组。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="sample的常见问题"><a class="header" href="#sample的常见问题"><code>SAMPLE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="sample和group-by-time子句同时使用"><a class="header" href="#sample和group-by-time子句同时使用"><code>SAMPLE()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>SAMPLE()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数(<code>N</code>)的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>SAMPLE()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个随机选择的<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   sample
----                   ------
                           __
2021-09-18T00:09:00Z      55   |
2021-09-18T00:12:00Z      63   | &lt;------- Randomly-selected points for the first time interval
                           --
                           __
2021-09-18T00:18:00Z      79  |
2021-09-18T00:21:00Z      68  | &lt;------- Randomly-selected points for the second time interval
                           --
</code></pre>
</li>
<li>
<h3 id="top"><a class="header" href="#top">TOP()</a></h3>
<p>返回最大的N个field value</p>
<h4 id="语法-30"><a class="header" href="#语法-30">语法</a></h4>
<pre><code>SELECT TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TOP(field_key,N)</code>返回field key对应的最大的N个值。</p>
<p><code>TOP(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最大值。</p>
<p><code>TOP(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最大的N个值，以及相关的tag和/或field。</p>
<p><code>TOP()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最大值有两个或多个并且它们之间有关联，<code>TOP()</code>返回具有最早时间戳的field value。</li>
</ul>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值"><a class="header" href="#选择指定field-key对应的最大的三个值">选择指定field key对应的最大的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 top
----                 ---
2021-08-31T18:03:00Z 80
2021-08-31T18:18:00Z 80
2021-08-31T18:57:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最大的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最大值"><a class="header" href="#选择两个tag对应的field-key的最大值">选择两个tag对应的field key的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最大的四个值以及相关的tag和field">选择指定field key对应的最大的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 top station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
2021-08-31T18:18:00Z 80  XiaoMaiDao  53
2021-08-31T18:57:00Z 80  LianYunGang 51
2021-08-31T20:15:00Z 80  XiaoMaiDao  53
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最大的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最大的三个值并包含多个子句">选择指定field key对应的最大的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 top station
----                 --- -------
2021-09-18T00:54:00Z 79  XiaoMaiDao
2021-09-18T00:51:00Z 71  XiaoMaiDao
2021-09-18T00:48:00Z 77  LianYunGang
2021-09-18T00:30:00Z 75  LianYunGang
2021-09-18T00:27:00Z 79  LianYunGang
2021-09-18T00:24:00Z 70  LianYunGang
2021-09-18T00:18:00Z 79  LianYunGang
2021-09-18T00:09:00Z 80  XiaoMaiDao
2021-09-18T00:00:00Z 77  XiaoMaiDao
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最大的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="top的常见问题"><a class="header" href="#top的常见问题"><code>TOP()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="top和group-by-time子句同时使用"><a class="header" href="#top和group-by-time子句同时使用"><code>TOP()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>TOP()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>TOP()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)

name: air
time                   top
----                   ------
                        __
2021-09-18T00:12:00Z    63   |
2021-09-18T00:15:00Z    74   | &lt;------- Greatest points for the first time interval
                        --
                        __
2021-09-18T00:18:00Z    79   |
2021-09-18T00:27:00Z   79    | &lt;------- Greatest points for the second time interval
                        --
</code></pre>
<ul>
<li>
<h4 id="top和具有少于n个tag-value的tag-key"><a class="header" href="#top和具有少于n个tag-value的tag-key"><code>TOP()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT TOP(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最大值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<ul>
<li>
<h4 id="toptag和into子句"><a class="header" href="#toptag和into子句"><code>TOP()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数CnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>TOP()</code>函数，除非<code>TOP()</code>中包含tag key作为参数：<code>TOP(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值，并且，它这些结果写入measurement <code>top_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>top_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;top_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;top_temperatures&quot;
name: top_temperatures
tagKey
------
station
</code></pre>
</li>
</ul>
<h3 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h3>
<ul>
<li>
<h3 id="abs"><a class="header" href="#abs">ABS()</a></h3>
<p>返回field value的绝对值</p>
<h4 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h4>
<pre><code class="language-sql">SELECT ABS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ABS(field_key)</code>返回field key对应的field value的绝对值。</p>
<p><code>ABS(*)</code>返回在measurement中每个field key对应的field value的绝对值。</p>
<p><code>ABS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ABS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-19"><a class="header" href="#示例-19">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-09-24T12:00:00Z 76       LianYunGang 61          59
2021-09-24T12:00:00Z 58       XiaoMaiDao  52          77
2021-09-24T12:03:00Z 64       LianYunGang 57          72
2021-09-24T12:03:00Z 50       XiaoMaiDao  70          77
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值"><a class="header" href="#计算指定field-key对应的field-value的绝对值">计算指定field key对应的field value的绝对值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 76
2021-09-24T12:00:00Z 58
2021-09-24T12:03:00Z 64
2021-09-24T12:03:00Z 50
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值。</p>
</li>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的绝对值"><a class="header" href="#计算measurement中每个field-key对应的field-value的绝对值">计算measurement中每个field key对应的field value的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs_pressure abs_temperature abs_visibility
----                 ------------ --------------- --------------
2021-09-24T12:00:00Z 76           61              59
2021-09-24T12:00:00Z 58           52              77
2021-09-24T12:03:00Z 64           57              72
2021-09-24T12:03:00Z 50           70              77
</code></pre>
<p>该查询返回measurement <code>data</code>中每个存储数值的field key对应的field value的绝对值。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>,<code>pressure</code>和<code>visibility</code>。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的绝对值并包含多个子句">计算指定field key对应的field value的绝对值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 58
2021-09-24T12:00:00Z 76
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值，它涵盖的时间范围在<code>2020-06-24T12:00:00Z</code>和<code>2020-06-24T12:05:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法"><a class="header" href="#高级语法">高级语法</a></h4>
<pre><code class="language-sql">SELECT ABS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的绝对值。</p>
<p><code>ABS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="计算平均值的绝对值"><a class="header" href="#计算平均值的绝对值">计算平均值的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 62.75
2021-09-24T12:12:00Z 64.25
2021-09-24T12:24:00Z 66
2021-09-24T12:36:00Z 64.375
2021-09-24T12:48:00Z 63.875
2021-09-24T13:00:00Z 59.5
</code></pre>
<p>该查询返回field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ABS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-24T12:00:00Z 61.75
2021-09-24T12:12:00Z 68.25
2021-09-24T12:24:00Z 66.125
2021-09-24T12:36:00Z 58
2021-09-24T12:48:00Z 68.625
2021-09-24T13:00:00Z 71
</code></pre>
<p>然后，CnosDB计算这些平均值的绝对值。</p>
</li>
<li>
<h3 id="acos"><a class="header" href="#acos">ACOS()</a></h3>
<p>返回field value的反余弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h4>
<pre><code>SELECT ACOS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ACOS(field_key)</code>返回field key对应的field value的反余弦。</p>
<p><code>ACOS(*)</code>返回在measurement中每个field key对应的field value的反余弦。</p>
<p><code>ACOS()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ACOS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-20"><a class="header" href="#示例-20">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ACOS()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦"><a class="header" href="#计算指定field-key对应的field-value的反余弦">计算指定field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  acos
----                  ----
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反余弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反余弦">计算measurement中每个field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 acos_pressure acos_temperature acos_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反余弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但由于这三个field key对应的field value超过余弦函数的范围，因此其反余弦值并不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反余弦并包含多个子句">计算指定field key对应的field value的反余弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 acos
----                 ----
2021-09-18T23:57:00Z 0.6435011087932843
2021-09-18T23:57:00Z 0.6599873293874983
2021-09-18T23:54:00Z 0.7669940078618667
2021-09-18T23:54:00Z 1.0003592173949745
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-1"><a class="header" href="#高级语法-1">高级语法</a></h4>
<pre><code class="language-sql">SELECT ACOS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反余弦。</p>
<p>ACOS()支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的反余弦"><a class="header" href="#计算平均值的反余弦">计算平均值的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 acos
----                 ----
2021-09-09T00:00:00Z
2021-09-12T00:00:00Z
2021-09-15T00:00:00Z
2021-09-18T00:00:00Z  、
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反余弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ACOS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反余弦。</p>
</li>
<li>
<h3 id="asin"><a class="header" href="#asin">ASIN()</a></h3>
<p>返回field value的反正弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h4>
<pre><code>SELECT ASIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ASIN(field_key)</code>返回field key对应的field value的反正弦。</p>
<p><code>ASIN(*)</code>返回在measurement中每个field key对应的field value的反正弦。</p>
<p><code>ASIN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ASIN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-21"><a class="header" href="#示例-21">示例</a></h4>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦"><a class="header" href="#计算指定field-key对应的field-value的反正弦">计算指定field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin
----                 ----
2021-09-11T00:00:00Z 0.8330703583416478
2021-09-11T00:00:00Z 0.9108089974073983
2021-09-11T00:03:00Z 0.6560605909249226
2021-09-11T00:03:00Z 0.8183219506315597
2021-09-11T00:06:00Z 0.8038023189330299
2021-09-11T00:06:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.8038023189330299
2021-09-11T00:12:00Z 0.546850950695944
2021-09-11T00:12:00Z 0.618728690672251
2021-09-11T00:15:00Z 0.8330703583416478
2021-09-11T00:15:00Z 0.8946658172342352
2021-09-11T00:18:00Z 0.7342087874533589
2021-09-11T00:18:00Z 0.8330703583416478
2021-09-11T00:21:00Z 0.7894982093461719
2021-09-11T00:21:00Z 0.5823642378687435
2021-09-11T00:24:00Z 0.7208187608700896
2021-09-11T00:24:00Z 0.7342087874533589
2021-09-11T00:27:00Z 0.8038023189330299
2021-09-11T00:27:00Z 0.7208187608700896
2021-09-11T00:30:00Z 0.6560605909249226
2021-09-11T00:30:00Z 0.570437109399922
2021-09-11T00:33:00Z 0.5823642378687435
2021-09-11T00:33:00Z 0.848062078981481
2021-09-11T00:36:00Z 0.7075844367253555
2021-09-11T00:36:00Z 0.7208187608700896
2021-09-11T00:39:00Z 0.7477626346599205
2021-09-11T00:39:00Z 0.618728690672251
2021-09-11T00:42:00Z 0.6310588407780212
2021-09-11T00:42:00Z 0.618728690672251
2021-09-11T00:45:00Z 0.7614890527476331
2021-09-11T00:45:00Z 0.7894982093461719
2021-09-11T00:48:00Z 0.7614890527476331
2021-09-11T00:48:00Z 0.6065058552130869
2021-09-11T00:51:00Z 0.5823642378687435
2021-09-11T00:51:00Z 0.8183219506315597
2021-09-11T00:54:00Z 0.7614890527476331
2021-09-11T00:54:00Z 0.6944982656265559
2021-09-11T00:57:00Z 0.8183219506315597
2021-09-11T00:57:00Z 0.546850950695944
2021-09-11T01:00:00Z 0.6310588407780212
2021-09-11T01:00:00Z 0.7477626346599205    
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正弦">计算measurement中每个field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin_pressure asin_temperature asin_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但是由于这三个field value全部大于1，因此其反正弦值不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正弦并包含多个子句">计算指定field key对应的field value的反正弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 asin
----                 ----
2021-09-18T23:57:00Z 0.9272952180016123
2021-09-18T23:57:00Z 0.9108089974073983
2021-09-18T23:54:00Z 0.8038023189330299
2021-09-18T23:54:00Z 0.570437109399922
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-2"><a class="header" href="#高级语法-2">高级语法</a></h4>
<pre><code class="language-sql">SELECT ASIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正弦。</p>
<p>ASIN()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-22"><a class="header" href="#示例-22">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正弦"><a class="header" href="#计算平均值的反正弦">计算平均值的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(MEAN(&quot;speed&quot;)) FROM &quot;wind&quot; WHERE time &gt;= '2021-09-01T00:00:00Z' AND time &lt;= '2021-09-30T00:00:00Z' GROUP BY time(1d)
name: air
time                  asin
----                  ----
2020-04-30T00:00:00Z  0.6004332535805232
2020-05-03T00:00:00Z  0.42245406218675574
2020-05-06T00:00:00Z  0.7894982093461719
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ASIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正弦。</p>
</li>
<li>
<h3 id="atan"><a class="header" href="#atan">ATAN()</a></h3>
<p>返回field value的反正切（以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h4>
<pre><code class="language-sql">SELECT ATAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN(field_key)</code>返回field key对应的field value的反正切。</p>
<p><code>ATAN(*)</code>返回在measurement中每个field key对应的field value的反正切。</p>
<p><code>ATAN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-23"><a class="header" href="#示例-23">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ATAN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切"><a class="header" href="#计算指定field-key对应的field-value的反正切">计算指定field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan
----                 ----
2021-09-11T00:00:00Z 1.5572836357815683
2021-09-11T00:00:00Z 1.5581387749608446
2021-09-11T00:03:00Z 1.5544043524868913
2021-09-11T00:03:00Z 1.5570985534220307
2021-09-11T00:06:00Z 1.5569083308639295
2021-09-11T00:06:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5569083308639295
2021-09-11T00:12:00Z 1.5515679276951893
2021-09-11T00:12:00Z 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683
2021-09-11T00:15:00Z 1.557976516321996
2021-09-11T00:18:00Z 1.5558720618048116
2021-09-11T00:18:00Z 1.5572836357815683
2021-09-11T00:21:00Z 1.5567127509720364
2021-09-11T00:21:00Z 1.5526165117219182
2021-09-11T00:24:00Z 1.5556459709201267
2021-09-11T00:24:00Z 1.5558720618048116
2021-09-11T00:27:00Z 1.5569083308639295
2021-09-11T00:27:00Z 1.5556459709201267
2021-09-11T00:30:00Z 1.5544043524868913
2021-09-11T00:30:00Z 1.5522799247268875
2021-09-11T00:33:00Z 1.5526165117219182
2021-09-11T00:33:00Z 1.557463783500751
2021-09-11T00:36:00Z 1.5554129250143014
2021-09-11T00:36:00Z 1.5556459709201267
2021-09-11T00:39:00Z 1.5560915044170451
2021-09-11T00:39:00Z 1.5535566556003668
2021-09-11T00:42:00Z 1.5538487969884915
2021-09-11T00:42:00Z 1.5535566556003668
2021-09-11T00:45:00Z 1.5563045877293966
2021-09-11T00:45:00Z 1.5567127509720364
2021-09-11T00:48:00Z 1.5563045877293966
2021-09-11T00:48:00Z 1.553254266737494
2021-09-11T00:51:00Z 1.5526165117219182
2021-09-11T00:51:00Z 1.5570985534220307
2021-09-11T00:54:00Z 1.5563045877293966
2021-09-11T00:54:00Z 1.5551725981744198
2021-09-11T00:57:00Z 1.5570985534220307
2021-09-11T00:57:00Z 1.5515679276951893
2021-09-11T01:00:00Z 1.5538487969884915
2021-09-11T01:00:00Z 1.5560915044170451
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正切"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正切">计算measurement中每个field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan_pressure      atan_temperature   atan_visibility
----                 -------------      ----------------   ---------------
2021-09-11T00:00:00Z 1.5544043524868913 1.5572836357815683 1.5526165117219182
2021-09-11T00:00:00Z 1.5576391913221408 1.5581387749608446 1.550798992821746
2021-09-11T00:03:00Z 1.5535566556003668 1.5544043524868913 1.551190995937692
2021-09-11T00:03:00Z 1.5541312030809558 1.5570985534220307 1.5581387749608446
2021-09-11T00:06:00Z 1.5549246438031066 1.5569083308639295 1.5556459709201267
2021-09-11T00:06:00Z 1.557976516321996  1.5544043524868913 1.5541312030809558
2021-09-11T00:09:00Z 1.553254266737494  1.5544043524868913 1.5560915044170451
2021-09-11T00:09:00Z 1.5556459709201267 1.5569083308639295 1.557463783500751
2021-09-11T00:12:00Z 1.5541312030809558 1.5515679276951893 1.5563045877293966
2021-09-11T00:12:00Z 1.550798992821746  1.5535566556003668 1.5565115842075
2021-09-11T00:15:00Z 1.5554129250143014 1.5572836357815683 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683 1.557976516321996  1.557976516321996
2021-09-11T00:18:00Z 1.557463783500751  1.5558720618048116 1.5526165117219182
2021-09-11T00:18:00Z 1.557810043874724  1.5572836357815683 1.551190995937692
2021-09-11T00:21:00Z 1.5544043524868913 1.5567127509720364 1.552941081655344
2021-09-11T00:21:00Z 1.5576391913221408 1.5526165117219182 1.5570985534220307
2021-09-11T00:24:00Z 1.552941081655344  1.5556459709201267 1.5541312030809558
2021-09-11T00:24:00Z 1.5570985534220307 1.5558720618048116 1.550798992821746
2021-09-11T00:27:00Z 1.550798992821746  1.5569083308639295 1.552941081655344
2021-09-11T00:27:00Z 1.5582969777755349 1.5556459709201267 1.5551725981744198
2021-09-11T00:30:00Z 1.5582969777755349 1.5544043524868913 1.5567127509720364
2021-09-11T00:30:00Z 1.5549246438031066 1.5522799247268875 1.5546686929512603
2021-09-11T00:33:00Z 1.5576391913221408 1.5526165117219182 1.5560915044170451
2021-09-11T00:33:00Z 1.5519306407732258 1.557463783500751  1.5560915044170451
2021-09-11T00:36:00Z 1.5558720618048116 1.5554129250143014 1.5519306407732258
2021-09-11T00:36:00Z 1.5560915044170451 1.5556459709201267 1.5563045877293966
2021-09-11T00:39:00Z 1.5526165117219182 1.5560915044170451 1.5567127509720364
2021-09-11T00:39:00Z 1.5563045877293966 1.5535566556003668 1.557810043874724
2021-09-11T00:42:00Z 1.5569083308639295 1.5538487969884915 1.5565115842075
2021-09-11T00:42:00Z 1.5522799247268875 1.5535566556003668 1.5549246438031066
2021-09-11T00:45:00Z 1.557810043874724  1.5563045877293966 1.5576391913221408
2021-09-11T00:45:00Z 1.5560915044170451 1.5567127509720364 1.557810043874724
2021-09-11T00:48:00Z 1.5535566556003668 1.5563045877293966 1.5551725981744198
2021-09-11T00:48:00Z 1.5546686929512603 1.553254266737494  1.5560915044170451
2021-09-11T00:51:00Z 1.5526165117219182 1.5526165117219182 1.5570985534220307
2021-09-11T00:51:00Z 1.557463783500751  1.5570985534220307 1.5572836357815683
2021-09-11T00:54:00Z 1.5563045877293966 1.5563045877293966 1.5558720618048116
2021-09-11T00:54:00Z 1.5538487969884915 1.5551725981744198 1.5544043524868913
2021-09-11T00:57:00Z 1.5565115842075    1.5570985534220307 1.5572836357815683
2021-09-11T00:57:00Z 1.5576391913221408 1.5515679276951893 1.5572836357815683
2021-09-11T01:00:00Z 1.5522799247268875 1.5538487969884915 1.5522799247268875
2021-09-11T01:00:00Z 1.557810043874724  1.5560915044170451 1.5551725981744198
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正切。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正切并包含多个子句">计算指定field key对应的field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan
----                 ----
2021-09-18T23:57:00Z 1.5582969777755349
2021-09-18T23:57:00Z 1.5581387749608446
2021-09-18T23:54:00Z 1.5569083308639295
2021-09-18T23:54:00Z 1.5522799247268875
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-3"><a class="header" href="#高级语法-3">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切。</p>
<p><code>ATAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-24"><a class="header" href="#示例-24">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切"><a class="header" href="#计算平均值的反正切">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 atan
----                 ----
2021-09-09T00:00:00Z 1.5554743016680184
2021-09-12T00:00:00Z 1.5554056912417906
2021-09-15T00:00:00Z 1.555415060964228
2021-09-18T00:00:00Z 1.555490506678637
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正切。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="atan2"><a class="header" href="#atan2">ATAN2()</a></h3>
<p>返回以弧度表示的<code>y/x</code>的反正切。</p>
<h4 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h4>
<pre><code>SELECT ATAN2( [ * | &lt;field_key&gt; | num ], [ &lt;field_key&gt; | num ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN2(field_key_y, field_key_x)</code>返回field key “field_key_y”对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2(*, field_key_x)&lt;br /&gt;</code>返回在measurement中每个field key对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN2()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-25"><a class="header" href="#示例-25">示例</a></h4>
<p>下面的示例将使用如下模拟的飞行数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot;, &quot;pressure&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:15:00Z'
name: air
time                 temperature pressure
----                 ----------- --------
2021-09-06T12:03:00Z 53          78
2021-09-06T12:03:00Z 72          71
2021-09-06T12:06:00Z 69          58
2021-09-06T12:06:00Z 59          76
2021-09-06T12:09:00Z 71          55
2021-09-06T12:09:00Z 57          76
2021-09-06T12:12:00Z 53          75
2021-09-06T12:12:00Z 65          52
2021-09-06T12:15:00Z 69          67
2021-09-06T12:15:00Z 64          56
</code></pre>
<ul>
<li>
<h4 id="计算field_key_y除以field_key_x的反正切"><a class="header" href="#计算field_key_y除以field_key_x的反正切">计算field_key_y除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T13:01:00Z'
name: air
time                 atan2
----                 -----
2021-09-06T12:03:00Z 0.5968259039857009
2021-09-06T12:03:00Z 0.7923910564027816
2021-09-06T12:06:00Z 0.8717967127558954
2021-09-06T12:06:00Z 0.6601315920749263
2021-09-06T12:09:00Z 0.9117062804606886
2021-09-06T12:09:00Z 0.6435011087932844
2021-09-06T12:12:00Z 0.6151862381119739
2021-09-06T12:12:00Z 0.8960553845713439
2021-09-06T12:15:00Z 0.8001029857752997
2021-09-06T12:15:00Z 0.851966327173272
2021-09-06T12:18:00Z 0.6960841704042261
2021-09-06T12:18:00Z 0.8010218920179252
2021-09-06T12:21:00Z 0.7594299761858918
2021-09-06T12:21:00Z 0.7028792089644667
2021-09-06T12:24:00Z 0.812418612584713
2021-09-06T12:24:00Z 0.7309067071567171
2021-09-06T12:27:00Z 0.9948777271765435
2021-09-06T12:27:00Z 0.7546386373269791
2021-09-06T12:30:00Z 0.7785017210090998
2021-09-06T12:30:00Z 0.6435011087932844
2021-09-06T12:33:00Z 0.8960553845713439
2021-09-06T12:33:00Z 0.8007815651780434
2021-09-06T12:36:00Z 0.8498250028230019
2021-09-06T12:36:00Z 0.8736040677941312
2021-09-06T12:39:00Z 0.7168036599431737
2021-09-06T12:39:00Z 0.9296875579351908
2021-09-06T12:42:00Z 0.8633647972289906
2021-09-06T12:42:00Z 0.9437256642058782
2021-09-06T12:45:00Z 0.6215266244966218
2021-09-06T12:45:00Z 0.8152400480645576
2021-09-06T12:48:00Z 0.7378150601204648
2021-09-06T12:48:00Z 0.7638187798309181
2021-09-06T12:51:00Z 0.9179496956941223
2021-09-06T12:51:00Z 0.7935280655773922
2021-09-06T12:54:00Z 0.9572401812829798
2021-09-06T12:54:00Z 0.6593100683328579
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T13:00:00Z 0.8187191592756955
2021-09-06T13:00:00Z 0.8134282033572947
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切。这两个field key都在measurement <code>wind</code>中。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key除以field_key_x的反正切"><a class="header" href="#计算measurement中每个field-key除以field_key_x的反正切">计算measurement中每个field key除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(*, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:06:00Z'
name: air
time                 atan2_pressure     atan2_temperature  atan2_visibility
----                 --------------     -----------------  ----------------
2021-09-06T12:03:00Z 0.7853981633974483 0.5968259039857009 0.60554466360497
2021-09-06T12:03:00Z 0.7853981633974483 0.7923910564027816 0.7257674502662789
2021-09-06T12:06:00Z 0.7853981633974483 0.8717967127558954 0.8645972343668997
2021-09-06T12:06:00Z 0.7853981633974483 0.6601315920749263 0.6435011087932844
</code></pre>
<p>该查询返回measurement <code>wind</code>中每个存储数值的field key对应的field value除以field key <code>pressure</code>对应的field value的反正切。measurement <code>wind</code>中有两个数值类型的field：<code>temperature</code>和<code>pressure</code>。</p>
<ul>
<li>
<h4 id="计算field-value的反正切并包含多个子句"><a class="header" href="#计算field-value的反正切并包含多个子句">计算field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-16T13:01:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan2
----                 -----
2021-09-16T12:57:00Z 0.8773368222796695
2021-09-16T12:57:00Z 0.8114792046882006
2021-09-16T12:54:00Z 0.8007815651780434
2021-09-16T12:54:00Z 1.003258702010146
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-16T12:10:00Z</code>和<code>2020-05-16T12:10:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-4"><a class="header" href="#高级语法-4">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN2(&lt;function()&gt;, &lt;function()&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切(<code>ATAN2()</code>)。</p>
<p>ATAN2()支持以下嵌套函数：</p>
<ul>
<li>COUNT()</li>
<li>MEAN()</li>
<li>MEDIAN()</li>
<li>MODE()</li>
<li>SUM()</li>
<li>FIRST()</li>
<li>LAST()</li>
<li>MIN()</li>
<li>MAX()</li>
<li>PERCENTILE()</li>
</ul>
<h4 id="示例-26"><a class="header" href="#示例-26">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切-1"><a class="header" href="#计算平均值的反正切-1">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 atan2
----                 -----
2021-09-16T12:00:00Z 0.7916716068182019
2021-09-16T12:12:00Z 0.7687819020057319
2021-09-16T12:24:00Z 0.8293469014295621
2021-09-16T12:36:00Z 0.7483094274728471
2021-09-16T12:48:00Z 0.8579805385837196
2021-09-16T13:00:00Z 0.7640815957515122
2021-09-16T13:12:00Z 0.7660813391498594
2021-09-16T13:24:00Z 0.7595170787800846
2021-09-16T13:36:00Z 0.781755192263569
2021-09-16T13:48:00Z 0.8137459550765823
2021-09-16T14:00:00Z 0.7572931159369924
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value的平均值除以field key <code>pressure</code>对应的field value的平均值的反正切。平均值是按每12分钟的时间间隔计算的。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>和<code>pressure</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 mean              mean_1
----                 ----              ------
2021-09-16T12:00:00Z 66.83333333333333 66
2021-09-16T12:12:00Z 62.875            65
2021-09-16T12:24:00Z 68.25             62.5
2021-09-16T12:36:00Z 64.875            69.875
2021-09-16T12:48:00Z 71                61.375
2021-09-16T13:00:00Z 60.25             62.875
2021-09-16T13:12:00Z 66.625            69.25
2021-09-16T13:24:00Z 63.5              66.875
2021-09-16T13:36:00Z 68.375            68.875
2021-09-16T13:48:00Z 68                64.25
2021-09-16T14:00:00Z 60.5              64
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="ceil"><a class="header" href="#ceil">CEIL()</a></h3>
<p>返回大于指定值的最小整数。</p>
<h4 id="基本语法-5"><a class="header" href="#基本语法-5">基本语法</a></h4>
<pre><code>SELECT CEIL( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CEIL(field_key)</code>返回field key对应的大于field value的最小整数。</p>
<p><code>CEIL(*)</code>返回在measurement中每个field key对应的大于field value的最小整数。</p>
<p><code>CEIL()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CEIL()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-27"><a class="header" href="#示例-27">示例</a></h4>
<p>下面的示例将使用<a href="content/cnosdb/latest/cnosql/oceanic_station.txt"><code>oceanic_station</code>数据集</a>的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数">计算指定field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的大于field value的最小整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的大于field-value的最小整数"><a class="header" href="#计算measurement中每个field-key对应的大于field-value的最小整数">计算measurement中每个field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil_pressure ceil_temperature ceil_visibility
----                 ------------- ---------------- ---------------
2021-09-18T00:00:00Z 64            51               68
2021-09-18T00:03:00Z 72            60               74
2021-09-18T00:06:00Z 54            55               77
2021-09-18T00:09:00Z 66            55               55
2021-09-18T00:12:00Z 64            63               70
2021-09-18T00:15:00Z 58            74               62
2021-09-18T00:18:00Z 55            79               54
2021-09-18T00:21:00Z 64            68               58
2021-09-18T00:24:00Z 66            70               69
2021-09-18T00:27:00Z 77            79               78
2021-09-18T00:30:00Z 62            75               80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的大于field value的最小整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数并包含多个子句"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数并包含多个子句">计算指定field key对应的大于field value的最小整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ceil
----                 ----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的大于field value的最小整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-5"><a class="header" href="#高级语法-5">高级语法</a></h4>
<pre><code>SELECT CEIL(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>CEIL()</code>应用于这些结果。</p>
<p><code>CEIL()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-28"><a class="header" href="#示例-28">示例</a></h4>
<ul>
<li>
<h4 id="计算大于平均值的最小整数"><a class="header" href="#计算大于平均值的最小整数">计算大于平均值的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 56
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的大于<code>temperature</code>平均值的最小整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的大于<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CEIL()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算大于这些平均值的最小整数。</p>
</li>
<li>
<h3 id="cos"><a class="header" href="#cos">COS()</a></h3>
<p>返回field value的余弦值。</p>
<h4 id="基本语法-6"><a class="header" href="#基本语法-6">基本语法</a></h4>
<pre><code>SELECT COS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>COS(field_key)</code>返回field key对应的field value的余弦值。</p>
<p><code>COS(*)</code>返回在measurement中每个field key对应的field value的余弦值。</p>
<p><code>COS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>COS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-29"><a class="header" href="#示例-29">示例</a></h4>
<ul>
<li>
<h4 id="下面的示例将使用oceanic_station数据集的如下数据"><a class="header" href="#下面的示例将使用oceanic_station数据集的如下数据">下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值"><a class="header" href="#计算指定field-key对应的field-value的余弦值">计算指定field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.7421541968137826
2021-09-18T00:03:00Z -0.9524129804151563
2021-09-18T00:06:00Z 0.022126756261955732
2021-09-18T00:09:00Z 0.022126756261955732
2021-09-18T00:12:00Z 0.9858965815825497
2021-09-18T00:15:00Z 0.17171734183077755
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:27:00Z -0.8959709467909631
2021-09-18T00:30:00Z 0.9217512697247493
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的余弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的余弦值">计算measurement中每个field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos_pressure          cos_temperature      cos_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.39185723042955      0.7421541968137826   0.4401430224960407
2021-09-18T00:03:00Z -0.9672505882738824   -0.9524129804151563  0.17171734183077755
2021-09-18T00:06:00Z -0.8293098328631501   0.022126756261955732 -0.030975031731216456
2021-09-18T00:09:00Z -0.9996474559663501   0.022126756261955732 0.022126756261955732
2021-09-18T00:12:00Z 0.39185723042955      0.9858965815825497   0.6333192030862999
2021-09-18T00:15:00Z 0.11918013544881928   0.17171734183077755  0.6735071623235862
2021-09-18T00:18:00Z 0.022126756261955732  -0.8959709467909631  -0.8293098328631501
2021-09-18T00:21:00Z 0.39185723042955      0.4401430224960407   0.11918013544881928
2021-09-18T00:24:00Z -0.9996474559663501   0.6333192030862999   0.9933903797222716
2021-09-18T00:27:00Z -0.030975031731216456 -0.8959709467909631  -0.8578030932449878
2021-09-18T00:30:00Z 0.6735071623235862    0.9217512697247493   -0.11038724383904756
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的余弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的余弦值并包含多个子句">计算指定field key对应的field value的余弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cos
----                 ---
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:15:00Z 0.17171734183077755
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-6"><a class="header" href="#高级语法-6">高级语法</a></h4>
<pre><code>SELECT COS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的余弦值。</p>
<p><code>COS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-30"><a class="header" href="#示例-30">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的余弦值"><a class="header" href="#计算平均值的余弦值">计算平均值的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.2687822771684872
2021-09-18T00:12:00Z -0.3090227281660707
2021-09-18T00:24:00Z 0.7441351704799297
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的余弦值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>COS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的余弦值。</p>
</li>
<li>
<h3 id="cumulative_sum"><a class="header" href="#cumulative_sum">CUMULATIVE_SUM()</a></h3>
<p>返回field value的累积总和。</p>
<h4 id="基本语法-7"><a class="header" href="#基本语法-7">基本语法</a></h4>
<pre><code>SELECT CUMULATIVE_SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CUMULATIVE_SUM(field_key)</code>返回field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(*)</code>返回在measurement中每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CUMULATIVE_SUM()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-31"><a class="header" href="#示例-31">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和"><a class="header" href="#计算指定field-key对应的field-value的累积总和">计算指定field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的累积总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的累积总和">计算measurement中每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum_pressure cumulative_sum_temperature cumulative_sum_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:00:00Z 64                      51                         68
2021-09-18T00:03:00Z 136                     111                        142
2021-09-18T00:06:00Z 190                     166                        219
2021-09-18T00:09:00Z 256                     221                        274
2021-09-18T00:12:00Z 320                     284                        344
2021-09-18T00:15:00Z 378                     358                        406
2021-09-18T00:18:00Z 433                     437                        460
2021-09-18T00:21:00Z 497                     505                        518
2021-09-18T00:24:00Z 563                     575                        587
2021-09-18T00:27:00Z 640                     654                        665
2021-09-18T00:30:00Z 702                     729                        745
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的累积总和。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的累积总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的累积总和">计算与正则表达式匹配的每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(/temp/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
time                 cumulative_sum_temperature
----                 --------------------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的累积总和并包含多个子句">计算指定field key对应的field value的累积总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:24:00Z 224
2021-09-18T00:21:00Z 292
2021-09-18T00:18:00Z 371
2021-09-18T00:15:00Z 445
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-7"><a class="header" href="#高级语法-7">高级语法</a></h4>
<pre><code class="language-sql">SELECT CUMULATIVE_SUM(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的累积总和"><a class="header" href="#计算平均值的累积总和">计算平均值的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 126.25
2021-09-18T00:24:00Z 200.91666666666669
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的累积总和。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CUMULATIVE_SUM()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的累积总和。最终查询结果中的第二个<code>point</code>(<code>4.167</code>)是<code>2.09</code>和<code>2.077</code>的总和，第三个<code>point</code>(<code>6.213</code>)是<code>2.09</code>、<code>2.077</code>和<code>2.0460000000000003</code>的总和。</p>
</li>
<li>
<h3 id="derivative"><a class="header" href="#derivative">DERIVATIVE()</a></h3>
<p>返回field value之间的变化率，即导数。</p>
<h4 id="基本语法-8"><a class="header" href="#基本语法-8">基本语法</a></h4>
<pre><code>SELECT DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>DERIVATIVE(field_key)</code>返回field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-32"><a class="header" href="#示例-32">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数"><a class="header" href="#计算指定field-key对应的field-value的导数">计算指定field key对应的field value的导数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 0.05
2021-09-18T00:06:00Z -0.027777777777777776
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0.044444444444444446
2021-09-18T00:15:00Z 0.06111111111111111
2021-09-18T00:18:00Z 0.027777777777777776
2021-09-18T00:21:00Z -0.06111111111111111
2021-09-18T00:24:00Z 0.011111111111111112
2021-09-18T00:27:00Z 0.05
2021-09-18T00:30:00Z -0.022222222222222223
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率。</p>
<p>第一个结果(<code>0.05</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的导数并指定unit"><a class="header" href="#计算指定field-key对应的field-value的导数并指定unit">计算指定field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;,6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 18
2021-09-18T00:06:00Z -10
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 16
2021-09-18T00:15:00Z 22
2021-09-18T00:18:00Z 10
2021-09-18T00:21:00Z -22
2021-09-18T00:24:00Z 4
2021-09-18T00:27:00Z 18
2021-09-18T00:30:00Z -8
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每六分钟的变化率。</p>
<p>第一个结果(<code>0.052000000000000046</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 6m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算measurement中每个field-key对应的field-value的导数并指定unit">计算measurement中每个field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(*,3m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_pressure derivative_temperature derivative_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的每三分钟的变化率。measurement <code>air</code>中数值类型的field：<code>temperature</code>,<code>pressure</code>,<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit">计算与正则表达式匹配的每个field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(/temp/,2m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_temperature
----                 ----------------------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z -3.3333333333333335
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 5.333333333333333
2021-09-18T00:15:00Z 7.333333333333333
2021-09-18T00:18:00Z 3.3333333333333335
2021-09-18T00:21:00Z -7.333333333333333
2021-09-18T00:24:00Z 1.3333333333333333
2021-09-18T00:27:00Z 6
2021-09-18T00:30:00Z -2.6666666666666665
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中的对应field key&quot;temperature&quot;对应的field value的每两分钟的变化率。</p>
<p>第一个结果(<code>6</code>)是原始数据中前两个field value在两分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为两分钟的变化率：</p>
<pre><code>(-3.3333333333333335 6) / (6m / 2m)
--------------            ----------
       |                      |
       |                the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的导数并包含多个子句">计算指定field key对应的field value的导数并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 1 OFFSET 2
name: air
time                 derivative
----                 ----------
2021-09-18T00:21:00Z -0.011111111111111112
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<p>唯一的结果(<code>-0.011111111111111112</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
<h4 id="高级语法-8"><a class="header" href="#高级语法-8">高级语法</a></h4>
<pre><code>SELECT DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。</p>
<p><code>DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的导数"><a class="header" href="#计算平均值的导数">计算平均值的导数</a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -14.25
2021-09-18T00:12:00Z 15.75
2021-09-18T00:24:00Z 3.6666666666666714
</code></pre>
</li>
</ul>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每12分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每12分钟的变化率。第一个结果(<code>55.25</code>)是原始数据中前两个field value在12分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为12分钟的变化率：</p>
<pre><code>(71 - 74.66666666666667)  / (12m / 12m)
-------------                   ----------
       |                           |
       |                     the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算平均值的导数并指定unit"><a class="header" href="#计算平均值的导数并指定unit">计算平均值的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;),6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -7.125
2021-09-18T00:12:00Z 7.875
2021-09-18T00:24:00Z 1.8333333333333357
</code></pre>
</li>
</ul>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每六分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)

name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每六分钟的变化率。第一个结果(<code>-55.25</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code class="language-sql">(71 - 74.66666666666667) / (12m / 6m)
-------------    ----------
       |                         |
       |                    the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h3 id="difference"><a class="header" href="#difference">DIFFERENCE()</a></h3>
<p>返回field value之间的差值。</p>
<h4 id="基本语法-9"><a class="header" href="#基本语法-9">基本语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>DIFFERENCE(field_key)</code>返回field key对应的field value的差值。</p>
<p><code>DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-33"><a class="header" href="#示例-33">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值"><a class="header" href="#计算指定field-key对应的field-value的差值">计算指定field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference
----                 ----------
2021-09-18T00:03:00Z 9
2021-09-18T00:06:00Z -5
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 8
2021-09-18T00:15:00Z 11
2021-09-18T00:18:00Z 5
2021-09-18T00:21:00Z -11
2021-09-18T00:24:00Z 2
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z -4
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的差值"><a class="header" href="#计算measurement中每个field-key对应的field-value的差值">计算measurement中每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_pressure difference_temperature difference_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value之间的差值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的差值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的差值">计算与正则表达式匹配的每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(/visi/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_visibility
----                 ----------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z -22
2021-09-18T00:12:00Z 15
2021-09-18T00:15:00Z -8
2021-09-18T00:18:00Z -8
2021-09-18T00:21:00Z 4
2021-09-18T00:24:00Z 11
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z 2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的差值并包含多个子句">计算指定field key对应的field value的差值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 2 OFFSET 2
name: air
time                 difference
----                 ----------
2021-09-18T00:21:00Z -2
2021-09-18T00:18:00Z 11
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-9"><a class="header" href="#高级语法-9">高级语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的差值。</p>
<p>DIFFERENCE()支持以下嵌套函数：
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-34"><a class="header" href="#示例-34">示例</a></h4>
<ul>
<li>
<h4 id="计算最大值之间的差值"><a class="header" href="#计算最大值之间的差值">计算最大值之间的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(MAX(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 difference
----                 ----------
2021-09-18T00:00:00Z -19
2021-09-18T00:12:00Z 19
2021-09-18T00:24:00Z 0
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值之间的差值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DIFFERENCE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值之间的差值。最终查询结果中的第一个<code>point</code>(<code>0.009999999999999787</code>)是<code>2.126</code>和<code>2.116</code>的差，第二个<code>point</code>(<code>-0.07499999999999973</code>)是<code>2.051</code>和<code>2.126</code>的差。</p>
</li>
<li>
<h3 id="elapsed"><a class="header" href="#elapsed">ELAPSED()</a></h3>
<p>返回field value的时间戳之间的差值。</p>
<h4 id="语法-31"><a class="header" href="#语法-31">语法</a></h4>
<pre><code>SELECT ELAPSED( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算时间戳之间的差值。参数<code>unit</code>的值是一个整数，后跟一个时间单位，它决定了返回的差值的单位。这个参数是可选的，不是必须要有的。如果没有指定<code>unit</code>的值，那么查询将返回以纳秒为单位的两个时间戳之间的差值。</p>
<p><code>ELAPSED(field_key)</code>返回field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(*)</code>返回在measurement中每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED()</code>支持所有数据类型的field value。</p>
<h4 id="示例-35"><a class="header" href="#示例-35">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔">计算指定field key对应的field value之间的时间间隔</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 180000000000
2021-09-18T00:06:00Z 180000000000
2021-09-18T00:09:00Z 180000000000
2021-09-18T00:12:00Z 180000000000
2021-09-18T00:15:00Z 180000000000
2021-09-18T00:18:00Z 180000000000
2021-09-18T00:21:00Z 180000000000
2021-09-18T00:24:00Z 180000000000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以纳秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并指定unit">计算指定field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的时间戳之间的差值(以分钟为单位)。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(/press/,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed_pressure
----                 ----------------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并包含多个子句">计算指定field key对应的field value之间的时间间隔并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1ms) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z' ORDER BY time DESC LIMIT 1 OFFSET 1
name: air
time                 elapsed
----                 -------
2021-09-18T00:18:00Z -180000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以毫秒为单位)，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:12:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移一个（即前一个<code>point</code>不返回）。</p>
<p>请注意，查询结果是负数；因为<code>ORDER BY time DESC</code>子句按递减的顺序对时间戳进行排序，所以<code>ELAPSED()</code>以相反的顺序计算时间戳的差值。</p>
<h4 id="elapsed的常见问题"><a class="header" href="#elapsed的常见问题"><code>ELAPSED()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="elapsed和大于经过时间的单位"><a class="header" href="#elapsed和大于经过时间的单位"><code>ELAPSED()</code>和大于经过时间的单位</a></h4>
</li>
</ul>
<p>I如果<code>unit</code>的值大于时间戳之间的差值，那么CnosDB将会返回<code>0</code>。</p>
<p>measurement <code>air</code>中每六分钟有一个<code>point</code>。如果查询将<code>unit</code>设置为一小时，CnosDB将会返回<code>0</code>：</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1h) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:12:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 0
2021-09-18T00:06:00Z 0
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0
</code></pre>
<ul>
<li>
<h4 id="elapsed和group-by-time子句同时使用"><a class="header" href="#elapsed和group-by-time子句同时使用"><code>ELAPSED()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p><code>ELAPSED()</code>函数支持<code>GROUP BY time()</code>子句，但是查询结果不是特别有用。目前，如果<code>ELAPSED()</code>查询包含一个嵌套的CnosQL函数和一个<code>GROUP BY time()</code>子句，那么只会返回指定<code>GROUP BY time()</code>子句中的时间间隔。</p>
<p><code>GROUP BY time()</code>子句决定了查询结果中的时间戳：每个时间戳表示时间间隔的开始时间。该行为也适用于嵌套的selector函数(例如<code>FIRST()</code>或<code>MAX()</code>)，而在其它的所有情况下，这些函数返回的是原始数据的特定时间戳。因为<code>GROUP BY time()</code>子句会覆盖原始时间戳，所以<code>ELAPSED()</code>始终返回与<code>GROUP BY time()</code>的时间间隔相同的时间戳。</p>
<p>下面代码块中的第一个查询尝试使用<code>ELAPSED()</code>和<code>GROUP BY time()</code>子句来查找最小的<code>temperature</code>的值之间经过的时间(以分钟为单位)。查询的两个时间间隔都返回了12分钟。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔的<code>temperature</code>的最小值。代码块中的第二个查询展示了这一步的结果。这一步跟同时使用<code>MIN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ELAPSED()</code>的情形一样。请注意，第二个查询返回的时间戳间隔12分钟。在原始数据中，第一个结果(<code>2.057</code>)发生在<code>2020-08-18T00:42:00Z</code>，但是<code>GROUP BY time()</code>子句覆盖了原始的时间戳。因为时间戳由<code>GROUP BY time()</code>的时间间隔(而不是原始数据)决定，所以<code>ELAPSED()</code>始终返回与GROUP BY time()的时间间隔相同的时间戳。</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(MIN(&quot;temperature&quot;),1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 elapsed
----                 -------
2021-09-08T00:36:00Z 12
2021-09-08T00:48:00Z 12

&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 min
----                 ---
2021-09-08T00:36:00Z 50
2021-09-08T00:48:00Z 73  &lt;--- Actually occurs at 2021-09-08T00:48:00Z
</code></pre>
</li>
<li>
<h3 id="exp"><a class="header" href="#exp">EXP()</a></h3>
<p>返回field value的指数。</p>
<h4 id="基本语法-10"><a class="header" href="#基本语法-10">基本语法</a></h4>
<pre><code>SELECT EXP( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>EXP(field_key)</code>返回field key对应的field value的指数。</p>
<p><code>EXP(*)</code>返回在measurement中每个field key对应的field value的指数。</p>
<p><code>EXP()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>EXP()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-36"><a class="header" href="#示例-36">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.85.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数"><a class="header" href="#计算指定field-key对应的field-value的指数">计算指定field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 1.4093490824269389e+22
2021-09-18T00:03:00Z 1.1420073898156842e+26
2021-09-18T00:06:00Z 7.694785265142018e+23
2021-09-18T00:09:00Z 7.694785265142018e+23
2021-09-18T00:12:00Z 2.29378315946961e+27
2021-09-18T00:15:00Z 1.3733829795401763e+32
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:27:00Z 2.0382810665126688e+34
2021-09-18T00:30:00Z 3.7332419967990015e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的指数"><a class="header" href="#计算measurement中每个field-key对应的field-value的指数">计算measurement中每个field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp_pressure           exp_temperature        exp_visibility
----                 ------------           ---------------        --------------
2021-09-18T00:00:00Z 6.235149080811617e+27  1.4093490824269389e+22 3.404276049931741e+29
2021-09-18T00:03:00Z 1.8586717452841279e+31 1.1420073898156842e+26 1.3733829795401763e+32
2021-09-18T00:06:00Z 2.830753303274694e+23  7.694785265142018e+23  2.7585134545231703e+33
2021-09-18T00:09:00Z 4.607186634331292e+28  7.694785265142018e+23  7.694785265142018e+23
2021-09-18T00:12:00Z 6.235149080811617e+27  2.29378315946961e+27   2.515438670919167e+30
2021-09-18T00:15:00Z 1.545538935590104e+25  1.3733829795401763e+32 8.438356668741455e+26
2021-09-18T00:18:00Z 7.694785265142018e+23  2.0382810665126688e+34 2.830753303274694e+23
2021-09-18T00:21:00Z 6.235149080811617e+27  3.404276049931741e+29  1.545538935590104e+25
2021-09-18T00:24:00Z 4.607186634331292e+28  2.515438670919167e+30  9.253781725587789e+29
2021-09-18T00:27:00Z 2.7585134545231703e+33 2.0382810665126688e+34 7.49841699699012e+33
2021-09-18T00:30:00Z 8.438356668741455e+26  3.7332419967990015e+32 5.54062238439351e+34
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的指数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的指数并包含多个子句">计算指定field key对应的field value的指数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 exp
----                 ---
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:15:00Z 1.3733829795401763e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-10"><a class="header" href="#高级语法-10">高级语法</a></h4>
<pre><code>SELECT EXP(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的指数。</p>
<p>EXP()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-37"><a class="header" href="#示例-37">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的指数"><a class="header" href="#计算平均值的指数">计算平均值的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 9.880299856396672e+23
2021-09-18T00:12:00Z 6.837671229762744e+30
2021-09-18T00:24:00Z 2.674984780655511e+32
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>EXP()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>.然后，CnosDB计算这些平均值的指数。</p>
<h3 id="floor"><a class="header" href="#floor">FLOOR()</a></h3>
<p>返回小于指定值的最大整数。</p>
<h4 id="基本语法-11"><a class="header" href="#基本语法-11">基本语法</a></h4>
<pre><code>SELECT FLOOR( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>FLOOR(field_key)</code>返回field key对应的小于field value的最大整数。</p>
<p><code>FLOOR(*)</code>返回在measurement中每个field key对应的小于field value的最大整数。</p>
<p><code>FLOOR()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>FLOOR()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-38"><a class="header" href="#示例-38">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数">计算指定field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的小于field value的最大整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的小于field-value的最大整数"><a class="header" href="#计算measurement中每个field-key对应的小于field-value的最大整数">计算measurement中每个field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor_pressure floor_temperature floor_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的小于field value的最大整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数并包含多个子句"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数并包含多个子句">计算指定field key对应的小于field value的最大整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 floor
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的小于field value的最大整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-11"><a class="header" href="#高级语法-11">高级语法</a></h4>
<pre><code>SELECT FLOOR(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>FLOOR()</code>应用于这些结果。</p>
<p><code>FLOOR()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算小于平均值的最大整数"><a class="header" href="#计算小于平均值的最大整数">计算小于平均值的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的小于<code>temperature</code>平均值的最大整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>FLOOR()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算小于这些平均值的最大整数。</p>
</li>
<li>
<h3 id="ln"><a class="header" href="#ln">LN()</a></h3>
<p>返回field value的自然对数。</p>
<h4 id="基本语法-12"><a class="header" href="#基本语法-12">基本语法</a></h4>
<pre><code>SELECT LN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LN(field_key)</code>返回field key对应的field value的自然对数。</p>
<p><code>LN(*)</code>返回在measurement中每个field key对应的field value的自然对数。</p>
<p><code>LN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-39"><a class="header" href="#示例-39">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.86.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数"><a class="header" href="#计算指定field-key对应的field-value的自然对数">计算指定field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 3.9318256327243257
2021-09-18T00:03:00Z 4.0943445622221
2021-09-18T00:06:00Z 4.007333185232471
2021-09-18T00:09:00Z 4.007333185232471
2021-09-18T00:12:00Z 4.143134726391533
2021-09-18T00:15:00Z 4.304065093204169
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:27:00Z 4.3694478524670215
2021-09-18T00:30:00Z 4.31748811353631
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的自然对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的自然对数">计算measurement中每个field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln_pressure        ln_temperature     ln_visibility
----                 -----------        --------------     -------------
2021-09-18T00:00:00Z 4.1588830833596715 3.9318256327243257 4.219507705176107
2021-09-18T00:03:00Z 4.276666119016055  4.0943445622221    4.304065093204169
2021-09-18T00:06:00Z 3.9889840465642745 4.007333185232471  4.343805421853684
2021-09-18T00:09:00Z 4.189654742026425  4.007333185232471  4.007333185232471
2021-09-18T00:12:00Z 4.1588830833596715 4.143134726391533  4.248495242049359
2021-09-18T00:15:00Z 4.060443010546419  4.304065093204169  4.127134385045092
2021-09-18T00:18:00Z 4.007333185232471  4.3694478524670215 3.9889840465642745
2021-09-18T00:21:00Z 4.1588830833596715 4.219507705176107  4.060443010546419
2021-09-18T00:24:00Z 4.189654742026425  4.248495242049359  4.23410650459726
2021-09-18T00:27:00Z 4.343805421853684  4.3694478524670215 4.356708826689592
2021-09-18T00:30:00Z 4.127134385045092  4.31748811353631   4.382026634673881
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的自然对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的自然对数并包含多个子句">计算指定field key对应的field value的自然对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ln
----                 --
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:15:00Z 4.304065093204169
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-12"><a class="header" href="#高级语法-12">高级语法</a></h4>
<pre><code>SELECT LN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个 GROUP BY time() <code>和一个嵌套的CnosQL 函数. 该查询受限以指定</code>GROUP BY time()<code>间隔计算嵌套函数的结果 </code>LN()` .</p>
<p>LN()支持以下嵌套函数：</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a>,
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a>, and
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>.</p>
</li>
</ul>
<h4 id="示例-40"><a class="header" href="#示例-40">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的自然对数"><a class="header" href="#计算平均值的自然对数">计算平均值的自然对数</a></h4>
<pre><code class="language-sql">&gt; SELECT LN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 4.0118683403978626
2021-09-18T00:12:00Z 4.2626798770413155
2021-09-18T00:24:00Z 4.31303376318693
</code></pre>
</li>
</ul>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的自然对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的自然对数。</p>
<ul>
<li>
<h3 id="log"><a class="header" href="#log">LOG()</a></h3>
<p>返回field value的以<code>b</code>为底数的对数。</p>
<h4 id="基本语法-13"><a class="header" href="#基本语法-13">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG( [ * | &lt;field_key&gt; ], &lt;b&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG(field_key, b)</code>返回field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG(*, b)</code>返回在measurement中每个field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.87.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数">计算指定field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.836212670985748
2021-09-18T00:03:00Z 2.9534452978042594
2021-09-18T00:06:00Z 2.89067985676233
2021-09-18T00:09:00Z 2.89067985676233
2021-09-18T00:12:00Z 2.9886399617499584
2021-09-18T00:15:00Z 3.1047266828144746
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:27:00Z 3.1518903740885515
2021-09-18T00:30:00Z 3.11440934524794
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以4为底数的对数">计算measurement中每个field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log_pressure       log_temperature    log_visibility
----                 ------------       ---------------    --------------
2021-09-18T00:00:00Z 3                  2.836212670985748  3.04373142062517
2021-09-18T00:03:00Z 3.084962500721156  2.9534452978042594 3.1047266828144746
2021-09-18T00:06:00Z 2.8774437510817346 2.89067985676233   3.133393270347451
2021-09-18T00:09:00Z 3.0221970596792267 2.89067985676233   2.89067985676233
2021-09-18T00:12:00Z 3                  2.9886399617499584 3.0646415084724836
2021-09-18T00:15:00Z 2.928990497563786  3.1047266828144746 2.977098155193438
2021-09-18T00:18:00Z 2.89067985676233   3.1518903740885515 2.8774437510817346
2021-09-18T00:21:00Z 3                  3.04373142062517   2.928990497563786
2021-09-18T00:24:00Z 3.0221970596792267 3.0646415084724836 3.054262228389085
2021-09-18T00:27:00Z 3.133393270347451  3.1518903740885515 3.1427011094311244
2021-09-18T00:30:00Z 2.977098155193438  3.11440934524794   3.160964047443681
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以4为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数并包含多个子句">计算指定field key对应的field value的以4为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log
----                 ---
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:15:00Z 3.1047266828144746
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-13"><a class="header" href="#高级语法-13">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;b&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的对数。</p>
<p><code>LOG()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以4为底数的对数"><a class="header" href="#计算平均值的以4为底数的对数">计算平均值的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.8939512796957163
2021-09-18T00:12:00Z 3.074873559752341
2021-09-18T00:24:00Z 3.1111962106682243
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以4为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以4为底数的对数。</p>
</li>
<li>
<h3 id="log2"><a class="header" href="#log2">LOG2()</a></h3>
<p>返回field value的以2为底数的对数。</p>
<h4 id="基本语法-14"><a class="header" href="#基本语法-14">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG2( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG2(field_key)</code>返回field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2(*)</code>返回在measurement中每个field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG2()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.88.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数">计算指定field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.672425341971495
2021-09-18T00:03:00Z 5.906890595608519
2021-09-18T00:06:00Z 5.78135971352466
2021-09-18T00:09:00Z 5.78135971352466
2021-09-18T00:12:00Z 5.977279923499917
2021-09-18T00:15:00Z 6.20945336562895
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:27:00Z 6.303780748177103
2021-09-18T00:30:00Z 6.22881869049588
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以2为底数的对数">计算measurement中每个field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2_pressure     log2_temperature  log2_visibility
----                 -------------     ----------------  ---------------
2021-09-18T00:00:00Z 6                 5.672425341971495 6.087462841250339
2021-09-18T00:03:00Z 6.169925001442312 5.906890595608519 6.20945336562895
2021-09-18T00:06:00Z 5.754887502163468 5.78135971352466  6.266786540694901
2021-09-18T00:09:00Z 6.044394119358453 5.78135971352466  5.78135971352466
2021-09-18T00:12:00Z 6                 5.977279923499917 6.129283016944966
2021-09-18T00:15:00Z 5.857980995127572 6.20945336562895  5.954196310386875
2021-09-18T00:18:00Z 5.78135971352466  6.303780748177103 5.754887502163468
2021-09-18T00:21:00Z 6                 6.087462841250339 5.857980995127572
2021-09-18T00:24:00Z 6.044394119358453 6.129283016944966 6.108524456778169
2021-09-18T00:27:00Z 6.266786540694901 6.303780748177103 6.285402218862249
2021-09-18T00:30:00Z 5.954196310386875 6.22881869049588  6.321928094887363
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以2为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数并包含多个子句">计算指定field key对应的field value的以2为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log2
----                 ----
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:15:00Z 6.20945336562895
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-14"><a class="header" href="#高级语法-14">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG2(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以2为底数的对数。</p>
<p><code>LOG2()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以2为底数的对数"><a class="header" href="#计算平均值的以2为底数的对数">计算平均值的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.787902559391432
2021-09-18T00:12:00Z 6.149747119504682
2021-09-18T00:24:00Z 6.222392421336448
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以2为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以2为底数的对数。</p>
</li>
<li>
<h3 id="log10"><a class="header" href="#log10">LOG10()</a></h3>
<p>返回field value的以10为底数的对数。</p>
<h4 id="基本语法-15"><a class="header" href="#基本语法-15">基本语法</a></h4>
<pre><code>SELECT LOG10( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG10(field_key)</code>返回field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10(*)</code>返回在measurement中每个field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG10()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.89.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数">计算指定field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7075701760979363
2021-09-18T00:03:00Z 1.7781512503836434
2021-09-18T00:06:00Z 1.7403626894942439
2021-09-18T00:09:00Z 1.7403626894942439
2021-09-18T00:12:00Z 1.7993405494535817
2021-09-18T00:15:00Z 1.869231719730976
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:27:00Z 1.8976270912904414
2021-09-18T00:30:00Z 1.8750612633916999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以10为底数的对数">计算measurement中每个field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10_pressure     log10_temperature  log10_visibility
----                 --------------     -----------------  ----------------
2021-09-18T00:00:00Z 1.806179973983887  1.7075701760979363 1.8325089127062364
2021-09-18T00:03:00Z 1.8573324964312685 1.7781512503836434 1.869231719730976
2021-09-18T00:06:00Z 1.7323937598229686 1.7403626894942439 1.8864907251724818
2021-09-18T00:09:00Z 1.8195439355418686 1.7403626894942439 1.7403626894942439
2021-09-18T00:12:00Z 1.806179973983887  1.7993405494535817 1.845098040014257
2021-09-18T00:15:00Z 1.7634279935629371 1.869231719730976  1.792391689498254
2021-09-18T00:18:00Z 1.7403626894942439 1.8976270912904414 1.7323937598229686
2021-09-18T00:21:00Z 1.806179973983887  1.8325089127062364 1.7634279935629371
2021-09-18T00:24:00Z 1.8195439355418686 1.845098040014257  1.8388490907372554
2021-09-18T00:27:00Z 1.8864907251724818 1.8976270912904414 1.8920946026904804
2021-09-18T00:30:00Z 1.792391689498254  1.8750612633916999 1.9030899869919433
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以10为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数并包含多个子句">计算指定field key对应的field value的以10为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log10
----                 -----
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:15:00Z 1.869231719730976
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-15"><a class="header" href="#高级语法-15">高级语法</a></h4>
<pre><code>SELECT LOG10(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以10为底数的对数。</p>
<p><code>LOG10()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以10为底数的对数"><a class="header" href="#计算平均值的以10为底数的对数">计算平均值的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7423322823571483
2021-09-18T00:12:00Z 1.8512583487190752
2021-09-18T00:24:00Z 1.8731267636145004
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以10为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG10()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以10为底数的对数。</p>
</li>
<li>
<h3 id="moving_average"><a class="header" href="#moving_average">MOVING_AVERAGE()</a></h3>
<p>返回field value窗口的滚动平均值。</p>
<h4 id="基本语法-16"><a class="header" href="#基本语法-16">基本语法</a></h4>
<pre><code class="language-sql">SELECT MOVING_AVERAGE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] , &lt;N&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MOVING_AVERAGE()</code>计算包含<code>N</code>个连续field value的窗口的滚动平均值。参数<code>N</code>是一个整数，并且它是必须的。</p>
<p><code>MOVING_AVERAGE(field_key,N)</code>返回field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(*,N)</code>返回在measurement中每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>MOVING_AVERAGE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值">计算指定field key对应的field value的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average
----                 --------------
2021-09-18T00:03:00Z 55.5
2021-09-18T00:06:00Z 57.5
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 59
2021-09-18T00:15:00Z 68.5
2021-09-18T00:18:00Z 76.5
2021-09-18T00:21:00Z 73.5
2021-09-18T00:24:00Z 69
2021-09-18T00:27:00Z 74.5
2021-09-18T00:30:00Z 77
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值。第一个结果(<code>2.09</code>)是原始数据中前两个field value的平均值：(2.064 + 2.116) / 2。第二个结果(<code>2.072</code>)是原始数据中第二和第三个field value的平均值：(2.116 + 2.028) / 2。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的滚动平均值">计算measurement中每个field key对应的field value的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(*,3) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure moving_average_temperature moving_average_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:06:00Z 63.333333333333336      55.333333333333336         73
2021-09-18T00:09:00Z 64                      56.666666666666664         68.66666666666667
2021-09-18T00:12:00Z 61.333333333333336      57.666666666666664         67.33333333333333
2021-09-18T00:15:00Z 62.666666666666664      64                         62.333333333333336
2021-09-18T00:18:00Z 59                      72                         62
2021-09-18T00:21:00Z 59                      73.66666666666667          58
2021-09-18T00:24:00Z 61.666666666666664      72.33333333333333          60.333333333333336
2021-09-18T00:27:00Z 69                      72.33333333333333          68.33333333333333
2021-09-18T00:30:00Z 68.33333333333333       74.66666666666667          75.66666666666667
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的窗口大小为三个field value的滚动平均值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值">计算与正则表达式匹配的每个field key对应的field value的滚动平均值</a></h4>
<pre><code>&gt; SELECT MOVING_AVERAGE(/press/,4) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure
----                 -----------------------
2021-09-18T00:09:00Z 64
2021-09-18T00:12:00Z 64
2021-09-18T00:15:00Z 60.5
2021-09-18T00:18:00Z 60.75
2021-09-18T00:21:00Z 60.25
2021-09-18T00:24:00Z 60.75
2021-09-18T00:27:00Z 65.5
2021-09-18T00:30:00Z 67.25
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>level</code>的field key对应的窗口大小为四个field value的滚动平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值并包含多个子句">计算指定field key对应的field value的滚动平均值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 2 OFFSET 3
name: air
time                 moving_average
----                 --------------
2021-09-18T00:18:00Z 73.5
2021-09-18T00:15:00Z 76.5
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移三个(即前三个<code>point</code>不返回）。</p>
<h4 id="高级语法-16"><a class="header" href="#高级语法-16">高级语法</a></h4>
<pre><code>SELECT MOVING_AVERAGE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) , N ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算最大值的滚动平均值"><a class="header" href="#计算最大值的滚动平均值">计算最大值的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(MAX(&quot;temperature&quot;),2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 moving_average
----                 --------------
2021-09-18T00:00:00Z 69.5
2021-09-18T00:12:00Z 69.5
2021-09-18T00:24:00Z 79
</code></pre>
</li>
</ul>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的最大值的窗口大小为两个值的滚动平均值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>MOVING_AVERAGE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值的窗口大小为两个值的滚动平均值。最终查询结果中的第一个<code>point</code>(<code>2.121</code>)是前两个最大值的平均值(<code>(2.116 + 2.126) / 2</code>)。</p>
<ul>
<li>
<h3 id="non_negative_derivative"><a class="header" href="#non_negative_derivative">NON_NEGATIVE_DERIVATIVE()</a></h3>
<p>返回field value之间的非负变化率。非负变化率包括正的变化率和等于0的变化率。</p>
<h4 id="基本语法-17"><a class="header" href="#基本语法-17">基本语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(field_key)</code>返回field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
<h4 id="高级语法-17"><a class="header" href="#高级语法-17">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的非负导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a>
####示例</li>
</ul>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
</li>
<li>
<h3 id="non_negative_difference"><a class="header" href="#non_negative_difference">NON_NEGATIVE_DIFFERENCE()</a></h3>
<p>返回field value之间的非负差值。非负差值包括正的差值和等于0的差值。</p>
<h4 id="基本语法-18"><a class="header" href="#基本语法-18">基本语法</a></h4>
<pre><code>SELECT NON_NEGATIVE_DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>NON_NEGATIVE_DIFFERENCE(field_key)</code>返回field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
<h4 id="高级语法-18"><a class="header" href="#高级语法-18">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的非负差值。</p>
<p>`NON_NEGATIVE_DIFFERENCE()支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
</li>
<li>
<h3 id="pow"><a class="header" href="#pow">POW()</a></h3>
<p>返回field value的<code>x</code>次方。</p>
<h4 id="基本语法-19"><a class="header" href="#基本语法-19">基本语法</a></h4>
<pre><code>SELECT POW( [ * | &lt;field_key&gt; ], &lt;x&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>POW(field_key, x)</code>返回field key对应的field value的<code>x</code>次方。</p>
<p><code>POW(*, x)</code>返回在measurement中每个field key对应的field value的<code>x</code>次方。</p>
<p><code>POW()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>POW()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.90.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方"><a class="header" href="#计算指定field-key对应的field-value的4次方">计算指定field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 6765201
2021-09-18T00:03:00Z 12960000
2021-09-18T00:06:00Z 9150625
2021-09-18T00:09:00Z 9150625
2021-09-18T00:12:00Z 15752961
2021-09-18T00:15:00Z 29986576
2021-09-18T00:18:00Z 38950081
2021-09-18T00:21:00Z 21381376
2021-09-18T00:24:00Z 24010000
2021-09-18T00:27:00Z 38950081
2021-09-18T00:30:00Z 31640625
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的4次方"><a class="header" href="#计算measurement中每个field-key对应的field-value的4次方">计算measurement中每个field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow_pressure pow_temperature pow_visibility
----                 ------------ --------------- --------------
2021-09-18T00:00:00Z 16777216     6765201         21381376
2021-09-18T00:03:00Z 26873856     12960000        29986576
2021-09-18T00:06:00Z 8503056      9150625         35153041
2021-09-18T00:09:00Z 18974736     9150625         9150625
2021-09-18T00:12:00Z 16777216     15752961        24010000
2021-09-18T00:15:00Z 11316496     29986576        14776336
2021-09-18T00:18:00Z 9150625      38950081        8503056
2021-09-18T00:21:00Z 16777216     21381376        11316496
2021-09-18T00:24:00Z 18974736     24010000        22667121
2021-09-18T00:27:00Z 35153041     38950081        37015056
2021-09-18T00:30:00Z 14776336     31640625        40960000
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的4次方。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的4次方并包含多个子句">计算指定field key对应的field value的4次方并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 pow
----                 ---
2021-09-18T00:24:00Z 24010000
2021-09-18T00:21:00Z 21381376
2021-09-18T00:18:00Z 38950081
2021-09-18T00:15:00Z 29986576
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-19"><a class="header" href="#高级语法-19">高级语法</a></h4>
<pre><code class="language-sql">SELECT POW(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;x&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的<code>x</code>次方。</p>
<p><code>POW()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的4次方"><a class="header" href="#计算平均值的4次方">计算平均值的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 9318137.81640625
2021-09-18T00:12:00Z 25411681
2021-09-18T00:24:00Z 31081863.901234582
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的4次方。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>POW()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的4次方。</p>
</li>
<li>
<h3 id="round"><a class="header" href="#round">ROUND()</a></h3>
<p>返回指定值的四舍五入后的整数。</p>
<h4 id="基本语法-20"><a class="header" href="#基本语法-20">基本语法</a></h4>
<pre><code>SELECT ROUND( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ROUND(field_key)</code>返回field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND(*)</code>返回在measurement中每个field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ROUND()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.91.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数">计算指定field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算measurement中每个field-key对应的field-value四舍五入后的整数">计算measurement中每个field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round_pressure round_temperature round_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数并包含多个子句">计算指定field key对应的field value四舍五入后的整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 round
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-20"><a class="header" href="#高级语法-20">高级语法</a></h4>
<pre><code class="language-sql">SELECT ROUND(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果四舍五入后的整数。</p>
<p><code>ROUND()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值四舍五入后的整数"><a class="header" href="#计算平均值四舍五入后的整数">计算平均值四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值四舍五入后的整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ROUND()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值四舍五入后的整数。</p>
</li>
<li>
<h3 id="sin"><a class="header" href="#sin">SIN()</a></h3>
<p>返回field value的正弦值。</p>
<h4 id="基本语法-21"><a class="header" href="#基本语法-21">基本语法</a></h4>
<pre><code class="language-sql">SELECT SIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SIN(field_key)</code>返回field key对应的field value的正弦值。</p>
<p><code>SIN(*)</code>返回在measurement中每个field key对应的field value的正弦值。</p>
<p><code>SIN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SIN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值"><a class="header" href="#计算指定field-key对应的field-value的正弦值">计算指定field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z 0.6702291758433747
2021-09-18T00:03:00Z -0.3048106211022167
2021-09-18T00:06:00Z -0.9997551733586199
2021-09-18T00:09:00Z -0.9997551733586199
2021-09-18T00:12:00Z 0.16735570030280694
2021-09-18T00:15:00Z -0.9851462604682474
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:27:00Z -0.4441126687075084
2021-09-18T00:30:00Z -0.38778163540943045
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正弦值">计算measurement中每个field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin_pressure          sin_temperature      sin_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.9200260381967907    0.6702291758433747   -0.8979276806892912
2021-09-18T00:03:00Z 0.25382336276203626   -0.3048106211022167  -0.9851462604682474
2021-09-18T00:06:00Z -0.5587890488516162   -0.9997551733586199  0.9995201585807312
2021-09-18T00:09:00Z -0.026551154023966794 -0.9997551733586199  -0.9997551733586199
2021-09-18T00:12:00Z 0.9200260381967907    0.16735570030280694  0.7738906815578891
2021-09-18T00:15:00Z 0.9928726480845371    -0.9851462604682474  -0.7391806966492229
2021-09-18T00:18:00Z -0.9997551733586199   -0.4441126687075084  -0.5587890488516162
2021-09-18T00:21:00Z 0.9200260381967907    -0.8979276806892912  0.9928726480845371
2021-09-18T00:24:00Z -0.026551154023966794 0.7738906815578891   -0.11478481378318722
2021-09-18T00:27:00Z 0.9995201585807312    -0.4441126687075084  0.5139784559875352
2021-09-18T00:30:00Z -0.7391806966492229   -0.38778163540943045 -0.9938886539233751
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正弦值并包含多个子句">计算指定field key对应的field value的正弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sin
----                 ---
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:15:00Z -0.9851462604682474
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-21"><a class="header" href="#高级语法-21">高级语法</a></h4>
<pre><code class="language-sql">SELECT SIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正弦值。</p>
<p><code>SIN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值"><a class="header" href="#计算平均值的正弦值">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z -0.9632009590319781
2021-09-18T00:12:00Z 0.9510546532543747
2021-09-18T00:24:00Z -0.6680290772524845
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正弦值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正弦值。</p>
</li>
<li>
<h3 id="sqrt"><a class="header" href="#sqrt">SQRT()</a></h3>
<p>返回field value的平方根。</p>
<h4 id="基本语法-22"><a class="header" href="#基本语法-22">基本语法</a></h4>
<pre><code>SELECT SQRT( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SQRT(field_key)</code>返回field key对应的field value的平方根。</p>
<p><code>SQRT(*)</code>返回在measurement中每个field key对应的field value的平方根。</p>
<p><code>SQRT()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SQRT()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用”oceanic_station”数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根"><a class="header" href="#计算指定field-key对应的field-value的平方根">计算指定field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.14142842854285
2021-09-18T00:03:00Z 7.745966692414834
2021-09-18T00:06:00Z 7.416198487095663
2021-09-18T00:09:00Z 7.416198487095663
2021-09-18T00:12:00Z 7.937253933193772
2021-09-18T00:15:00Z 8.602325267042627
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:27:00Z 8.888194417315589
2021-09-18T00:30:00Z 8.660254037844387
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平方根"><a class="header" href="#计算measurement中每个field-key对应的field-value的平方根">计算measurement中每个field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt_pressure      sqrt_temperature  sqrt_visibility
----                 -------------      ----------------  ---------------
2021-09-18T00:00:00Z 8                  7.14142842854285  8.246211251235321
2021-09-18T00:03:00Z 8.48528137423857   7.745966692414834 8.602325267042627
2021-09-18T00:06:00Z 7.3484692283495345 7.416198487095663 8.774964387392123
2021-09-18T00:09:00Z 8.12403840463596   7.416198487095663 7.416198487095663
2021-09-18T00:12:00Z 8                  7.937253933193772 8.366600265340756
2021-09-18T00:15:00Z 7.615773105863909  8.602325267042627 7.874007874011811
2021-09-18T00:18:00Z 7.416198487095663  8.888194417315589 7.3484692283495345
2021-09-18T00:21:00Z 8                  8.246211251235321 7.615773105863909
2021-09-18T00:24:00Z 8.12403840463596   8.366600265340756 8.306623862918075
2021-09-18T00:27:00Z 8.774964387392123  8.888194417315589 8.831760866327848
2021-09-18T00:30:00Z 7.874007874011811  8.660254037844387 8.94427190999916
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的平方根。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平方根并包含多个子句">计算指定field key对应的field value的平方根并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sqrt
----                 ----
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:15:00Z 8.602325267042627
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-22"><a class="header" href="#高级语法-22">高级语法</a></h4>
<pre><code>SELECT SQRT(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的平方根。</p>
<p><code>SQRT()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的平方根"><a class="header" href="#计算平均值的平方根">计算平均值的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.433034373659253
2021-09-18T00:12:00Z 8.426149773176359
2021-09-18T00:24:00Z 8.640987597877148
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的平方根。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SQRT()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的平方根。</p>
</li>
<li>
<h3 id="tan"><a class="header" href="#tan">TAN()</a></h3>
<p>返回field value的正切值。</p>
<h4 id="基本语法-23"><a class="header" href="#基本语法-23">基本语法</a></h4>
<pre><code>SELECT TAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TAN(field_key)</code>返回field key对应的field value的正切值。</p>
<p><code>TAN(*)</code>返回在measurement中每个field key对应的field value的正切值。</p>
<p><code>TAN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>TAN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值"><a class="header" href="#计算指定field-key对应的field-value的正切值">计算指定field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z 0.9030861493754311
2021-09-18T00:03:00Z 0.320040389379563
2021-09-18T00:06:00Z -45.18308791052113
2021-09-18T00:09:00Z -45.18308791052113
2021-09-18T00:12:00Z 0.16974975208268753
2021-09-18T00:15:00Z -5.737022539278999
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:27:00Z 0.49567753318135577
2021-09-18T00:30:00Z -0.42070095062112434
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正切值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正切值">计算measurement中每个field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan_pressure         tan_temperature      tan_visibility
----                 ------------         ---------------      --------------
2021-09-18T00:00:00Z 2.3478603091954366   0.9030861493754311   -2.040081598015946
2021-09-18T00:03:00Z -0.26241737750193517 0.320040389379563    -5.737022539278999
2021-09-18T00:06:00Z 0.6738001006480597   -45.18308791052113   -32.268575775934416
2021-09-18T00:09:00Z 0.026560517776039395 -45.18308791052113   -45.18308791052113
2021-09-18T00:12:00Z 2.3478603091954366   0.16974975208268753  1.2219599181369432
2021-09-18T00:15:00Z 8.33085685249046     -5.737022539278999   -1.0975097786622852
2021-09-18T00:18:00Z -45.18308791052113   0.49567753318135577  0.6738001006480597
2021-09-18T00:21:00Z 2.3478603091954366   -2.040081598015946   8.33085685249046
2021-09-18T00:24:00Z 0.026560517776039395 1.2219599181369432   -0.11554854579453279
2021-09-18T00:27:00Z -32.268575775934416  0.49567753318135577  -0.5991799983411151
2021-09-18T00:30:00Z -1.0975097786622852  -0.42070095062112434 9.00365494560708
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正切值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正切值并包含多个子句">计算指定field key对应的field value的正切值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 tan
----                 ---
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:15:00Z -5.737022539278999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-23"><a class="header" href="#高级语法-23">高级语法</a></h4>
<pre><code class="language-sql">SELECT TAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正切值。</p>
<p><code>TAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mean"><code>MEAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#median"><code>MEDIAN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#mode"><code>MODE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#sum"><code>SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#first"><code>FIRST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#last"><code>LAST()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#min"><code>MIN()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#max"><code>MAX()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值-1"><a class="header" href="#计算平均值的正弦值-1">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z -3.583573177439047
2021-09-18T00:12:00Z -3.0776204031933605
2021-09-18T00:24:00Z -0.8977254452596822
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正切值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>TAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正切值。</p>
</li>
</ul>
<h3 id="预测函数"><a class="header" href="#预测函数">预测函数</a></h3>
<ul>
<li>
<h3 id="holt_winters"><a class="header" href="#holt_winters">HOLT_WINTERS()</a></h3>
<ul>
<li>
<p>使用<a href="https://www.otexts.org/fpp/7/5?spm=a2c4g.11186623.2.92.41fc3ee27HC1R6">Holt-Winters</a>的季节性方法返回N个预测的field value。</p>
<p><code>HOLT_WINTERS()</code>可用于：</p>
<ul>
<li>预测时间什么时候会超过给定的阈值</li>
<li>将预测值与实际值进行比较，检测数据中的异常</li>
</ul>
</li>
</ul>
<h4 id="语法-32"><a class="header" href="#语法-32">语法</a></h4>
<pre><code>SELECT HOLT_WINTERS[_WITH-FIT](&lt;function&gt;(&lt;field_key&gt;),&lt;N&gt;,&lt;S&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>HOLT_WINTERS(function(field_key),N,S)</code>返回field key对应的<code>N</code>个季节性调整的预测field value。</p>
<p><code>N</code>个预测值出现的时间间隔跟group by time时间间隔相同。如果您的<code>GROUP BY time()</code>时间间隔是<code>6m</code>并且<code>N</code>等于<code>3</code>，那么您将会得到3个时间间隔为6分钟的预测值。</p>
<p><code>S</code>是一个季节性模式参数，并且根据<code>GROUP BY time()</code>时间间隔限定一个季节性模式的长度。如果您的<code>GROUP BY time()</code>时间间隔是<code>2m</code>并且<code>S</code>等于<code>3</code>，那么这个季节性模式每六分钟出现一次，也就是每三个<code>point</code>。如果您不希望季节性调整您的预测值，请将<code>S</code>设置为<code>0</code>或<code>1</code>。</p>
<p><code>HOLT_WINTERS_WITH_FIT(function(field_key),N,S)</code>除了返回field key对应的<code>N</code>个季节性调整的预测field value，还返回拟合值。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>处理以相同的时间间隔出现的数据；嵌套的CnosQL函数和<code>GROUP BY time()</code>子句确保Holt-Winters函数能够对常规数据进行操作。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-41"><a class="header" href="#示例-41">示例</a></h4>
<ul>
<li>
<h4 id="预测指定field-key的field-value"><a class="header" href="#预测指定field-key的field-value">预测指定field key的field value</a></h4>
</li>
<li>
<h4 id="原始数据"><a class="header" href="#原始数据">原始数据</a></h4>
</li>
</ul>
<p>该示例重点关注<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">SELECT &quot;temperature&quot; FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00'
</code></pre>
<ul>
<li>
<h4 id="步骤一匹配原始数据的趋势"><a class="header" href="#步骤一匹配原始数据的趋势">步骤一：匹配原始数据的趋势</a></h4>
</li>
</ul>
<p>编写一个<code>GROUP BY time()</code>查询，使得它匹配原始<code>temperature</code>数据的总体趋势。这里，我们使用了<code>FIRST()</code>函数：</p>
<pre><code class="language-sql">SELECT FIRST(&quot;temperature&quot;) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' and time &gt;= '2021-09-12 12:12:00' and time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>GROUP BY time()</code>子句中，第一个参数(<code>379m</code>)匹配<code>temperature</code>数据中每个波峰和波谷之间发生的时间长度，第二个参数(<code>348m</code>)是一个偏移间隔，它通过改变CnosDB的默认<code>GROUP BY time()</code>边界来匹配原始数据的时间范围。</p>
<ul>
<li>
<h4 id="步骤二确定季节性模式"><a class="header" href="#步骤二确定季节性模式">步骤二：确定季节性模式</a></h4>
</li>
</ul>
<p>使用步骤一中查询的信息确定数据中的季节性模式。</p>
<ul>
<li>
<h4 id="步骤三应用holt_winters函数"><a class="header" href="#步骤三应用holt_winters函数">步骤三：应用<code>HOLT_WINTERS()</code>函数</a></h4>
</li>
</ul>
<p>在查询中加入Holt-Winters函数。这里，我们使用<code>HOLT_WINTERS_WITH_FIT()</code>来查看拟合值和预测值：</p>
<pre><code class="language-sql">SELECT HOLT_WINTERS_WITH_FIT(FIRST(&quot;temperature&quot;),10,4) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>HOLT_WINTERS_WITH_FIT()</code>函数中，第一个参数(<code>10</code>)请求10个预测的field value。每个预测的<code>point</code>相距<code>379m</code>，与<code>GROUP BY time()</code>子句中的第一个参数相同。<code>HOLT_WINTERS_WITH_FIT()</code>函数中的第二个参数(<code>4</code>)是我们在上一步骤中确定的季节性模式。</p>
<h4 id="holt_winters的常见问题"><a class="header" href="#holt_winters的常见问题"><code>HOLT_WINTERS()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="holt_winters和收到的point少于n个"><a class="header" href="#holt_winters和收到的point少于n个"><code>HOLT_WINTERS()</code>和收到的<code>point</code>少于”N”个</a></h4>
</li>
</ul>
<p>在某些情况下，用户可能会收到比参数<code>N</code>请求的更少的预测<code>point</code>。当数学计算不稳定和不能预测更多<code>point</code>时，这种情况就会发生。这意味着该数据集不适合使用<code>HOLT_WINTERS()</code>，或者，季节性调整参数是无效的并且是算法混乱。</p>
</li>
</ul>
<h3 id="分析函数"><a class="header" href="#分析函数">分析函数</a></h3>
<p>下面技术分析的函数将广泛使用的算法应用在您的数据中。虽然这些函数主要应用在金融和投资领域，但是它们也适用于其它行业和用例。</p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></p>
<ul>
<li>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>除了field key，技术分析函数还接受以下参数：</p>
<p><code>PERIOD</code></p>
<p><strong>必需，整数，min=1</strong></p>
<p>算法的样本大小。这基本上是对算法的输出有显著影响的历史样本的数量。例如，<code>2</code>表示当前的<code>point</code>和前一个<code>point</code>。算法使用指数衰减率来决定历史<code>point</code>的权重，通常称为<code>alpha(α)</code>。参数<code>PERIOD</code>控制衰减率。</p>
<blockquote>
<p>请注意，历史<code>point</code>仍然可以产生影响。</p>
</blockquote>
<h4 id="hold_period"><a class="header" href="#hold_period">HOLD_PERIOD</a></h4>
<p><strong>整数，min=-1</strong></p>
<p>算法需要多少个样本才会开始发送结果。默认值<code>-1</code>表示该参数的值基于算法、<code>PERIOD</code>和<code>WARMUP_TYPE</code>，但是这是一个可以使算法发送有意义的结果的值。</p>
<p><strong>默认的Hold Periods：</strong></p>
<p>对于大多数提供的技术分析，<code>HOLD_PERIOD</code>的默认值由您使用的技术分析算法和<code>WARMUP_TYPE</code>决定。</p>
</li>
</ul>
<table><thead><tr><th>算法 \ Warmup Type</th><th>simple</th><th>exponential</th><th style="text-align: center">none</th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE</a></td><td>PERIOD - 1</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 2</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 3</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE</a></td><td>( PERIOD - 1 ) * 3 + 1</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#relative_strength_index">RELATIVE_STRENGTH_INDEX</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center">PERIOD - 1</td></tr>
</tbody></table>
<p><em><strong>Kaufman算法默认的Hold Periods：</strong></em></p>
<table><thead><tr><th>算法</th><th>默认的Hold Period</th></tr></thead><tbody>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></td><td>PERIOD</td></tr>
<tr><td><a href="content/cnosdb/latest/cnosql/cnosql_function.html#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></td><td>PERIOD</td></tr>
</tbody></table>
<h4 id="warmup_type"><a class="header" href="#warmup_type">WARMUP_TYPE</a></h4>
<p><strong>默认=”exponential”</strong></p>
<p>这个参数控制算法如何为第一个<code>PERIOD</code>样本初始化自身，它本质上是具有不完整样本集的持续时间。</p>
<p><code>simple</code>
第一个<code>PERIOD</code>样本的简单移动平均值(simple moving average，SMA)。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.106.41fc3ee27HC1R6">ta-lib</a>使用的方法。</p>
<p><code>exponential</code>
具有缩放alpha(α)的指数移动平均值(exponential moving average，EMA)。基本上是这样使用EMA：<code>PERIOD=1</code>用于第一个点，<code>PERIOD=2</code>用于第二个点，以此类推，直至算法已经消耗了<code>PERIOD</code>个<code>point</code>。由于算法一开始就使用了EMA，当使用此方法并且没有指定<code>HOLD_PERIOD</code>的值或<code>HOLD_PERIOD</code>的值为<code>-1</code>时，算法可能会在比<code>simple</code>小得多的样本大小的情况下开始发送<code>point</code>。</p>
<p><code>none</code>
算法不执行任何的平滑操作。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.107.41fc3ee27HC1R6">ta-lib</a>使用的方法。当使用此方法并且没有指定<code>HOLD_PERIOD</code>时，<code>HOLD_PERIOD</code>的默认值是<code>PERIOD - 1</code>。</p>
<blockquote>
<p>类型<code>none</code>仅适用于<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数。</p>
</blockquote>
<ul>
<li>
<h3 id="chande_momentum_oscillator"><a class="header" href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></h3>
<p>Chande Momentum Oscillator (CMO)是由Tushar Chande开发的一个技术动量指标。通过计算所有最近较高<code>point</code>的总和与所有最近较低<code>point</code>的总和的差值，然后将结果除以给定时间范围内的所有数据变动的总和来创建CMO指标。将结果乘以100可以得到一个从-100到+100的范围。
<sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo" target="\_blank">Source</a></p>
<h4 id="基本语法-24"><a class="header" href="#基本语法-24">基本语法</a></h4>
<pre><code>CHANDE_MOMENTUM_OSCILLATOR([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;, [warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup-type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 2)</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 10, 9, 'none')</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>none</code>。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用CMO算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(/regular_expression/, 2)</code>返回使用CMO算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(*, 2)</code>返回使用CMO算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="exponential_moving_average"><a class="header" href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>指数移动平均值 (Exponential Moving Average，EMA)类似于简单移动平均值，不同的是，指数移动平均值对最新数据给予更多的权重，它也被称为”指数加权移动平均值”。与简单移动平均值相比，这种类型的移动平均值对最近数据的变化反应更快。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/e/ema.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-25"><a class="header" href="#基本语法-25">基本语法</a></h4>
<pre><code>EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用参数:</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用EMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用EMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用EMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="double_exponential_moving_average"><a class="header" href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>双重指数移动平均值 (Double Exponential Moving Average，DEMA)通过增加最近数据的权重，尝试消除与移动平均值相关的固有滞后。该名字似乎表明这是通过双重指数平滑来实现的，然而事实并非如此，它表示的是将EMA的值翻倍。为了使它与实际数据保持一致，也为了消除滞后，从之前两倍EMA的值中把”EMA of EMA”的值减去，公式为：DEMA = 2 * EMA - EMA(EMA)。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Double_exponential_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-26"><a class="header" href="#基本语法-26">基本语法</a></h4>
<pre><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用DEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用DEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用DEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="kaufmans_efficiency_ratio"><a class="header" href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></h3>
<p>Kaufman效率比 (Kaufman’s Efficiency Ration)，或简称为效率比 (Efficiency Ratio，ER)，它的计算方法是：将一段时间内的数据变化除以实现该变化所发生的数据变动的绝对值的总和。得出的比率在0和1之间，比率越高，表示市场越有效率或越有趋势。</p>
</li>
</ul>
<p>ER跟Chande Momentum Oscillator (CMO)非常类似。不同的是，CMO将市场方向考虑在内，但是如果您将CMO的绝对值除以100，就可以得到ER。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://etfhq.com/blog/2011/02/07/kaufmans-efficiency-ratio/" target="\_blank">Source</a></p>
<h4 id="基本语法-27"><a class="header" href="#基本语法-27">基本语法</a></h4>
<pre><code class="language-sql">KAUFMANS_EFFICIENCY_RATIO([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 2)</code>返回使用效率指数(Efficiency Index)算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 10, 10)</code>返回使用效率指数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用效率指数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_EFFICIENCY_RATIO()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_EFFICIENCY_RATIO(/regular_expression/, 2)</code>返回使用效率指数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(*, 2)</code>返回使用效率指数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO()</code>支持数据类型为int64和float64的field value。</p>
<ul>
<li>
<h3 id="kaufmans_adaptive_moving_average"><a class="header" href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></h3>
<p>Kaufman自适应移动平均值 (Kaufman’s Adaptive Moving Average，KAMA)，是一个用于计算样本噪音或波动率的移动平均值。当数据波动相对较小并且噪音较低时，KAMA会密切关注<code>point</code>。当数据波动较大时，KAMA会进行调整，平滑噪音。该趋势跟踪指标可用于识别总体趋势、时间转折点和过滤价格变动。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:kaufman_s_adaptive_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-28"><a class="header" href="#基本语法-28">基本语法</a></h4>
<pre><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 2)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 10, 10)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用KAMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用KAMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(*, 2)</code>返回使用KAMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_moving_average"><a class="header" href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>三重指数移动平均值 (Triple Exponential Moving Average，TEMA)，旨在过滤常规移动平均值的波动。该名字似乎表明这是通过三重指数平滑来实现的，然而事实并非如此，它实际上是包含指数移动平均值、双重指数移动平均值和三重指数移动平均值的复合函数。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/t/triple-exponential-moving-average.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-29"><a class="header" href="#基本语法-29">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用TEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用TEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用TEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_derivative"><a class="header" href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></h3>
<p>三重指数导数指标 (Triple Exponential Derivative Indicator)，通常称为”TRIX”，是一种用于识别超卖和超买市场的振荡器，也可用作动量指标。TRIX计算一段时间内输入数据的对数的三重指数移动平均值。从当前的值中减去之前的值，这可以防止指标考虑比规定期间短的周期。</p>
</li>
</ul>
<p>跟很多振荡器一样，TRIX围绕着零线震荡。当它用作振荡器时，正数表示炒买超买市场，而负数表示超卖市场。当它用作动量指标时，正数表示动量在增加，而负数表示动量在减少。很多分析师认为，当TRIX超过零线时，它会给出买入信号，当低于零线时，它会给出卖出信号。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/articles/technical/02/092402.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-30"><a class="header" href="#基本语法-30">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_DERIVATIVE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 2)</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 10, 10, 'exponential')</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用三重指数导数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(/regular_expression/, 2)</code>返回使用三重指数导数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(*, 2)</code>返回使用三重指数导数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<ul>
<li>
<h3 id="relative_strength_index"><a class="header" href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></h3>
<p>相对强弱指数 (Relative Strength Index，RSI)是一个动量指标，用于比较在指定时间段内最近数据增大和减小的幅度，以便measurement数据变动的速度和变化。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/r/rsi.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-31"><a class="header" href="#基本语法-31">基本语法</a></h4>
<pre><code>RELATIVE_STRENGTH_INDEX([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="content/cnosdb/latest/cnosql/cnosql_function.html#period">period</a>
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">hold_period</a> （可选项）
<a href="content/cnosdb/latest/cnosql/cnosql_function.html#warmup_type">warmup_type</a> （可选项）</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 2)</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 10, 10, 'exponential')</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>RELATIVE_STRENGTH_INDEX(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用RSI算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>RELATIVE_STRENGTH_INDEX()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>RELATIVE_STRENGTH_INDEX(/regular_expression/, 2)</code>返回使用RSI算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(*, 2)</code>返回使用RSI算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<h4 id="示例数据-1"><a class="header" href="#示例数据-1">示例数据</a></h4>
<p>本文档使用的数据可在<a href="content/cnosdb/latest/cnosql/oceanic_station.txt">示例数据</a>中下载。</p>
<h4 id="函数的通用语法"><a class="header" href="#函数的通用语法">函数的通用语法</a></h4>
<ul>
<li>
<h4 id="在select中指定多个函数"><a class="header" href="#在select中指定多个函数">在<code>SELECT</code>中指定多个函数</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;(),&lt;function&gt;() FROM_clause [...]
</code></pre>
<p>使用逗号(<code>,</code>)将<code>SELECT</code>语句中的多个函数分开。该语法适用于除<code>TOP()</code>和<code>BOTTOM()</code>之外的所有CnosQL函数。<code>SELECT</code>子句不支持<code>TOP()</code>或<code>BOTTOM()</code>和其它函数同时使用。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的平均值和平均数"><a class="header" href="#在一个查询中计算field-value的平均值和平均数">在一个查询中计算field value的平均值和平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;),MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mean              median
----                 ----              ------
1970-01-01T00:00:00Z 64.94933267424616 65
</code></pre>
<p>该查询返回<code>temperature</code>的平均值和平均数。</p>
<ul>
<li>
<h4 id="在一个查询中计算两个field的mode"><a class="header" href="#在一个查询中计算两个field的mode">在一个查询中计算两个field的mode</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;),MODE(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 mode mode_1
----                 ---- ------
1970-01-01T00:00:00Z 53
</code></pre>
<p>该查询返回<code>temperature</code>中出现频率最高的field value和<code>pressure</code>中出现频率最高的field value。<code>temperature</code>对应的值在列<code>mode</code>中，<code>pressure</code>对应的值在列<code>mode_1</code>中。因为系统不能返回多个具有相同名字的列，所以它将第二个列<code>mode</code>重命名为<code>mode_1</code>。</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的最小值和最大值"><a class="header" href="#在一个查询中计算field-value的最小值和最大值">在一个查询中计算field value的最小值和最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;), MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min max
----                 --- ---
1970-01-01T00:00:00Z 50  80
</code></pre>
<p>该查询返回<code>temperature</code>的最小值和最大值。</p>
<p>请注意，该查询返回<code>1970-01-01T00:00:00Z</code>作为时间戳，这是CnosDB的空时间戳。<code>MIN()</code>和<code>MAX()</code>是selector函数；当selector函数是<code>SELECT</code>子句中的唯一函数时，它返回一个特定的时间戳。因为<code>MIN()</code>和<code>MAX()</code>返回两个不同的时间戳（见下面的例子），所以系统会用空时间戳覆盖这些时间戳。</p>
<pre><code class="language-sql">&gt;  SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  min
----                  ---
2021-08-31T16:18:00Z  50    &lt;--- Timestamp 1

&gt;  SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2021-08-31T18:03:00Z  80    &lt;--- Timestamp 2
</code></pre>
<h4 id="重命名查询结果字段"><a class="header" href="#重命名查询结果字段">重命名查询结果字段</a></h4>
<ul>
<li>
<h4 id="语法-33"><a class="header" href="#语法-33">语法</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;() AS &lt;field_key&gt; [...]
</code></pre>
<p>默认情况下，函数返回的结果在与函数名称匹配的field key下面。使用<code>AS</code>子句可以指定输出的field key的名字。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="指定输出的field-key"><a class="header" href="#指定输出的field-key">指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) AS &quot;dream_name&quot; FROM &quot;air&quot;
name: air
time                  dream_name
----                  ----------
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<p>该查询返回<code>temperature</code>的平均值，并将输出的field key重命名为<code>dream_name</code>。如果没有<code>AS</code>子句，那么查询会返回<code>mean</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  mean
----                  ----
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<ul>
<li>
<h4 id="为多个函数指定输出的field-key"><a class="header" href="#为多个函数指定输出的field-key">为多个函数指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) AS &quot;med_wat&quot;,MODE(&quot;temperature&quot;) AS &quot;mode_wat&quot; FROM &quot;air&quot;
name: air
time                 med_wat mode_wat
----                 ------- --------
1970-01-01T00:00:00Z 65      53
</code></pre>
<p>该查询返回<code>temperature</code>的平均数和<code>temperature</code>中出现频率最高的field value，并将输出的field key分别重命名为<code>med_wat</code>和<code>mode_wat</code>。如果没有<code>AS</code>子句，那么查询会返回<code>median</code>和<code>mode</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;),MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 median mode
----                 ------ ----
1970-01-01T00:00:00Z 65     53
</code></pre>
<h4 id="改变不含数据的时间间隔的返回值"><a class="header" href="#改变不含数据的时间间隔的返回值">改变不含数据的时间间隔的返回值</a></h4>
<p>默认情况下，包含CnosQL函数和<code>GROUP BY time()</code>子句的查询对不包含数据的时间间隔返回空值。在<code>GROUP BY</code>子句后面加上<code>fill()</code>可以更改这个值。关于<code>fill()</code>的详细讨论，请查看数据探索。</p>
<h4 id="函数的常见问题"><a class="header" href="#函数的常见问题">函数的常见问题</a></h4>
<p>以下部分描述了所有函数、聚合函数和选择函数的常见混淆来源，有关单个功能的常见问题，请参见以下特定文档：</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-distinct">DISTINCT()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-bottom">BOTTOM()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-percentile">PERCENTILE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-sample">SAMPLE()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-top">TOP()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-elapsed">ELAPSED()</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#common-issues-with-holt-winters">HOLT_WINTERS()</a></li>
</ul>
<h4 id="所有函数"><a class="header" href="#所有函数">所有函数</a></h4>
<ul>
<li>
<h4 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h4>
</li>
</ul>
</li>
</ul>
<p>某些CnosQL 函数支持 <a href="content/cnosdb/latest/cnosql//cnosdb/v1.8/query_language/explore-data/#select-clause"><code>SELECT</code> clause</a>中嵌套:</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#count"><code>COUNT()</code></a> with <a href="content/cnosdb/latest/cnosql/cnosql_function.html#distinct"><code>DISTINCT()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#cumulative-sum"><code>CUMULATIVE_SUM()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#derivative"><code>DERIVATIVE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#difference"><code>DIFFERENCE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#elapsed"><code>ELAPSED()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#moving-average"><code>MOVING_AVERAGE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#non-negative-derivative"><code>NON_NEGATIVE_DERIVATIVE()</code></a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_function.html#holt-winters"><code>HOLT_WINTERS()</code></a> and <a href="content/cnosdb/latest/cnosql/cnosql_function.html#holt-winters"><code>HOLT_WINTERS_WITH_FIT()</code></a></li>
</ul>
<ul>
<li>
<h4 id="查询在now之后的时间范围"><a class="header" href="#查询在now之后的时间范围">查询在now()之后的时间范围</a></h4>
</li>
</ul>
<p>大多数<code>SELECT</code>语句的默认时间范围在<code>1677-09-21 00:12:43.145224194</code> UTC和<code>2262-04-11T23:47:16.854775806Z</code> UTC之间。对于包含CnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询，默认的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。</p>
<p>如果要查询时间戳发生在<code>now()</code>之后的数据，那么包含CnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询必须在<code>WHERE</code>子句中提供一个时间上限。请查看常见问题。</p>
<h4 id="聚合函数-1"><a class="header" href="#聚合函数-1">聚合函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳"><a class="header" href="#理解返回的时间戳">理解返回的时间戳</a></h4>
</li>
</ul>
<p>子句中具有 <a href="content/cnosdb/latest/cnosql/cnosql_function.html#aggregations">聚合函数</a> 且 <code>WHERE</code>没有时间范围的查询讲返回 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间戳.
CnosDB 使用 epoch 0 作为等效的空时间戳.
带有聚合函数的查询，如果 <code>WHERE</code> 子句中包含时间范围，将返回时间下限作为时间戳.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用聚合函数并且没有指定时间范围"><a class="header" href="#使用聚合函数并且没有指定时间范围">使用聚合函数并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 1839495
</code></pre>
</li>
</ul>
<p>该查询将CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为时间戳返回。<code>SUM()</code>将多个<code>point</code>聚合，没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围"><a class="header" href="#使用聚合函数并且指定时间范围">使用聚合函数并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 134766
</code></pre>
</li>
</ul>
<p>该查询将时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为时间戳返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围和使用group-by-time子句"><a class="header" href="#使用聚合函数并且指定时间范围和使用group-by-time子句">使用聚合函数并且指定时间范围和使用GROUP BY time()子句</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:28:00Z' GROUP BY time(12m)
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 490
2021-09-28T00:12:00Z 524
2021-09-28T00:24:00Z 263
</code></pre>
</li>
</ul>
<p>该查询将每个<code>GROUP BY time()</code>间隔的时间下界作为时间戳返回。</p>
<ul>
<li>
<h4 id="将聚合函数和不聚合的数据混合使用"><a class="header" href="#将聚合函数和不聚合的数据混合使用">将聚合函数和不聚合的数据混合使用</a></h4>
</li>
</ul>
<p>聚合函数不支持在<code>SELECT</code>语句中指定不使用聚合函数的单独的field key或tag key。聚合函数返回一个计算结果，对于没有被聚合的field或tag，没有明显的单个值可以返回。当<code>SELECT</code>语句同时包含聚合函数和单独的field key或tag key时，会返回错误：</p>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;),&quot;station&quot; FROM &quot;air&quot;
ERR: mixing aggregate and non-aggregate queries is not supported
</code></pre>
<ul>
<li>
<h4 id="得到略有不同的结果"><a class="header" href="#得到略有不同的结果">得到略有不同的结果</a></h4>
</li>
</ul>
<p>对于某些聚合函数，在相同的<code>point</code>（数据类型为float64)上执行相同的函数，可能会产生稍微不同的结果。在应用聚合函数之间，CnosDB不会将<code>point</code>进行排序；该行为可能会导致查询结果中出现小小的差异。</p>
<h4 id="selector函数"><a class="header" href="#selector函数">Selector函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳-1"><a class="header" href="#理解返回的时间戳-1">理解返回的时间戳</a></h4>
</li>
</ul>
<p>selector函数返回的时间戳依赖查询中函数的数量和查询中的其它子句：</p>
<p>带有单个选择器函数，单个 field key 参数和无 <code>GROUP BY time()</code> 的查询返回原始数据中出现的point时间戳.
具有单个 selector 函数, 多个 <code>field key</code> 参数的查询, <code>GROUP BY time()</code> 返回原始数据中出现的point 时间戳，或与空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>)等价的CnosDB.</p>
<p><code>WHERE</code>子句中有多个函数且没有时间范围的查询将返回相当于空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>).
在 <code>WHERE</code>子句中包含多个函数和时间范围的查询将时间下限作为时间戳返回</p>
<p>带有 selector 函数和  <code>GROUP BY time()</code> 子句的查询返回每个 <code>GROUP BY time()</code>间隔的时间下限.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用单个selector函数和单个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和单个field-key并且没有指定时间范围">使用单个selector函数和单个field key，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964

&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 max
----                 ---
2021-09-28T01:57:00Z 80
</code></pre>
</li>
</ul>
<p>该查询返回原始数据中具有<code>最大</code>值的<code>point</code>的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数和多个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和多个field-key并且没有指定时间范围">使用单个selector函数和多个field key，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;
name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71

&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80

</code></pre>
</li>
</ul>
<p>第一个查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>FIRST(*)</code>返回两个时间戳（对应measurement <code>air</code>中的每个field key），所以系统使用空时间戳覆盖这两个时间戳。</p>
<p>第二个查询返回原始数据中具有最大值的<code>point</code>的时间戳。因为<code>MAX(*)</code>只返回一个时间戳(measurement <code>air</code>中只有一个数值类型的field)，所以系统不会覆盖原始时间戳。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且没有指定时间范围"><a class="header" href="#使用多个selector函数并且没有指定时间范围">使用多个selector函数，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max min
----                 --- ---
1970-01-01T00:00:00Z 80  50 
</code></pre>
</li>
</ul>
<p>该查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>MAX()</code>和<code>MIN()</code>函数返回不同的时间戳，所以系统没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且指定时间范围"><a class="header" href="#使用多个selector函数并且指定时间范围">使用多个selector函数，并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
  name: air
  time                 max min
  ----                 --- ---
  2021-09-28T00:00:00Z 80  50
</code></pre>
</li>
</ul>
<p>该查询返回时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为查询结果中的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数并且指定时间范围"><a class="header" href="#使用单个selector函数并且指定时间范围">使用单个selector函数，并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:18:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 80
2021-09-18T00:12:00Z 797
</code></pre>
</li>
</ul>
<p>该查询返回每个<code>GROUP BY time()</code>间隔的时间下限作为查询结果中的时间戳。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="连续查询"><a class="header" href="#连续查询">连续查询</a></h1>
<blockquote>
<p>注意：以下将连续查询（Continuous Queries）简称为CQ</p>
</blockquote>
<ul>
<li>
<p><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">基本语法示例</a></p>
</li>
<li>
<p><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">高级语法示例</a></p>
</li>
<li>
<p><a href="content/cnosdb/latest/cnosql/continuous_queries.html#%E7%AE%A1%E7%90%86cq">管理CQ</a></p>
</li>
</ul>
<h3 id="语法-34"><a class="header" href="#语法-34">语法</a></h3>
<h4 id="基本语法-32"><a class="header" href="#基本语法-32">基本语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<p><strong>语法描述</strong></p>
<p>CQ查询必须包含一个函数，一个<code>INTO</code>子句和一个<code>GROUP BY time()</code>子句：</p>
<pre><code class="language-sql">SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</code></pre>
<blockquote>
<p>在<code>WHERE</code>子句中，不需要指定时间范围，CQ查询会为语句自动匹配时间范围</p>
</blockquote>
<h4 id="基本语法示例"><a class="header" href="#基本语法示例">基本语法示例</a></h4>
<p>以下示例使用数据库<code>transportation</code>中的示例数据，<code>bus_data</code>中存储的数据是公交车乘客数量和投诉数量的15分钟数：</p>
<pre><code class="language-sql">name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-08-31T16:00:00Z 78       LianYunGang 63          71
2021-08-31T16:00:00Z 75       XiaoMaiDao  79          68
2021-08-31T16:03:00Z 50       LianYunGang 52          53
2021-08-31T16:03:00Z 73       XiaoMaiDao  70          55
2021-08-31T16:06:00Z 60       LianYunGang 52          75
2021-08-31T16:06:00Z 58       XiaoMaiDao  77          79
2021-08-31T16:09:00Z 58       LianYunGang 73          65
2021-08-31T16:09:00Z 63       XiaoMaiDao  54          70
2021-08-31T16:12:00Z 50       LianYunGang 73          69
2021-08-31T16:12:00Z 73       XiaoMaiDao  77          63
...
</code></pre>
<p><strong>自动采样数据</strong></p>
<p>使用CQ自动从单个字段下采样数据，并将结果写入到同一个数据库的另一个<code>measurement</code>中：</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic&quot; ON &quot;oceanic_station&quot;
BEGIN
  SELECT mean(&quot;temperature&quot;) INTO &quot;average_air_temperatures&quot; FROM &quot;air&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">  &gt; SELECT * FROM &quot;average_air_temperatures&quot;
name: average_air_temperatures
time                 mean
----                 ----
2021-08-31T16:00:00Z 63.65
2021-08-31T17:00:00Z 63.3
2021-08-31T18:00:00Z 65.65
2021-08-31T19:00:00Z 61.425
2021-08-31T20:00:00Z 65.775
2021-08-31T21:00:00Z 64.45
2021-08-31T22:00:00Z 65.1
2021-08-31T23:00:00Z 64.95
2021-09-01T00:00:00Z 63.525
2021-09-01T01:00:00Z 66.125
...
</code></pre>
<p><strong>自动采样数据并将结果保存到另一个保留策略中</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_rp&quot; ON &quot;oceanic_station&quot;
BEGIN
  SELECT mean(&quot;temperature&quot;) INTO &quot;oceanic_station&quot;.&quot;one_year&quot;.&quot;average_air_temperatures_1year&quot; FROM &quot;air&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;oceanic_station&quot;.&quot;one_year&quot;.&quot;average_air_temperatures_1year&quot;
name: average_air_temperatures_1year
time                 mean
----                 ----
2021-08-31T16:00:00Z 63.65
2021-08-31T17:00:00Z 63.3
2021-08-31T18:00:00Z 65.65
2021-08-31T19:00:00Z 61.425
2021-08-31T20:00:00Z 65.775
...
</code></pre>
<p><strong>使用通配符自动下采样数据</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_br&quot; ON &quot;oceanic_station&quot;
BEGIN
  SELECT mean(*) INTO &quot;downsampled_oceanic&quot;.&quot;autogen&quot;.:MEASUREMENT FROM /.*/ GROUP BY time(168h),*
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;downsampled_oceanic&quot;.&quot;autogen&quot;.&quot;air&quot;
name: air
time                 mean_pressure     mean_temperature  mean_visibility   station
----                 -------------     ----------------  ---------------   -------
2021-08-26T00:00:00Z 64.5890625        64.4625           64.575            LianYunGang
2021-08-26T00:00:00Z 65.2546875        64.4765625        64.7109375        XiaoMaiDao
2021-09-02T00:00:00Z 65.06517857142858 64.80208333333333 65.0014880952381  LianYunGang
2021-09-02T00:00:00Z 64.86964285714286 64.93988095238095 64.93690476190476 XiaoMaiDao
2021-09-09T00:00:00Z 65.02410714285715 65.13988095238095 65.05684523809524 LianYunGang
2021-09-09T00:00:00Z 65.06607142857143 64.99732142857142 64.91964285714286 XiaoMaiDao
2021-09-16T00:00:00Z 65.13690476190476 64.99464285714286 65.08660714285715 LianYunGang
2021-09-16T00:00:00Z 65.13660714285714 65.09285714285714 64.95446428571428 XiaoMaiDao
2021-09-23T00:00:00Z 64.76636904761905 65.04642857142858 65.01726190476191 LianYunGang
2021-09-23T00:00:00Z 65.03333333333333 64.77708333333334 64.8202380952381  XiaoMaiDao
2021-09-30T00:00:00Z 64.1358024691358  65.01234567901234 64.20987654320987 LianYunGang
2021-09-30T00:00:00Z 64.54320987654322 64.35802469135803 65.06172839506173 XiaoMaiDao
</code></pre>
<p><strong>自动采样数据并配置CQ的时间边界</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_offset&quot; ON &quot;oceanic_station&quot;
BEGIN
  SELECT mean(&quot;temperature&quot;) INTO &quot;average_air_temperatures_offset&quot; FROM &quot;air&quot; GROUP BY time(1h,15m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">name: average_air_temperatures_offset
time                 mean
----                 ----
2021-08-26T00:03:00Z 64.47581903276131
2021-09-02T00:03:00Z 64.87008928571429
2021-09-09T00:03:00Z 65.06755952380952
2021-09-16T00:03:00Z 65.04315476190476
2021-09-23T00:03:00Z 64.9110119047619
2021-09-30T00:03:00Z 64.775
</code></pre>
<h4 id="高级语法-24"><a class="header" href="#高级语法-24">高级语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<h4 id="高级语法示例"><a class="header" href="#高级语法示例">高级语法示例</a></h4>
<p>示例数据如下：</p>
<pre><code class="language-sql">name: sea
time                 station     temperature
----                 -------     -----------
2021-08-31T16:00:00Z LianYunGang 55
2021-08-31T16:00:00Z XiaoMaiDao  50
2021-08-31T16:03:00Z LianYunGang 59
2021-08-31T16:03:00Z XiaoMaiDao  64
2021-08-31T16:06:00Z LianYunGang 71
2021-08-31T16:06:00Z XiaoMaiDao  60
2021-08-31T16:09:00Z LianYunGang 60
2021-08-31T16:09:00Z XiaoMaiDao  62
2021-08-31T16:12:00Z LianYunGang 62
2021-08-31T16:12:00Z XiaoMaiDao  65
...
</code></pre>
<p><strong>配置时间间隔</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>EVERY</code>来指明CQ的执行间隔</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every&quot; ON &quot;oceanic_station&quot;
RESAMPLE EVERY 30m
BEGIN
  SELECT mean(&quot;temperature&quot;) INTO &quot;average_sea_temperatures&quot; FROM &quot;sea&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">name: average_sea_temperatures
time                 mean
----                 ----
2021-08-31T16:00:00Z 63.025
2021-08-31T17:00:00Z 63.975
2021-08-31T18:00:00Z 64.45
2021-08-31T19:00:00Z 64.025
2021-08-31T20:00:00Z 64.55
2021-08-31T21:00:00Z 63.075
2021-08-31T22:00:00Z 66.15
2021-08-31T23:00:00Z 64.625
2021-09-01T00:00:00Z 63.025
2021-09-01T01:00:00Z 67.75
...
</code></pre>
<p><strong>配置CQ的重采样时间范围</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>FOR</code>来指明CQ的时间间隔的长度</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for&quot; ON &quot;oceanic_station&quot;
RESAMPLE FOR 1h
BEGIN
  SELECT mean(&quot;temperature&quot;) INTO &quot;average_sea_temperatures&quot; FROM &quot;sea&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">name: average_sea_temperatures
time                 mean
----                 ----
2021-08-31T16:00:00Z 62.6
2021-08-31T16:30:00Z 63.45
2021-08-31T17:00:00Z 65.85
2021-08-31T17:30:00Z 62.1
2021-08-31T18:00:00Z 64.45
2021-08-31T18:30:00Z 64.45
2021-08-31T19:00:00Z 64.45
2021-08-31T19:30:00Z 63.6
2021-08-31T20:00:00Z 65.8
2021-08-31T20:30:00Z 63.3
...
</code></pre>
<p><strong>配置执行间隔和CQ时间范围</strong></p>
<p>在<code>RESAMPLE</code>子句中使用<code>EVERY</code>和<code>FOR</code>来指定CQ的执行间隔和CQ的时间范围长度。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every_for&quot; ON &quot;oceanic_station&quot;
RESAMPLE EVERY 1h FOR 90m
BEGIN
  SELECT mean(&quot;temperature&quot;) INTO &quot;average_sea_temperatures&quot; FROM &quot;sea&quot; GROUP BY time(90m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">name: average_sea_temperatures
time                 mean
----                 ----
2021-08-31T15:00:00Z 62.6
2021-08-31T16:00:00Z 62.6
2021-08-31T16:30:00Z 63.8
2021-08-31T17:00:00Z 65.85
2021-08-31T17:30:00Z 62.1
2021-08-31T18:00:00Z 64.45
2021-08-31T18:30:00Z 64.45
2021-08-31T19:00:00Z 64.45
2021-08-31T19:30:00Z 64.23333333333333
2021-08-31T20:00:00Z 65.8
...
</code></pre>
<p><strong>配置CQ的时间范围并填充空值</strong></p>
<p>使用<code>FOR</code>间隔和<code>fill()</code>来更改不含数据的时间间隔值。请注意，至少有一个数据点必须在<code>fill()</code>运行的<code>FOR</code>间隔内。 如果没有数据落在<code>FOR</code>间隔内，则CQ不会将任何数据写入目标<code>measurement</code>。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for_fill&quot; ON &quot;oceanic_station&quot;
RESAMPLE FOR 2h
BEGIN
  SELECT mean(&quot;temperature&quot;) INTO &quot;average_sea_temperatures&quot; FROM &quot;sea&quot; GROUP BY time(1h) fill(1000)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">...
2021-09-30T01:30:00Z 64.35
2021-09-30T02:00:00Z 63.8
2021-09-30T02:30:00Z 64.95
2021-09-30T03:00:00Z 67.225
2021-09-30T03:30:00Z 66.75
2021-09-30T04:00:00Z 54
2021-09-30T05:00:00Z 1000
2021-09-30T06:00:00Z 1000
2021-09-30T07:00:00Z 1000
2021-09-30T08:00:00Z 1000
2021-09-30T09:00:00Z 1000
...
</code></pre>
<h3 id="管理cq"><a class="header" href="#管理cq">管理CQ</a></h3>
<blockquote>
<p>CQ不能<code>update</code>，只能<code>drop</code>和<code>create</code></p>
</blockquote>
<p><strong>列出所有CQ</strong></p>
<pre><code class="language-sql">SHOW CONTINUOUS QUERIES
</code></pre>
<p><strong>删除CQ</strong></p>
<pre><code class="language-sql">DROP CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosql-数学运算符"><a class="header" href="#cnosql-数学运算符">CnosQL 数学运算符</a></h1>
<ul>
<li>
<p><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6">数学运算符</a></p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E5%8A%A0%E6%B3%95">加法</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E5%87%8F%E6%B3%95">减法</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%B9%98%E6%B3%95">乘法</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E9%99%A4%E6%B3%95">除法</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%A8%A1%E8%BF%90%E7%AE%97">模运算</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%8C%89%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97">位与运算</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%8C%89%E4%BD%8D%E6%88%96%E8%BF%90%E7%AE%97">位或运算</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%8C%89%E4%BD%8D%E5%BC%82%E8%BF%90%E7%AE%97">位异运算</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></li>
</ul>
</li>
<li>
<p><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6">不支持的运算符</a></p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97">比较运算</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6">逻辑运算符</a></li>
<li><a href="content/cnosdb/latest/cnosql/math_operators.html#%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6">位运算符</a></li>
</ul>
</li>
</ul>
<h3 id="数学运算符"><a class="header" href="#数学运算符">数学运算符</a></h3>
<h4 id="加法"><a class="header" href="#加法">加法</a></h4>
<p>常量的加法</p>
<pre><code>SELECT &quot;temperature&quot; + 5 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; + 5 &gt; 10
</code></pre>
<p>两字段的加法</p>
<pre><code>SELECT &quot;temperature&quot; + &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; + &quot;visibility&quot; &gt; 10
</code></pre>
<h4 id="减法"><a class="header" href="#减法">减法</a></h4>
<p>常量的减法</p>
<pre><code>SELECT &quot;temperature&quot; - 2 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - 2 &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; - &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - &quot;visibility&quot; &gt; 10
</code></pre>
<h4 id="乘法"><a class="header" href="#乘法">乘法</a></h4>
<p>常量的乘法</p>
<pre><code>SELECT &quot;temperature&quot; * 2 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - 2 &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; * &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; * &quot;visibility&quot; &gt; 10
</code></pre>
<p>乘法和其他操作符并用</p>
<pre><code>SELECT 10 * (&quot;temperature&quot; + &quot;visibility&quot; + &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 * (&quot;temperature&quot; + &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 * (&quot;temperature&quot; - &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
</code></pre>
<h4 id="除法"><a class="header" href="#除法">除法</a></h4>
<p>常量的除法</p>
<pre><code>SELECT 10 / &quot;temperature&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE 10 / &quot;temperature&quot; &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; / &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; / &quot;visibility&quot; &gt; 10
</code></pre>
<p>乘法和其他操作符并用</p>
<pre><code>SELECT 10 / (&quot;temperature&quot; + &quot;visibility&quot; + &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 / (&quot;temperature&quot; + &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 / (&quot;temperature&quot; - &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
</code></pre>
<h4 id="模运算"><a class="header" href="#模运算">模运算</a></h4>
<p>常量的模运算</p>
<pre><code>SELECT 10 % &quot;temperature&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE 10 % &quot;temperature&quot; = 0
</code></pre>
<p>两字段的模运算</p>
<pre><code>SELECT &quot;temperature&quot; % &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; % &quot;visibility&quot; = 0
</code></pre>
<h4 id="按位与运算"><a class="header" href="#按位与运算">按位与运算</a></h4>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; &amp; 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; &amp; &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; &amp; 15 &gt; 0
SELECT &quot;temperature&quot; &amp; &quot;pressure&quot; FROM &quot;air&quot;
SELECT (&quot;temperature&quot; ^ true) &amp; &quot;pressure&quot; FROM &quot;air&quot;
</code></pre>
<h4 id="按位或运算"><a class="header" href="#按位或运算">按位或运算</a></h4>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; | 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; | &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; | 12 = 12
</code></pre>
<h4 id="按位异运算"><a class="header" href="#按位异运算">按位异运算</a></h4>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; ^ 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; ^ &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; ^ 12 = 12
</code></pre>
<h4 id="常见问题"><a class="header" href="#常见问题">常见问题</a></h4>
<p>带有通配符和正则表达式的数学操作符，CnosDB不支持在SELECT子句中组合数学操作与通配符(*)或正则表达式。以下查询无效，系统返回错误:对通配符执行数学运算。</p>
<pre><code>&gt; SELECT * + 2 FROM &quot;air&quot;
ERR: unsupported expression with wildcard: * + 2

对函数中的通配符执行数学运算。

&gt; SELECT COUNT(*) / 2 FROM &quot;nope&quot;
ERR: unsupported expression with wildcard: count(*) / 2

对正则表达式执行数学运算。

&gt; SELECT /A/ + 2 FROM &quot;air&quot;
ERR: error parsing query: found +, expected FROM at line 1, char 12

对函数中的正则表达式执行数学运算。

&gt; SELECT COUNT(/A/) + 2 FROM &quot;nope&quot;
ERR: unsupported expression with regex field: count(/A/) + 2
</code></pre>
<h4 id="函数的数学运算符"><a class="header" href="#函数的数学运算符">函数的数学运算符</a></h4>
<p>目前不支持在函数调用中使用数学运算符。注意，CnosDB只允许SELECT子句中的函数。</p>
<p>可行操作：</p>
<pre><code>SELECT 10 * mean(&quot;value&quot;) FROM &quot;cpu&quot;
</code></pre>
<p>不可行操作：</p>
<pre><code>SELECT mean(10 * &quot;value&quot;) FROM &quot;cpu&quot;
</code></pre>
<h3 id="不支持的运算符"><a class="header" href="#不支持的运算符">不支持的运算符</a></h3>
<h4 id="比较运算"><a class="header" href="#比较运算">比较运算</a></h4>
<p>所有的比较运算符都不支持。例如：<code>=</code>,<code>!=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>,<code>&lt;&gt;</code>。在SELECT语句中均不可以使用。</p>
<h4 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h4>
<p>使用逻辑运算符，如：<code>!|</code>, <code>NAND</code>,<code>XOR</code>,<code>NOR</code>；都会导致解析错误。</p>
<p>此外，在查询的<code>SELECT</code>子句中使用<code>AND</code>和<code>OR</code>不会表现为数学运算符，只会产生空结果，因为它们在CnosQL中已经被定义。但是，您可以对布尔数据应用位操作符<code>&amp;</code>、<code>|</code>和<code>^</code>。</p>
<h4 id="位非运算"><a class="header" href="#位非运算">位非运算</a></h4>
<p>没有位非运算符，因为您期望的结果取决于您的位域的宽度。CnosQL不知道您的位域有多宽，因此无法实现合适的位非运算。</p>
<p>您可以通过使用<code>^</code>(位异或)操作符和代表字宽的全1的二进制数字来实现位非操作:</p>
<pre><code>8-bit 数据：

SELECT &quot;temperature&quot; ^ 255 FROM &quot;air&quot;

16-bit 数据:

SELECT &quot;temperature&quot; ^ 65535 FROM &quot;air&quot;

32-bit 数据:

SELECT &quot;temperature&quot; ^ 4294967295 FROM &quot;air&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosql参考"><a class="header" href="#cnosql参考">CnosQL参考</a></h1>
<h2 id="介绍-1"><a class="header" href="#介绍-1">介绍</a></h2>
<p>CnosQL的定义和详细信息</p>
<ul>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E7%AC%A6%E5%8F%B7">符号</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E7%A4%BA">查询表示</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97">字母和数字</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%96%87%E5%AD%97">文字</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%9F%A5%E8%AF%A2">查询</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E8%AF%AD%E5%8F%A5">语句</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E6%9D%A1%E6%AC%BE">条款</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a></li>
<li><a href="content/cnosdb/latest/cnosql/cnosql_spect.html#%E5%85%B6%E4%BB%96">其他</a></li>
</ul>
<h3 id="符号"><a class="header" href="#符号">符号</a></h3>
<p>使用<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">Extended Backus-Naur Form(&quot; EBNF &quot;)</a>指定语法。EBNF与Go编程语言规范中使用的符号相同。并非巧合的是，CnosDB是用Go编写的。</p>
<pre><code>Production  = production_name &quot;=&quot; [ Expression ] &quot;.&quot; .
Expression  = Alternative { &quot;|&quot; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &quot;…&quot; token ] | Group | Option | Repetition .
Group       = &quot;(&quot; Expression &quot;)&quot; .
Option      = &quot;[&quot; Expression &quot;]&quot; .
Repetition  = &quot;{&quot; Expression &quot;}&quot; .
</code></pre>
<p>按优先级递增的顺序表示操作符:</p>
<pre><code>|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
</code></pre>
<h3 id="查询表示"><a class="header" href="#查询表示">查询表示</a></h3>
<ul>
<li>
<h4 id="字符"><a class="header" href="#字符">字符</a></h4>
</li>
</ul>
<p>CnosQL是使用UTF-8编码的Unicode文本。</p>
<pre><code>newline             = /* the Unicode code point U+000A */ .
unicode_char        = /* an arbitrary Unicode code point except newline */ .
</code></pre>
<h3 id="字母和数字"><a class="header" href="#字母和数字">字母和数字</a></h3>
<p>字母是ASCII字符的集合，加上下划线_ (U+005F)也被认为是字母。只支持十进制数字。</p>
<pre><code>letter              = ascii_letter | &quot;_&quot; .
ascii_letter        = &quot;A&quot; … &quot;Z&quot; | &quot;a&quot; … &quot;z&quot; .
digit               = &quot;0&quot; … &quot;9&quot; .
</code></pre>
<h3 id="标识符"><a class="header" href="#标识符">标识符</a></h3>
<p>标识符包括数据库名、保留策略名、用户名、度量名、标记键以及字段键。</p>
<p>标识符使用规则如下；</p>
<ul>
<li>双引号标识符可以包含除新行以外的任何unicode字符。</li>
<li>双引号标识符可以包括转义的<code>&quot;</code>字符。例如；<code>\&quot;</code> 。</li>
<li>双引号标识符中可以包括CnosQL的关键字。</li>
<li>未加引号的标识符必须以大写或小写ASCII字符或者&quot;_&quot;开头。</li>
<li>未加引号的标识符只能包括ASCII字母、十进制数字或者&quot;_&quot;。</li>
</ul>
<pre><code>identifier          = unquoted_identifier | quoted_identifier .
unquoted_identifier = ( letter ) { letter | digit } .
quoted_identifier   = `&quot;` unicode_char { unicode_char } `&quot;` .
</code></pre>
<p>例如：</p>
<pre><code>air
_air_temperature
&quot;1h&quot;
&quot;anything really&quot;
&quot;1_Crazy-1337.identifier&gt;NAME👍&quot;
</code></pre>
<h3 id="关键字"><a class="header" href="#关键字">关键字</a></h3>
<pre><code>ALL           ALTER         ANY           AS            ASC           BEGIN
BY            CREATE        CONTINUOUS    DATABASE      DATABASES     DEFAULT
DELETE        DESC          DESTINATIONS  DIAGNOSTICS   DISTINCT      DROP
DURATION      END           EVERY         EXPLAIN       FIELD         FOR
FROM          GRANT         GRANTS        GROUP         GROUPS        IN
INF           INSERT        INTO          KEY           KEYS          KILL
LIMIT         SHOW          MEASUREMENT   MEASUREMENTS  NAME          OFFSET
ON            ORDER         PASSWORD      POLICY        POLICIES      PRIVILEGES
QUERIES       QUERY         READ          REPLICATION   RESAMPLE      RETENTION
REVOKE        SELECT        SERIES        SET           SHARD         SHARDS
SLIMIT        SOFFSET       STATS         SUBSCRIPTION  SUBSCRIPTIONS TAG
TO            USER          USERS         VALUES        WHERE         WITH
WRITE
</code></pre>
<p>如果使用了CnosQL的关键字作为标识符，则需要在每次查询中对该标识符加双引号。</p>
<p>关键字<code>time</code>是一种特殊情况。<code>time</code>可以是连续查询名称、数据库名称、测量名称、保留策略名称、订阅名称和用户名称。在这些情况下，查询中的<code>time</code>不需要双引号。<code>time</code>不能是字段键或标签键；CnosQL拒绝将<code>time</code>作为字段键或标记键的写入，并返回错误。</p>
<h3 id="文字"><a class="header" href="#文字">文字</a></h3>
<ul>
<li>
<h4 id="整数"><a class="header" href="#整数">整数</a></h4>
</li>
</ul>
<p>CnosQL目前只支持十进制数字，并不支持其他进制数字。</p>
<pre><code>int_lit             = ( &quot;1&quot; … &quot;9&quot; ) { digit } .
</code></pre>
<ul>
<li>
<h4 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h4>
</li>
</ul>
<p>CnosQL目前只支持浮点数，并不支持指数。</p>
<pre><code>float_lit           = int_lit &quot;.&quot; int_lit .
</code></pre>
<ul>
<li>
<h4 id="字符串"><a class="header" href="#字符串">字符串</a></h4>
</li>
</ul>
<p>字符串必须和单引号搭配使用。如果加上转义字符，那么字符串中可以包含单引号。</p>
<pre><code>string_lit          = `'` { unicode_char } `'` .
</code></pre>
<ul>
<li>
<h4 id="持续时间"><a class="header" href="#持续时间">持续时间</a></h4>
</li>
</ul>
<p>持续时间的字面值指定时间长度。整数字面值紧跟着(没有空格)下面列出的持续时间单位被称为持续时间字面值。可以使用混合单元指定持续时间。</p>
<pre><code>duration_lit        = int_lit duration_unit .
duration_unit       = &quot;ns&quot; | &quot;u&quot; | &quot;µ&quot; | &quot;ms&quot; | &quot;s&quot; | &quot;m&quot; | &quot;h&quot; | &quot;d&quot; | &quot;w&quot; .
</code></pre>
<ul>
<li>
<h4 id="日期和时间"><a class="header" href="#日期和时间">日期和时间</a></h4>
</li>
</ul>
<p>与本文档的其余部分一样，EBNF中没有指定日期和时间文本格式。它是使用Go的日期/时间解析格式指定的，它是按照CnosQL要求的格式编写的引用日期。</p>
<p>参考日期时间为:January 2nd, 2006 at 3:04:05 PM</p>
<pre><code>time_lit            = &quot;2006-01-02 15:04:05.999999&quot; | &quot;2006-01-02&quot; .
</code></pre>
<ul>
<li>
<h4 id="布尔值"><a class="header" href="#布尔值">布尔值</a></h4>
</li>
</ul>
<pre><code>bool_lit            = TRUE | FALSE .
</code></pre>
<ul>
<li>
<h4 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h4>
</li>
</ul>
<pre><code>regex_lit           = &quot;/&quot; { unicode_char } &quot;/&quot; .
</code></pre>
<h3 id="查询"><a class="header" href="#查询">查询</a></h3>
<p>查询由一个或多个以分号分隔的语句组成。</p>
<pre><code>query               = statement { &quot;;&quot; statement } .

statement           = alter_retention_policy_stmt |
                      create_continuous_query_stmt |
                      create_database_stmt |
                      create_retention_policy_stmt |
                      create_subscription_stmt |
                      create_user_stmt |
                      delete_stmt |
                      drop_continuous_query_stmt |
                      drop_database_stmt |
                      drop_measurement_stmt |
                      drop_retention_policy_stmt |
                      drop_series_stmt |
                      drop_shard_stmt |
                      drop_subscription_stmt |
                      drop_user_stmt |
                      explain_stmt |
                      explain_analyze_stmt |
                      grant_stmt |
                      kill_query_statement |
                      revoke_stmt |
                      select_stmt |
                      show_continuous_queries_stmt |
                      show_databases_stmt |
                      show_diagnostics_stmt |
                      show_field_key_cardinality_stmt |
                      show_field_keys_stmt |
                      show_grants_stmt |
                      show_measurement_cardinality_stmt |
                      show_measurement_exact_cardinality_stmt |
                      show_measurements_stmt |
                      show_queries_stmt |
                      show_retention_policies_stmt |
                      show_series_cardinality_stmt |
                      show_series_exact_cardinality_stmt |
                      show_series_stmt |
                      show_shard_groups_stmt |
                      show_shards_stmt |
                      show_stats_stmt |
                      show_subscriptions_stmt |
                      show_tag_key_cardinality_stmt |
                      show_tag_key_exact_cardinality_stmt |
                      show_tag_keys_stmt |
                      show_tag_values_stmt |
                      show_tag_values_cardinality_stmt |
                      show_users_stmt .
</code></pre>
<h3 id="语句"><a class="header" href="#语句">语句</a></h3>
<ul>
<li>
<h4 id="改变保留策略"><a class="header" href="#改变保留策略">改变保留策略</a></h4>
</li>
</ul>
<pre><code>alter_retention_policy_stmt  = &quot;ALTER RETENTION POLICY&quot; policy_name on_clause
                               retention_policy_option
                               [ retention_policy_option ]
                               [ retention_policy_option ]
                               [ retention_policy_option ] .
</code></pre>
<ul>
<li>
<h4 id="创建连续查询"><a class="header" href="#创建连续查询">创建连续查询</a></h4>
</li>
</ul>
<pre><code>create_continuous_query_stmt = &quot;CREATE CONTINUOUS QUERY&quot; query_name on_clause
[ &quot;RESAMPLE&quot; resample_opts ]
&quot;BEGIN&quot; select_stmt &quot;END&quot; .

query_name                   = identifier .

resample_opts                = (every_stmt for_stmt | every_stmt | for_stmt) .
every_stmt                   = &quot;EVERY&quot; duration_lit
for_stmt                     = &quot;FOR&quot; duration_lit
</code></pre>
<ul>
<li>
<h4 id="创建数据库-2"><a class="header" href="#创建数据库-2">创建数据库</a></h4>
</li>
</ul>
<pre><code>create_database_stmt = &quot;CREATE DATABASE&quot; db_name
                       [ WITH
                           [ retention_policy_duration ]
                           [ retention_policy_replication ]
                           [ retention_policy_shard_group_duration ]
                           [ retention_policy_name ]
                        ] .
</code></pre>
<ul>
<li>
<h4 id="创建保留策略"><a class="header" href="#创建保留策略">创建保留策略</a></h4>
</li>
</ul>
<pre><code>create_retention_policy_stmt = &quot;CREATE RETENTION POLICY&quot; policy_name on_clause
                               retention_policy_duration
                               retention_policy_replication
                               [ retention_policy_shard_group_duration ]
                               [ &quot;DEFAULT&quot; ] .
</code></pre>
<ul>
<li>
<h4 id="创建用户"><a class="header" href="#创建用户">创建用户</a></h4>
</li>
</ul>
<pre><code>create_user_stmt = &quot;CREATE USER&quot; user_name &quot;WITH PASSWORD&quot; password
                   [ &quot;WITH ALL PRIVILEGES&quot; ] .
</code></pre>
<ul>
<li>
<h4 id="删除"><a class="header" href="#删除">删除</a></h4>
</li>
</ul>
<pre><code>e_stmt = &quot;DELETE&quot; ( from_clause | where_clause | from_clause where_clause ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃连续查询"><a class="header" href="#抛弃连续查询">抛弃连续查询</a></h4>
</li>
</ul>
<pre><code>drop_continuous_query_stmt = &quot;DROP CONTINUOUS QUERY&quot; query_name on_clause .
</code></pre>
<ul>
<li>
<h4 id="抛弃数据库"><a class="header" href="#抛弃数据库">抛弃数据库</a></h4>
</li>
</ul>
<pre><code>drop_database_stmt = &quot;DROP DATABASE&quot; db_name .
</code></pre>
<ul>
<li>
<h4 id="抛弃度量"><a class="header" href="#抛弃度量">抛弃度量</a></h4>
</li>
</ul>
<pre><code>drop_measurement_stmt = &quot;DROP MEASUREMENT&quot; measurement .
</code></pre>
<ul>
<li>
<h4 id="抛弃保留策略"><a class="header" href="#抛弃保留策略">抛弃保留策略</a></h4>
</li>
</ul>
<pre><code>drop_retention_policy_stmt = &quot;DROP RETENTION POLICY&quot; policy_name on_clause .
</code></pre>
<ul>
<li>
<h4 id="抛弃序列"><a class="header" href="#抛弃序列">抛弃序列</a></h4>
</li>
</ul>
<pre><code>drop_series_stmt = &quot;DROP SERIES&quot; ( from_clause | where_clause | from_clause where_clause ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃分片"><a class="header" href="#抛弃分片">抛弃分片</a></h4>
</li>
</ul>
<pre><code>drop_shard_stmt = &quot;DROP SHARD&quot; ( shard_id ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃用户"><a class="header" href="#抛弃用户">抛弃用户</a></h4>
</li>
</ul>
<pre><code>drop_user_stmt = &quot;DROP USER&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="explain"><a class="header" href="#explain">EXPLAIN</a></h4>
</li>
</ul>
<pre><code>explain_stmt = &quot;EXPLAIN&quot; select_stmt .
</code></pre>
<ul>
<li>
<h4 id="explain-analyze"><a class="header" href="#explain-analyze">EXPLAIN ANALYZE</a></h4>
</li>
</ul>
<p>例如</p>
<pre><code>&gt; explain analyze select mean(temperature) from air where time &gt;= '2018-02-22T00:00:00Z' and time &lt; '2018-02-22T12:00:00Z'
EXPLAIN ANALYZE
----    -----------
 .
 └── select
   ├── execution_time: 279.292µs
   ├── planning_time: 952.75µs
   ├── total_time: 1.232042ms
   └── build_cursor
    ├── labels
     │   └── statement: SELECT mean(temperature) FROM data.autogen.air
     └── iterator_scanner
      └── labels
       └── expr: mean(temperature)
</code></pre>
<p>execution_time: 执行查询所花费的时间，包括读取时间序列数据、在数据流经迭代器时执行操作，以及从迭代器中提取已处理的数据。执行时间不包括将输出序列化为JSON或其他格式所花费的时间。
planning_time: 显示计划查询所花费的时间量。在CnosDB中规划查询需要许多步骤。根据查询的复杂性，与执行查询相比，计划可能需要更多的工作并消耗更多的CPU和内存资源。例如，执行查询所需的系列键的数量会影响计划查询的速度和所需的内存。
create_iterator: 表示本地CnosDB实例所做的工作──一组复杂的嵌套迭代器组合在一起，以产生最终的查询输出。
cursor type：EXPLAIN ANALYZE区分3种游标类型。虽然游标类型具有相同的数据结构和相同的CPU和I/O成本，但每种游标类型的构造原因不同，并在最终输出中分开。
block types：EXPLAIN ANALYZE分离存储块类型，并报告被解码的块的总数和它们在磁盘上的大小(以字节为单位)。</p>
<ul>
<li>
<h4 id="授权"><a class="header" href="#授权">授权</a></h4>
</li>
</ul>
<pre><code>grant_stmt = &quot;GRANT&quot; privilege [ on_clause ] to_clause .
</code></pre>
<ul>
<li>
<h4 id="关闭查询"><a class="header" href="#关闭查询">关闭查询</a></h4>
</li>
</ul>
<pre><code>kill_query_statement = &quot;KILL QUERY&quot; query_id .
</code></pre>
<ul>
<li>
<h4 id="撤销"><a class="header" href="#撤销">撤销</a></h4>
</li>
</ul>
<pre><code>revoke_stmt = &quot;REVOKE&quot; privilege [ on_clause ] &quot;FROM&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="选择"><a class="header" href="#选择">选择</a></h4>
</li>
</ul>
<pre><code>select_stmt = &quot;SELECT&quot; fields [ into_clause ] from_clause [ where_clause ]
         [ group_by_clause ] [ order_by_clause ] [ limit_clause ]
         [ offset_clause ] [ slimit_clause ] [ soffset_clause ] [ timezone_clause ] .
</code></pre>
<ul>
<li>
<h4 id="展示基数"><a class="header" href="#展示基数">展示基数</a></h4>
</li>
</ul>
<p>指用于精确估计或计数测量值、序列、标记键、标记键值和字段键的基数的一组命令。SHOW CARDINALITY命令有两种变体:估计的和精确的。估计值使用草图计算，是所有基数大小的安全默认值。准确的值是直接从TSM(时间结构合并树)数据中计算的，但是对于高基数的数据来说，运行这些值是非常昂贵的。除非必要，使用估计的品种。仅当在数据库上启用了时间序列索引(TSI)时，才支持按时间过滤。</p>
<ul>
<li>
<h4 id="show-continuous-queries"><a class="header" href="#show-continuous-queries">SHOW CONTINUOUS QUERIES</a></h4>
</li>
</ul>
<pre><code>show_continuous_queries_stmt = &quot;SHOW CONTINUOUS QUERIES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-databases"><a class="header" href="#show-databases">SHOW DATABASES</a></h4>
</li>
</ul>
<pre><code>show_databases_stmt = &quot;SHOW DATABASES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-diagnostics"><a class="header" href="#show-diagnostics">SHOW DIAGNOSTICS</a></h4>
</li>
</ul>
<p>示节点信息，如构建信息、正常运行时间、主机名、服务器配置、内存使用和运行时诊断。</p>
<pre><code>show_diagnostics_stmt = &quot;SHOW DIAGNOSTICS&quot;
</code></pre>
<ul>
<li>
<h4 id="show-field-key-cardinality"><a class="header" href="#show-field-key-cardinality">SHOW FIELD KEY CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_field_key_cardinality_stmt = &quot;SHOW FIELD KEY CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

show_field_key_exact_cardinality_stmt = &quot;SHOW FIELD KEY EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]
</code></pre>
<ul>
<li>
<h4 id="show-field-keys"><a class="header" href="#show-field-keys">SHOW FIELD KEYS</a></h4>
</li>
</ul>
<pre><code>show_field_keys_stmt = &quot;SHOW FIELD KEYS&quot; [on_clause] [ from_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-grants"><a class="header" href="#show-grants">SHOW GRANTS</a></h4>
</li>
</ul>
<pre><code>show_grants_stmt = &quot;SHOW GRANTS FOR&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="show-measurements"><a class="header" href="#show-measurements">SHOW MEASUREMENTS</a></h4>
</li>
</ul>
<pre><code>show_measurements_stmt = &quot;SHOW MEASUREMENTS&quot; [on_clause] [ with_measurement_clause ] [ where_clause ] [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-queries"><a class="header" href="#show-queries">SHOW QUERIES</a></h4>
</li>
</ul>
<pre><code>show_queries_stmt = &quot;SHOW QUERIES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-retention-policies"><a class="header" href="#show-retention-policies">SHOW RETENTION POLICIES</a></h4>
</li>
</ul>
<pre><code>show_retention_policies_stmt = &quot;SHOW RETENTION POLICIES&quot; [on_clause] .
</code></pre>
<ul>
<li>
<h4 id="show-series"><a class="header" href="#show-series">SHOW SERIES</a></h4>
</li>
</ul>
<pre><code>show_series_stmt = &quot;SHOW SERIES&quot; [on_clause] [ from_clause ] [ where_clause ] [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-series-cardinality"><a class="header" href="#show-series-cardinality">SHOW SERIES CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_series_cardinality_stmt = &quot;SHOW SERIES CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

show_series_exact_cardinality_stmt = &quot;SHOW SERIES EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

</code></pre>
<ul>
<li>
<h4 id="show-shard-groups"><a class="header" href="#show-shard-groups">SHOW SHARD GROUPS</a></h4>
</li>
</ul>
<pre><code>show_shard_groups_stmt = &quot;SHOW SHARD GROUPS&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-shards"><a class="header" href="#show-shards">SHOW SHARDS</a></h4>
</li>
</ul>
<pre><code>show_shards_stmt = &quot;SHOW SHARDS&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-stats"><a class="header" href="#show-stats">SHOW STATS</a></h4>
</li>
</ul>
<pre><code>show_stats_stmt = &quot;SHOW STATS [ FOR '&lt;component&gt;' | 'indexes' ]&quot;
</code></pre>
<ul>
<li>
<h4 id="show-tag-keys"><a class="header" href="#show-tag-keys">SHOW TAG KEYS</a></h4>
</li>
</ul>
<pre><code>show_tag_keys_stmt = &quot;SHOW TAG KEYS&quot; [on_clause] [ from_clause ] [ where_clause ]
                [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-tag-values"><a class="header" href="#show-tag-values">SHOW TAG VALUES</a></h4>
</li>
</ul>
<pre><code>show_tag_values_stmt = &quot;SHOW TAG VALUES&quot; [on_clause] [ from_clause ] with_tag_clause [ where_clause ]
                  [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-tag-values-cardinality"><a class="header" href="#show-tag-values-cardinality">SHOW TAG VALUES CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_tag_values_cardinality_stmt = &quot;SHOW TAG VALUES CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ] with_key_clause

show_tag_values_exact_cardinality_stmt = &quot;SHOW TAG VALUES EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ] with_key_clause
</code></pre>
<ul>
<li>
<h4 id="show-users"><a class="header" href="#show-users">SHOW USERS</a></h4>
</li>
</ul>
<pre><code>show_users_stmt = &quot;SHOW USERS&quot; .
</code></pre>
<h3 id="条款"><a class="header" href="#条款">条款</a></h3>
<pre><code>from_clause     = &quot;FROM&quot; measurements .

group_by_clause = &quot;GROUP BY&quot; dimensions fill(fill_option).

into_clause     = &quot;INTO&quot; ( measurement | back_ref ).

limit_clause    = &quot;LIMIT&quot; int_lit .

offset_clause   = &quot;OFFSET&quot; int_lit .

slimit_clause   = &quot;SLIMIT&quot; int_lit .

soffset_clause  = &quot;SOFFSET&quot; int_lit .

timezone_clause = tz(string_lit) .

on_clause       = &quot;ON&quot; db_name .

order_by_clause = &quot;ORDER BY&quot; sort_fields .

to_clause       = &quot;TO&quot; user_name .

where_clause    = &quot;WHERE&quot; expr .

with_measurement_clause = &quot;WITH MEASUREMENT&quot; ( &quot;=&quot; measurement | &quot;=~&quot; regex_lit ) .

with_tag_clause = &quot;WITH KEY&quot; ( &quot;=&quot; tag_key | &quot;!=&quot; tag_key | &quot;=~&quot; regex_lit | &quot;IN (&quot; tag_keys &quot;)&quot;  ) .
</code></pre>
<h3 id="表达式"><a class="header" href="#表达式">表达式</a></h3>
<pre><code class="language-SQL">binary_op        = &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&amp;&quot; | &quot;|&quot; | &quot;^&quot; | &quot;AND&quot; |
                &quot;OR&quot; | &quot;=&quot; | &quot;!=&quot; | &quot;&lt;&gt;&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; .

expr             = unary_expr { binary_op unary_expr } .

unary_expr       = &quot;(&quot; expr &quot;)&quot; | var_ref | time_lit | string_lit | int_lit |
float_lit | bool_lit | duration_lit | regex_lit .
</code></pre>
<h3 id="其他"><a class="header" href="#其他">其他</a></h3>
<pre><code>alias            = &quot;AS&quot; identifier .

back_ref         = ( policy_name &quot;.:MEASUREMENT&quot; ) |
( db_name &quot;.&quot; [ policy_name ] &quot;.:MEASUREMENT&quot; ) .

db_name          = identifier .

dimension        = expr .

dimensions       = dimension { &quot;,&quot; dimension } .

field_key        = identifier .

field            = expr [ alias ] .

fields           = field { &quot;,&quot; field } .

fill_option      = &quot;null&quot; | &quot;none&quot; | &quot;previous&quot; | int_lit | float_lit | &quot;linear&quot; .

host             = string_lit .

measurement      = measurement_name |
( policy_name &quot;.&quot; measurement_name ) |
( db_name &quot;.&quot; [ policy_name ] &quot;.&quot; measurement_name ) .

measurements     = measurement { &quot;,&quot; measurement } .

measurement_name = identifier | regex_lit .

password         = string_lit .

policy_name      = identifier .

privilege        = &quot;ALL&quot; [ &quot;PRIVILEGES&quot; ] | &quot;READ&quot; | &quot;WRITE&quot; .

query_id         = int_lit .

query_name       = identifier .

retention_policy = identifier .

retention_policy_option      = retention_policy_duration |
retention_policy_replication |
retention_policy_shard_group_duration |
&quot;DEFAULT&quot; .

retention_policy_duration    = &quot;DURATION&quot; duration_lit .

retention_policy_replication = &quot;REPLICATION&quot; int_lit .

retention_policy_shard_group_duration = &quot;SHARD DURATION&quot; duration_lit .

retention_policy_name = &quot;NAME&quot; identifier .

series_id        = int_lit .

shard_id         = int_lit .

sort_field       = field_key [ ASC | DESC ] .

sort_fields      = sort_field { &quot;,&quot; sort_field } .

subscription_name = identifier .

tag_key          = identifier .

tag_keys         = tag_key { &quot;,&quot; tag_key } .

user_name        = identifier .

var_ref          = measurement .
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="其他-1"><a class="header" href="#其他-1">其他</a></h1>
<ul>
<li><a href="content/cnosdb/latest/other/../other/version_manager.html">发行版本说明</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="版本管理"><a class="header" href="#版本管理">版本管理</a></h1>
<p>CnosDB的版本管理按照X.Y.Z的形式，其中X.Y是发行版本序列号，Z是修正版本序列号。</p>
<ol>
<li>X 代表API将重构，无法保证向前兼容。</li>
<li>Y 代表增加新功能，不完全保证向前兼容，但不会出现根本性的变化。</li>
<li>Z 代表修正版本，序列号越高代表版本越稳定。</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cnosdb性能比较"><a class="header" href="#cnosdb性能比较">CnosDB性能比较</a></h1>
<h2 id="描述"><a class="header" href="#描述">描述</a></h2>
<p>为了帮助用户快速选型，本文对CnosDB，InfluxDB，TimescaleDB，TDengine等四种不同的时间序列数据库分别在数据写入，磁盘占用和查询效率三个纬度进行比较。</p>
<ol>
<li>数据写入</li>
<li>磁盘占用</li>
<li>查询效率
测试工具使用<a href="https://github.com/cnosdb/tsdb-comparisons">时序数据库专用测试工具</a>进行测试</li>
</ol>
<h2 id="运行环境"><a class="header" href="#运行环境">运行环境</a></h2>
<p>为了公平起见，均使用统一规格的运行环境进行比较，以下为阿里云上的ECS服务器配置</p>
<ol>
<li>
<p>运行环境</p>
<pre><code>ecs.c6e.4xlarge
16vCPU
32GiB
Ubuntu 18.04.6 LTS
ESSD云盘 400GB  PL1
</code></pre>
<ol>
<li>软件版本</li>
</ol>
<table><thead><tr><th>数据库</th><th>版本</th></tr></thead><tbody>
<tr><td>CnosDB</td><td>v1.0.1</td></tr>
<tr><td>InfluxDB</td><td>v1.8.10</td></tr>
<tr><td>TimescaleDB</td><td>v2.6.1-pg14</td></tr>
<tr><td>TDengine</td><td>v2.4.0.18</td></tr>
</tbody></table>
</li>
</ol>
<h2 id="摘要"><a class="header" href="#摘要">摘要</a></h2>
<p>CnosDB在每批次为5000的时候写入为245340.98/sec</p>
<p>InfluxDB在每批次为5000的时候写入为223701.85/sec</p>
<p>TimescaleDB在每批次为5000的时候写入为426297.89/sec</p>
<p>TDengine在每批次为200的时候写入为289107.37/sec</p>
<p>测试数据总量为62231779行数据，492052007个值，大小为12G，以8个线程分不同的批次向数据库写入</p>
<h2 id="写入效率"><a class="header" href="#写入效率">写入效率</a></h2>
<p><img src="content/cnosdb/latest/other/../image/write_speet.png" alt="" /></p>
<h2 id="磁盘占用"><a class="header" href="#磁盘占用">磁盘占用</a></h2>
<p><img src="content/cnosdb/latest/other/../image/disk_usage.png" alt="" /></p>
<h2 id="查询效率"><a class="header" href="#查询效率">查询效率</a></h2>
<table><thead><tr><th></th><th>CnosDB</th><th>InfluxDB</th><th>TimescaleDB</th><th>TDengine</th></tr></thead><tbody>
<tr><td>last-loc</td><td>23.50/sec</td><td>21.72/sec</td><td>861.71/sec</td><td>2225.86/sec</td></tr>
<tr><td>low-fuel</td><td>18.84/sec</td><td>11.97/sec</td><td>970.40/sec</td><td>2608.26/sec</td></tr>
<tr><td>high-load</td><td>23.37/sec</td><td>16.47/sec</td><td>896.53/sec</td><td>不支持</td></tr>
<tr><td>stationary-trucks</td><td>3.95/sec</td><td>2.99/sec</td><td>87.37/sec</td><td>不支持</td></tr>
<tr><td>long-driving-sessions</td><td>21.20/sec</td><td>19.54/sec</td><td>2.33/sec</td><td>不支持</td></tr>
<tr><td>long-daily-sessions</td><td>4.66/sec</td><td>4.33/sec</td><td>0.29/sec</td><td>不支持</td></tr>
<tr><td>avg-vs-projected-fuel-consumption</td><td>0.62/sec</td><td>0.47/sec</td><td>0.79/sec</td><td>不支持</td></tr>
<tr><td>avg-daily-driving-duration</td><td>0.69/sec</td><td>0.60/sec</td><td>0.29/sec</td><td>738.69/sec</td></tr>
<tr><td>avg-daily-driving-session</td><td>0.36/sec</td><td>0.33/sec</td><td>0.29/sec</td><td>不支持</td></tr>
</tbody></table>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
