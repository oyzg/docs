<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CnosQL</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/about.html"><strong aria-hidden="true">1.</strong> 关于本项目</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/index.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/download.html"><strong aria-hidden="true">2.1.</strong> 下载</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/install.html"><strong aria-hidden="true">2.2.</strong> 安装</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/get-start.html"><strong aria-hidden="true">2.3.</strong> 快速开始</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/concept/index.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/index.html"><strong aria-hidden="true">4.</strong> 指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/cnosdb.html"><strong aria-hidden="true">4.1.</strong> cnosdb</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/cnosdb-cli.html"><strong aria-hidden="true">4.2.</strong> cnosdb-cli</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/write.html"><strong aria-hidden="true">4.3.</strong> HTTP写入</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/query.html"><strong aria-hidden="true">4.4.</strong> HTTP查询</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/cnosdb_inspect.html"><strong aria-hidden="true">4.5.</strong> CnosDB Inspect</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/index.html"><strong aria-hidden="true">5.</strong> CnosQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/ddl.html"><strong aria-hidden="true">5.1.</strong> DDL</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/dml.html"><strong aria-hidden="true">5.2.</strong> DML</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/function.html"><strong aria-hidden="true">5.3.</strong> 函数</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/countine_query.html"><strong aria-hidden="true">5.4.</strong> 连续查询</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cluster/introduction.html"><strong aria-hidden="true">6.</strong> CnosDB分布式</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/other/index.html"><strong aria-hidden="true">7.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/other/kubernetes-deployment.html"><strong aria-hidden="true">7.1.</strong> 使用Kubernetes部署CnosDB</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/other/kubernetes-StatefulSet.html"><strong aria-hidden="true">7.2.</strong> 使用Kubernetes部署CnosDB集群</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/SUMMARY.html"><strong aria-hidden="true">8.</strong> latest</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/introduction.html"><strong aria-hidden="true">8.1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/quickstart.html"><strong aria-hidden="true">8.2.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/concept.html"><strong aria-hidden="true">8.3.</strong> 概念</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/guide.html"><strong aria-hidden="true">8.4.</strong> 入门指南</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/management.html"><strong aria-hidden="true">8.5.</strong> 运维管理</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/cnosql.html" class="active"><strong aria-hidden="true">8.6.</strong> CnosQL</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/protocol.html"><strong aria-hidden="true">8.7.</strong> 数据协议</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/sandboxmanagement.html"><strong aria-hidden="true">8.8.</strong> 集群管理</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/question.html"><strong aria-hidden="true">8.9.</strong> 疑难解答</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cnosql"><a class="header" href="#cnosql">CnosQL</a></h1>
<h2 id="cnosdb入门"><a class="header" href="#cnosdb入门">CnosDB入门</a></h2>
<ul>
<li>
<h3 id="摘要"><a class="header" href="#摘要">摘要</a></h3>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE">什么是时序数据？</a></li>
<li><a href="#cnosdb%E7%AE%80%E4%BB%8B">CnosDB简介</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">快速开始</a></li>
<li><a href="#cnosql-vs-sql">CnosQL VS SQL</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%85%A5%E9%97%A8">查询入门</a></li>
</ul>
</li>
<li>
<h3 id="什么是时序数据"><a class="header" href="#什么是时序数据">什么是时序数据？</a></h3>
<p>时序数据是指时间序列数据。是按<strong>时间顺序</strong>记录的数据列，在同一数据列中的各个数据必须是同口径的，要求具有可比性。</p>
<p><a href="https://www.cnosdb.com">场景</a></p>
<p><a href="https://weathernew.pae.baidu.com/weathernew/pc?query=%E5%8C%97%E4%BA%AC%E5%A4%A9%E6%B0%94&amp;srcid=4982">天气</a></p>
</li>
<li>
<h3 id="cnosdb简介"><a class="header" href="#cnosdb简介">CnosDB简介</a></h3>
<p><strong>时序数据库</strong> - 用于处理带时间标签（按照时间的顺序变化，即时间序列化）的数据</p>
<p><strong>时序数据管理系统</strong> - 主要通过对时序数据的采集、处理和分析帮助企业实时监控企业的生产与经营过程。</p>
<ul>
<li>数据是时序的，一定带有时间戳</li>
<li>数据极少有更新操作</li>
<li>数据的写入多，读取少</li>
<li>用户关注的是一段时间的趋势</li>
<li>数据是有保留期限的</li>
<li>除了存储查询外，还需要实时的计算操作</li>
<li>数据量巨大，每天很容易就会过百亿</li>
</ul>
</li>
<li>
<h3 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h3>
<h4 id="使用docker启动"><a class="header" href="#使用docker启动">使用Docker启动</a></h4>
<pre><code class="language-bash">docker pull cnosdb/cnosdb:latest
docker run -itd -p 8086:8086 cnosdb/cnosdb:latest
</code></pre>
<h4 id="导入示例数据"><a class="header" href="#导入示例数据">导入示例数据</a></h4>
<blockquote>
<p>如何提示<code>bash: wget: command not found</code></p>
<p>请下载<code>wget</code>工具: <code>apt-get update &amp;&amp; apt-get install wget</code></p>
</blockquote>
<pre><code class="language-bash">docker ps # 查看运行中的容器

docker exec -it container_id bash # 进入容器

wget https://gist.githubusercontent.com/cnos-db/9839ac8e78e45b0ee50d2803de4acfd8/raw/818b19d0dd3c80befe636b60ee569451ac2ca4b1/oceanic_station

cnosdb-cli import --path oceanic_station # 导入数据到cnosdb

cnosdb-cli

SHOW DATABASES

USE oceanic_station

</code></pre>
</li>
<li>
<h3 id="cnosql-vs-sql"><a class="header" href="#cnosql-vs-sql">CnosQL vs SQL</a></h3>
<ul>
<li>
<p>时间序列数据在聚合场景中最有用</p>
</li>
<li>
<p>CnosDB 中的<code>measurement</code>类似于一个 SQL 中的<code>table</code></p>
</li>
<li>
<p>CnosDB 中的<code>tag</code>就像 SQL 中的一个带索引的列</p>
</li>
<li>
<p>CnosDB 中的<code>field</code>就像 SQL 中的没有索引的列</p>
</li>
<li>
<p>CnosDB<code>points</code>类似于 SQL 中的行</p>
</li>
<li>
<p>CnosDB 中不需要预定义<code>schema</code></p>
</li>
</ul>
</li>
</ul>
<h3 id="查询入门"><a class="header" href="#查询入门">查询入门</a></h3>
<h4 id="查看所有-measurements"><a class="header" href="#查看所有-measurements">查看所有 <code>measurements</code></a></h4>
<pre><code>  SHOW MEASUREMENTS
</code></pre>
<h4 id="计算air中temperature的数量"><a class="header" href="#计算air中temperature的数量">计算<code>air</code>中<code>temperature</code>的数量</a></h4>
<p><code>  SELECT COUNT(&quot;temperature&quot;) FROM air</code></p>
<h4 id="查看air中的前五个值"><a class="header" href="#查看air中的前五个值">查看<code>air</code>中的前五个值</a></h4>
<pre><code>`SELECT * FROM air LIMIT 5`
</code></pre>
<h4 id="指定字段的标识符号"><a class="header" href="#指定字段的标识符号">指定字段的标识符号</a></h4>
<pre><code> SELECT &quot;temperature&quot;::field,&quot;station&quot;::tag,&quot;visibility&quot;::field FROM &quot;air&quot; limit 10
</code></pre>
<h4 id="查看measurement的tag-key"><a class="header" href="#查看measurement的tag-key">查看<code>measurement</code>的tag key</a></h4>
<p><code> SHOW TAG KEYS FROM air</code></p>
<h4 id="查看tag-value"><a class="header" href="#查看tag-value">查看tag value</a></h4>
<p><code> SHOW TAG VALUES FROM air WITH KEY = &quot;station&quot;</code></p>
<h4 id="查看field-key"><a class="header" href="#查看field-key">查看field key</a></h4>
<p><code> SHOW FIELD KEYS FROM air</code></p>
<h4 id="查看series"><a class="header" href="#查看series">查看series</a></h4>
<pre><code>`SHOW SERIES`
</code></pre>
<h4 id="函数使用"><a class="header" href="#函数使用">函数使用</a></h4>
<blockquote>
<p><a href="https://www.cnosdb.com/content/cnosdb/0.10/cnosql/function.html">更多</a></p>
</blockquote>
<p><code> SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;</code></p>
<h2 id="cnosql语法"><a class="header" href="#cnosql语法">CnosQL语法</a></h2>
<ul>
<li>
<h3 id="ddl"><a class="header" href="#ddl">DDL</a></h3>
<p>CnosQL提供了一整套DDL（数据定义语言）</p>
</li>
</ul>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86">数据库管理</a></th><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">CREATE DATABASE</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93">SHOW DATABASES</a></td><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">DROP DATABASE</a></td></tr>
<tr><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAseries">SHOW SERIES</a></td><td style="text-align: center"><a href="#%E4%BD%BF%E7%94%A8drop%E5%88%A0%E9%99%A4series">DROP SERIES</a></td><td style="text-align: center"><a href="#%E4%BD%BF%E7%94%A8delete%E5%88%A0%E9%99%A4series">DELETE</a></td></tr>
<tr><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAmeasurement">SHOW MEASUREMENTS</a></td><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4measurement">DROP MEASUREMENT</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAtag-key">SHOW TAG KEYS</a></td></tr>
<tr><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAtag-value">SHOW TAG VALUES</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAfield-key">SHOW FIELD KEYS</a></td><td style="text-align: center"><a href="#%E6%8C%89%E6%97%B6%E9%97%B4%E8%BF%87%E6%BB%A4">按时间过滤</a></td></tr>
<tr><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E7%89%87">DROP SHARD</a></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"><a href="#%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5%E7%AE%A1%E7%90%86"><strong>保留策略管理</strong></a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><a href="#%E5%88%9B%E5%BB%BA%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">CREATE RETENTION POLICY</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BA%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">SHOW RETENTION POLICIES</a></td><td style="text-align: center"><a href="#%E4%BF%AE%E6%94%B9%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">ALTER RETENTION POLICY</a></td></tr>
<tr><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">DROP RETENTION POLICY</a></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
<ul>
<li>
<h3 id="数据库管理"><a class="header" href="#数据库管理">数据库管理</a></h3>
<h4 id="创建数据库"><a class="header" href="#创建数据库">创建数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE DATABASE &lt;database_name&gt; [WITH [DURATION &lt;duration&gt;] [REPLICATION &lt;n&gt;] [SHARD DURATION &lt;duration&gt;] [NAME &lt;rp-name&gt;]]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>CREATE DATABASE</code>需要一个数据库名称，其他都为可选项。如果未在<code>WITH</code>后面指定保留策略，则会创建一个默认的保留策略，名称为<code>autogen</code>。</p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>NAME</code>指定保留策略名称。</p>
<p><code>CREATE DATABASE</code>成功执行后不会返回任何结果。</p>
<p><strong>示例</strong></p>
<p>创建数据库</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，CnosDB还会在其下创建一个名为<code>autogen</code>的保留策略。</p>
</blockquote>
<pre><code class="language-sql"> CREATE DATABASE &quot;cnos&quot;
</code></pre>
<p>创建数据库并指定保留策略</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，并指定保留策略为<code>1d_events</code>，它的生命周期为总保留时长为一天，副本数为1，每个分片的的窗口长度为一小时。</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE DATABASE &quot;cnos&quot; WITH DURATION 1d REPLICATION 1 SHARD DURATION 1h NAME &quot;1d_events&quot;
</code></pre>
<h4 id="显示数据库"><a class="header" href="#显示数据库">显示数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code>SHOW DATABASES
</code></pre>
<h4 id="删除数据库"><a class="header" href="#删除数据库">删除数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP DATABASE &lt;database_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP DATABASE</code>会删除数据库下所有数据。</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP DATABASE &quot;cnos&quot;
</code></pre>
</li>
<li>
<h3 id="保留策略管理"><a class="header" href="#保留策略管理">保留策略管理</a></h3>
<h4 id="创建保留策略"><a class="header" href="#创建保留策略">创建保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; [SHARD DURATION &lt;duration&gt;] [DEFAULT]
</code></pre>
<p><strong>描述</strong></p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>DEFAULT</code>可选项，指定其是否为默认保留策略</p>
<p><strong>示例</strong></p>
<p>创建保留策略</p>
<blockquote>
<p>该语句创建了一个名为<code>1d_events</code>的保留策略，并且副本数为1</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 1d REPLICATION 1
&gt;
</code></pre>
<p>创建默认保留策略</p>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 23h60m REPLICATION 1 DEFAULT
&gt;
</code></pre>
<h4 id="显示保留策略"><a class="header" href="#显示保留策略">显示保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW RETENTION POLICIES [ON &lt;database_name&gt;]
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">&gt; SHOW RETENTION POLICIES ON &quot;cnos&quot;

name      duration   shardGroupDuration   replicaN   default
----      --------   ------------------   --------   -------
autogen   0s         168h0m0s             1          true
</code></pre>
<h4 id="修改保留策略"><a class="header" href="#修改保留策略">修改保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; SHARD DURATION &lt;duration&gt; DEFAULT
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 7 SHARD DURATION 1d DEFAULT
</code></pre>
<h4 id="删除保留策略"><a class="header" href="#删除保留策略">删除保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt;
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">&gt; DROP RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot;
&gt;
</code></pre>
</li>
</ul>
<h2 id="schema查询"><a class="header" href="#schema查询">schema查询</a></h2>
<ul>
<li>
<h3 id="显示series"><a class="header" href="#显示series">显示<code>SERIES</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW SERIES [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; [ '&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW SERIES</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW SERIES ON &quot;cnos&quot; WHERE time &gt; now() - 1m LIMIT 10
</code></pre>
</li>
<li>
<h3 id="使用drop删除series"><a class="header" href="#使用drop删除series">使用<code>DROP</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SERIES FROM &lt;measurement_name[,measurement_name]&gt; WHERE &lt;tag_key&gt;='&lt;tag_value&gt;'
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据以及数据所对应的索引</p>
<p><strong>示例</strong></p>
<p>从一个<code>measurement</code>中删除所有<code>series</code></p>
<pre><code class="language-sql">&gt; DROP SERIES FROM &quot;cpu&quot;
</code></pre>
<p>从一个<code>measurement</code>中删除具有特定条件的<code>series</code></p>
<pre><code class="language-sql">DROP SERIES FROM &quot;cpu&quot; WHERE &quot;region&quot; = 'Shanghai'
</code></pre>
</li>
<li>
<h3 id="使用delete删除series"><a class="header" href="#使用delete删除series">使用<code>DELETE</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DELETE FROM &lt;measurement_name&gt; WHERE [&lt;tag_key&gt;='&lt;tag_value&gt;'] | [&lt;time interval&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据，但是不会删除索引，并且支持时间过滤</p>
<p><strong>示例</strong></p>
<blockquote>
<p>删除2020-01-01之前产生的的所有数据</p>
</blockquote>
<pre><code class="language-sql">&gt; DELETE WHERE time &lt; '2021-01-01'
</code></pre>
</li>
<li>
<h3 id="显示measurement"><a class="header" href="#显示measurement">显示<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW MEASUREMENTS [ON &lt;database_name&gt;] [WITH MEASUREMENT &lt;operator&gt; ['&lt;measurement_name&gt;' | &lt;regular_expression&gt;]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><code>SHOW MEASUREMENTS</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<blockquote>
<p>该查询返回数据库<code>cnos</code>下<code>tag key</code>host下的<code>tag value</code>的值中包含一个整数</p>
</blockquote>
<pre><code class="language-sql">SHOW MEASUREMENTS ON &quot;cnos&quot; WITH MEASUREMENT =~ /h2o.*/ WHERE &quot;host&quot;  =~ /\d/
</code></pre>
</li>
<li>
<h3 id="删除measurement"><a class="header" href="#删除measurement">删除<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &lt;measurement_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP MEASUREMENT</code>会删除指定<code>measurement</code>下所有的数据</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &quot;cpu&quot;
</code></pre>
</li>
<li>
<h3 id="显示tag-key"><a class="header" href="#显示tag-key">显示<code>tag key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW tag keys</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON &quot;cnos&quot; FROM &quot;cpu&quot; LIMIT 1 OFFSET 1
</code></pre>
</li>
<li>
<h3 id="显示tag-value"><a class="header" href="#显示tag-value">显示<code>tag value</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW TAG VALUES [ON &lt;database_name&gt;][FROM_clause] WITH KEY [ [&lt;operator&gt; &quot;&lt;tag_key&gt;&quot; | &lt;regular_expression&gt;] | [IN (&quot;&lt;tag_key1&gt;&quot;,&quot;&lt;tag_key2&quot;)]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG VALUES ON &quot;cnos&quot; WITH KEY IN (&quot;region&quot;,&quot;host&quot;) WHERE &quot;host&quot; =~ /./ LIMIT 3
</code></pre>
</li>
<li>
<h3 id="显示field-key"><a class="header" href="#显示field-key">显示<code>field key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS [ON &lt;database_name&gt;] [FROM &lt;measurement_name&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>FROM</code>子句为可选项</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS ON &quot;cnos&quot; FROM &quot;cpu&quot;
</code></pre>
</li>
<li>
<h3 id="按时间过滤"><a class="header" href="#按时间过滤">按时间过滤</a></h3>
<p>可以在<code>SHOW TAG KEYS</code>、<code>SHOW TAG VALUES</code> <code>SHOW SERIES</code> <code>SHOW MEASUREMENTS</code> <code>SHOW FIELD KEYS</code>上使用</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON cnos where time &gt; now() -1h and time &lt; now()
</code></pre>
</li>
<li>
<h3 id="删除分片"><a class="header" href="#删除分片">删除分片</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SHARD &lt;shard_id_number&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SHARD</code>会在磁盘上删除有关分片的所有数据以及元数据</p>
<pre><code class="language-sql">&gt; DROP SHARD 1
&gt;
</code></pre>
</li>
</ul>
<h2 id="管理数据库"><a class="header" href="#管理数据库">管理数据库</a></h2>
<p><strong><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86">数据库管理</a></strong></p>
<h2 id="连续查询"><a class="header" href="#连续查询">连续查询</a></h2>
<table><thead><tr><th><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></th><th><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95">高级语法</a></th><th><a href="#%E7%AE%A1%E7%90%86CQ">管理CQ</a></th></tr></thead><tbody>
<tr><td><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">基本语法示例</a></td><td><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">高级语法示例</a></td><td></td></tr>
</tbody></table>
<ul>
<li>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<h4 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<p><strong>语法描述</strong></p>
<p>CQ查询必须包含一个函数，一个<code>INTO</code>子句和一个<code>GROUP BY time()</code>子句：</p>
<pre><code class="language-sql">SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</code></pre>
<blockquote>
<p>在<code>WHERE</code>子句中，不需要指定时间范围，CQ查询会为语句自动匹配时间范围</p>
</blockquote>
<h4 id="基本语法示例"><a class="header" href="#基本语法示例">基本语法示例</a></h4>
<p>以下示例使用数据库<code>transportation</code>中的示例数据，<code>bus_data</code>中存储的数据是公交车乘客数量和投诉数量的15分钟数：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers   complaints
2020-08-28T07:00:00Z   5            9
2020-08-28T07:15:00Z   8            9
2020-08-28T07:30:00Z   8            9
2020-08-28T07:45:00Z   7            9
2020-08-28T08:00:00Z   8            9
2020-08-28T08:15:00Z   15           7
2020-08-28T08:30:00Z   15           7
2020-08-28T08:45:00Z   17           7
2020-08-28T09:00:00Z   20           7
</code></pre>
<p><strong>自动采样数据</strong></p>
<p>使用CQ自动从单个字段下采样数据，并将结果写入到同一个数据库的另一个<code>measurement</code>中：</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>自动采样数据并将结果保存到另一个保留策略中</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_rp&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>使用通配符自动下采样数据</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_br&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(*) INTO &quot;downsampled_transportation&quot;.&quot;autogen&quot;.:MEASUREMENT FROM /.*/ GROUP BY time(30m),*
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;downsampled_transportation.&quot;autogen&quot;.&quot;bus_data&quot;
name: bus_data
--------------
time                   mean_complaints   mean_passengers
2020-08-28T07:00:00Z   9                 6.5
2020-08-28T07:30:00Z   9                 7.5
2020-08-28T08:00:00Z   8                 11.5
2020-08-28T08:30:00Z   7                 16
</code></pre>
<p><strong>自动采样数据并配置CQ的时间边界</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_offset&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h,15m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:15:00Z   7.75
2020-08-28T08:15:00Z   16.75
</code></pre>
<h4 id="高级语法"><a class="header" href="#高级语法">高级语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<h4 id="高级语法示例"><a class="header" href="#高级语法示例">高级语法示例</a></h4>
<p>示例数据如下：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers
2020-08-28T06:30:00Z   2
2020-08-28T06:45:00Z   4
2020-08-28T07:00:00Z   5
2020-08-28T07:15:00Z   8
2020-08-28T07:30:00Z   8
2020-08-28T07:45:00Z   7
2020-08-28T08:00:00Z   8
2020-08-28T08:15:00Z   15
2020-08-28T08:30:00Z   15
2020-08-28T08:45:00Z   17
2020-08-28T09:00:00Z   20
</code></pre>
<p><strong>配置时间间隔</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>EVERY</code>来指明CQ的执行间隔</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 30m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>配置CQ的重采样时间范围</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>FOR</code>来指明CQ的时间间隔的长度</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for&quot; ON &quot;transportation&quot;
RESAMPLE FOR 1h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置执行间隔和CQ时间范围</strong></p>
<p>在<code>RESAMPLE</code>子句中使用<code>EVERY</code>和<code>FOR</code>来指定CQ的执行间隔和CQ的时间范围长度。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every_for&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 1h FOR 90m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T06:30:00Z   3
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置CQ的时间范围并填充空值</strong></p>
<p>使用<code>FOR</code>间隔和<code>fill()</code>来更改不含数据的时间间隔值。请注意，至少有一个数据点必须在<code>fill()</code>运行的<code>FOR</code>间隔内。 如果没有数据落在<code>FOR</code>间隔内，则CQ不会将任何数据写入目标<code>measurement</code>。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for_fill&quot; ON &quot;transportation&quot;
RESAMPLE FOR 2h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h) fill(1000)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T05:00:00Z   1000
2020-08-28T06:00:00Z   3
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
2020-08-28T09:00:00Z   20
2020-08-28T10:00:00Z   1000
</code></pre>
</li>
<li>
<h3 id="管理cq"><a class="header" href="#管理cq">管理CQ</a></h3>
<blockquote>
<p>CQ不能<code>update</code>，只能<code>drop</code>和<code>create</code></p>
</blockquote>
<p><strong>列出所有CQ</strong></p>
<pre><code class="language-sql">SHOW CONTINUOUS QUERIES
</code></pre>
<p><strong>删除CQ</strong></p>
<pre><code class="language-sql">DROP CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</code></pre>
</li>
</ul>
<h2 id="cnosql函数"><a class="header" href="#cnosql函数">CnosQL函数</a></h2>
<ul>
<li>
<h3 id="目录"><a class="header" href="#目录">目录</a></h3>
<ul>
<li><a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a>
<ul>
<li><a href="#count">COUNT()</a></li>
<li><a href="#distinct">DISTINCT()</a></li>
<li><a href="#integral">INTEGRAL()</a></li>
<li><a href="#mean">MEAN()</a></li>
<li><a href="#median">MEDIAN()</a></li>
<li><a href="#mode">MODE()</a></li>
<li><a href="#spread">SPREAD()</a></li>
<li><a href="#stddev">STDDEV()</a></li>
<li><a href="#sum">SUM()</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0">选择函数</a>
<ul>
<li><a href="#bottom">BOTTOM()</a></li>
<li><a href="#first">FIRST()</a></li>
<li><a href="#last">LAST()</a></li>
<li><a href="#max">MAX()</a></li>
<li><a href="#min">MIN()</a></li>
<li><a href="#percentile">PERCENTILE()</a></li>
<li><a href="#sample">SAMPLE()</a></li>
<li><a href="#top">TOP()</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">转换函数</a>
<ul>
<li><a href="#abs">ABS()</a></li>
<li><a href="#acos">ACOS()</a></li>
<li><a href="#asin">ASIN()</a></li>
<li><a href="#atan">ATAN()</a></li>
<li><a href="#atan2">ATAN2()</a></li>
<li><a href="#ceil">CEIL()</a></li>
<li><a href="#cos">COS()</a></li>
<li><a href="#cumulative-sum">CUMULATIVE_SUM()</a></li>
<li><a href="#derivative">DERIVATIVE()</a></li>
<li><a href="#difference">DIFFERENCE()</a></li>
<li><a href="#elapsed">ELAPSED()</a></li>
<li><a href="#exp">EXP()</a></li>
<li><a href="#floor">FLOOR()</a></li>
<li><a href="#histogram">HISTOGRAM()</a></li>
<li><a href="#ln">LN()</a></li>
<li><a href="#log">LOG()</a></li>
<li><a href="#log2">LOG2()</a></li>
<li><a href="#log10">LOG10()</a></li>
<li><a href="#moving-average">MOVING_AVERAGE()</a></li>
<li><a href="#non-negative-derivative">NON_NEGATIVE_DERIVATIVE()</a></li>
<li><a href="#non-negative-difference">NON_NEGATIVE_DIFFERENCE()</a></li>
<li><a href="#pow">POW()</a></li>
<li><a href="#round">ROUND()</a></li>
<li><a href="#sin">SIN()</a></li>
<li><a href="#sqrt">SQRT()</a></li>
<li><a href="#tan">TAN()</a></li>
</ul>
</li>
<li><a href="#%E9%A2%84%E6%B5%8B%E5%87%BD%E6%95%B0">预测函数</a>
<ul>
<li><a href="#holt_winters">HOLT_WINTERS()</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0">分析函数</a>
<ul>
<li><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></li>
<li><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></li>
<li><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></li>
<li><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></li>
<li><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></li>
</ul>
</li>
<li><a href="#other">其他</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE">示例数据</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95">函数的通用语法</a>
<ul>
<li><a href="#%E5%9C%A8SELECT%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">在<code>SELECT</code>中指定多个函数</a></li>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%AD%97%E6%AE%B5">重命名查询结果字段</a></li>
<li><a href="#%E6%94%B9%E5%8F%98%E4%B8%8D%E5%90%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">改变不含数据的时间间隔的返回值</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">函数常见问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h3>
<ul>
<li>
<h3 id="count"><a class="header" href="#count">COUNT()</a></h3>
<p>返回非空值 field values数量</p>
<h4 id="语法-1"><a class="header" href="#语法-1">语法</a></h4>
<pre><code class="language-sql">SELECT COUNT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法"><a class="header" href="#嵌套语法">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<p><code>COUNT(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT()</code>支持所有数据类型的<code>field value</code>。cnosQL支持将<a href="#distinct"><code>DISTINCT()</code></a>函数嵌套在<code>COUNT()</code>函数里。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key的field-value的数目"><a class="header" href="#计算指定field-key的field-value的数目">计算指定field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count
----                   -----
1970-01-01T00:00:00Z   15258
</code></pre>
<p>该查询返回<code>measurement``h2o_feet</code>中的<code>water_level</code>的非空field value的数量。</p>
<ul>
<li>
<h4 id="计数measurement中每个field-key关联的field-value的数量"><a class="header" href="#计数measurement中每个field-key关联的field-value的数量">计数measurement中每个field key关联的field value的数量</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count_level description   count_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   15258                     15258
</code></pre>
<p>该查询返回与1measurement``h2o_feet<code>相关联的每个field key的非空field value的数量。</code>h2o_feet<code>有两个field keys：</code>level_description<code>和</code>water_level`</p>
<ul>
<li>
<h4 id="计算匹配一个正则表达式的每个field-key关联的field-value的数目"><a class="header" href="#计算匹配一个正则表达式的每个field-key关联的field-value的数目">计算匹配一个正则表达式的每个field key关联的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count_water_level
----                   -----------------
1970-01-01T00:00:00Z   15258
</code></pre>
<p>该查询返回measurement<code>h2o_feet</code>中包含<code>water</code>单词的每个field key的非空字段值的数量。</p>
<ul>
<li>
<h4 id="计数包括多个子句的field-key的field-value的数目"><a class="header" href="#计数包括多个子句的field-key的field-value的数目">计数包括多个子句的field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(200) LIMIT 7 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   count
----                   -----
2020-08-17T23:48:00Z   200
2020-08-18T00:00:00Z   2
2020-08-18T00:12:00Z   2
2020-08-18T00:24:00Z   2
2020-08-18T00:36:00Z   2
2020-08-18T00:48:00Z   2
</code></pre>
<p>该查询返回<code>water_level</code>field key中的非空field value的数量。它涵盖<code>2020-08-17T23：48：00Z</code>和<code>2020-08-18T00：54：00Z</code>之间的<code>时间段</code>，并将结果分组为12分钟的时间间隔和每个tag。并用<code>200</code>填充空的时间间隔，并返回7个<code>point</code>，表格返回1。</p>
<ul>
<li>
<h4 id="计算一个field-key的distinct的field-value的数量"><a class="header" href="#计算一个field-key的distinct的field-value的数量">计算一个field key的distinct的field value的数量</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;level description&quot;)) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count
----                   -----
1970-01-01T00:00:00Z   4
</code></pre>
<p>查询返回measurement为<code>h2o_feet</code>field<code>为</code>level description 的唯一field value的数量。</p>
<h4 id="count的常见问题"><a class="header" href="#count的常见问题"><code>COUNT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="count和fill"><a class="header" href="#count和fill"><code>COUNT()</code>和<code>fill()</code></a></h4>
</li>
</ul>
<p>大多数cnosQL函数对于没有数据的时间间隔返回<code>null</code>值，<code>fill(&lt;fill_option&gt;)</code>将该<code>null</code>值替换为<code>fill_option</code>。 <code>COUNT()</code>针对没有数据的时间间隔返回<code>0</code>，<code>fill(&lt;fill_option&gt;)</code>用<code>fill_option</code>替换0值。</p>
<p><em>示例</em></p>
<p>下面的代码块中的第一个查询不包括<code>fill()</code>。最后一个时间间隔没有数据，因此该时间间隔的值返回为零。第二个查询包括<code>fill(800000)</code>; 它将最后一个间隔中的零替换为<code>800000</code>。</p>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-09-18T21:24:00Z' AND time &lt;= '2020-09-18T21:54:00Z' GROUP BY time(12m)

name: h2o_feet
time                   count
----                   -----
2020-09-18T21:24:00Z   2
2020-09-18T21:36:00Z   2
2020-09-18T21:48:00Z   0

&gt; SELECT COUNT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-09-18T21:24:00Z' AND time &lt;= '2020-09-18T21:54:00Z' GROUP BY time(12m) fill(800000)

name: h2o_feet
time                   count
----                   -----
2020-09-18T21:24:00Z   2
2020-09-18T21:36:00Z   2
2020-09-18T21:48:00Z   800000
</code></pre>
</li>
<li>
<h3 id="distinct"><a class="header" href="#distinct"><code>DISTINCT()</code></a></h3>
<p>返回<code>field value</code>的不重复值列表。</p>
<h4 id="语法-2"><a class="header" href="#语法-2">语法</a></h4>
<pre><code class="language-sql">SELECT DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法-1"><a class="header" href="#嵌套语法-1">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<h4 id="语法描述"><a class="header" href="#语法描述">语法描述</a></h4>
<p><code>DISTINCT(field_key)</code> 返回<code>field key</code>对应的不同<code>field values</code>。</p>
<p><code>DISTINCT()</code> 支持所有数据类型的<code>field value</code>，cnosQL支持<a href="#count"><code>COUNT()</code></a>嵌套<code>DISTINCT()</code>。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<ul>
<li>
<h4 id="列出一个field-key的不同的field-value"><a class="header" href="#列出一个field-key的不同的field-value">列出一个<code>field key</code>的不同的<code>field value</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   distinct
----                   --------
1970-01-01T00:00:00Z   between 6 and 9 feet
1970-01-01T00:00:00Z   below 3 feet
1970-01-01T00:00:00Z   between 3 and 6 feet
1970-01-01T00:00:00Z   at or greater than 9 feet
</code></pre>
<p>该查询返回<code>h2o_feet</code> measurement中<code>level description</code>filed 关键字中唯一<code>field values</code>的列表</p>
<ul>
<li>
<h4 id="列出一个measurement中每个field-key的不同的值"><a class="header" href="#列出一个measurement中每个field-key的不同的值">列出一个measurement中每个field key的不同的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DISTINCT(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   distinct_level description   distinct_water_level
----                   --------------------------   --------------------
1970-01-01T00:00:00Z   between 6 and 9 feet         8.12
1970-01-01T00:00:00Z   between 3 and 6 feet         8.005
1970-01-01T00:00:00Z   at or greater than 9 feet    7.887
1970-01-01T00:00:00Z   below 3 feet                 7.762
[...]
</code></pre>
<p>查询返回<code>h2o_feet</code>中每个字段的唯一字段值的列表。<code>h2o_feet</code>有两个字段：<code>description</code>和<code>water_level</code>。</p>
<ul>
<li>
<h4 id="列出包含多个子句的field-key关联的不同值的列表"><a class="header" href="#列出包含多个子句的field-key关联的不同值的列表">列出包含多个子句的field key关联的不同值的列表</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;  SELECT DISTINCT(&quot;level description&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   distinct
----                   --------
2020-08-18T00:00:00Z   between 6 and 9 feet
2020-08-18T00:12:00Z   between 6 and 9 feet
2020-08-18T00:24:00Z   between 6 and 9 feet
2020-08-18T00:36:00Z   between 6 and 9 feet
2020-08-18T00:48:00Z   between 6 and 9 feet
</code></pre>
<p>该查询返回<code>level description</code>field key中不同field value的列表。它涵盖<code>2020-08-17T23：48：00Z</code>和<code>2020-08-18T00：54：00Z</code>之间的时间段，并将结果按12分钟的时间间隔和每个tag分组。查询限制返回一个series。</p>
<ul>
<li>
<h4 id="对一个字段的不同值进行计算"><a class="header" href="#对一个字段的不同值进行计算">对一个字段的不同值进行计算</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;level description&quot;)) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   count
----                   -----
1970-01-01T00:00:00Z   4
</code></pre>
<p>查询返回<code>h2o_feet</code>这个measurement中字段<code>level description</code>的不同值的数目。</p>
<h4 id="distinct的常见问题"><a class="header" href="#distinct的常见问题"><code>DISTINCT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="distinct-和-into-子句"><a class="header" href="#distinct-和-into-子句"><code>DISTINCT()</code> 和 <code>INTO</code> 子句</a></h4>
</li>
</ul>
<p>在<code>INTO</code>子句中使用<code>DISTINCT()</code>可能会导致cnosDB覆盖目标measurement中的<code>points</code>。<code>DISTINCT()</code>通常返回多个具有相同时间戳的结果；cnosDB假设在相同series中并具有相同时间戳的<code>point</code>是重复<code>point</code>，并简单地用目标measurement中最新的<code>point</code>覆盖重复<code>point</code>。</p>
<p>####示例</p>
<p>下面代码块中的第一个查询使用了<code>DISTINCT()</code>，并返回四个结果。请注意，每个结果都有相同的时间戳。第二个查询将<code>INTO</code>子句添加到查询中，并将查询结果写入measurement <code>distincts</code>。最后一个查询选择measurement <code>distincts</code>中所有数据。
因为原来的四个结果是重复的(它们在相同的series，有相同的时间戳)，所以最后一个查询只返回一个<code>point</code>。当系统遇到重复数据<code>point</code>，它会用最近的<code>point</code>覆盖之前的<code>point</code>。</p>
<pre><code class="language-sql">&gt;  SELECT DISTINCT(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   distinct
----                   --------
1970-01-01T00:00:00Z   below 3 feet
1970-01-01T00:00:00Z   between 6 and 9 feet
1970-01-01T00:00:00Z   between 3 and 6 feet
1970-01-01T00:00:00Z   at or greater than 9 feet

&gt;  SELECT DISTINCT(&quot;level description&quot;) INTO &quot;distincts&quot; FROM &quot;h2o_feet&quot;

name: result
time                   written
----                   -------
1970-01-01T00:00:00Z   4

&gt; SELECT * FROM &quot;distincts&quot;

name: distincts
time                   distinct
----                   --------
1970-01-01T00:00:00Z   at or greater than 9 feet
</code></pre>
</li>
<li>
<h3 id="integral"><a class="header" href="#integral"><code>INTEGRAL()</code></a></h3>
<p>返回<code>field value</code>曲线下的面积，即关于<code>field value</code>的积分。</p>
<h4 id="语法-3"><a class="header" href="#语法-3">语法</a></h4>
<pre><code>SELECT INTEGRAL( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ]  ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-1"><a class="header" href="#语法描述-1">语法描述</a></h4>
<p>cnosDB计算field value曲线下的面积，并将这些结果转换为每个<code>unit</code>的总面积。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>INTEGRAL(field_key)</code>返回field key关联的值之下的面积。</p>
<p><code>INTEGRAL(/regular_expression/)</code>返回满足正则表达式的每个field key关联的值之下的面积。</p>
<p><code>INTEGRAL(*)</code>返回<code>measurement</code>中每个<code>field key</code>关联的值之下的面积。</p>
<p><code>INTEGRAL()</code>不支持<code>fill()</code>，<code>INTEGRAL()</code>支持int64和float64两个数据类型。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<p>下面的五个例子，使用数据库<a href="NOAA_water_database.txt"><code>NOAA_water_database</code>中的数据</a>：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定的field-key的值得积分"><a class="header" href="#计算指定的field-key的值得积分">计算指定的field key的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral
----                 --------
1970-01-01T00:00:00Z 3732.66
</code></pre>
<p>该查询返回<code>h2o_feet</code>中的字段<code>water_level</code>的曲线下的面积（以秒为单位）。</p>
<ul>
<li>
<h4 id="计算指定的field-key和时间单位的值得积分"><a class="header" href="#计算指定的field-key和时间单位的值得积分">计算指定的field key和时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(&quot;water_level&quot;,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral
----                 --------
1970-01-01T00:00:00Z 62.211
</code></pre>
<p>该查询返回<code>h2o_feet</code>中的字段<code>water_level</code>的曲线下的面积（以分钟为单位）。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中每个field-key在指定时间单位的值得积分">计算measurement中每个field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(*,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral_water_level
----                 --------------------
1970-01-01T00:00:00Z 62.211
</code></pre>
<p>查询返回measurement<code>h2o_feet</code>中存储的每个数值字段相关的字段值的曲线下面积（以分钟为单位）。 <code>h2o_feet</code>的数值字段为<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分">计算measurement中匹配正则表达式的field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(/water/,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                 integral_water_level
----                 --------------------
1970-01-01T00:00:00Z 62.211
</code></pre>
<p>查询返回field key包括单词<code>water</code>的每个数值类型的字段相关联的字段值的曲线下的区域（以分钟为单位）。</p>
<ul>
<li>
<h4 id="在含有多个子句中计算指定字段的积分"><a class="header" href="#在含有多个子句中计算指定字段的积分">在含有多个子句中计算指定字段的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT INTEGRAL(&quot;water_level&quot;,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m) LIMIT 1

name: h2o_feet
time                 integral
----                 --------
2020-08-18T00:00:00Z 24.972
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的field value曲线下的面积(以分钟为单位)，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并将查询结果按12分钟的时间间隔进行分组，同时，该查询将返回的<code>point</code>个数限制为1。</p>
</li>
<li>
<h3 id="mean"><a class="header" href="#mean"><code>MEAN()</code></a></h3>
<p>返回field value的平均值。</p>
<h4 id="语法-4"><a class="header" href="#语法-4">语法</a></h4>
<pre><code>SELECT MEAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MEAN(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的field value的平均值。</p>
<p><code>MEAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值"><a class="header" href="#计算指定field-key对应的field-value的平均值">计算指定field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mean
----                   ----
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均值">计算measurement中每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mean_water_level
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均值。<code>measurement</code> <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均值">计算与正则表达式匹配的每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mean_water_level
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822523
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均值并包含多个子句">计算指定field key对应的field value的平均值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 7 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   mean
----                   ----
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.0625
2020-08-18T00:12:00Z   7.8245
2020-08-18T00:24:00Z   7.5675
2020-08-18T00:36:00Z   7.303
2020-08-18T00:48:00Z   7.046
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的平均值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为7和1。</p>
</li>
<li>
<h3 id="median"><a class="header" href="#median">MEDIAN()</a></h3>
<p>返回<code>field value</code>的计算平均值。</p>
<h4 id="语法-5"><a class="header" href="#语法-5">语法</a></h4>
<pre><code>SELECT MEDIAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-2"><a class="header" href="#语法描述-2">语法描述</a></h4>
<p><code>MEDIAN(field_key)</code>返回与<code>field key</code>对应的field value的平均值。</p>
<p><code>MEDIAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEDIAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEDIAN()</code> 支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong><code>MEDIAN()</code>近似于<code>PERCENTILE(field_key, 50)</code>，除非<code>field key</code>包含的<code>field value</code>有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</p>
</blockquote>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均数"><a class="header" href="#计算指定field-key对应的field-value的平均数">计算指定field key对应的field value的平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   median
----                   ------
1970-01-01T00:00:00Z   4.124
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中field key <code>water_level</code>对应的<code>field value</code>的平均数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平均数"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均数">计算measurement中每个field key对应的field value的平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   median_water_level
----                   ------------------
1970-01-01T00:00:00Z   4.124
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均数。<code>measurement</code> <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的平均数"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均数">计算与正则表达式匹配的每个field key对应的field value的平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   median_water_level
----                   ------------------
1970-01-01T00:00:00Z   4.124
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的平均数。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均数并包含多个子句">计算指定field key对应的field value的平均数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(700) LIMIT 7 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   median
----                   ------
2020-08-17T23:48:00Z   700
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
2020-08-18T00:36:00Z   2.0620000000000003
2020-08-18T00:48:00Z   700
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>的平均数，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>700</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为7和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="mode"><a class="header" href="#mode">MODE()</a></h3>
<p>返回<code>field value</code>中出现频率最高的值。</p>
<h4 id="语法-6"><a class="header" href="#语法-6">语法</a></h4>
<pre><code>SELECT MODE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MODE(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE()</code> 支持所有数据类型的<code>field value</code>。</p>
<blockquote>
<p>**注意：**如果出现频率最高的值有两个或多个并且它们之间有关联，那么<code>MODE()</code>返回具有最早时间戳的<code>field value</code>。</p>
</blockquote>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值">计算指定field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mode
----                   ----
1970-01-01T00:00:00Z   between 3 and 6 feet
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。measurement <code>h2o_feet</code>中有两个<code>field key</code>：<code>level description</code>和<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算measurement中每个field-key对应的field-value中出现频率最高的值">计算measurement中每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mode_level description   mode_water_level
----                   ----------------------   ----------------
1970-01-01T00:00:00Z   between 3 and 6 feet     2.69
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。<code>measurement</code> <code>h2o_feet</code>中有两个<code>field key</code>：<code>level description</code>和<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值">计算与正则表达式匹配的每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   mode_water_level
----                   ----------------
1970-01-01T00:00:00Z   2.69
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值并包含多个子句">计算指定field key对应的field value中出现频率最高的值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;level description&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* LIMIT 3 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   mode
----                   ----
2020-08-17T23:48:00Z
2020-08-18T00:00:00Z   below 3 feet
2020-08-18T00:12:00Z   below 3 feet
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>中出现频率最高的值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="spread"><a class="header" href="#spread">SPREAD()</a></h3>
<p>返回<code>field value</code>中最大值和最小值之差。</p>
<h4 id="语法-7"><a class="header" href="#语法-7">语法</a></h4>
<pre><code class="language-sql">SELECT SPREAD( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-3"><a class="header" href="#语法描述-3">语法描述</a></h4>
<p><code>SPREAD(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD()</code>支持数据类型为int64和float64的<code>field value</code>。</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差">计算指定field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   spread
----                   ------
1970-01-01T00:00:00Z   10.574
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中<code>field key</code> <code>water_level</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算measurement中每个field-key对应的field-value中最大值和最小值之差">计算measurement中每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   spread_water_level
----                   ------------------
1970-01-01T00:00:00Z   10.574
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。<code>measurement</code> <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差">计算与正则表达式匹配的每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   spread_water_level
----                   ------------------
1970-01-01T00:00:00Z   10.574
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句">计算指定field key对应的field value中最大值和最小值之差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(18) LIMIT 3 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   spread
----                   ------
2020-08-17T23:48:00Z   18
2020-08-18T00:00:00Z   0.052000000000000046
2020-08-18T00:12:00Z   0.09799999999999986
</code></pre>
<p>该查询返回<code>measurement</code> <code>h2o_feet</code>中field key <code>water_level</code>对应的field value中最大值和最小值之差，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>18</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）</p>
</li>
<li>
<h3 id="stddev"><a class="header" href="#stddev">STDDEV()</a></h3>
<p>返回<code>field value</code>的标准差。</p>
<h4 id="语法-8"><a class="header" href="#语法-8">语法</a></h4>
<pre><code class="language-sql">SELECT STDDEV( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>STDDEV(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(*)</code>返回在measurement中每个field key对应的field value的标准差。</p>
<p><code>STDDEV()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差"><a class="header" href="#计算指定field-key对应的field-value的标准差">计算指定field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   stddev
----                   ------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的标准差"><a class="header" href="#计算measurement中每个field-key对应的field-value的标准差">计算measurement中每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   stddev_water_level
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的标准差。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的标准差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的标准差">计算与正则表达式匹配的每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   stddev_water_level
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的标准差并包含多个子句">计算指定field key对应的field value的标准差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(18000) LIMIT 2 SLIMIT 1 SOFFSET 1

name: h2o_feet
tags: location=santa_monica
time                   stddev
----                   ------
2020-08-17T23:48:00Z   18000
2020-08-18T00:00:00Z   0.03676955262170051
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的标准差，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为2和1，并将返回的series偏移一个（即第一个series的数据不返回）。</p>
</li>
<li>
<h3 id="sum"><a class="header" href="#sum">SUM()</a></h3>
<p>返回field value的总和。</p>
<h4 id="语法-9"><a class="header" href="#语法-9">语法</a></h4>
<pre><code>SELECT SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-4"><a class="header" href="#语法描述-4">语法描述</a></h4>
<p><code>SUM(field_key)</code>返回field key对应的field value的总和。</p>
<p><code>SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的总和。</p>
<p><code>SUM(*)</code>返回在measurement中每个field key对应的field value的总和。</p>
<p><code>SUM()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和"><a class="header" href="#计算指定field-key对应的field-value的总和">计算指定field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum
----                   ---
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的总和">计算measurement中每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum_water_level
----                   ---------------
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的总和。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的总和">计算与正则表达式匹配的每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(/water/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum_water_level
----                   ---------------
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的总和并包含多个子句">计算指定field key对应的field value的总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(18000) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   sum
----                   ---
2020-08-17T23:48:00Z   18000
2020-08-18T00:00:00Z   16.125
2020-08-18T00:12:00Z   15.649
2020-08-18T00:24:00Z   15.135
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的总和，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
</li>
</ul>
<h2 id="选择函数"><a class="header" href="#选择函数">选择函数</a></h2>
<ul>
<li>
<h3 id="bottom"><a class="header" href="#bottom">BOTTOM()</a></h3>
<p>返回最小的N个field value。</p>
<h4 id="语法-10"><a class="header" href="#语法-10">语法</a></h4>
<pre><code>SELECT BOTTOM(&lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-5"><a class="header" href="#语法描述-5">语法描述</a></h4>
<p><code>BOTTOM(field_key,N)</code>返回field key对应的最小的N个值。</p>
<p><code>BOTTOM(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最小值。</p>
<p><code>BOTTOM(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最小的N个值，以及相关的tag和/或field。</p>
<p><code>BOTTOM()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最小值有两个或多个相等的值，<code>BOTTOM()</code>返回具有最早时间戳的field value。</li>
<li>当<code>BOTTOM()</code>函数与<code>INTO</code>子句一起使用时，<code>BOTTOM()</code>与其它cnosQL函数不同。请查看<code>BOTTOM()</code>的常见问题章节获得更多信息。</li>
</ul>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值"><a class="header" href="#选择指定field-key对应的最小的三个值">选择指定field key对应的最小的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   bottom
----                   ------
2020-08-29T14:30:00Z   -0.61
2020-08-29T14:36:00Z   -0.591
2020-08-30T15:18:00Z   -0.594
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的最小的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最小值"><a class="header" href="#选择两个tag对应的field-key的最小值">选择两个tag对应的field key的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,&quot;location&quot;,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   bottom   location
----                   ------   --------
2020-08-29T10:36:00Z   -0.243   santa_monica
2020-08-29T14:30:00Z   -0.61    coyote_creek
</code></pre>
<p>该查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最小的四个值以及相关的tag和field">选择指定field key对应的最小的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,4),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  bottom  location      level description
----                  ------  --------      -----------------
2020-08-29T14:24:00Z  -0.587  coyote_creek  below 3 feet
2020-08-29T14:30:00Z  -0.61   coyote_creek  below 3 feet
2020-08-29T14:36:00Z  -0.591  coyote_creek  below 3 feet
2020-08-30T15:18:00Z  -0.594  coyote_creek  below 3 feet
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的最小的四个值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最小的三个值并包含多个子句">选择指定field key对应的最小的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,3),&quot;location&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC

name: h2o_feet
time                  bottom  location
----                  ------  --------
2020-08-18T00:48:00Z  1.991   santa_monica
2020-08-18T00:54:00Z  2.054   santa_monica
2020-08-18T00:54:00Z  6.982   coyote_creek
2020-08-18T00:24:00Z  2.041   santa_monica
2020-08-18T00:30:00Z  2.051   santa_monica
2020-08-18T00:42:00Z  2.057   santa_monica
2020-08-18T00:00:00Z  2.064   santa_monica
2020-08-18T00:06:00Z  2.116   santa_monica
2020-08-18T00:12:00Z  2.028   santa_monica
</code></pre>
<p>该查询返回在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>water_level</code>对应的最小的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="bottom的常见问题"><a class="header" href="#bottom的常见问题"><code>BOTTOM()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="bottom和group-by-time子句同时使用"><a class="header" href="#bottom和group-by-time子句同时使用"><code>BOTTOM()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>BOTTOM()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>BOTTOM()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   bottom
----                   ------
                           __
2020-08-18T00:00:00Z  2.064 |
2020-08-18T00:12:00Z  2.028 | &lt;------- Smallest points for the first time interval
                           --
                           __
2020-08-18T00:24:00Z  2.041 |
2020-08-18T00:30:00Z  2.051 | &lt;------- Smallest points for the second time interval                      --
</code></pre>
<ul>
<li>
<h4 id="bottom和具有少于n个tag-value的tag-key"><a class="header" href="#bottom和具有少于n个tag-value的tag-key"><code>BOTTOM()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT BOTTOM(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>location</code>的三个tag value对于的<code>water_level</code>的最小值。因为tag key <code>location</code>只有两个tag value(<code>santa_monica</code>和<code>coyote_creek</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,&quot;location&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   bottom   location
----                   ------   --------
2020-08-29T10:36:00Z   -0.243   santa_monica
2020-08-29T14:30:00Z   -0.61    coyote_creek
</code></pre>
<ul>
<li>
<h4 id="bottomtag和into子句"><a class="header" href="#bottomtag和into子句"><code>BOTTOM()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>BOTTOM()</code>函数除非<code>BOTTOM()</code>中包含tag key作为参数：<code>BOTTOM(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最小值，并且，它这些结果写入measurement <code>bottom_water_levels</code>中。第二个查询展示了CnosDB将tag <code>location</code>保留为measurement <code>bottom_water_levels</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;water_level&quot;,&quot;location&quot;,2) INTO &quot;bottom_water_levels&quot; FROM &quot;h2o_feet&quot;

name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;bottom_water_levels&quot;

name: bottom_water_levels
tagKey
------
location
</code></pre>
</li>
<li>
<h3 id="first"><a class="header" href="#first">FIRST()</a></h3>
<p>返回具有最早时间戳的field value。</p>
<h4 id="语法-11"><a class="header" href="#语法-11">语法</a></h4>
<pre><code>SELECT FIRST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-6"><a class="header" href="#语法描述-6">语法描述</a></h4>
<p><code>FIRST(field_key)</code>返回field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(*)</code>返回在measurement中每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最早时间戳的field value，以及相关的tag或field。</p>
<p><code>FIRST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value">选择指定field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   first
----                   -----
2020-08-18T00:00:00Z   between 6 and 9 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最早时间戳的field-value">选择measurement中每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   first_level description   first_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 6 and 9 feet      8.12
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的具有最早时间戳的field value。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   first_level description   first_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 6 and 9 feet      8.12
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最早时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;level description&quot;),&quot;location&quot;,&quot;water_level&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  first                 location      water_level
----                  -----                 --------      -----------
2020-08-18T00:00:00Z  between 6 and 9 feet  coyote_creek  8.12
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最早时间戳的field value，以及相关的tag key <code>location</code>和field key <code>water_level</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value并包含多个子句">选择指定field key对应的具有最早时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   first
----                   -----
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.12
2020-08-18T00:12:00Z   7.887
2020-08-18T00:24:00Z   7.635
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的具有最早时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="last"><a class="header" href="#last">LAST()</a></h3>
<p>返回具有最新时间戳的field value。</p>
<h4 id="语法-12"><a class="header" href="#语法-12">语法</a></h4>
<pre><code class="language-sql">SELECT LAST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_keys(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LAST(field_key)</code>返回field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(*)</code>返回在measurement中每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最新时间戳的field value，以及相关的tag或field。</p>
<p><code>LAST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value">选择指定field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   last
----                   ----
2020-09-18T21:42:00Z   between 3 and 6 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最新时间戳的field-value">选择measurement中每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   last_level description   last_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 3 and 6 feet      4.938
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的具有最新时间戳的field value。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   last_level description   last_water_level
----                   -----------------------   -----------------
1970-01-01T00:00:00Z   between 3 and 6 feet      4.938
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最新时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;level description&quot;),&quot;location&quot;,&quot;water_level&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  last                  location      water_level
----                  ----                  --------      -----------
2020-09-18T21:42:00Z  between 3 and 6 feet  santa_monica  4.938
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>level description</code>对应的具有最新时间戳的field value，以及相关的tag key <code>location</code>和field key <code>water_level</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value并包含多个子句">选择指定field key对应的具有最新时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   last
----                   ----
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.005
2020-08-18T00:12:00Z   7.762
2020-08-18T00:24:00Z   7.5
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的具有最新时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="max"><a class="header" href="#max">MAX()</a></h3>
<p>返回field value的最大值。</p>
<h4 id="语法-13"><a class="header" href="#语法-13">语法</a></h4>
<pre><code>SELECT MAX(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field__key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MAX(field_key)</code>返回field key对应的field value的最大值。</p>
<p><code>MAX(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最大值。</p>
<p><code>MAX(*)</code>返回在measurement中每个field key对应的field value的最大值。</p>
<p><code>MAX(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最大值，以及相关的tag或field。</p>
<p><code>MAX()</code> 支持数据类型为int64和float64的field value。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值"><a class="header" href="#选择指定field-key对应的field-value的最大值">选择指定field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   max
----                   ---
2020-08-29T07:24:00Z   9.964
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最大值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最大值">选择measurement中每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   max_water_level
----                   ---------------
2020-08-29T07:24:00Z   9.964
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的最大值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最大值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最大值">选择与正则表达式匹配的每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   max_water_level
----                   ---------------
2020-08-29T07:24:00Z   9.964
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最大值以及相关的tag和field">选择指定field key对应的field value的最大值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max    location      level description
----                  ---    --------      -----------------
2020-08-29T07:24:00Z  9.964  coyote_creek  at or greater than 9 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最大值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最大值并包含多个子句">选择指定field key对应的field value的最大值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   max
----                   ---
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.12
2020-08-18T00:12:00Z   7.887
2020-08-18T00:24:00Z   7.635
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最大值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="min"><a class="header" href="#min">MIN()</a></h3>
<p>返回field value的最小值。</p>
<h4 id="语法-14"><a class="header" href="#语法-14">语法</a></h4>
<pre><code>SELECT MIN(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MIN(field_key)</code>返回field key对应的field value的最小值。</p>
<p><code>MIN(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最小值。</p>
<p><code>MIN(*)</code>返回在measurement中每个field key对应的field value的最小值。</p>
<p><code>MIN(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最小值，以及相关的tag和/或field。</p>
<p><code>MIN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-13"><a class="header" href="#示例-13">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值"><a class="header" href="#选择指定field-key对应的field-value的最小值">选择指定field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   min
----                   ---
2020-08-29T14:30:00Z   -0.61
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最小值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最小值">选择measurement中每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   min_water_level
----                   ---------------
2020-08-29T14:30:00Z   -0.61
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的最小值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最小值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最小值">选择与正则表达式匹配的每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(/level/) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   min_water_level
----                   ---------------
2020-08-29T14:30:00Z   -0.61
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最小值以及相关的tag和field">选择指定field key对应的field value的最小值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  min    location      level description
----                  ---    --------      -----------------
2020-08-29T14:30:00Z  -0.61  coyote_creek  below 3 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最小值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最小值并包含多个子句">选择指定field key对应的field value的最小值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1

name: h2o_feet
tags: location=coyote_creek
time                   min
----                   ---
2020-08-17T23:48:00Z   9.01
2020-08-18T00:00:00Z   8.005
2020-08-18T00:12:00Z   7.762
2020-08-18T00:24:00Z   7.5
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的最小值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="percentile"><a class="header" href="#percentile">PERCENTILE()</a></h3>
<p>返回第N个百分位数的<code>field value</code></p>
<h4 id="语法-15"><a class="header" href="#语法-15">语法</a></h4>
<pre><code>SELECT PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>PERCENTILE(field_key,N)</code>返回指定field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(*,N)</code>返回在measurement中每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的第N个百分位数的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是0到100之间的整数或浮点数。</p>
<p><code>PERCENTILE()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value">选择指定field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;water_level&quot;,5) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   percentile
----                   ----------
2020-08-31T03:42:00Z   1.122
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择measurement中每个field-key对应的第五个百分位数的field-value">选择measurement中每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(*,5) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   percentile_water_level
----                   ----------------------
2020-08-31T03:42:00Z   1.122
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中每个存储数值的field key对应的所有field value中的百分之五。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value">选择与正则表达式匹配的每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(/level/,5) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   percentile_water_level
----                   ----------------------
2020-08-31T03:42:00Z   1.122
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field">选择指定field key对应的第五个百分位数的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;water_level&quot;,5),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  percentile  location      level description
----                  ----------  --------      -----------------
2020-08-31T03:42:00Z  1.122       coyote_creek  below 3 feet
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的所有field value中的百分之五，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第20个百分位数的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的第20个百分位数的field-value并包含多个子句">选择指定field key对应的第20个百分位数的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;water_level&quot;,20) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-17T23:48:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(24m) fill(15) LIMIT 2

name: h2o_feet
time                   percentile
----                   ----------
2020-08-17T23:36:00Z   15
2020-08-18T00:00:00Z   2.064
</code></pre>
<p>该查询返回的field value大于measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的所有field value中的百分之二十，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按24分钟的时间间隔进行分组，同时，该查询用<code>15</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数限制为2。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每24分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:36:00Z</code>和<code>2020-08-18T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:24:00Z</code>之间。</p>
<h4 id="percentile的常见问题"><a class="header" href="#percentile的常见问题"><code>PERCENTILE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="percentile-vs-其它cnosql函数"><a class="header" href="#percentile-vs-其它cnosql函数"><code>PERCENTILE()</code> vs 其它cnosQL函数</a></h4>
</li>
</ul>
<ul>
<li><code>PERCENTILE(&lt;field_key&gt;,100)</code>相当于<code>MAX(&lt;field_key&gt;)</code>。</li>
<li><code>PERCENTILE(&lt;field_key&gt;, 50)</code>近似于<code>MEDIAN(&lt;field_key&gt;)</code>，除非field key包含的field value有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</li>
<li><code>PERCENTILE(&lt;field_key&gt;,0)</code>不等于<code>MIN(&lt;field_key&gt;)</code>，<code>PERCENTILE(&lt;field_key&gt;,0)</code>会返回<code>null</code>。</li>
</ul>
</li>
<li>
<h3 id="sample"><a class="header" href="#sample">SAMPLE()</a></h3>
<p>返回包含N个field value的随机样本。<code>SAMPLE()</code>使用<a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a>来生成随机<code>point</code>。</p>
<h4 id="语法-16"><a class="header" href="#语法-16">语法</a></h4>
<pre><code>SELECT SAMPLE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SAMPLE(field_key,N)</code>返回指定field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(*,N)</code>返回在measurement中每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的N个随机选择的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是整数。</p>
<p><code>SAMPLE()</code>支持所有数据类型的field value。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本"><a class="header" href="#选择指定field-key对应的field-value的随机样本">选择指定field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sample
----                   ------
2020-09-09T21:48:00Z   5.659
2020-09-18T10:00:00Z   6.939
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的随机样本"><a class="header" href="#选择measurement中每个field-key对应的field-value的随机样本">选择measurement中每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(*,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sample_level description   sample_water_level
----                   ------------------------   ------------------
2020-08-25T17:06:00Z                              3.284
2020-09-03T04:30:00Z   below 3 feet
2020-09-03T20:06:00Z   between 3 and 6 feet
2020-09-08T21:54:00Z                              3.412
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的两个随机选择的<code>point</code>。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的随机样本"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的随机样本">选择与正则表达式匹配的每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(/level/,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sample_level description   sample_water_level
----                   ------------------------   ------------------
2020-08-30T05:54:00Z   between 6 and 9 feet
2020-09-07T01:18:00Z                              7.854
2020-09-09T20:30:00Z                              7.32
2020-09-13T19:18:00Z   between 3 and 6 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的随机样本以及相关的tag和field">选择指定field key对应的field value的随机样本以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,2),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  sample  location      level description
----                  ------  --------      -----------------
2020-08-29T10:54:00Z  5.689   coyote_creek  between 3 and 6 feet
2020-09-08T15:48:00Z  6.391   coyote_creek  between 6 and 9 feet
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的两个随机选择的<code>point</code>，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应field-value的随机样本并包含多个子句"><a class="header" href="#选择指定field-key对应field-value的随机样本并包含多个子句">选择指定field key对应field value的随机样本并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,1) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   sample
----                   ------
2020-08-18T00:12:00Z   2.028
2020-08-18T00:30:00Z   2.051
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的一个随机选择的<code>point</code>，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并将查询结果按18分钟的时间间隔进行分组。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="sample的常见问题"><a class="header" href="#sample的常见问题"><code>SAMPLE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="sample和group-by-time子句同时使用"><a class="header" href="#sample和group-by-time子句同时使用"><code>SAMPLE()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>SAMPLE()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数(<code>N</code>)的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>SAMPLE()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个随机选择的<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   sample
----                   ------
                           __
2020-08-18T00:06:00Z   2.116 |
2020-08-18T00:12:00Z   2.028 | &lt;------- Randomly-selected points for the first time interval
                           --
                           __
2020-08-18T00:18:00Z   2.126 |
2020-08-18T00:30:00Z   2.051 | &lt;------- Randomly-selected points for the second time interval
                           --
</code></pre>
</li>
<li>
<h3 id="top"><a class="header" href="#top">TOP()</a></h3>
<p>返回最大的N个field value</p>
<h4 id="语法-17"><a class="header" href="#语法-17">语法</a></h4>
<pre><code>SELECT TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TOP(field_key,N)</code>返回field key对应的最大的N个值。</p>
<p><code>TOP(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最大值。</p>
<p><code>TOP(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最大的N个值，以及相关的tag和/或field。</p>
<p><code>TOP()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最大值有两个或多个并且它们之间有关联，<code>TOP()</code>返回具有最早时间戳的field value。</li>
</ul>
<h4 id="示例-16"><a class="header" href="#示例-16">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值"><a class="header" href="#选择指定field-key对应的最大的三个值">选择指定field key对应的最大的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   top
----                   ---
2020-08-29T07:18:00Z   9.957
2020-08-29T07:24:00Z   9.964
2020-08-29T07:30:00Z   9.954
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的最大的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最大值"><a class="header" href="#选择两个tag对应的field-key的最大值">选择两个tag对应的field key的最大值</a></h4>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,&quot;location&quot;,2) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   top     location
----                   ---     --------
2020-08-29T03:54:00Z   7.205   santa_monica
2020-08-29T07:24:00Z   9.964   coyote_creek
</code></pre>
<p>该查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最大值。</p>
</li>
<li>
<h4 id="选择指定field-key对应的最大的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最大的四个值以及相关的tag和field">选择指定field key对应的最大的四个值以及相关的tag和field</a></h4>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,4),&quot;location&quot;,&quot;level description&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  top    location      level description
----                  ---    --------      -----------------
2020-08-29T07:18:00Z  9.957  coyote_creek  at or greater than 9 feet
2020-08-29T07:24:00Z  9.964  coyote_creek  at or greater than 9 feet
2020-08-29T07:30:00Z  9.954  coyote_creek  at or greater than 9 feet
2020-08-29T07:36:00Z  9.941  coyote_creek  at or greater than 9 feet
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的最大的四个值，以及相关的tag key <code>location</code>和field key <code>level description</code>的值。</p>
</li>
<li>
<h4 id="选择指定field-key对应的最大的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最大的三个值并包含多个子句">选择指定field key对应的最大的三个值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,3),&quot;location&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC

name: h2o_feet
time                  top    location
----                  ---    --------
2020-08-18T00:48:00Z  7.11   coyote_creek
2020-08-18T00:54:00Z  6.982  coyote_creek
2020-08-18T00:54:00Z  2.054  santa_monica
2020-08-18T00:24:00Z  7.635  coyote_creek
2020-08-18T00:30:00Z  7.5    coyote_creek
2020-08-18T00:36:00Z  7.372  coyote_creek
2020-08-18T00:00:00Z  8.12   coyote_creek
2020-08-18T00:06:00Z  8.005  coyote_creek
2020-08-18T00:12:00Z  7.887  coyote_creek
</code></pre>
<p>该查询返回在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>water_level</code>对应的最大的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
</li>
</ul>
<h4 id="top的常见问题"><a class="header" href="#top的常见问题"><code>TOP()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="top和group-by-time子句同时使用"><a class="header" href="#top和group-by-time子句同时使用"><code>TOP()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>TOP()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>TOP()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(18m)

name: h2o_feet
time                   top
----                   ------
                        __
2020-08-18T00:00:00Z  2.064 |
2020-08-18T00:06:00Z  2.116 | &lt;------- Greatest points for the first time interval
                        --
                        __
2020-08-18T00:18:00Z  2.126 |
2020-08-18T00:30:00Z  2.051 | &lt;------- Greatest points for the second time interval
                        --
</code></pre>
<ul>
<li>
<h4 id="top和具有少于n个tag-value的tag-key"><a class="header" href="#top和具有少于n个tag-value的tag-key"><code>TOP()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT TOP(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>location</code>的三个tag value对于的<code>water_level</code>的最大值。因为tag key <code>location</code>只有两个tag value(<code>santa_monica</code>和<code>coyote_creek</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,&quot;location&quot;,3) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  top    location
----                  ---    --------
2020-08-29T03:54:00Z  7.205  santa_monica
2020-08-29T07:24:00Z  9.964  coyote_creek
</code></pre>
<ul>
<li>
<h4 id="toptag和into子句"><a class="header" href="#toptag和into子句"><code>TOP()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>TOP()</code>函数，除非<code>TOP()</code>中包含tag key作为参数：<code>TOP(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>location</code>的两个tag value对应的field key <code>water_level</code>的最大值，并且，它这些结果写入measurement <code>top_water_levels</code>中。第二个查询展示了cnosDB将tag <code>location</code>保留为measurement <code>top_water_levels</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;water_level&quot;,&quot;location&quot;,2) INTO &quot;top_water_levels&quot; FROM &quot;h2o_feet&quot;

name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;top_water_levels&quot;

name: top_water_levels
tagKey
------
location
</code></pre>
</li>
</ul>
<h3 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h3>
<ul>
<li>
<h3 id="abs"><a class="header" href="#abs">ABS()</a></h3>
<p>返回field value的绝对值</p>
<h4 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h4>
<pre><code class="language-sql">SELECT ABS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ABS(field_key)</code>返回field key对应的field value的绝对值。</p>
<p><code>ABS(*)</code>返回在measurement中每个field key对应的field value的绝对值。</p>
<p><code>ABS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ABS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-17"><a class="header" href="#示例-17">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z'

name: data
time                 a                   b
----                 -                   -
1529841600000000000  1.33909108671076    -0.163643058925645
1529841660000000000  -0.774984088561186  0.137034364053949
1529841720000000000  -0.921037167720451  -0.482943221384294
1529841780000000000  -1.73880754843378   -0.0729732928756677
1529841840000000000  -0.905980032168252  1.77857552719844
1529841900000000000  -0.891164752631417  0.741147445214238
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值"><a class="header" href="#计算指定field-key对应的field-value的绝对值">计算指定field key对应的field value的绝对值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;a&quot;) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z'

name: data
time                 abs
----                 ---
1529841600000000000  1.33909108671076
1529841660000000000  0.774984088561186
1529841720000000000  0.921037167720451
1529841780000000000  1.73880754843378
1529841840000000000  0.905980032168252
1529841900000000000  0.891164752631417
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值。</p>
</li>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的绝对值"><a class="header" href="#计算measurement中每个field-key对应的field-value的绝对值">计算measurement中每个field key对应的field value的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(*) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z'

name: data
time                 abs_a              abs_b
----                 -----              -----
1529841600000000000  1.33909108671076   0.163643058925645
1529841660000000000  0.774984088561186  0.137034364053949
1529841720000000000  0.921037167720451  0.482943221384294
1529841780000000000  1.73880754843378   0.0729732928756677
1529841840000000000  0.905980032168252  1.77857552719844
1529841900000000000  0.891164752631417  0.741147445214238
</code></pre>
<p>该查询返回measurement <code>data</code>中每个存储数值的field key对应的field value的绝对值。measurement <code>data</code>中有两个数值类型的field：<code>a</code>和<code>b</code>。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的绝对值并包含多个子句">计算指定field key对应的field value的绝对值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;a&quot;) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T12:05:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: data
time                 abs
----                 ---
1529841780000000000  1.73880754843378
1529841720000000000  0.921037167720451
1529841660000000000  0.774984088561186
1529841600000000000  1.33909108671076
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值，它涵盖的时间范围在<code>2020-06-24T12:00:00Z</code>和<code>2020-06-24T12:05:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-1"><a class="header" href="#高级语法-1">高级语法</a></h4>
<pre><code class="language-sql">SELECT ABS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的绝对值。</p>
<p><code>ABS()</code>支持以下嵌套函数：</p>
</li>
<li>
<p><a href="#count"><code>COUNT()</code></a></p>
</li>
<li>
<p><a href="#mean"><code>MEAN()</code></a></p>
</li>
<li>
<p><a href="#median"><code>MEDIAN()</code></a></p>
</li>
<li>
<p><a href="#mode"><code>MODE()</code></a></p>
</li>
<li>
<p><a href="#sum"><code>SUM()</code></a></p>
</li>
<li>
<p><a href="#first"><code>FIRST()</code></a></p>
</li>
<li>
<p><a href="#last"><code>LAST()</code></a></p>
</li>
<li>
<p><a href="#min"><code>MIN()</code></a></p>
</li>
<li>
<p><a href="#max"><code>MAX()</code></a></p>
</li>
<li>
<p><a href="#percentile"><code>PERCENTILE()</code></a></p>
<p>####示例</p>
<h4 id="计算平均值的绝对值"><a class="header" href="#计算平均值的绝对值">计算平均值的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(MEAN(&quot;a&quot;)) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T13:00:00Z' GROUP BY time(12m)
  
name: data
time                 abs
----                 ---
1529841600000000000  0.3960977256302787
1529842320000000000  0.0010541018316373302
1529843040000000000  0.04494733240283668
1529843760000000000  0.2553594777104415
1529844480000000000  0.20382988543108413
1529845200000000000  0.790836070736962
</code></pre>
<p>该查询返回field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值的绝对值。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ABS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;a&quot;) FROM &quot;data&quot; WHERE time &gt;= '2020-06-24T12:00:00Z' AND time &lt;= '2020-06-24T13:00:00Z' GROUP BY time(12m)
  
name: data
time                 mean
----                 ----
1529841600000000000  -0.3960977256302787
1529842320000000000  0.0010541018316373302
1529843040000000000  0.04494733240283668
1529843760000000000  0.2553594777104415
1529844480000000000  0.20382988543108413
1529845200000000000  -0.790836070736962
</code></pre>
<p>然后，CnosDB计算这些平均值的绝对值。</p>
<ul>
<li>
<h3 id="acos"><a class="header" href="#acos">ACOS()</a></h3>
<p>返回field value的反余弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h4>
<pre><code>SELECT ACOS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ACOS(field_key)</code>返回field key对应的field value的反余弦。</p>
<p><code>ACOS(*)</code>返回在measurement中每个field key对应的field value的反余弦。</p>
<p><code>ACOS()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ACOS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ACOS()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;of_capacity&quot; FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦"><a class="header" href="#计算指定field-key对应的field-value的反余弦">计算指定field key对应的field value的反余弦</a></h4>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  acos
----                  ----
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反余弦。</p>
</li>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反余弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反余弦">计算measurement中每个field key对应的field value的反余弦</a></h4>
<pre><code class="language-sql">&gt; SELECT ACOS(*) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  acos_of_capacity
----                  -------------
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中每个存储数值的field key对应的field value的反余弦。measurement <code>park_occupancy</code>中只有一个数值类型的field：<code>of_capacity</code>。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反余弦并包含多个子句">计算指定field key对应的field value的反余弦并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: park_occupancy
time                  acos
----                  ----
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-05T00:00:00Z  1.399966657665792
2020-05-04T00:00:00Z  1.3489818562981022
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反余弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-2"><a class="header" href="#高级语法-2">高级语法</a></h4>
<pre><code class="language-sql">SELECT ACOS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反余弦。</p>
<p>ACOS()支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<h4 id="计算平均值的反余弦"><a class="header" href="#计算平均值的反余弦">计算平均值的反余弦</a></h4>
<pre><code class="language-sql">&gt; SELECT ACOS(MEAN(&quot;of_capacity&quot;)) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  acos
----                  ----
2020-04-30T00:00:00Z  0.9703630732143733
2020-05-03T00:00:00Z  1.1483422646081407
2020-05-06T00:00:00Z  0.7812981174487247
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值的反余弦。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ACOS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  mean
----                  ----
2020-04-30T00:00:00Z  0.565
2020-05-03T00:00:00Z  0.41
2020-05-06T00:00:00Z  0.71
2020-05-09T00:00:00Z  0.16
</code></pre>
<p>然后，cnosDB计算这些平均值的反余弦。</p>
<ul>
<li>
<h3 id="asin"><a class="header" href="#asin">ASIN()</a></h3>
<p>返回field value的反正弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h4>
<pre><code>SELECT ASIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ASIN(field_key)</code>返回field key对应的field value的反正弦。</p>
<p><code>ASIN(*)</code>返回在measurement中每个field key对应的field value的反正弦。</p>
<p><code>ASIN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ASIN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-19"><a class="header" href="#示例-19">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ASIN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;of_capacity&quot; FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦"><a class="header" href="#计算指定field-key对应的field-value的反正弦">计算指定field key对应的field value的反正弦</a></h4>
<pre><code class="language-sql">&gt; SELECT ASIN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  asin
----                  ----
2020-05-01T00:00:00Z  0.9791076843683526
2020-05-02T00:00:00Z  0.3046926540153975
2020-05-03T00:00:00Z  0.9972832223717997
2020-05-04T00:00:00Z  0.22181447049679442
2020-05-05T00:00:00Z  0.1708296691291045
2020-05-06T00:00:00Z  0.8788411516685797
2020-05-07T00:00:00Z  0.6944982656265559
2020-05-08T00:00:00Z  0.8038023189330299
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正弦。</p>
</li>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正弦">计算measurement中每个field key对应的field value的反正弦</a></h4>
<pre><code class="language-sql">&gt; SELECT ASIN(*) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  asin_of_capacity
----                  -------------
2020-05-01T00:00:00Z  0.9791076843683526
2020-05-02T00:00:00Z  0.3046926540153975
2020-05-03T00:00:00Z  0.9972832223717997
2020-05-04T00:00:00Z  0.22181447049679442
2020-05-05T00:00:00Z  0.1708296691291045
2020-05-06T00:00:00Z  0.8788411516685797
2020-05-07T00:00:00Z  0.6944982656265559
2020-05-08T00:00:00Z  0.8038023189330299
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中每个存储数值的field key对应的field value的反正弦。measurement <code>park_occupancy</code>中只有一个数值类型的field：<code>of_capacity</code>。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正弦并包含多个子句">计算指定field key对应的field value的反正弦并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT ASIN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: park_occupancy
time                  asin
----                  ----
2020-05-07T00:00:00Z  0.6944982656265559
2020-05-06T00:00:00Z  0.8788411516685797
2020-05-05T00:00:00Z  0.1708296691291045
2020-05-04T00:00:00Z  0.22181447049679442
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-3"><a class="header" href="#高级语法-3">高级语法</a></h4>
<pre><code class="language-sql">SELECT ASIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正弦。</p>
<p>ASIN()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>,
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-20"><a class="header" href="#示例-20">示例</a></h4>
</li>
<li>
<h4 id="计算平均值的反正弦"><a class="header" href="#计算平均值的反正弦">计算平均值的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(MEAN(&quot;of_capacity&quot;)) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  asin
----                  ----
2020-04-30T00:00:00Z  0.6004332535805232
2020-05-03T00:00:00Z  0.42245406218675574
2020-05-06T00:00:00Z  0.7894982093461719
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值的反正弦。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ASIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  mean
----                  ----
2020-04-30T00:00:00Z  0.565
2020-05-03T00:00:00Z  0.41
2020-05-06T00:00:00Z  0.71
2020-05-09T00:00:00Z  0.16
</code></pre>
<p>然后，cnosDB计算这些平均值的反正弦。</p>
</li>
</ul>
</li>
<li>
<h3 id="atan"><a class="header" href="#atan">ATAN()</a></h3>
<p>返回field value的反正切（以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h4>
<pre><code class="language-sql">SELECT ATAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN(field_key)</code>返回field key对应的field value的反正切。</p>
<p><code>ATAN(*)</code>返回在measurement中每个field key对应的field value的反正切。</p>
<p><code>ATAN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-21"><a class="header" href="#示例-21">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ATAN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;of_capacity&quot; FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切"><a class="header" href="#计算指定field-key对应的field-value的反正切">计算指定field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  atan
----                  ----
2020-05-01T00:00:00Z  0.6927678353971222
2020-05-02T00:00:00Z  0.2914567944778671
2020-05-03T00:00:00Z  0.6986598247214632
2020-05-04T00:00:00Z  0.2165503049760893
2020-05-05T00:00:00Z  0.16839015714752992
2020-05-06T00:00:00Z  0.6561787179913948
2020-05-07T00:00:00Z  0.5693131911006619
2020-05-08T00:00:00Z  0.6240230529767568
2020-05-09T00:00:00Z  0.1586552621864014
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正切。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正切"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正切">计算measurement中每个field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(*) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z'

name: park_occupancy
time                  atan_of_capacity
----                  -------------
2020-05-01T00:00:00Z  0.6927678353971222
2020-05-02T00:00:00Z  0.2914567944778671
2020-05-03T00:00:00Z  0.6986598247214632
2020-05-04T00:00:00Z  0.2165503049760893
2020-05-05T00:00:00Z  0.16839015714752992
2020-05-06T00:00:00Z  0.6561787179913948
2020-05-07T00:00:00Z  0.5693131911006619
2020-05-08T00:00:00Z  0.6240230529767568
2020-05-09T00:00:00Z  0.1586552621864014
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中每个存储数值的field key对应的field value的反正切。measurement <code>park_occupancy</code>中只有一个数值类型的field：<code>of_capacity</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正切并包含多个子句">计算指定field key对应的field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: park_occupancy
time                  atan
----                  ----
2020-05-07T00:00:00Z  0.5693131911006619
2020-05-06T00:00:00Z  0.6561787179913948
2020-05-05T00:00:00Z  0.16839015714752992
2020-05-04T00:00:00Z  0.2165503049760893
</code></pre>
<p>该查询返回measurement <code>park_occupancy</code>中field key <code>of_capacity</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-4"><a class="header" href="#高级语法-4">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切。</p>
<p><code>ATAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-22"><a class="header" href="#示例-22">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切"><a class="header" href="#计算平均值的反正切">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(MEAN(&quot;of_capacity&quot;)) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                 atan
----                 ----
2020-04-30T00:00:00Z 0.5142865412694495
2020-05-03T00:00:00Z 0.3890972310552784
2020-05-06T00:00:00Z 0.6174058917515726
2020-05-09T00:00:00Z 0.1586552621864014
</code></pre>
<p>该查询返回field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值的反正切。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>of_capacity</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;of_capacity&quot;) FROM &quot;park_occupancy&quot; WHERE time &gt;= '2020-05-01T00:00:00Z' AND time &lt;= '2020-05-09T00:00:00Z' GROUP BY time(3d)

name: park_occupancy
time                  mean
----                  ----
2020-04-30T00:00:00Z  0.565
2020-05-03T00:00:00Z  0.41
2020-05-06T00:00:00Z  0.71
2020-05-09T00:00:00Z  0.16
</code></pre>
<p>然后，cnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="atan2"><a class="header" href="#atan2">ATAN2()</a></h3>
<p>返回以弧度表示的<code>y/x</code>的反正切。</p>
<h4 id="基本语法-5"><a class="header" href="#基本语法-5">基本语法</a></h4>
<pre><code>SELECT ATAN2( [ * | &lt;field_key&gt; | num ], [ &lt;field_key&gt; | num ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN2(field_key_y, field_key_x)</code>返回field key “field_key_y”对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2(*, field_key_x)&lt;br /&gt;</code>返回在measurement中每个field key对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN2()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-23"><a class="header" href="#示例-23">示例</a></h4>
<p>下面的示例将使用如下模拟的飞行数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;altitude_ft&quot;, &quot;distance_ft&quot; FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z'

name: flight_data
time                  altitude_ft  distance_ft
----                  -----------  -----------
2020-05-16T12:01:00Z  1026         50094
2020-05-16T12:02:00Z  2549         53576
2020-05-16T12:03:00Z  4033         55208
2020-05-16T12:04:00Z  5579         58579
2020-05-16T12:05:00Z  7065         61213
2020-05-16T12:06:00Z  8589         64807
2020-05-16T12:07:00Z  10180        67707
2020-05-16T12:08:00Z  11777        69819
2020-05-16T12:09:00Z  13321        72452
2020-05-16T12:10:00Z  14885        75881
</code></pre>
<ul>
<li>
<h4 id="计算field_key_y除以field_key_x的反正切"><a class="header" href="#计算field_key_y除以field_key_x的反正切">计算field_key_y除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;altitude_ft&quot;, &quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z'

name: flight_data
time                  atan2
----                  -----
2020-05-16T12:01:00Z  0.020478631571881498
2020-05-16T12:02:00Z  0.04754142349303296
2020-05-16T12:03:00Z  0.07292147724575364
2020-05-16T12:04:00Z  0.09495251193874832
2020-05-16T12:05:00Z  0.11490822875441563
2020-05-16T12:06:00Z  0.13176409347584003
2020-05-16T12:07:00Z  0.14923587589682233
2020-05-16T12:08:00Z  0.1671059946640312
2020-05-16T12:09:00Z  0.18182893717409565
2020-05-16T12:10:00Z  0.1937028631495223
</code></pre>
<p>该查询返回field key <code>altitude_ft</code>对应的field value除以field key <code>distance_ft</code>对应的field value的反正切。这两个field key都在measurement <code>flight_data</code>中。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key除以field_key_x的反正切"><a class="header" href="#计算measurement中每个field-key除以field_key_x的反正切">计算measurement中每个field key除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(*, &quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z'

name: flight_data
time                  atan2_altitude_ft     atan2_distance_ft
----                  -----------------     -----------------
2020-05-16T12:01:00Z  0.020478631571881498  0.7853981633974483
2020-05-16T12:02:00Z  0.04754142349303296   0.7853981633974483
2020-05-16T12:03:00Z  0.07292147724575364   0.7853981633974483
2020-05-16T12:04:00Z  0.09495251193874832   0.7853981633974483
2020-05-16T12:05:00Z  0.11490822875441563   0.7853981633974483
2020-05-16T12:06:00Z  0.13176409347584003   0.7853981633974483
2020-05-16T12:07:00Z  0.14923587589682233   0.7853981633974483
2020-05-16T12:08:00Z  0.1671059946640312    0.7853981633974483
2020-05-16T12:09:00Z  0.18182893717409565   0.7853981633974483
2020-05-16T12:10:00Z  0.19370286314952234   0.7853981633974483
</code></pre>
<p>该查询返回measurement <code>flight_data</code>中每个存储数值的field key对应的field value除以field key <code>distance_ft</code>对应的field value的反正切。measurement <code>flight_data</code>中有两个数值类型的field：<code>altitude_ft</code>和<code>distance_ft</code>。</p>
<ul>
<li>
<h4 id="计算field-value的反正切并包含多个子句"><a class="header" href="#计算field-value的反正切并包含多个子句">计算field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;altitude_ft&quot;, &quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T12:10:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2

name: flight_data
time                  atan2
----                  -----
2020-05-16T12:08:00Z  0.1671059946640312
2020-05-16T12:07:00Z  0.14923587589682233
2020-05-16T12:06:00Z  0.13176409347584003
2020-05-16T12:05:00Z  0.11490822875441563
</code></pre>
<p>该查询返回field key <code>altitude_ft</code>对应的field value除以field key <code>distance_ft</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-16T12:10:00Z</code>和<code>2020-05-16T12:10:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-5"><a class="header" href="#高级语法-5">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN2(&lt;function()&gt;, &lt;function()&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切(<code>ATAN2()</code>)。</p>
<p>ATAN2()支持以下嵌套函数：</p>
<ul>
<li>COUNT()</li>
<li>MEAN()</li>
<li>MEDIAN()</li>
<li>MODE()</li>
<li>SUM()</li>
<li>FIRST()</li>
<li>LAST()</li>
<li>MIN()</li>
<li>MAX()</li>
<li>PERCENTILE()</li>
</ul>
<h4 id="示例-24"><a class="header" href="#示例-24">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切-1"><a class="header" href="#计算平均值的反正切-1">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(MEAN(&quot;altitude_ft&quot;), MEAN(&quot;distance_ft&quot;)) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T13:01:00Z' GROUP BY time(12m)

name: flight_data
time                  atan2
----                  -----
2020-05-16T12:00:00Z  0.133815587896842
2020-05-16T12:12:00Z  0.2662716308351908
2020-05-16T12:24:00Z  0.2958845306108965
2020-05-16T12:36:00Z  0.23783439588429497
2020-05-16T12:48:00Z  0.1906803720242831
2020-05-16T13:00:00Z  0.17291511946158172
</code></pre>
<p>该查询返回field key <code>altitude_ft</code>对应的field value的平均值除以field key <code>distance_ft</code>对应的field value的平均值的反正切。平均值是按每12分钟的时间间隔计算的。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>altitude_ft</code>和<code>distance_ft</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;altitude_ft&quot;), MEAN(&quot;distance_ft&quot;) FROM &quot;flight_data&quot; WHERE time &gt;= '2020-05-16T12:01:00Z' AND time &lt;= '2020-05-16T13:01:00Z' GROUP BY time(12m)

name: flight_data
time                  mean                mean_1
----                  ----                ------
2020-05-16T12:00:00Z  8674                64433.181818181816
2020-05-16T12:12:00Z  26419.833333333332  96865.25
2020-05-16T12:24:00Z  40337.416666666664  132326.41666666666
2020-05-16T12:36:00Z  41149.583333333336  169743.16666666666
2020-05-16T12:48:00Z  41230.416666666664  213600.91666666666
2020-05-16T13:00:00Z  41184.5             235799
</code></pre>
<p>然后，cnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="ceil"><a class="header" href="#ceil">CEIL()</a></h3>
<p>返回大于指定值的最小整数。</p>
<h4 id="基本语法-6"><a class="header" href="#基本语法-6">基本语法</a></h4>
<pre><code>SELECT CEIL( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CEIL(field_key)</code>返回field key对应的大于field value的最小整数。</p>
<p><code>CEIL(*)</code>返回在measurement中每个field key对应的大于field value的最小整数。</p>
<p><code>CEIL()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CEIL()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-25"><a class="header" href="#示例-25">示例</a></h4>
<p>下面的示例将使用<a href="NOAA_water_database.txt"><code>NOAA_water_database</code>数据集</a>的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数">计算指定field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ceil
----                  ----
2020-08-18T00:00:00Z  3
2020-08-18T00:06:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:18:00Z  3
2020-08-18T00:24:00Z  3
2020-08-18T00:30:00Z  3
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的大于field value的最小整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的大于field-value的最小整数"><a class="header" href="#计算measurement中每个field-key对应的大于field-value的最小整数">计算measurement中每个field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ceil_water_level
----                  ----------------
2020-08-18T00:00:00Z  3
2020-08-18T00:06:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:18:00Z  3
2020-08-18T00:24:00Z  3
2020-08-18T00:30:00Z  3
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的大于field value的最小整数。measurement <code>h2o_feet</code>只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数并包含多个子句"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数并包含多个子句">计算指定field key对应的大于field value的最小整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  ceil
----                  ----
2020-08-18T00:18:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:06:00Z  3
2020-08-18T00:00:00Z  3
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的大于field value的最小整数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-6"><a class="header" href="#高级语法-6">高级语法</a></h4>
<pre><code>SELECT CEIL(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>CEIL()</code>应用于这些结果。</p>
<p><code>CEIL()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-26"><a class="header" href="#示例-26">示例</a></h4>
<ul>
<li>
<h4 id="计算大于平均值的最小整数"><a class="header" href="#计算大于平均值的最小整数">计算大于平均值的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  ceil
----                  ----
2020-08-18T00:00:00Z  3
2020-08-18T00:12:00Z  3
2020-08-18T00:24:00Z  3
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的大于<code>water_level</code>平均值的最小整数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的大于<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CEIL()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算大于这些平均值的最小整数。</p>
</li>
<li>
<h3 id="cos"><a class="header" href="#cos">COS()</a></h3>
<p>返回field value的余弦值。</p>
<h4 id="基本语法-7"><a class="header" href="#基本语法-7">基本语法</a></h4>
<pre><code>SELECT COS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>COS(field_key)</code>返回field key对应的field value的余弦值。</p>
<p><code>COS(*)</code>返回在measurement中每个field key对应的field value的余弦值。</p>
<p><code>COS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>COS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-27"><a class="header" href="#示例-27">示例</a></h4>
<ul>
<li>
<h4 id="下面的示例将使用noaa_water_database数据集的如下数据"><a class="header" href="#下面的示例将使用noaa_water_database数据集的如下数据">下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值"><a class="header" href="#计算指定field-key对应的field-value的余弦值">计算指定field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  cos
----                  ---
2020-08-18T00:00:00Z  -0.47345017433543124
2020-08-18T00:06:00Z  -0.5185922462666872
2020-08-18T00:12:00Z  -0.4414407189100776
2020-08-18T00:18:00Z  -0.5271163912192579
2020-08-18T00:24:00Z  -0.45306786455514825
2020-08-18T00:30:00Z  -0.4619598230611262
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的余弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的余弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的余弦值">计算measurement中每个field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  cos_water_level
----                  ---------------
2020-08-18T00:00:00Z  -0.47345017433543124
2020-08-18T00:06:00Z  -0.5185922462666872
2020-08-18T00:12:00Z  -0.4414407189100776
2020-08-18T00:18:00Z  -0.5271163912192579
2020-08-18T00:24:00Z  -0.45306786455514825
2020-08-18T00:30:00Z  -0.4619598230611262
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的余弦值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的余弦值并包含多个子句">计算指定field key对应的field value的余弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  cos
----                  ---
2020-08-18T00:18:00Z  -0.5271163912192579
2020-08-18T00:12:00Z  -0.4414407189100776
2020-08-18T00:06:00Z  -0.5185922462666872
2020-08-18T00:00:00Z  -0.47345017433543124
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的余弦值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-7"><a class="header" href="#高级语法-7">高级语法</a></h4>
<pre><code>SELECT COS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的余弦值。</p>
<p><code>COS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-28"><a class="header" href="#示例-28">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的余弦值"><a class="header" href="#计算平均值的余弦值">计算平均值的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  cos
----                  ---
2020-08-18T00:00:00Z  -0.49618891270599885
2020-08-18T00:12:00Z  -0.4848605136571181
2020-08-18T00:24:00Z  -0.4575195627907578
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的余弦值。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>COS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的余弦值。</p>
</li>
<li>
<h3 id="cumulative_sum"><a class="header" href="#cumulative_sum">CUMULATIVE_SUM()</a></h3>
<p>返回field value的累积总和。</p>
<h4 id="基本语法-8"><a class="header" href="#基本语法-8">基本语法</a></h4>
<pre><code>SELECT CUMULATIVE_SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CUMULATIVE_SUM(field_key)</code>返回field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(*)</code>返回在measurement中每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CUMULATIVE_SUM()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-29"><a class="header" href="#示例-29">示例</a></h4>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和"><a class="header" href="#计算指定field-key对应的field-value的累积总和">计算指定field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   cumulative_sum
----                   --------------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   4.18
2020-08-18T00:12:00Z   6.208
2020-08-18T00:18:00Z   8.334
2020-08-18T00:24:00Z   10.375
2020-08-18T00:30:00Z   12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的累积总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的累积总和">计算measurement中每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   cumulative_sum_water_level
----                   --------------------------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   4.18
2020-08-18T00:12:00Z   6.208
2020-08-18T00:18:00Z   8.334
2020-08-18T00:24:00Z   10.375
2020-08-18T00:30:00Z   12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的累积总和。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的累积总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的累积总和">计算与正则表达式匹配的每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(/water/) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   cumulative_sum_water_level
----                   --------------------------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   4.18
2020-08-18T00:12:00Z   6.208
2020-08-18T00:18:00Z   8.334
2020-08-18T00:24:00Z   10.375
2020-08-18T00:30:00Z   12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的累积总和并包含多个子句">计算指定field key对应的field value的累积总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  cumulative_sum
----                  --------------
2020-08-18T00:18:00Z  6.218
2020-08-18T00:12:00Z  8.246
2020-08-18T00:06:00Z  10.362
2020-08-18T00:00:00Z  12.426
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的累积总和，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-8"><a class="header" href="#高级语法-8">高级语法</a></h4>
<pre><code class="language-sql">SELECT CUMULATIVE_SUM(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的累积总和"><a class="header" href="#计算平均值的累积总和">计算平均值的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   cumulative_sum
----                   --------------
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   4.167
2020-08-18T00:24:00Z   6.213
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的累积总和。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CUMULATIVE_SUM()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的累积总和。最终查询结果中的第二个<code>point</code>(<code>4.167</code>)是<code>2.09</code>和<code>2.077</code>的总和，第三个<code>point</code>(<code>6.213</code>)是<code>2.09</code>、<code>2.077</code>和<code>2.0460000000000003</code>的总和。</p>
</li>
<li>
<h3 id="derivative"><a class="header" href="#derivative">DERIVATIVE()</a></h3>
<p>返回field value之间的变化率，即导数。</p>
<h4 id="基本语法-9"><a class="header" href="#基本语法-9">基本语法</a></h4>
<pre><code>SELECT DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>cnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>DERIVATIVE(field_key)</code>返回field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-30"><a class="header" href="#示例-30">示例</a></h4>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数"><a class="header" href="#计算指定field-key对应的field-value的导数">计算指定field key对应的field value的导数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:06:00Z   0.00014444444444444457
2020-08-18T00:12:00Z   -0.00024444444444444465
2020-08-18T00:18:00Z   0.0002722222222222218
2020-08-18T00:24:00Z   -0.000236111111111111
2020-08-18T00:30:00Z   2.777777777777842e-05
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的每秒变化率。</p>
<p>第一个结果(<code>0.00014444444444444457</code>)是原始数据中前两个field value在一秒内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率：</p>
<pre><code>(2.116 - 2.064) / (360s / 1s)
--------------    ----------
       |               |
       |          the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数并指定unit"><a class="header" href="#计算指定field-key对应的field-value的导数并指定unit">计算指定field key对应的field value的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;water_level&quot;,6m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time			derivative
----			----------
2020-08-18T00:06:00Z	0.052000000000000046
2020-08-18T00:12:00Z	-0.08800000000000008
2020-08-18T00:18:00Z	0.09799999999999986
2020-08-18T00:24:00Z	-0.08499999999999996
2020-08-18T00:30:00Z	0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的每六分钟的变化率。</p>
<p>第一个结果(<code>0.052000000000000046</code>)是原始数据中前两个field value在六分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 6m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算measurement中每个field-key对应的field-value的导数并指定unit">计算measurement中每个field key对应的field value的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(*,3m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'


name: h2o_feet
time                   derivative_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.026000000000000023
2020-08-18T00:12:00Z   -0.04400000000000004
2020-08-18T00:18:00Z   0.04899999999999993
2020-08-18T00:24:00Z   -0.04249999999999998
2020-08-18T00:30:00Z   0.0050000000000001155
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的每三分钟的变化率。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<p>第一个结果(<code>0.026000000000000023</code>)是原始数据中前两个field value在三分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为三分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 3m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit">计算与正则表达式匹配的每个field key对应的field value的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(/water/,2m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   derivative_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.01733333333333335
2020-08-18T00:12:00Z   -0.02933333333333336
2020-08-18T00:18:00Z   0.03266666666666662
2020-08-18T00:24:00Z   -0.02833333333333332
2020-08-18T00:30:00Z   0.0033333333333334103
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的每两分钟的变化率。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<p>第一个结果(<code>0.01733333333333335</code>)是原始数据中前两个field value在两分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为两分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 2m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的导数并包含多个子句">计算指定field key对应的field value的导数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' ORDER BY time DESC LIMIT 1 OFFSET 2

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:12:00Z   -0.0002722222222222218
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的每秒变化率，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<p>唯一的结果(<code>-0.0002722222222222218</code>)是原始数据中前两个field value在一秒内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率：</p>
<pre><code>(2.126 - 2.028) / (360s / 1s)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<h4 id="高级语法-9"><a class="header" href="#高级语法-9">高级语法</a></h4>
<pre><code>SELECT DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。</p>
<p><code>DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的导数"><a class="header" href="#计算平均值的导数">计算平均值的导数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:12:00Z   -0.0129999999999999
2020-08-18T00:24:00Z   -0.030999999999999694
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的每12分钟变化率。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的每12分钟的变化率。第一个结果(<code>-0.0129999999999999</code>)是原始数据中前两个field value在12分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为12分钟的变化率：</p>
<pre><code>(2.077 - 2.09) / (12m / 12m)
-------------    ----------
       |               |
       |          the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算平均值的导数并指定unit"><a class="header" href="#计算平均值的导数并指定unit">计算平均值的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;water_level&quot;),6m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   derivative
----                   ----------
2020-08-18T00:12:00Z   -0.00649999999999995
2020-08-18T00:24:00Z   -0.015499999999999847
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值的每六分钟变化率。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的每六分钟的变化率。第一个结果(<code>-0.00649999999999995</code>)是原始数据中前两个field value在六分钟内的变化率。cnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code class="language-sql">(2.077 - 2.09) / (12m / 6m)
-------------    ----------
       |               |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
</li>
<li>
<h3 id="difference"><a class="header" href="#difference">DIFFERENCE()</a></h3>
<p>返回field value之间的差值。</p>
<h4 id="基本语法-10"><a class="header" href="#基本语法-10">基本语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>DIFFERENCE(field_key)</code>返回field key对应的field value的差值。</p>
<p><code>DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-31"><a class="header" href="#示例-31">示例</a></h4>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值"><a class="header" href="#计算指定field-key对应的field-value的差值">计算指定field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   difference
----                   ----------
2020-08-18T00:06:00Z   0.052000000000000046
2020-08-18T00:12:00Z   -0.08800000000000008
2020-08-18T00:18:00Z   0.09799999999999986
2020-08-18T00:24:00Z   -0.08499999999999996
2020-08-18T00:30:00Z   0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的差值"><a class="header" href="#计算measurement中每个field-key对应的field-value的差值">计算measurement中每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   difference_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.052000000000000046
2020-08-18T00:12:00Z   -0.08800000000000008
2020-08-18T00:18:00Z   0.09799999999999986
2020-08-18T00:24:00Z   -0.08499999999999996
2020-08-18T00:30:00Z   0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value之间的差值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的差值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的差值">计算与正则表达式匹配的每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(/water/) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                   difference_water_level
----                   ----------------------
2020-08-18T00:06:00Z   0.052000000000000046
2020-08-18T00:12:00Z   -0.08800000000000008
2020-08-18T00:18:00Z   0.09799999999999986
2020-08-18T00:24:00Z   -0.08499999999999996
2020-08-18T00:30:00Z   0.010000000000000231
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的差值并包含多个子句">计算指定field key对应的field value的差值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 2 OFFSET 2

name: h2o_feet
time                   difference
----                   ----------
2020-08-18T00:12:00Z   -0.09799999999999986
2020-08-18T00:06:00Z   0.08800000000000008
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value之间的差值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-10"><a class="header" href="#高级语法-10">高级语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的差值。</p>
<p>DIFFERENCE()支持以下嵌套函数：
<a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-32"><a class="header" href="#示例-32">示例</a></h4>
<ul>
<li>
<h4 id="计算最大值之间的差值"><a class="header" href="#计算最大值之间的差值">计算最大值之间的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(MAX(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   difference
----                   ----------
2020-08-18T00:12:00Z   0.009999999999999787
2020-08-18T00:24:00Z   -0.07499999999999973
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的每12分钟的时间间隔的field value的最大值之间的差值。</p>
<p>为了得到这些结果，cnosDB首先计算field key <code>water_level</code>对应的每12分钟的时间间隔的field value的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DIFFERENCE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   max
----                   ---
2020-08-18T00:00:00Z   2.116
2020-08-18T00:12:00Z   2.126
2020-08-18T00:24:00Z   2.051
</code></pre>
<p>然后，cnosDB计算这些最大值之间的差值。最终查询结果中的第一个<code>point</code>(<code>0.009999999999999787</code>)是<code>2.126</code>和<code>2.116</code>的差，第二个<code>point</code>(<code>-0.07499999999999973</code>)是<code>2.051</code>和<code>2.126</code>的差。</p>
</li>
<li>
<h3 id="elapsed"><a class="header" href="#elapsed">ELAPSED()</a></h3>
<p>返回field value的时间戳之间的差值。</p>
<h4 id="语法-18"><a class="header" href="#语法-18">语法</a></h4>
<pre><code>SELECT ELAPSED( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>cnosDB计算时间戳之间的差值。参数<code>unit</code>的值是一个整数，后跟一个时间单位，它决定了返回的差值的单位。这个参数是可选的，不是必须要有的。如果没有指定<code>unit</code>的值，那么查询将返回以纳秒为单位的两个时间戳之间的差值。</p>
<p><code>ELAPSED(field_key)</code>返回field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(*)</code>返回在measurement中每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED()</code>支持所有数据类型的field value。</p>
<h4 id="示例-33"><a class="header" href="#示例-33">示例</a></h4>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔">计算指定field key对应的field value之间的时间间隔</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:06:00Z   360000000000
2020-08-18T00:12:00Z   360000000000
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的时间戳之间的差值(以纳秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并指定unit">计算指定field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:06:00Z   6
2020-08-18T00:12:00Z   6
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个field key对应的时间戳之间的差值(以分钟为单位)。measurement <code>h2o_feet</code>中有两个field key：<code>level description</code>和<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(*,1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed_level description   elapsed_water_level
----                   -------------------------   -------------------
2020-08-18T00:06:00Z   6                           6
2020-08-18T00:12:00Z   6                           6
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit-1"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit-1">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(/level/,1s) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed_level description   elapsed_water_level
----                   -------------------------   -------------------
2020-08-18T00:06:00Z   360                         360
2020-08-18T00:12:00Z   360                         360
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并包含多个子句">计算指定field key对应的field value之间的时间间隔并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;,1ms) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z' ORDER BY time DESC LIMIT 1 OFFSET 1

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:00:00Z   -360000
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的时间戳之间的差值(以毫秒为单位)，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:12:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移一个（即前一个<code>point</code>不返回）。</p>
<p>请注意，查询结果是负数；因为<code>ORDER BY time DESC</code>子句按递减的顺序对时间戳进行排序，所以<code>ELAPSED()</code>以相反的顺序计算时间戳的差值。</p>
<h4 id="elapsed的常见问题"><a class="header" href="#elapsed的常见问题"><code>ELAPSED()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="elapsed和大于经过时间的单位"><a class="header" href="#elapsed和大于经过时间的单位"><code>ELAPSED()</code>和大于经过时间的单位</a></h4>
</li>
</ul>
<p>I如果<code>unit</code>的值大于时间戳之间的差值，那么cnosDB将会返回<code>0</code>。</p>
<p>measurement <code>h2o_feet</code>中每六分钟有一个<code>point</code>。如果查询将<code>unit</code>设置为一小时，cnosDB将会返回<code>0</code>：</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;water_level&quot;,1h) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:12:00Z'

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:06:00Z   0
2020-08-18T00:12:00Z   0
</code></pre>
<ul>
<li>
<h4 id="elapsed和group-by-time子句同时使用"><a class="header" href="#elapsed和group-by-time子句同时使用"><code>ELAPSED()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p><code>ELAPSED()</code>函数支持<code>GROUP BY time()</code>子句，但是查询结果不是特别有用。目前，如果<code>ELAPSED()</code>查询包含一个嵌套的cnosQL函数和一个<code>GROUP BY time()</code>子句，那么只会返回指定<code>GROUP BY time()</code>子句中的时间间隔。</p>
<p><code>GROUP BY time()</code>子句决定了查询结果中的时间戳：每个时间戳表示时间间隔的开始时间。该行为也适用于嵌套的selector函数(例如<code>FIRST()</code>或<code>MAX()</code>)，而在其它的所有情况下，这些函数返回的是原始数据的特定时间戳。因为<code>GROUP BY time()</code>子句会覆盖原始时间戳，所以<code>ELAPSED()</code>始终返回与<code>GROUP BY time()</code>的时间间隔相同的时间戳。</p>
<p>下面代码块中的第一个查询尝试使用<code>ELAPSED()</code>和<code>GROUP BY time()</code>子句来查找最小的<code>water_level</code>的值之间经过的时间(以分钟为单位)。查询的两个时间间隔都返回了12分钟。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔的<code>water_level</code>的最小值。代码块中的第二个查询展示了这一步的结果。这一步跟同时使用<code>MIN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ELAPSED()</code>的情形一样。请注意，第二个查询返回的时间戳间隔12分钟。在原始数据中，第一个结果(<code>2.057</code>)发生在<code>2020-08-18T00:42:00Z</code>，但是<code>GROUP BY time()</code>子句覆盖了原始的时间戳。因为时间戳由<code>GROUP BY time()</code>的时间间隔(而不是原始数据)决定，所以<code>ELAPSED()</code>始终返回与GROUP BY time()的时间间隔相同的时间戳。</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(MIN(&quot;water_level&quot;),1m) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:36:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m)

name: h2o_feet
time                   elapsed
----                   -------
2020-08-18T00:36:00Z   12
2020-08-18T00:48:00Z   12

&gt; SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:36:00Z' AND time &lt;= '2020-08-18T00:54:00Z' GROUP BY time(12m)

name: h2o_feet
time                   min
----                   ---
2020-08-18T00:36:00Z   2.057    &lt;--- Actually occurs at 2020-08-18T00:42:00Z
2020-08-18T00:48:00Z   1.991
</code></pre>
</li>
<li>
<h3 id="exp"><a class="header" href="#exp">EXP()</a></h3>
<p>返回field value的指数。</p>
<h4 id="基本语法-11"><a class="header" href="#基本语法-11">基本语法</a></h4>
<pre><code>SELECT EXP( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>EXP(field_key)</code>返回field key对应的field value的指数。</p>
<p><code>EXP(*)</code>返回在measurement中每个field key对应的field value的指数。</p>
<p><code>EXP()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>EXP()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-34"><a class="header" href="#示例-34">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.85.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数"><a class="header" href="#计算指定field-key对应的field-value的指数">计算指定field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  exp
----                  ---
2020-08-18T00:00:00Z  7.877416541092307
2020-08-18T00:06:00Z  8.297879498060171
2020-08-18T00:12:00Z  7.598873404088091
2020-08-18T00:18:00Z  8.381274573459967
2020-08-18T00:24:00Z  7.6983036546645645
2020-08-18T00:30:00Z  7.775672892658607
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的指数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的指数"><a class="header" href="#计算measurement中每个field-key对应的field-value的指数">计算measurement中每个field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  exp_water_level
----                  ---------------
2020-08-18T00:00:00Z  7.877416541092307
2020-08-18T00:06:00Z  8.297879498060171
2020-08-18T00:12:00Z  7.598873404088091
2020-08-18T00:18:00Z  8.381274573459967
2020-08-18T00:24:00Z  7.6983036546645645
2020-08-18T00:30:00Z  7.775672892658607
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的指数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的指数并包含多个子句">计算指定field key对应的field value的指数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  exp
----                  ---
2020-08-18T00:18:00Z  8.381274573459967
2020-08-18T00:12:00Z  7.598873404088091
2020-08-18T00:06:00Z  8.297879498060171
2020-08-18T00:00:00Z  7.877416541092307
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的指数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-11"><a class="header" href="#高级语法-11">高级语法</a></h4>
<pre><code>SELECT EXP(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的指数。</p>
<p>EXP()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-35"><a class="header" href="#示例-35">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的指数"><a class="header" href="#计算平均值的指数">计算平均值的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  exp
----                  ---
2020-08-18T00:00:00Z  8.084915164305059
2020-08-18T00:12:00Z  7.980491491670466
2020-08-18T00:24:00Z  7.736891562315577
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的绝对值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>EXP()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>.然后，cnosDB计算这些平均值的指数。</p>
<h3 id="floor"><a class="header" href="#floor">FLOOR()</a></h3>
<p>返回小于指定值的最大整数。</p>
<h4 id="基本语法-12"><a class="header" href="#基本语法-12">基本语法</a></h4>
<pre><code>SELECT FLOOR( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>FLOOR(field_key)</code>返回field key对应的小于field value的最大整数。</p>
<p><code>FLOOR(*)</code>返回在measurement中每个field key对应的小于field value的最大整数。</p>
<p><code>FLOOR()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>FLOOR()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-36"><a class="header" href="#示例-36">示例</a></h4>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数">计算指定field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  floor
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的小于field value的最大整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的小于field-value的最大整数"><a class="header" href="#计算measurement中每个field-key对应的小于field-value的最大整数">计算measurement中每个field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  floor_water_level
----                  -----------------
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的小于field value的最大整数。measurement <code>h2o_feet</code>只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数并包含多个子句"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数并包含多个子句">计算指定field key对应的小于field value的最大整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  floor
----                  -----
2020-08-18T00:18:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:00:00Z  2
</code></pre>
<p>该查询返回field key <code>water_level</code>对应的小于field value的最大整数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-12"><a class="header" href="#高级语法-12">高级语法</a></h4>
<pre><code>SELECT FLOOR(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>FLOOR()</code>应用于这些结果。</p>
<p><code>FLOOR()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算小于平均值的最大整数"><a class="header" href="#计算小于平均值的最大整数">计算小于平均值的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  floor
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:24:00Z  2
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的小于<code>water_level</code>平均值的最大整数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>FLOOR()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算小于这些平均值的最大整数。</p>
</li>
<li>
<h3 id="ln"><a class="header" href="#ln">LN()</a></h3>
<p>返回field value的自然对数。</p>
<h4 id="基本语法-13"><a class="header" href="#基本语法-13">基本语法</a></h4>
<pre><code>SELECT LN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LN(field_key)</code>返回field key对应的field value的自然对数。</p>
<p><code>LN(*)</code>返回在measurement中每个field key对应的field value的自然对数。</p>
<p><code>LN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-37"><a class="header" href="#示例-37">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.86.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数"><a class="header" href="#计算指定field-key对应的field-value的自然对数">计算指定field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ln
----                  --
2020-08-18T00:00:00Z  0.7246458476193163
2020-08-18T00:06:00Z  0.749527513996053
2020-08-18T00:12:00Z  0.7070500857289368
2020-08-18T00:18:00Z  0.7542422799197561
2020-08-18T00:24:00Z  0.7134398838277077
2020-08-18T00:30:00Z  0.7183274790902436
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的自然对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的自然对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的自然对数">计算measurement中每个field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  ln_water_level
----                  --------------
2020-08-18T00:00:00Z  0.7246458476193163
2020-08-18T00:06:00Z  0.749527513996053
2020-08-18T00:12:00Z  0.7070500857289368
2020-08-18T00:18:00Z  0.7542422799197561
2020-08-18T00:24:00Z  0.7134398838277077
2020-08-18T00:30:00Z  0.7183274790902436
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的自然对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的自然对数并包含多个子句">计算指定field key对应的field value的自然对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  ln
----                  --
2020-08-18T00:18:00Z  0.7542422799197561
2020-08-18T00:12:00Z  0.7070500857289368
2020-08-18T00:06:00Z  0.749527513996053
2020-08-18T00:00:00Z  0.7246458476193163
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的自然对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-13"><a class="header" href="#高级语法-13">高级语法</a></h4>
<pre><code>SELECT LN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个 GROUP BY time() <code>和一个嵌套的cnosQL 函数. 该查询受限以指定</code>GROUP BY time()<code>间隔计算嵌套函数的结果 </code>LN()` .</p>
<p>LN()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-38"><a class="header" href="#示例-38">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的自然对数"><a class="header" href="#计算平均值的自然对数">计算平均值的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  ln
----                  --
2020-08-18T00:00:00Z  0.7371640659767196
2020-08-18T00:12:00Z  0.7309245448939752
2020-08-18T00:24:00Z  0.7158866675294349
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的自然对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的自然对数。</p>
</li>
<li>
<h3 id="log"><a class="header" href="#log">LOG()</a></h3>
<p>返回field value的以<code>b</code>为底数的对数。</p>
<h4 id="基本语法-14"><a class="header" href="#基本语法-14">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG( [ * | &lt;field_key&gt; ], &lt;b&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG(field_key, b)</code>返回field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG(*, b)</code>返回在measurement中每个field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.87.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数">计算指定field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log
----                  ---
2020-08-18T00:00:00Z  0.5227214853805835
2020-08-18T00:06:00Z  0.5406698137259695
2020-08-18T00:12:00Z  0.5100288261706268
2020-08-18T00:18:00Z  0.5440707984345088
2020-08-18T00:24:00Z  0.5146380911853161
2020-08-18T00:30:00Z  0.5181637459088826
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以4为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以4为底数的对数">计算measurement中每个field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(*, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log_water_level
----                  ---------------
2020-08-18T00:00:00Z  0.5227214853805835
2020-08-18T00:06:00Z  0.5406698137259695
2020-08-18T00:12:00Z  0.5100288261706268
2020-08-18T00:18:00Z  0.5440707984345088
2020-08-18T00:24:00Z  0.5146380911853161
2020-08-18T00:30:00Z  0.5181637459088826
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的以4为底数的对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数并包含多个子句">计算指定field key对应的field value的以4为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  log
----                  ---
2020-08-18T00:18:00Z  0.5440707984345088
2020-08-18T00:12:00Z  0.5100288261706268
2020-08-18T00:06:00Z  0.5406698137259695
2020-08-18T00:00:00Z  0.5227214853805835
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以4为底数的对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-14"><a class="header" href="#高级语法-14">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;b&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的对数。</p>
<p><code>LOG()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以4为底数的对数"><a class="header" href="#计算平均值的以4为底数的对数">计算平均值的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(MEAN(&quot;water_level&quot;), 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  log
----                  ---
2020-08-18T00:00:00Z  0.531751471153079
2020-08-18T00:12:00Z  0.5272506080912802
2020-08-18T00:24:00Z  0.5164030725416209
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的以4为底数的对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的以4为底数的对数。</p>
</li>
<li>
<h3 id="log2"><a class="header" href="#log2">LOG2()</a></h3>
<p>返回field value的以2为底数的对数。</p>
<h4 id="基本语法-15"><a class="header" href="#基本语法-15">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG2( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG2(field_key)</code>返回field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2(*)</code>返回在measurement中每个field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG2()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.88.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数">计算指定field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log2
----                  ----
2020-08-18T00:00:00Z  1.045442970761167
2020-08-18T00:06:00Z  1.081339627451939
2020-08-18T00:12:00Z  1.0200576523412537
2020-08-18T00:18:00Z  1.0881415968690176
2020-08-18T00:24:00Z  1.0292761823706322
2020-08-18T00:30:00Z  1.0363274918177652
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以2为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以2为底数的对数">计算measurement中每个field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log2_water_level
----                  ----------------
2020-08-18T00:00:00Z  1.045442970761167
2020-08-18T00:06:00Z  1.081339627451939
2020-08-18T00:12:00Z  1.0200576523412537
2020-08-18T00:18:00Z  1.0881415968690176
2020-08-18T00:24:00Z  1.0292761823706322
2020-08-18T00:30:00Z  1.0363274918177652
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的以2为底数的对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数并包含多个子句">计算指定field key对应的field value的以2为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  log2
----                  ----
2020-08-18T00:18:00Z  1.0881415968690176
2020-08-18T00:12:00Z  1.0200576523412537
2020-08-18T00:06:00Z  1.081339627451939
2020-08-18T00:00:00Z  1.045442970761167
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以2为底数的对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-15"><a class="header" href="#高级语法-15">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG2(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以2为底数的对数。</p>
<p><code>LOG2()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以2为底数的对数"><a class="header" href="#计算平均值的以2为底数的对数">计算平均值的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  log2
----                  ----
2020-08-18T00:00:00Z  1.063502942306158
2020-08-18T00:12:00Z  1.0545012161825604
2020-08-18T00:24:00Z  1.0328061450832418
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的以2为底数的对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的以2为底数的对数。</p>
</li>
<li>
<h3 id="log10"><a class="header" href="#log10">LOG10()</a></h3>
<p>返回field value的以10为底数的对数。</p>
<h4 id="基本语法-16"><a class="header" href="#基本语法-16">基本语法</a></h4>
<pre><code>SELECT LOG10( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG10(field_key)</code>返回field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10(*)</code>返回在measurement中每个field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG10()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.89.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数">计算指定field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log10
----                  -----
2020-08-18T00:00:00Z  0.3147096929551737
2020-08-18T00:06:00Z  0.32551566336314813
2020-08-18T00:12:00Z  0.3070679506612984
2020-08-18T00:18:00Z  0.32756326018727794
2020-08-18T00:24:00Z  0.3098430047160705
2020-08-18T00:30:00Z  0.3119656603683663
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以10为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以10为底数的对数">计算measurement中每个field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  log10_water_level
----                  -----------------
2020-08-18T00:00:00Z  0.3147096929551737
2020-08-18T00:06:00Z  0.32551566336314813
2020-08-18T00:12:00Z  0.3070679506612984
2020-08-18T00:18:00Z  0.32756326018727794
2020-08-18T00:24:00Z  0.3098430047160705
2020-08-18T00:30:00Z  0.3119656603683663
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的以10为底数的对数。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数并包含多个子句">计算指定field key对应的field value的以10为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  log10
----                  -----
2020-08-18T00:18:00Z  0.32756326018727794
2020-08-18T00:12:00Z  0.3070679506612984
2020-08-18T00:06:00Z  0.32551566336314813
2020-08-18T00:00:00Z  0.3147096929551737
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的以10为底数的对数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-16"><a class="header" href="#高级语法-16">高级语法</a></h4>
<pre><code>SELECT LOG10(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以10为底数的对数。</p>
<p><code>LOG10()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以10为底数的对数"><a class="header" href="#计算平均值的以10为底数的对数">计算平均值的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  log10
----                  -----
2020-08-18T00:00:00Z  0.32014628611105395
2020-08-18T00:12:00Z  0.3174364965350991
2020-08-18T00:24:00Z  0.3109056293761414
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的以10为底数的对数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG10()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的以10为底数的对数。</p>
</li>
<li>
<h3 id="moving_average"><a class="header" href="#moving_average">MOVING_AVERAGE()</a></h3>
<p>返回field value窗口的滚动平均值。</p>
<h4 id="基本语法-17"><a class="header" href="#基本语法-17">基本语法</a></h4>
<pre><code class="language-sql">SELECT MOVING_AVERAGE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] , &lt;N&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MOVING_AVERAGE()</code>计算包含<code>N</code>个连续field value的窗口的滚动平均值。参数<code>N</code>是一个整数，并且它是必须的。</p>
<p><code>MOVING_AVERAGE(field_key,N)</code>返回field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(*,N)</code>返回在measurement中每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>MOVING_AVERAGE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   water_level
----                   -----------
2020-08-18T00:00:00Z   2.064
2020-08-18T00:06:00Z   2.116
2020-08-18T00:12:00Z   2.028
2020-08-18T00:18:00Z   2.126
2020-08-18T00:24:00Z   2.041
2020-08-18T00:30:00Z   2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值">计算指定field key对应的field value的滚动平均值</a></h4>
</li>
</ul>
<pre><code>&gt; SELECT MOVING_AVERAGE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   moving_average
----                   --------------
2020-08-18T00:06:00Z   2.09
2020-08-18T00:12:00Z   2.072
2020-08-18T00:18:00Z   2.077
2020-08-18T00:24:00Z   2.0835
2020-08-18T00:30:00Z   2.0460000000000003
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的窗口大小为两个field value的滚动平均值。第一个结果(<code>2.09</code>)是原始数据中前两个field value的平均值：(2.064 + 2.116) / 2。第二个结果(<code>2.072</code>)是原始数据中第二和第三个field value的平均值：(2.116 + 2.028) / 2。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的滚动平均值">计算measurement中每个field key对应的field value的滚动平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(*,3) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                   moving_average_water_level
----                   --------------------------
2020-08-18T00:12:00Z   2.0693333333333332
2020-08-18T00:18:00Z   2.09
2020-08-18T00:24:00Z   2.065
2020-08-18T00:30:00Z   2.0726666666666667
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的窗口大小为三个field value的滚动平均值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值">计算与正则表达式匹配的每个field key对应的field value的滚动平均值</a></h4>
</li>
</ul>
<pre><code>&gt; SELECT MOVING_AVERAGE(/level/,4) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z'

name: h2o_feet
time                    moving_average_water_level
----                    --------------------------
2020-08-18T00:18:00Z    2.0835
2020-08-18T00:24:00Z    2.07775
2020-08-18T00:30:00Z    2.0615
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值并包含单词<code>level</code>的field key对应的窗口大小为四个field value的滚动平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值并包含多个子句">计算指定field key对应的field value的滚动平均值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;water_level&quot;,2) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' ORDER BY time DESC LIMIT 2 OFFSET 3

name: h2o_feet
time                   moving_average
----                   --------------
2020-08-18T00:06:00Z   2.072
2020-08-18T00:00:00Z   2.09
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的窗口大小为两个field value的滚动平均值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移三个(即前三个<code>point</code>不返回）。</p>
</li>
</ul>
<h4 id="高级语法-17"><a class="header" href="#高级语法-17">高级语法</a></h4>
<pre><code>SELECT MOVING_AVERAGE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) , N ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算最大值的滚动平均值"><a class="header" href="#计算最大值的滚动平均值">计算最大值的滚动平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(MAX(&quot;water_level&quot;),2) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   moving_average
----                   --------------
2020-08-18T00:12:00Z   2.121
2020-08-18T00:24:00Z   2.0885
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的最大值的窗口大小为两个值的滚动平均值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>MOVING_AVERAGE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE &quot;location&quot; = 'santa_monica' AND time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' GROUP BY time(12m)

name: h2o_feet
time                   max
----                   ---
2020-08-18T00:00:00Z   2.116
2020-08-18T00:12:00Z   2.126
2020-08-18T00:24:00Z   2.051
</code></pre>
<p>然后，cnosDB计算这些最大值的窗口大小为两个值的滚动平均值。最终查询结果中的第一个<code>point</code>(<code>2.121</code>)是前两个最大值的平均值(<code>(2.116 + 2.126) / 2</code>)。</p>
<ul>
<li>
<h3 id="non_negative_derivative"><a class="header" href="#non_negative_derivative">NON_NEGATIVE_DERIVATIVE()</a></h3>
<p>返回field value之间的非负变化率。非负变化率包括正的变化率和等于0的变化率。</p>
<h4 id="基本语法-18"><a class="header" href="#基本语法-18">基本语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>cnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(field_key)</code>返回field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
<h4 id="高级语法-18"><a class="header" href="#高级语法-18">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的非负导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a>
####示例</li>
</ul>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
</li>
<li>
<h3 id="non_negative_difference"><a class="header" href="#non_negative_difference">NON_NEGATIVE_DIFFERENCE()</a></h3>
<p>返回field value之间的非负差值。非负差值包括正的差值和等于0的差值。</p>
<h4 id="基本语法-19"><a class="header" href="#基本语法-19">基本语法</a></h4>
<pre><code>SELECT NON_NEGATIVE_DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>NON_NEGATIVE_DIFFERENCE(field_key)</code>返回field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
<h4 id="高级语法-19"><a class="header" href="#高级语法-19">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的非负差值。</p>
<p>`NON_NEGATIVE_DIFFERENCE()支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
</li>
<li>
<h3 id="pow"><a class="header" href="#pow">POW()</a></h3>
<p>返回field value的<code>x</code>次方。</p>
<h4 id="基本语法-20"><a class="header" href="#基本语法-20">基本语法</a></h4>
<pre><code>SELECT POW( [ * | &lt;field_key&gt; ], &lt;x&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>POW(field_key, x)</code>返回field key对应的field value的<code>x</code>次方。</p>
<p><code>POW(*, x)</code>返回在measurement中每个field key对应的field value的<code>x</code>次方。</p>
<p><code>POW()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>POW()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.90.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方"><a class="header" href="#计算指定field-key对应的field-value的4次方">计算指定field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  pow
----                  ---
2020-08-18T00:00:00Z  18.148417929216
2020-08-18T00:06:00Z  20.047612231936
2020-08-18T00:12:00Z  16.914992230656004
2020-08-18T00:18:00Z  20.429279055375993
2020-08-18T00:24:00Z  17.352898193760993
2020-08-18T00:30:00Z  17.69549197320101
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的4次方。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的4次方"><a class="header" href="#计算measurement中每个field-key对应的field-value的4次方">计算measurement中每个field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(*, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  pow_water_level
----                  ---------------
2020-08-18T00:00:00Z  18.148417929216
2020-08-18T00:06:00Z  20.047612231936
2020-08-18T00:12:00Z  16.914992230656004
2020-08-18T00:18:00Z  20.429279055375993
2020-08-18T00:24:00Z  17.352898193760993
2020-08-18T00:30:00Z  17.69549197320101
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的4次方。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的4次方并包含多个子句">计算指定field key对应的field value的4次方并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;water_level&quot;, 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  pow
----                  ---
2020-08-18T00:18:00Z  20.429279055375993
2020-08-18T00:12:00Z  16.914992230656004
2020-08-18T00:06:00Z  20.047612231936
2020-08-18T00:00:00Z  18.148417929216
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的4次方，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-20"><a class="header" href="#高级语法-20">高级语法</a></h4>
<pre><code class="language-sql">SELECT POW(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;x&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的<code>x</code>次方。</p>
<p><code>POW()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的4次方"><a class="header" href="#计算平均值的4次方">计算平均值的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(MEAN(&quot;water_level&quot;), 4) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  pow
----                  ---
2020-08-18T00:00:00Z  19.08029760999999
2020-08-18T00:12:00Z  18.609983417041
2020-08-18T00:24:00Z  17.523567165456008
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的4次方。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>POW()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的4次方。</p>
</li>
<li>
<h3 id="round"><a class="header" href="#round">ROUND()</a></h3>
<p>返回指定值的四舍五入后的整数。</p>
<h4 id="基本语法-21"><a class="header" href="#基本语法-21">基本语法</a></h4>
<pre><code>SELECT ROUND( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ROUND(field_key)</code>返回field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND(*)</code>返回在measurement中每个field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ROUND()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.91.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数">计算指定field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  round
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value四舍五入后的整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算measurement中每个field-key对应的field-value四舍五入后的整数">计算measurement中每个field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  round_water_level
----                  -----------------
2020-08-18T00:00:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:18:00Z  2
2020-08-18T00:24:00Z  2
2020-08-18T00:30:00Z  2
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数并包含多个子句">计算指定field key对应的field value四舍五入后的整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  round
----                  -----
2020-08-18T00:18:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:06:00Z  2
2020-08-18T00:00:00Z  2
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value四舍五入后的整数，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-21"><a class="header" href="#高级语法-21">高级语法</a></h4>
<pre><code class="language-sql">SELECT ROUND(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果四舍五入后的整数。</p>
<p><code>ROUND()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值四舍五入后的整数"><a class="header" href="#计算平均值四舍五入后的整数">计算平均值四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  round
----                  -----
2020-08-18T00:00:00Z  2
2020-08-18T00:12:00Z  2
2020-08-18T00:24:00Z  2
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值四舍五入后的整数。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ROUND()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值四舍五入后的整数。</p>
</li>
<li>
<h3 id="sin"><a class="header" href="#sin">SIN()</a></h3>
<p>返回field value的正弦值。</p>
<h4 id="基本语法-22"><a class="header" href="#基本语法-22">基本语法</a></h4>
<pre><code class="language-sql">SELECT SIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SIN(field_key)</code>返回field key对应的field value的正弦值。</p>
<p><code>SIN(*)</code>返回在measurement中每个field key对应的field value的正弦值。</p>
<p><code>SIN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SIN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值"><a class="header" href="#计算指定field-key对应的field-value的正弦值">计算指定field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sin
----                  ---
2020-08-18T00:00:00Z  0.8808206017241819
2020-08-18T00:06:00Z  0.8550216851706579
2020-08-18T00:12:00Z  0.8972904165810275
2020-08-18T00:18:00Z  0.8497930984115993
2020-08-18T00:24:00Z  0.8914760289023131
2020-08-18T00:30:00Z  0.8869008523376968
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正弦值">计算measurement中每个field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sin_water_level
----                  ---------------
2020-08-18T00:00:00Z  0.8808206017241819
2020-08-18T00:06:00Z  0.8550216851706579
2020-08-18T00:12:00Z  0.8972904165810275
2020-08-18T00:18:00Z  0.8497930984115993
2020-08-18T00:24:00Z  0.8914760289023131
2020-08-18T00:30:00Z  0.8869008523376968
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的正弦值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正弦值并包含多个子句">计算指定field key对应的field value的正弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  sin
----                  ---
2020-08-18T00:18:00Z  0.8497930984115993
2020-08-18T00:12:00Z  0.8972904165810275
2020-08-18T00:06:00Z  0.8550216851706579
2020-08-18T00:00:00Z  0.8808206017241819
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正弦值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-22"><a class="header" href="#高级语法-22">高级语法</a></h4>
<pre><code class="language-sql">SELECT SIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正弦值。</p>
<p><code>SIN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值"><a class="header" href="#计算平均值的正弦值">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  sin

----                  ---
2020-08-18T00:00:00Z  0.8682145834456126
2020-08-18T00:12:00Z  0.8745914945253902
2020-08-18T00:24:00Z  0.8891995555912935
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的正弦值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的正弦值。</p>
</li>
<li>
<h3 id="sqrt"><a class="header" href="#sqrt">SQRT()</a></h3>
<p>返回field value的平方根。</p>
<h4 id="基本语法-23"><a class="header" href="#基本语法-23">基本语法</a></h4>
<pre><code>SELECT SQRT( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SQRT(field_key)</code>返回field key对应的field value的平方根。</p>
<p><code>SQRT(*)</code>返回在measurement中每个field key对应的field value的平方根。</p>
<p><code>SQRT()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SQRT()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用”NOAA_water_database”数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根"><a class="header" href="#计算指定field-key对应的field-value的平方根">计算指定field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sqrt
----                  ----
2020-08-18T00:00:00Z  1.4366627996854378
2020-08-18T00:06:00Z  1.4546477236774544
2020-08-18T00:12:00Z  1.4240786495134319
2020-08-18T00:18:00Z  1.4580809305384939
2020-08-18T00:24:00Z  1.4286357128393508
2020-08-18T00:30:00Z  1.4321312788986909
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的平方根。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平方根"><a class="header" href="#计算measurement中每个field-key对应的field-value的平方根">计算measurement中每个field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  sqrt_water_level
----                  ----------------
2020-08-18T00:00:00Z  1.4366627996854378
2020-08-18T00:06:00Z  1.4546477236774544
2020-08-18T00:12:00Z  1.4240786495134319
2020-08-18T00:18:00Z  1.4580809305384939
2020-08-18T00:24:00Z  1.4286357128393508
2020-08-18T00:30:00Z  1.4321312788986909
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的平方根。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平方根并包含多个子句">计算指定field key对应的field value的平方根并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  sqrt
----                  ----
2020-08-18T00:18:00Z  1.4580809305384939
2020-08-18T00:12:00Z  1.4240786495134319
2020-08-18T00:06:00Z  1.4546477236774544
2020-08-18T00:00:00Z  1.4366627996854378
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的平方根，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-23"><a class="header" href="#高级语法-23">高级语法</a></h4>
<pre><code>SELECT SQRT(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的平方根。</p>
<p><code>SQRT()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的平方根"><a class="header" href="#计算平均值的平方根">计算平均值的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  sqrt
----                  ----
2020-08-18T00:00:00Z  1.445683229480096
2020-08-18T00:12:00Z  1.4411800720243115
2020-08-18T00:24:00Z  1.430384563675098
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的平方根。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SQRT()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的平方根。</p>
</li>
<li>
<h3 id="tan"><a class="header" href="#tan">TAN()</a></h3>
<p>返回field value的正切值。</p>
<h4 id="基本语法-24"><a class="header" href="#基本语法-24">基本语法</a></h4>
<pre><code>SELECT TAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TAN(field_key)</code>返回field key对应的field value的正切值。</p>
<p><code>TAN(*)</code>返回在measurement中每个field key对应的field value的正切值。</p>
<p><code>TAN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>TAN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;water_level&quot; FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  water_level
----                  -----------
2020-08-18T00:00:00Z  2.064
2020-08-18T00:06:00Z  2.116
2020-08-18T00:12:00Z  2.028
2020-08-18T00:18:00Z  2.126
2020-08-18T00:24:00Z  2.041
2020-08-18T00:30:00Z  2.051
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值"><a class="header" href="#计算指定field-key对应的field-value的正切值">计算指定field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  tan
----                  ---
2020-08-18T00:00:00Z  -1.8604293534384375
2020-08-18T00:06:00Z  -1.6487359603347427
2020-08-18T00:12:00Z  -2.0326408012302273
2020-08-18T00:18:00Z  -1.6121545688343464
2020-08-18T00:24:00Z  -1.9676434782626282
2020-08-18T00:30:00Z  -1.9198657720074992
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正切值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正切值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正切值">计算measurement中每个field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(*) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica'

name: h2o_feet
time                  tan_water_level
----                  ---------------
2020-08-18T00:00:00Z  -1.8604293534384375
2020-08-18T00:06:00Z  -1.6487359603347427
2020-08-18T00:12:00Z  -2.0326408012302273
2020-08-18T00:18:00Z  -1.6121545688343464
2020-08-18T00:24:00Z  -1.9676434782626282
2020-08-18T00:30:00Z  -1.9198657720074992
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中每个存储数值的field key对应的field value的正切值。measurement <code>h2o_feet</code>中只有一个数值类型的field：<code>water_level</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正切值并包含多个子句">计算指定field key对应的field value的正切值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' ORDER BY time DESC LIMIT 4 OFFSET 2

name: h2o_feet
time                  tan
----                  ---
2020-08-18T00:18:00Z  -1.6121545688343464
2020-08-18T00:12:00Z  -2.0326408012302273
2020-08-18T00:06:00Z  -1.6487359603347427
2020-08-18T00:00:00Z  -1.8604293534384375
</code></pre>
<p>该查询返回measurement <code>h2o_feet</code>中field key <code>water_level</code>对应的field value的正切值，它涵盖的时间范围在<code>2020-08-18T00:00:00Z</code>和<code>2020-08-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-24"><a class="header" href="#高级语法-24">高级语法</a></h4>
<pre><code class="language-sql">SELECT TAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正切值。</p>
<p><code>TAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值-1"><a class="header" href="#计算平均值的正弦值-1">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(MEAN(&quot;water_level&quot;)) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                  tan
----                  ---
2020-08-18T00:00:00Z  -1.7497661902817365
2020-08-18T00:12:00Z  -1.8038002062256624
2020-08-18T00:24:00Z  -1.9435224805850773
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>water_level</code>的平均值的正切值。</p>
<p>为了得到这些结果，cnosDB首先计算每12分钟的时间间隔对应的<code>water_level</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>TAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:30:00Z' AND &quot;location&quot; = 'santa_monica' GROUP BY time(12m)

name: h2o_feet
time                   mean
----                   ----
2020-08-18T00:00:00Z   2.09
2020-08-18T00:12:00Z   2.077
2020-08-18T00:24:00Z   2.0460000000000003
</code></pre>
<p>然后，cnosDB计算这些平均值的正切值。</p>
</li>
</ul>
<h3 id="预测函数"><a class="header" href="#预测函数">预测函数</a></h3>
<ul>
<li>
<h3 id="holt_winters"><a class="header" href="#holt_winters">HOLT_WINTERS()</a></h3>
<ul>
<li>
<p>使用<a href="https://www.otexts.org/fpp/7/5?spm=a2c4g.11186623.2.92.41fc3ee27HC1R6">Holt-Winters</a>的季节性方法返回N个预测的field value。</p>
<p><code>HOLT_WINTERS()</code>可用于：</p>
<ul>
<li>预测时间什么时候会超过给定的阈值</li>
<li>将预测值与实际值进行比较，检测数据中的异常</li>
</ul>
</li>
</ul>
<h4 id="语法-19"><a class="header" href="#语法-19">语法</a></h4>
<pre><code>SELECT HOLT_WINTERS[_WITH-FIT](&lt;function&gt;(&lt;field_key&gt;),&lt;N&gt;,&lt;S&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>HOLT_WINTERS(function(field_key),N,S)</code>返回field key对应的<code>N</code>个季节性调整的预测field value。</p>
<p><code>N</code>个预测值出现的时间间隔跟group by time时间间隔相同。如果您的<code>GROUP BY time()</code>时间间隔是<code>6m</code>并且<code>N</code>等于<code>3</code>，那么您将会得到3个时间间隔为6分钟的预测值。</p>
<p><code>S</code>是一个季节性模式参数，并且根据<code>GROUP BY time()</code>时间间隔限定一个季节性模式的长度。如果您的<code>GROUP BY time()</code>时间间隔是<code>2m</code>并且<code>S</code>等于<code>3</code>，那么这个季节性模式每六分钟出现一次，也就是每三个<code>point</code>。如果您不希望季节性调整您的预测值，请将<code>S</code>设置为<code>0</code>或<code>1</code>。</p>
<p><code>HOLT_WINTERS_WITH_FIT(function(field_key),N,S)</code>除了返回field key对应的<code>N</code>个季节性调整的预测field value，还返回拟合值。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>处理以相同的时间间隔出现的数据；嵌套的cnosQL函数和<code>GROUP BY time()</code>子句确保Holt-Winters函数能够对常规数据进行操作。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-39"><a class="header" href="#示例-39">示例</a></h4>
<ul>
<li>
<h4 id="预测指定field-key的field-value"><a class="header" href="#预测指定field-key的field-value">预测指定field key的field value</a></h4>
</li>
<li>
<h4 id="原始数据"><a class="header" href="#原始数据">原始数据</a></h4>
</li>
</ul>
<p>该示例重点关注<code>NOAA_water_database</code>数据集的如下数据：</p>
<pre><code class="language-sql">SELECT &quot;water_level&quot; FROM &quot;NOAA_water_database&quot;.&quot;autogen&quot;.&quot;h2o_feet&quot; WHERE &quot;location&quot;='santa_monica' AND time &gt;= '2020-08-22 22:12:00' AND time &lt;= '2020-08-28 03:00:00'
</code></pre>
<ul>
<li>
<h4 id="步骤一匹配原始数据的趋势"><a class="header" href="#步骤一匹配原始数据的趋势">步骤一：匹配原始数据的趋势</a></h4>
</li>
</ul>
<p>编写一个<code>GROUP BY time()</code>查询，使得它匹配原始<code>water_level</code>数据的总体趋势。这里，我们使用了<code>FIRST()</code>函数：</p>
<pre><code class="language-sql">SELECT FIRST(&quot;water_level&quot;) FROM &quot;NOAA_water_database&quot;.&quot;autogen&quot;.&quot;h2o_feet&quot; WHERE &quot;location&quot;='santa_monica' and time &gt;= '2020-08-22 22:12:00' and time &lt;= '2020-08-28 03:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>GROUP BY time()</code>子句中，第一个参数(<code>379m</code>)匹配<code>water_level</code>数据中每个波峰和波谷之间发生的时间长度，第二个参数(<code>348m</code>)是一个偏移间隔，它通过改变cnosDB的默认<code>GROUP BY time()</code>边界来匹配原始数据的时间范围。</p>
<ul>
<li>
<h4 id="步骤二确定季节性模式"><a class="header" href="#步骤二确定季节性模式">步骤二：确定季节性模式</a></h4>
</li>
</ul>
<p>使用步骤一中查询的信息确定数据中的季节性模式。</p>
<ul>
<li>
<h4 id="步骤三应用holt_winters函数"><a class="header" href="#步骤三应用holt_winters函数">步骤三：应用<code>HOLT_WINTERS()</code>函数</a></h4>
</li>
</ul>
<p>在查询中加入Holt-Winters函数。这里，我们使用<code>HOLT_WINTERS_WITH_FIT()</code>来查看拟合值和预测值：</p>
<pre><code class="language-sql">SELECT HOLT_WINTERS_WITH_FIT(FIRST(&quot;water_level&quot;),10,4) FROM &quot;NOAA_water_database&quot;.&quot;autogen&quot;.&quot;h2o_feet&quot; WHERE &quot;location&quot;='santa_monica' AND time &gt;= '2020-08-22 22:12:00' AND time &lt;= '2020-08-28 03:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>HOLT_WINTERS_WITH_FIT()</code>函数中，第一个参数(<code>10</code>)请求10个预测的field value。每个预测的<code>point</code>相距<code>379m</code>，与<code>GROUP BY time()</code>子句中的第一个参数相同。<code>HOLT_WINTERS_WITH_FIT()</code>函数中的第二个参数(<code>4</code>)是我们在上一步骤中确定的季节性模式。</p>
<h4 id="holt_winters的常见问题"><a class="header" href="#holt_winters的常见问题"><code>HOLT_WINTERS()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="holt_winters和收到的point少于n个"><a class="header" href="#holt_winters和收到的point少于n个"><code>HOLT_WINTERS()</code>和收到的<code>point</code>少于”N”个</a></h4>
</li>
</ul>
<p>在某些情况下，用户可能会收到比参数<code>N</code>请求的更少的预测<code>point</code>。当数学计算不稳定和不能预测更多<code>point</code>时，这种情况就会发生。这意味着该数据集不适合使用<code>HOLT_WINTERS()</code>，或者，季节性调整参数是无效的并且是算法混乱。</p>
</li>
</ul>
<h3 id="分析函数"><a class="header" href="#分析函数">分析函数</a></h3>
<p>下面技术分析的函数将广泛使用的算法应用在您的数据中。虽然这些函数主要应用在金融和投资领域，但是它们也适用于其它行业和用例。</p>
<p><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></p>
<p><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></p>
<p><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></p>
<p><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></p>
<p><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></p>
<ul>
<li>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>除了field key，技术分析函数还接受以下参数：</p>
<p><code>PERIOD</code></p>
<p><strong>必需，整数，min=1</strong></p>
<p>算法的样本大小。这基本上是对算法的输出有显著影响的历史样本的数量。例如，<code>2</code>表示当前的<code>point</code>和前一个<code>point</code>。算法使用指数衰减率来决定历史<code>point</code>的权重，通常称为<code>alpha(α)</code>。参数<code>PERIOD</code>控制衰减率。</p>
<blockquote>
<p>请注意，历史<code>point</code>仍然可以产生影响。</p>
</blockquote>
<h4 id="hold_period"><a class="header" href="#hold_period">HOLD_PERIOD</a></h4>
<p><strong>整数，min=-1</strong></p>
<p>算法需要多少个样本才会开始发送结果。默认值<code>-1</code>表示该参数的值基于算法、<code>PERIOD</code>和<code>WARMUP_TYPE</code>，但是这是一个可以使算法发送有意义的结果的值。</p>
<p><strong>默认的Hold Periods：</strong></p>
<p>对于大多数提供的技术分析，<code>HOLD_PERIOD</code>的默认值由您使用的技术分析算法和<code>WARMUP_TYPE</code>决定。</p>
</li>
</ul>
<table><thead><tr><th>算法 \ Warmup Type</th><th>simple</th><th>exponential</th><th style="text-align: center">none</th></tr></thead><tbody>
<tr><td><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE</a></td><td>PERIOD - 1</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 2</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 3</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE</a></td><td>( PERIOD - 1 ) * 3 + 1</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center">PERIOD - 1</td></tr>
</tbody></table>
<p><em><strong>Kaufman算法默认的Hold Periods：</strong></em></p>
<table><thead><tr><th>算法</th><th>默认的Hold Period</th></tr></thead><tbody>
<tr><td><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></td><td>PERIOD</td></tr>
<tr><td><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></td><td>PERIOD</td></tr>
</tbody></table>
<h4 id="warmup_type"><a class="header" href="#warmup_type">WARMUP_TYPE</a></h4>
<p><strong>默认=”exponential”</strong></p>
<p>这个参数控制算法如何为第一个<code>PERIOD</code>样本初始化自身，它本质上是具有不完整样本集的持续时间。</p>
<p><code>simple</code>
第一个<code>PERIOD</code>样本的简单移动平均值(simple moving average，SMA)。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.106.41fc3ee27HC1R6">ta-lib</a>使用的方法。</p>
<p><code>exponential</code>
具有缩放alpha(α)的指数移动平均值(exponential moving average，EMA)。基本上是这样使用EMA：<code>PERIOD=1</code>用于第一个点，<code>PERIOD=2</code>用于第二个点，以此类推，直至算法已经消耗了<code>PERIOD</code>个<code>point</code>。由于算法一开始就使用了EMA，当使用此方法并且没有指定<code>HOLD_PERIOD</code>的值或<code>HOLD_PERIOD</code>的值为<code>-1</code>时，算法可能会在比<code>simple</code>小得多的样本大小的情况下开始发送<code>point</code>。</p>
<p><code>none</code>
算法不执行任何的平滑操作。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.107.41fc3ee27HC1R6">ta-lib</a>使用的方法。当使用此方法并且没有指定<code>HOLD_PERIOD</code>时，<code>HOLD_PERIOD</code>的默认值是<code>PERIOD - 1</code>。</p>
<blockquote>
<p>类型<code>none</code>仅适用于<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数。</p>
</blockquote>
<ul>
<li>
<h3 id="chande_momentum_oscillator"><a class="header" href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></h3>
<p>Chande Momentum Oscillator (CMO)是由Tushar Chande开发的一个技术动量指标。通过计算所有最近较高<code>point</code>的总和与所有最近较低<code>point</code>的总和的差值，然后将结果除以给定时间范围内的所有数据变动的总和来创建CMO指标。将结果乘以100可以得到一个从-100到+100的范围。
<sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo" target="\_blank">Source</a></p>
<h4 id="基本语法-25"><a class="header" href="#基本语法-25">基本语法</a></h4>
<pre><code>CHANDE_MOMENTUM_OSCILLATOR([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;, [warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup-type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 2)</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 10, 9, 'none')</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>none</code>。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用CMO算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(/regular_expression/, 2)</code>返回使用CMO算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(*, 2)</code>返回使用CMO算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="exponential_moving_average"><a class="header" href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>指数移动平均值 (Exponential Moving Average，EMA)类似于简单移动平均值，不同的是，指数移动平均值对最新数据给予更多的权重，它也被称为”指数加权移动平均值”。与简单移动平均值相比，这种类型的移动平均值对最近数据的变化反应更快。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/e/ema.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-26"><a class="header" href="#基本语法-26">基本语法</a></h4>
<pre><code>EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用参数:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用EMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用EMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用EMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="double_exponential_moving_average"><a class="header" href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>双重指数移动平均值 (Double Exponential Moving Average，DEMA)通过增加最近数据的权重，尝试消除与移动平均值相关的固有滞后。该名字似乎表明这是通过双重指数平滑来实现的，然而事实并非如此，它表示的是将EMA的值翻倍。为了使它与实际数据保持一致，也为了消除滞后，从之前两倍EMA的值中把”EMA of EMA”的值减去，公式为：DEMA = 2 * EMA - EMA(EMA)。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Double_exponential_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-27"><a class="header" href="#基本语法-27">基本语法</a></h4>
<pre><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用DEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用DEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用DEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="kaufmans_efficiency_ratio"><a class="header" href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></h3>
<p>Kaufman效率比 (Kaufman’s Efficiency Ration)，或简称为效率比 (Efficiency Ratio，ER)，它的计算方法是：将一段时间内的数据变化除以实现该变化所发生的数据变动的绝对值的总和。得出的比率在0和1之间，比率越高，表示市场越有效率或越有趋势。</p>
<p>ER跟Chande Momentum Oscillator (CMO)非常类似。不同的是，CMO将市场方向考虑在内，但是如果您将CMO的绝对值除以100，就可以得到ER。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://etfhq.com/blog/2011/02/07/kaufmans-efficiency-ratio/" target="\_blank">Source</a></p>
<h4 id="基本语法-28"><a class="header" href="#基本语法-28">基本语法</a></h4>
<pre><code class="language-sql">KAUFMANS_EFFICIENCY_RATIO([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 2)</code>返回使用效率指数(Efficiency Index)算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 10, 10)</code>返回使用效率指数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用效率指数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_EFFICIENCY_RATIO()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_EFFICIENCY_RATIO(/regular_expression/, 2)</code>返回使用效率指数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(*, 2)</code>返回使用效率指数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="kaufmans_adaptive_moving_average"><a class="header" href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></h3>
<p>Kaufman自适应移动平均值 (Kaufman’s Adaptive Moving Average，KAMA)，是一个用于计算样本噪音或波动率的移动平均值。当数据波动相对较小并且噪音较低时，KAMA会密切关注<code>point</code>。当数据波动较大时，KAMA会进行调整，平滑噪音。该趋势跟踪指标可用于识别总体趋势、时间转折点和过滤价格变动。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:kaufman_s_adaptive_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-29"><a class="header" href="#基本语法-29">基本语法</a></h4>
<pre><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong>
<a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 2)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 10, 10)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用KAMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用KAMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(*, 2)</code>返回使用KAMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_moving_average"><a class="header" href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>三重指数移动平均值 (Triple Exponential Moving Average，TEMA)，旨在过滤常规移动平均值的波动。该名字似乎表明这是通过三重指数平滑来实现的，然而事实并非如此，它实际上是包含指数移动平均值、双重指数移动平均值和三重指数移动平均值的复合函数。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/t/triple-exponential-moving-average.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-30"><a class="header" href="#基本语法-30">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用TEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用TEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用TEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_derivative"><a class="header" href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></h3>
<p>三重指数导数指标 (Triple Exponential Derivative Indicator)，通常称为”TRIX”，是一种用于识别超卖和超买市场的振荡器，也可用作动量指标。TRIX计算一段时间内输入数据的对数的三重指数移动平均值。从当前的值中减去之前的值，这可以防止指标考虑比规定期间短的周期。</p>
<p>跟很多振荡器一样，TRIX围绕着零线震荡。当它用作振荡器时，正数表示炒买超买市场，而负数表示超卖市场。当它用作动量指标时，正数表示动量在增加，而负数表示动量在减少。很多分析师认为，当TRIX超过零线时，它会给出买入信号，当低于零线时，它会给出卖出信号。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/articles/technical/02/092402.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-31"><a class="header" href="#基本语法-31">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_DERIVATIVE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 2)</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 10, 10, 'exponential')</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用三重指数导数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(/regular_expression/, 2)</code>返回使用三重指数导数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(*, 2)</code>返回使用三重指数导数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="relative_strength_index"><a class="header" href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></h3>
<p>相对强弱指数 (Relative Strength Index，RSI)是一个动量指标，用于比较在指定时间段内最近数据增大和减小的幅度，以便measurement数据变动的速度和变化。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/r/rsi.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-32"><a class="header" href="#基本语法-32">基本语法</a></h4>
<pre><code>RELATIVE_STRENGTH_INDEX([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 2)</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 10, 10, 'exponential')</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>RELATIVE_STRENGTH_INDEX(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用RSI算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>RELATIVE_STRENGTH_INDEX()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>RELATIVE_STRENGTH_INDEX(/regular_expression/, 2)</code>返回使用RSI算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(*, 2)</code>返回使用RSI算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<h4 id="示例数据"><a class="header" href="#示例数据">示例数据</a></h4>
<p>本文档使用的数据可在<a href="NOAA_water_database.txt">示例数据</a>中下载。</p>
<h4 id="函数的通用语法"><a class="header" href="#函数的通用语法">函数的通用语法</a></h4>
<ul>
<li>
<h4 id="在select中指定多个函数"><a class="header" href="#在select中指定多个函数">在<code>SELECT</code>中指定多个函数</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;(),&lt;function&gt;() FROM_clause [...]
</code></pre>
<p>使用逗号(<code>,</code>)将<code>SELECT</code>语句中的多个函数分开。该语法适用于除<code>TOP()</code>和<code>BOTTOM()</code>之外的所有cnosQL函数。<code>SELECT</code>子句不支持<code>TOP()</code>或<code>BOTTOM()</code>和其它函数同时使用。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的平均值和平均数"><a class="header" href="#在一个查询中计算field-value的平均值和平均数">在一个查询中计算field value的平均值和平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;),MEDIAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  mean               median
----                  ----               ------
1970-01-01T00:00:00Z  4.442107025822522  4.124
</code></pre>
<p>该查询返回<code>water_level</code>的平均值和平均数。</p>
<ul>
<li>
<h4 id="在一个查询中计算两个field的mode"><a class="header" href="#在一个查询中计算两个field的mode">在一个查询中计算两个field的mode</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;water_level&quot;),MODE(&quot;level description&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  mode  mode_1
----                  ----  ------
1970-01-01T00:00:00Z  2.69  between 3 and 6 feet
</code></pre>
<p>该查询返回<code>water_level</code>中出现频率最高的field value和<code>level description</code>中出现频率最高的field value。<code>water_level</code>对应的值在列<code>mode</code>中，<code>level description</code>对应的值在列<code>mode_1</code>中。因为系统不能返回多个具有相同名字的列，所以它将第二个列<code>mode</code>重命名为<code>mode_1</code>。</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的最小值和最大值"><a class="header" href="#在一个查询中计算field-value的最小值和最大值">在一个查询中计算field value的最小值和最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;water_level&quot;), MAX(&quot;water_level&quot;) [...]

name: h2o_feet
time                  min    max
----                  ---    ---
1970-01-01T00:00:00Z  -0.61  9.964
</code></pre>
<p>该查询返回<code>water_level</code>的最小值和最大值。</p>
<p>请注意，该查询返回<code>1970-01-01T00:00:00Z</code>作为时间戳，这是cnosDB的空时间戳。<code>MIN()</code>和<code>MAX()</code>是selector函数；当selector函数是<code>SELECT</code>子句中的唯一函数时，它返回一个特定的时间戳。因为<code>MIN()</code>和<code>MAX()</code>返回两个不同的时间戳（见下面的例子），所以系统会用空时间戳覆盖这些时间戳。</p>
<pre><code class="language-sql">&gt;  SELECT MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  min
----                  ---
2020-08-29T14:30:00Z  -0.61    &lt;--- Timestamp 1

&gt;  SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964    &lt;--- Timestamp 2
</code></pre>
<h4 id="重命名查询结果字段"><a class="header" href="#重命名查询结果字段">重命名查询结果字段</a></h4>
<ul>
<li>
<h4 id="语法-20"><a class="header" href="#语法-20">语法</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;() AS &lt;field_key&gt; [...]
</code></pre>
<p>默认情况下，函数返回的结果在与函数名称匹配的field key下面。使用<code>AS</code>子句可以指定输出的field key的名字。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="指定输出的field-key"><a class="header" href="#指定输出的field-key">指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) AS &quot;dream_name&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  dream_name
----                  ----------
1970-01-01T00:00:00Z  4.442107025822522
</code></pre>
<p>该查询返回<code>water_level</code>的平均值，并将输出的field key重命名为<code>dream_name</code>。如果没有<code>AS</code>子句，那么查询会返回<code>mean</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  mean
----                  ----
1970-01-01T00:00:00Z  4.442107025822522
</code></pre>
<ul>
<li>
<h4 id="为多个函数指定输出的field-key"><a class="header" href="#为多个函数指定输出的field-key">为多个函数指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;) AS &quot;med_wat&quot;,MODE(&quot;water_level&quot;) AS &quot;mode_wat&quot; FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  med_wat  mode_wat
----                  -------  --------
1970-01-01T00:00:00Z  4.124    2.69
</code></pre>
<p>该查询返回<code>water_level</code>的平均数和<code>water_level</code>中出现频率最高的field value，并将输出的field key分别重命名为<code>med_wat</code>和<code>mode_wat</code>。如果没有<code>AS</code>子句，那么查询会返回<code>median</code>和<code>mode</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;water_level&quot;),MODE(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  median  mode
----                  ------  ----
1970-01-01T00:00:00Z  4.124   2.69
</code></pre>
<h4 id="改变不含数据的时间间隔的返回值"><a class="header" href="#改变不含数据的时间间隔的返回值">改变不含数据的时间间隔的返回值</a></h4>
<p>默认情况下，包含cnosQL函数和<code>GROUP BY time()</code>子句的查询对不包含数据的时间间隔返回空值。在<code>GROUP BY</code>子句后面加上<code>fill()</code>可以更改这个值。关于<code>fill()</code>的详细讨论，请查看数据探索。</p>
<h4 id="函数的常见问题"><a class="header" href="#函数的常见问题">函数的常见问题</a></h4>
<p>以下部分描述了所有函数、聚合函数和选择函数的常见混淆来源，有关单个功能的常见问题，请参见以下特定文档：</p>
<ul>
<li><a href="#common-issues-with-distinct">DISTINCT()</a></li>
<li><a href="#common-issues-with-bottom">BOTTOM()</a></li>
<li><a href="#common-issues-with-percentile">PERCENTILE()</a></li>
<li><a href="#common-issues-with-sample">SAMPLE()</a></li>
<li><a href="#common-issues-with-top">TOP()</a></li>
<li><a href="#common-issues-with-elapsed">ELAPSED()</a></li>
<li><a href="#common-issues-with-holt-winters">HOLT_WINTERS()</a></li>
</ul>
<h4 id="所有函数"><a class="header" href="#所有函数">所有函数</a></h4>
<ul>
<li>
<h4 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h4>
</li>
</ul>
<p>某些cnosQL 函数支持 <a href="/cnosdb/v1.8/query_language/explore-data/#select-clause"><code>SELECT</code> clause</a>中嵌套:</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a> with <a href="#distinct"><code>DISTINCT()</code></a></li>
<li><a href="#cumulative-sum"><code>CUMULATIVE_SUM()</code></a></li>
<li><a href="#derivative"><code>DERIVATIVE()</code></a></li>
<li><a href="#difference"><code>DIFFERENCE()</code></a></li>
<li><a href="#elapsed"><code>ELAPSED()</code></a></li>
<li><a href="#moving-average"><code>MOVING_AVERAGE()</code></a></li>
<li><a href="#non-negative-derivative"><code>NON_NEGATIVE_DERIVATIVE()</code></a></li>
<li><a href="#holt-winters"><code>HOLT_WINTERS()</code></a> and <a href="#holt-winters"><code>HOLT_WINTERS_WITH_FIT()</code></a></li>
</ul>
<ul>
<li>
<h4 id="查询在now之后的时间范围"><a class="header" href="#查询在now之后的时间范围">查询在now()之后的时间范围</a></h4>
</li>
</ul>
<p>大多数<code>SELECT</code>语句的默认时间范围在<code>1677-09-21 00:12:43.145224194</code> UTC和<code>2262-04-11T23:47:16.854775806Z</code> UTC之间。对于包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询，默认的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。</p>
<p>如果要查询时间戳发生在<code>now()</code>之后的数据，那么包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询必须在<code>WHERE</code>子句中提供一个时间上限。请查看常见问题。</p>
<h4 id="聚合函数-1"><a class="header" href="#聚合函数-1">聚合函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳"><a class="header" href="#理解返回的时间戳">理解返回的时间戳</a></h4>
</li>
</ul>
<p>子句中具有 <a href="#aggregations">聚合函数</a> 且 <code>WHERE</code>没有时间范围的查询讲返回 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间戳.
cnosDB 使用 epoch 0 作为等效的空时间戳.
带有聚合函数的查询，如果 <code>WHERE</code> 子句中包含时间范围，将返回时间下限作为时间戳.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用聚合函数并且没有指定时间范围"><a class="header" href="#使用聚合函数并且没有指定时间范围">使用聚合函数并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                   sum
----                   ---
1970-01-01T00:00:00Z   67777.66900000004
</code></pre>
<p>该查询将cnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为时间戳返回。<code>SUM()</code>将多个<code>point</code>聚合，没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围"><a class="header" href="#使用聚合函数并且指定时间范围">使用聚合函数并且指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z'

name: h2o_feet
time                  sum
----                  ---
2020-08-18T00:00:00Z  67777.66900000004
</code></pre>
<p>该查询将时间范围的下界(<code>WHERE time &gt;= '2020-08-18T00:00:00Z'</code>)作为时间戳返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围和使用group-by-time子句"><a class="header" href="#使用聚合函数并且指定时间范围和使用group-by-time子句">使用聚合函数并且指定时间范围和使用GROUP BY time()子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:18:00Z' GROUP BY time(12m)

name: h2o_feet
time                  sum
----                  ---
2020-08-18T00:00:00Z  20.305
2020-08-18T00:12:00Z  19.802999999999997
</code></pre>
<p>该查询将每个<code>GROUP BY time()</code>间隔的时间下界作为时间戳返回。</p>
<ul>
<li>
<h4 id="将聚合函数和不聚合的数据混合使用"><a class="header" href="#将聚合函数和不聚合的数据混合使用">将聚合函数和不聚合的数据混合使用</a></h4>
</li>
</ul>
<p>聚合函数不支持在<code>SELECT</code>语句中指定不使用聚合函数的单独的field key或tag key。聚合函数返回一个计算结果，对于没有被聚合的field或tag，没有明显的单个值可以返回。当<code>SELECT</code>语句同时包含聚合函数和单独的field key或tag key时，会返回错误：</p>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;water_level&quot;),&quot;location&quot; FROM &quot;h2o_feet&quot;

ERR: error parsing query: mixing aggregate and non-aggregate queries is not supported
</code></pre>
<ul>
<li>
<h4 id="得到略有不同的结果"><a class="header" href="#得到略有不同的结果">得到略有不同的结果</a></h4>
</li>
</ul>
<p>对于某些聚合函数，在相同的<code>point</code>（数据类型为float64)上执行相同的函数，可能会产生稍微不同的结果。在应用聚合函数之间，cnosDB不会将<code>point</code>进行排序；该行为可能会导致查询结果中出现小小的差异。</p>
<h4 id="selector函数"><a class="header" href="#selector函数">Selector函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳-1"><a class="header" href="#理解返回的时间戳-1">理解返回的时间戳</a></h4>
</li>
</ul>
<p>selector函数返回的时间戳依赖查询中函数的数量和查询中的其它子句：</p>
<p>带有单个选择器函数，单个 field key 参数和无 <code>GROUP BY time()</code> 的查询返回原始数据中出现的point时间戳.
具有单个 selector 函数, 多个 <code>field key</code> 参数的查询, <code>GROUP BY time()</code> 返回原始数据中出现的point 时间戳，或与空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>)等价的cnosDB.</p>
<p><code>WHERE</code>子句中有多个函数且没有时间范围的查询将返回相当于空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>).
在 <code>WHERE</code>子句中包含多个函数和时间范围的查询将时间下限作为时间戳返回</p>
<p>带有 selector 函数和  <code>GROUP BY time()</code> 子句的查询返回每个 <code>GROUP BY time()</code>间隔的时间下限.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用单个selector函数和单个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和单个field-key并且没有指定时间范围">使用单个selector函数和单个field key，并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964

&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z'

name: h2o_feet
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964
</code></pre>
<p>该查询返回原始数据中具有<code>最大</code>值的<code>point</code>的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数和多个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和多个field-key并且没有指定时间范围">使用单个selector函数和多个field key，并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  first_level description  first_water_level
----                  -----------------------  -----------------
1970-01-01T00:00:00Z  between 6 and 9 feet     8.12

&gt; SELECT MAX(*) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max_water_level
----                  ---------------
2020-08-29T07:24:00Z  9.964
</code></pre>
<p>第一个查询返回cnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>FIRST(*)</code>返回两个时间戳（对应measurement <code>h2o_feet</code>中的每个field key），所以系统使用空时间戳覆盖这两个时间戳。</p>
<p>第二个查询返回原始数据中具有最大值的<code>point</code>的时间戳。因为<code>MAX(*)</code>只返回一个时间戳(measurement <code>h2o_feet</code>中只有一个数值类型的field)，所以系统不会覆盖原始时间戳。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且没有指定时间范围"><a class="header" href="#使用多个selector函数并且没有指定时间范围">使用多个selector函数，并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;),MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot;

name: h2o_feet
time                  max    min
----                  ---    ---
1970-01-01T00:00:00Z  9.964  -0.61
</code></pre>
<p>该查询返回cnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>MAX()</code>和<code>MIN()</code>函数返回不同的时间戳，所以系统没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且指定时间范围"><a class="header" href="#使用多个selector函数并且指定时间范围">使用多个selector函数，并且指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;),MIN(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z'

name: h2o_feet
time                  max    min
----                  ---    ---
2020-08-18T00:00:00Z  9.964  -0.61
</code></pre>
<p>该查询返回时间范围的下界(<code>WHERE time &gt;= '2020-08-18T00:00:00Z'</code>)作为查询结果中的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数并且指定时间范围"><a class="header" href="#使用单个selector函数并且指定时间范围">使用单个selector函数，并且指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;water_level&quot;) FROM &quot;h2o_feet&quot; WHERE time &gt;= '2020-08-18T00:00:00Z' AND time &lt;= '2020-08-18T00:18:00Z' GROUP BY time(12m)

name: h2o_feet
time                  max
----                  ---
2020-08-18T00:00:00Z  8.12
2020-08-18T00:12:00Z  7.887
</code></pre>
<p>该查询返回每个<code>GROUP BY time()</code>间隔的时间下限作为查询结果中的时间戳。</p>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../content/cnosdb/latest/management.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../../content/cnosdb/latest/protocol.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../content/cnosdb/latest/management.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../../content/cnosdb/latest/protocol.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
