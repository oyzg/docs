<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CnosQL</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../favicon.svg">
        <link rel="shortcut icon" href="../../../favicon.png">
        <link rel="stylesheet" href="../../../css/variables.css">
        <link rel="stylesheet" href="../../../css/general.css">
        <link rel="stylesheet" href="../../../css/chrome.css">
        <link rel="stylesheet" href="../../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../highlight.css">
        <link rel="stylesheet" href="../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/about.html"><strong aria-hidden="true">1.</strong> 关于本项目</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/index.html"><strong aria-hidden="true">2.</strong> 介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/download.html"><strong aria-hidden="true">2.1.</strong> 下载</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/install.html"><strong aria-hidden="true">2.2.</strong> 安装</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/introduction/get-start.html"><strong aria-hidden="true">2.3.</strong> 快速开始</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/concept/index.html"><strong aria-hidden="true">3.</strong> 概念</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/index.html"><strong aria-hidden="true">4.</strong> 指南</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/cnosdb.html"><strong aria-hidden="true">4.1.</strong> cnosdb</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/cnosdb-cli.html"><strong aria-hidden="true">4.2.</strong> cnosdb-cli</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/write.html"><strong aria-hidden="true">4.3.</strong> HTTP写入</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/query.html"><strong aria-hidden="true">4.4.</strong> HTTP查询</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/guide/cnosdb_inspect.html"><strong aria-hidden="true">4.5.</strong> CnosDB Inspect</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/index.html"><strong aria-hidden="true">5.</strong> CnosQL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/ddl.html"><strong aria-hidden="true">5.1.</strong> DDL</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/dml.html"><strong aria-hidden="true">5.2.</strong> DML</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/function.html"><strong aria-hidden="true">5.3.</strong> 函数</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cnosql/countine_query.html"><strong aria-hidden="true">5.4.</strong> 连续查询</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/cluster/introduction.html"><strong aria-hidden="true">6.</strong> CnosDB分布式</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/other/index.html"><strong aria-hidden="true">7.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/other/kubernetes-deployment.html"><strong aria-hidden="true">7.1.</strong> 使用Kubernetes部署CnosDB</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/0.10/other/kubernetes-StatefulSet.html"><strong aria-hidden="true">7.2.</strong> 使用Kubernetes部署CnosDB集群</a></li></ol></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/SUMMARY.html"><strong aria-hidden="true">8.</strong> latest</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/introduction.html"><strong aria-hidden="true">8.1.</strong> 介绍</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/quickstart.html"><strong aria-hidden="true">8.2.</strong> 快速开始</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/concept.html"><strong aria-hidden="true">8.3.</strong> 概念</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/guide.html"><strong aria-hidden="true">8.4.</strong> 入门指南</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/management.html"><strong aria-hidden="true">8.5.</strong> 运维管理</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/cnosql.html" class="active"><strong aria-hidden="true">8.6.</strong> CnosQL</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/protocol.html"><strong aria-hidden="true">8.7.</strong> 数据协议</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/sandboxmanagement.html"><strong aria-hidden="true">8.8.</strong> 集群管理</a></li><li class="chapter-item expanded "><a href="../../../content/cnosdb/latest/question.html"><strong aria-hidden="true">8.9.</strong> 疑难解答</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cnosql"><a class="header" href="#cnosql">CnosQL</a></h1>
<h2 id="cnosdb入门"><a class="header" href="#cnosdb入门">CnosDB入门</a></h2>
<ul>
<li>
<h3 id="摘要"><a class="header" href="#摘要">摘要</a></h3>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E5%BA%8F%E6%95%B0%E6%8D%AE">什么是时序数据？</a></li>
<li><a href="#cnosdb%E7%AE%80%E4%BB%8B">CnosDB简介</a></li>
<li><a href="#%E5%BF%AB%E9%80%9F%E5%BC%80%E5%A7%8B">快速开始</a></li>
<li><a href="#cnosql-vs-sql">CnosQL VS SQL</a></li>
<li><a href="#%E6%9F%A5%E8%AF%A2%E5%85%A5%E9%97%A8">查询入门</a></li>
</ul>
</li>
<li>
<h3 id="什么是时序数据"><a class="header" href="#什么是时序数据">什么是时序数据？</a></h3>
<p>时序数据是指时间序列数据。是按<strong>时间顺序</strong>记录的数据列，在同一数据列中的各个数据必须是同口径的，要求具有可比性。</p>
<p><a href="https://www.cnosdb.com">场景</a></p>
<p><a href="https://weathernew.pae.baidu.com/weathernew/pc?query=%E5%8C%97%E4%BA%AC%E5%A4%A9%E6%B0%94&amp;srcid=4982">天气</a></p>
</li>
<li>
<h3 id="cnosdb简介"><a class="header" href="#cnosdb简介">CnosDB简介</a></h3>
<p><strong>时序数据库</strong> - 用于处理带时间标签（按照时间的顺序变化，即时间序列化）的数据</p>
<p><strong>时序数据管理系统</strong> - 主要通过对时序数据的采集、处理和分析帮助企业实时监控企业的生产与经营过程。</p>
<ul>
<li>数据是时序的，一定带有时间戳</li>
<li>数据极少有更新操作</li>
<li>数据的写入多，读取少</li>
<li>用户关注的是一段时间的趋势</li>
<li>数据是有保留期限的</li>
<li>除了存储查询外，还需要实时的计算操作</li>
<li>数据量巨大，每天很容易就会过百亿</li>
</ul>
</li>
<li>
<h3 id="快速开始"><a class="header" href="#快速开始">快速开始</a></h3>
<h4 id="使用docker启动"><a class="header" href="#使用docker启动">使用Docker启动</a></h4>
<pre><code class="language-bash">docker pull cnosdb/cnosdb:latest
docker run -itd -p 8086:8086 cnosdb/cnosdb:latest
</code></pre>
<h4 id="导入示例数据"><a class="header" href="#导入示例数据">导入示例数据</a></h4>
<blockquote>
<p>如何提示<code>bash: wget: command not found</code></p>
<p>请下载<code>wget</code>工具: <code>apt-get update &amp;&amp; apt-get install wget</code></p>
</blockquote>
<pre><code class="language-bash">docker ps # 查看运行中的容器

docker exec -it container_id bash # 进入容器


#下载提前准备的有效数据
wget https://github.com/ailunyegeer/docs/blob/main/src/content/cnosdb/latest/data.txt

cnosdb-cli import --path data.txt # 导入数据到cnosdb

cnosdb-cli

SHOW DATABASES

#能看见名为oceanic_station的数据库


USE oceanic_station

</code></pre>
</li>
<li>
<h3 id="cnosql-vs-sql"><a class="header" href="#cnosql-vs-sql">CnosQL vs SQL</a></h3>
<ul>
<li>
<p>时间序列数据在聚合场景中最有用</p>
</li>
<li>
<p>CnosDB 中的<code>measurement</code>类似于一个 SQL 中的<code>table</code></p>
</li>
<li>
<p>CnosDB 中的<code>tag</code>就像 SQL 中的一个带索引的列</p>
</li>
<li>
<p>CnosDB 中的<code>field</code>就像 SQL 中的没有索引的列</p>
</li>
<li>
<p>CnosDB<code>points</code>类似于 SQL 中的行</p>
</li>
<li>
<p>CnosDB 中不需要预定义<code>schema</code></p>
</li>
</ul>
</li>
<li>
<h3 id="查询入门"><a class="header" href="#查询入门">查询入门</a></h3>
<h4 id="查看所有-measurements"><a class="header" href="#查看所有-measurements">查看所有 <code>measurements</code></a></h4>
<pre><code>SHOW MEASUREMENTS
</code></pre>
<h4 id="计算air中temperature的数量"><a class="header" href="#计算air中temperature的数量">计算<code>air</code>中<code>temperature</code>的数量</a></h4>
<p><code>  SELECT COUNT(&quot;temperature&quot;) FROM air</code></p>
<h4 id="查看air中的前五个值"><a class="header" href="#查看air中的前五个值">查看<code>air</code>中的前五个值</a></h4>
<p><code>SELECT * FROM air LIMIT 5</code></p>
<h4 id="指定字段的标识符号"><a class="header" href="#指定字段的标识符号">指定字段的标识符号</a></h4>
<pre><code> SELECT &quot;temperature&quot;::field,&quot;station&quot;::tag,&quot;visibility&quot;::field FROM &quot;air&quot; limit 10
</code></pre>
<h4 id="查看measurement的tag-key"><a class="header" href="#查看measurement的tag-key">查看<code>measurement</code>的tag key</a></h4>
<p><code> SHOW TAG KEYS FROM air</code></p>
<h4 id="查看tag-value"><a class="header" href="#查看tag-value">查看tag value</a></h4>
<p><code> SHOW TAG VALUES FROM air WITH KEY = &quot;station&quot;</code></p>
<h4 id="查看field-key"><a class="header" href="#查看field-key">查看field key</a></h4>
<p><code> SHOW FIELD KEYS FROM air</code></p>
<h4 id="查看series"><a class="header" href="#查看series">查看series</a></h4>
<p><code>SHOW SERIES</code></p>
<h4 id="函数使用"><a class="header" href="#函数使用">函数使用</a></h4>
<blockquote>
<p><a href="https://www.cnosdb.com/content/cnosdb/0.10/cnosql/function.html">更多</a></p>
</blockquote>
<p><code> SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;</code></p>
</li>
</ul>
<h2 id="cnosql语法"><a class="header" href="#cnosql语法">CnosQL语法</a></h2>
<ul>
<li>
<h3 id="ddl"><a class="header" href="#ddl">DDL</a></h3>
<p>CnosQL提供了一整套DDL（数据定义语言）</p>
</li>
</ul>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center"><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86">数据库管理</a></th><th style="text-align: center"></th></tr></thead><tbody>
<tr><td style="text-align: center"><a href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E5%BA%93">CREATE DATABASE</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BA%E6%95%B0%E6%8D%AE%E5%BA%93">SHOW DATABASES</a></td><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4%E6%95%B0%E6%8D%AE%E5%BA%93">DROP DATABASE</a></td></tr>
<tr><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAseries">SHOW SERIES</a></td><td style="text-align: center"><a href="#%E4%BD%BF%E7%94%A8drop%E5%88%A0%E9%99%A4series">DROP SERIES</a></td><td style="text-align: center"><a href="#%E4%BD%BF%E7%94%A8delete%E5%88%A0%E9%99%A4series">DELETE</a></td></tr>
<tr><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAmeasurement">SHOW MEASUREMENTS</a></td><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4measurement">DROP MEASUREMENT</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAtag-key">SHOW TAG KEYS</a></td></tr>
<tr><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAtag-value">SHOW TAG VALUES</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BAfield-key">SHOW FIELD KEYS</a></td><td style="text-align: center"><a href="#%E6%8C%89%E6%97%B6%E9%97%B4%E8%BF%87%E6%BB%A4">按时间过滤</a></td></tr>
<tr><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4%E5%88%86%E7%89%87">DROP SHARD</a></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"></td><td style="text-align: center"><a href="#%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5%E7%AE%A1%E7%90%86"><strong>保留策略管理</strong></a></td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center"><a href="#%E5%88%9B%E5%BB%BA%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">CREATE RETENTION POLICY</a></td><td style="text-align: center"><a href="#%E6%98%BE%E7%A4%BA%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">SHOW RETENTION POLICIES</a></td><td style="text-align: center"><a href="#%E4%BF%AE%E6%94%B9%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">ALTER RETENTION POLICY</a></td></tr>
<tr><td style="text-align: center"><a href="#%E5%88%A0%E9%99%A4%E4%BF%9D%E7%95%99%E7%AD%96%E7%95%A5">DROP RETENTION POLICY</a></td><td style="text-align: center"></td><td style="text-align: center"></td></tr>
</tbody></table>
<ul>
<li>
<h3 id="数据库管理"><a class="header" href="#数据库管理">数据库管理</a></h3>
<h4 id="创建数据库"><a class="header" href="#创建数据库">创建数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE DATABASE &lt;database_name&gt; [WITH [DURATION &lt;duration&gt;] [REPLICATION &lt;n&gt;] [SHARD DURATION &lt;duration&gt;] [NAME &lt;rp-name&gt;]]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>CREATE DATABASE</code>需要一个数据库名称，其他都为可选项。如果未在<code>WITH</code>后面指定保留策略，则会创建一个默认的保留策略，名称为<code>autogen</code>。</p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>NAME</code>指定保留策略名称。</p>
<p><code>CREATE DATABASE</code>成功执行后不会返回任何结果。</p>
<p><strong>示例</strong></p>
<p>创建数据库</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，CnosDB还会在其下创建一个名为<code>autogen</code>的保留策略。</p>
</blockquote>
<pre><code class="language-sql"> CREATE DATABASE &quot;cnos&quot;
</code></pre>
<p>创建数据库并指定保留策略</p>
<blockquote>
<p>创建一个名为<code>cnos</code>的数据库，并指定保留策略为<code>1d_events</code>，它的生命周期为总保留时长为一天，副本数为1，每个分片的的窗口长度为一小时。</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE DATABASE &quot;cnos&quot; WITH DURATION 1d REPLICATION 1 SHARD DURATION 1h NAME &quot;1d_events&quot;
</code></pre>
<h4 id="显示数据库"><a class="header" href="#显示数据库">显示数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code>SHOW DATABASES
</code></pre>
<h4 id="删除数据库"><a class="header" href="#删除数据库">删除数据库</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP DATABASE &lt;database_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP DATABASE</code>会删除数据库下所有数据。</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP DATABASE &quot;cnos&quot;
</code></pre>
</li>
<li>
<h3 id="保留策略管理"><a class="header" href="#保留策略管理">保留策略管理</a></h3>
<h4 id="创建保留策略"><a class="header" href="#创建保留策略">创建保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">CREATE RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; [SHARD DURATION &lt;duration&gt;] [DEFAULT]
</code></pre>
<p><strong>描述</strong></p>
<p><code>DURATION</code>保留策略的总窗口时长。</p>
<p><code>REPLICATION</code>副本数量，默认为<code>1</code>并且只能为<code>1</code>。</p>
<p><code>SHARD DURATION</code>分片的窗口时长。</p>
<p><code>DEFAULT</code>可选项，指定其是否为默认保留策略</p>
<p><strong>示例</strong></p>
<p>创建保留策略</p>
<blockquote>
<p>该语句创建了一个名为<code>1d_events</code>的保留策略，并且副本数为1</p>
</blockquote>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 1d REPLICATION 1
&gt;
</code></pre>
<p>创建默认保留策略</p>
<pre><code class="language-sql">&gt; CREATE RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 23h60m REPLICATION 1 DEFAULT
&gt;
</code></pre>
<h4 id="显示保留策略"><a class="header" href="#显示保留策略">显示保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW RETENTION POLICIES [ON &lt;database_name&gt;]
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">&gt; SHOW RETENTION POLICIES ON &quot;cnos&quot;

name      duration   shardGroupDuration   replicaN   default
----      --------   ------------------   --------   -------
autogen   0s         168h0m0s             1          true
</code></pre>
<h4 id="修改保留策略"><a class="header" href="#修改保留策略">修改保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt; DURATION &lt;duration&gt; REPLICATION &lt;n&gt; SHARD DURATION &lt;duration&gt; DEFAULT
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">ALTER RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot; DURATION 7 SHARD DURATION 1d DEFAULT
</code></pre>
<h4 id="删除保留策略"><a class="header" href="#删除保留策略">删除保留策略</a></h4>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP RETENTION POLICY &lt;rp_name&gt; ON &lt;database_name&gt;
</code></pre>
<p><strong>示例</strong></p>
<pre><code class="language-sql">&gt; DROP RETENTION POLICY &quot;1d_events&quot; ON &quot;cnos&quot;
&gt;
</code></pre>
</li>
</ul>
<h2 id="schema查询"><a class="header" href="#schema查询">schema查询</a></h2>
<ul>
<li>
<h3 id="显示series"><a class="header" href="#显示series">显示<code>SERIES</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW SERIES [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; [ '&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW SERIES</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW SERIES ON &quot;oceanic_station&quot; WHERE time &gt; now() - 1m LIMIT 10
</code></pre>
</li>
<li>
<h3 id="使用drop删除series"><a class="header" href="#使用drop删除series">使用<code>DROP</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SERIES FROM &lt;measurement_name[,measurement_name]&gt; WHERE &lt;tag_key&gt;='&lt;tag_value&gt;'
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据以及数据所对应的索引</p>
<p><strong>示例</strong></p>
<p>从一个<code>measurement</code>中删除所有<code>series</code></p>
<pre><code class="language-sql">&gt; DROP SERIES FROM &quot;oceanic_station&quot;
</code></pre>
<p>从一个<code>measurement</code>中删除具有特定条件的<code>series</code></p>
<pre><code class="language-sql">DROP SERIES FROM &quot;oceanic_station&quot; WHERE &quot;station&quot; = 'XiaoMaiDao'
</code></pre>
</li>
<li>
<h3 id="使用delete删除series"><a class="header" href="#使用delete删除series">使用<code>DELETE</code>删除<code>series</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DELETE FROM &lt;measurement_name&gt; WHERE [&lt;tag_key&gt;='&lt;tag_value&gt;'] | [&lt;time interval&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SERIES</code>会删除数据库中符合条件的所有数据，但是不会删除索引，并且支持时间过滤</p>
<p><strong>示例</strong></p>
<blockquote>
<p>删除2020-01-01之前产生的的所有数据</p>
</blockquote>
<pre><code class="language-sql">&gt; DELETE WHERE time &lt; '2021-01-01'
</code></pre>
</li>
<li>
<h3 id="显示measurement"><a class="header" href="#显示measurement">显示<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW MEASUREMENTS [ON &lt;database_name&gt;] [WITH MEASUREMENT &lt;operator&gt; ['&lt;measurement_name&gt;' | &lt;regular_expression&gt;]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><code>SHOW MEASUREMENTS</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<blockquote>
<p>该查询返回数据库<code>oceanic_station</code>下<code>tag key</code>   oceanic_station下满足正则表达式air*的一个measurement</p>
</blockquote>
<pre><code class="language-sql">SHOW MEASUREMENTS ON &quot;oceanic_station&quot; WITH MEASUREMENT =~ /air*/
</code></pre>
</li>
<li>
<h3 id="删除measurement"><a class="header" href="#删除measurement">删除<code>measurement</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &lt;measurement_name&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP MEASUREMENT</code>会删除指定<code>measurement</code>下所有的数据</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">DROP MEASUREMENT &quot;air&quot;
</code></pre>
</li>
<li>
<h3 id="显示tag-key"><a class="header" href="#显示tag-key">显示<code>tag key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS [ON &lt;database_name&gt;] [FROM_clause] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>SHOW tag keys</code>后面都是可选项</p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON &quot;oceanic_station&quot; FROM &quot;air&quot; LIMIT 1 OFFSET 1
</code></pre>
</li>
<li>
<h3 id="显示tag-value"><a class="header" href="#显示tag-value">显示<code>tag value</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW TAG VALUES [ON &lt;database_name&gt;][FROM_clause] WITH KEY [ [&lt;operator&gt; &quot;&lt;tag_key&gt;&quot; | &lt;regular_expression&gt;] | [IN (&quot;&lt;tag_key1&gt;&quot;,&quot;&lt;tag_key2&quot;)]] [WHERE &lt;tag_key&gt; &lt;operator&gt; ['&lt;tag_value&gt;' | &lt;regular_expression&gt;]] [LIMIT_clause] [OFFSET_clause]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>[ON &lt;database_name&gt;]</code>指定数据库名称</p>
<p><code>FROM</code>子句指定<code>measurement</code></p>
<p><code>WHERE</code>子句支持比较<code>tag</code>，<code>field</code>比较是无效的</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG VALUES ON &quot;oceanic_station&quot; WITH KEY IN (&quot;station&quot;)
</code></pre>
</li>
<li>
<h3 id="显示field-key"><a class="header" href="#显示field-key">显示<code>field key</code></a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS [ON &lt;database_name&gt;] [FROM &lt;measurement_name&gt;]
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>FROM</code>子句为可选项</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW FIELD KEYS ON &quot;oceanic_station&quot; FROM &quot;air&quot;
</code></pre>
</li>
<li>
<h3 id="按时间过滤"><a class="header" href="#按时间过滤">按时间过滤</a></h3>
<p>可以在<code>SHOW TAG KEYS</code>、<code>SHOW TAG VALUES</code> <code>SHOW SERIES</code> <code>SHOW MEASUREMENTS</code> <code>SHOW FIELD KEYS</code>上使用</p>
<p><strong>示例</strong></p>
<pre><code class="language-sql">SHOW TAG KEYS ON &quot;oceanic_station&quot; where time &gt; now() -1h and time &lt; now()
</code></pre>
</li>
<li>
<h3 id="删除分片"><a class="header" href="#删除分片">删除分片</a></h3>
<p><strong>语法</strong></p>
<pre><code class="language-sql">DROP SHARD &lt;shard_id_number&gt;
</code></pre>
<p><strong>语法描述</strong></p>
<p><code>DROP SHARD</code>会在磁盘上删除有关分片的所有数据以及元数据</p>
<pre><code class="language-sql">&gt; DROP SHARD 1
&gt;
</code></pre>
</li>
</ul>
<h2 id="管理数据库"><a class="header" href="#管理数据库">管理数据库</a></h2>
<p><strong><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%A1%E7%90%86">数据库管理</a></strong></p>
<h2 id="连续查询"><a class="header" href="#连续查询">连续查询</a></h2>
<table><thead><tr><th><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95">基本语法</a></th><th><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95">高级语法</a></th><th><a href="#%E7%AE%A1%E7%90%86CQ">管理CQ</a></th></tr></thead><tbody>
<tr><td><a href="#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">基本语法示例</a></td><td><a href="#%E9%AB%98%E7%BA%A7%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B">高级语法示例</a></td><td></td></tr>
</tbody></table>
<ul>
<li>
<h3 id="语法"><a class="header" href="#语法">语法</a></h3>
<h4 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<p><strong>语法描述</strong></p>
<p>CQ查询必须包含一个函数，一个<code>INTO</code>子句和一个<code>GROUP BY time()</code>子句：</p>
<pre><code class="language-sql">SELECT &lt;function[s]&gt; INTO &lt;destination_measurement&gt; FROM &lt;measurement&gt; [WHERE &lt;stuff&gt;] GROUP BY time(&lt;interval&gt;)[,&lt;tag_key[s]&gt;]
</code></pre>
<blockquote>
<p>在<code>WHERE</code>子句中，不需要指定时间范围，CQ查询会为语句自动匹配时间范围</p>
</blockquote>
<h4 id="基本语法示例"><a class="header" href="#基本语法示例">基本语法示例</a></h4>
<p>以下示例使用数据库<code>transportation</code>中的示例数据，<code>bus_data</code>中存储的数据是公交车乘客数量和投诉数量的15分钟数：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers   complaints
2020-08-28T07:00:00Z   5            9
2020-08-28T07:15:00Z   8            9
2020-08-28T07:30:00Z   8            9
2020-08-28T07:45:00Z   7            9
2020-08-28T08:00:00Z   8            9
2020-08-28T08:15:00Z   15           7
2020-08-28T08:30:00Z   15           7
2020-08-28T08:45:00Z   17           7
2020-08-28T09:00:00Z   20           7
</code></pre>
<p><strong>自动采样数据</strong></p>
<p>使用CQ自动从单个字段下采样数据，并将结果写入到同一个数据库的另一个<code>measurement</code>中：</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>自动采样数据并将结果保存到另一个保留策略中</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_rp&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;transportation&quot;.&quot;three_weeks&quot;.&quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>使用通配符自动下采样数据</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_br&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(*) INTO &quot;downsampled_transportation&quot;.&quot;autogen&quot;.:MEASUREMENT FROM /.*/ GROUP BY time(30m),*
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;downsampled_transportation.&quot;autogen&quot;.&quot;bus_data&quot;
name: bus_data
--------------
time                   mean_complaints   mean_passengers
2020-08-28T07:00:00Z   9                 6.5
2020-08-28T07:30:00Z   9                 7.5
2020-08-28T08:00:00Z   8                 11.5
2020-08-28T08:30:00Z   7                 16
</code></pre>
<p><strong>自动采样数据并配置CQ的时间边界</strong></p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_basic_offset&quot; ON &quot;transportation&quot;
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h,15m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:15:00Z   7.75
2020-08-28T08:15:00Z   16.75
</code></pre>
<h4 id="高级语法"><a class="header" href="#高级语法">高级语法</a></h4>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
RESAMPLE EVERY &lt;interval&gt; FOR &lt;interval&gt;
BEGIN
  &lt;cq_query&gt;
END
</code></pre>
<h4 id="高级语法示例"><a class="header" href="#高级语法示例">高级语法示例</a></h4>
<p>示例数据如下：</p>
<pre><code class="language-sql">name: bus_data
--------------
time                   passengers
2020-08-28T06:30:00Z   2
2020-08-28T06:45:00Z   4
2020-08-28T07:00:00Z   5
2020-08-28T07:15:00Z   8
2020-08-28T07:30:00Z   8
2020-08-28T07:45:00Z   7
2020-08-28T08:00:00Z   8
2020-08-28T08:15:00Z   15
2020-08-28T08:30:00Z   15
2020-08-28T08:45:00Z   17
2020-08-28T09:00:00Z   20
</code></pre>
<p><strong>配置时间间隔</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>EVERY</code>来指明CQ的执行间隔</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 30m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
</code></pre>
<p><strong>配置CQ的重采样时间范围</strong></p>
<p>在<code>RESAMPLE</code>中使用<code>FOR</code>来指明CQ的时间间隔的长度</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for&quot; ON &quot;transportation&quot;
RESAMPLE FOR 1h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置执行间隔和CQ时间范围</strong></p>
<p>在<code>RESAMPLE</code>子句中使用<code>EVERY</code>和<code>FOR</code>来指定CQ的执行间隔和CQ的时间范围长度。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_every_for&quot; ON &quot;transportation&quot;
RESAMPLE EVERY 1h FOR 90m
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(30m)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T06:30:00Z   3
2020-08-28T07:00:00Z   6.5
2020-08-28T07:30:00Z   7.5
2020-08-28T08:00:00Z   11.5
2020-08-28T08:30:00Z   16
</code></pre>
<p><strong>配置CQ的时间范围并填充空值</strong></p>
<p>使用<code>FOR</code>间隔和<code>fill()</code>来更改不含数据的时间间隔值。请注意，至少有一个数据点必须在<code>fill()</code>运行的<code>FOR</code>间隔内。 如果没有数据落在<code>FOR</code>间隔内，则CQ不会将任何数据写入目标<code>measurement</code>。</p>
<pre><code class="language-sql">CREATE CONTINUOUS QUERY &quot;cq_advanced_for_fill&quot; ON &quot;transportation&quot;
RESAMPLE FOR 2h
BEGIN
  SELECT mean(&quot;passengers&quot;) INTO &quot;average_passengers&quot; FROM &quot;bus_data&quot; GROUP BY time(1h) fill(1000)
END
</code></pre>
<p>最终结果如下：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;average_passengers&quot;
name: average_passengers
------------------------
time                   mean
2020-08-28T05:00:00Z   1000
2020-08-28T06:00:00Z   3
2020-08-28T07:00:00Z   7
2020-08-28T08:00:00Z   13.75
2020-08-28T09:00:00Z   20
2020-08-28T10:00:00Z   1000
</code></pre>
</li>
<li>
<h3 id="管理cq"><a class="header" href="#管理cq">管理CQ</a></h3>
<blockquote>
<p>CQ不能<code>update</code>，只能<code>drop</code>和<code>create</code></p>
</blockquote>
<p><strong>列出所有CQ</strong></p>
<pre><code class="language-sql">SHOW CONTINUOUS QUERIES
</code></pre>
<p><strong>删除CQ</strong></p>
<pre><code class="language-sql">DROP CONTINUOUS QUERY &lt;cq_name&gt; ON &lt;database_name&gt;
</code></pre>
</li>
</ul>
<h2 id="cnosql函数"><a class="header" href="#cnosql函数">CnosQL函数</a></h2>
<ul>
<li>
<h3 id="目录"><a class="header" href="#目录">目录</a></h3>
<ul>
<li><a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a>
<ul>
<li><a href="#count">COUNT()</a></li>
<li><a href="#distinct">DISTINCT()</a></li>
<li><a href="#integral">INTEGRAL()</a></li>
<li><a href="#mean">MEAN()</a></li>
<li><a href="#median">MEDIAN()</a></li>
<li><a href="#mode">MODE()</a></li>
<li><a href="#spread">SPREAD()</a></li>
<li><a href="#stddev">STDDEV()</a></li>
<li><a href="#sum">SUM()</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0">选择函数</a>
<ul>
<li><a href="#bottom">BOTTOM()</a></li>
<li><a href="#first">FIRST()</a></li>
<li><a href="#last">LAST()</a></li>
<li><a href="#max">MAX()</a></li>
<li><a href="#min">MIN()</a></li>
<li><a href="#percentile">PERCENTILE()</a></li>
<li><a href="#sample">SAMPLE()</a></li>
<li><a href="#top">TOP()</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">转换函数</a>
<ul>
<li><a href="#abs">ABS()</a></li>
<li><a href="#acos">ACOS()</a></li>
<li><a href="#asin">ASIN()</a></li>
<li><a href="#atan">ATAN()</a></li>
<li><a href="#atan2">ATAN2()</a></li>
<li><a href="#ceil">CEIL()</a></li>
<li><a href="#cos">COS()</a></li>
<li><a href="#cumulative-sum">CUMULATIVE_SUM()</a></li>
<li><a href="#derivative">DERIVATIVE()</a></li>
<li><a href="#difference">DIFFERENCE()</a></li>
<li><a href="#elapsed">ELAPSED()</a></li>
<li><a href="#exp">EXP()</a></li>
<li><a href="#floor">FLOOR()</a></li>
<li><a href="#histogram">HISTOGRAM()</a></li>
<li><a href="#ln">LN()</a></li>
<li><a href="#log">LOG()</a></li>
<li><a href="#log2">LOG2()</a></li>
<li><a href="#log10">LOG10()</a></li>
<li><a href="#moving-average">MOVING_AVERAGE()</a></li>
<li><a href="#non-negative-derivative">NON_NEGATIVE_DERIVATIVE()</a></li>
<li><a href="#non-negative-difference">NON_NEGATIVE_DIFFERENCE()</a></li>
<li><a href="#pow">POW()</a></li>
<li><a href="#round">ROUND()</a></li>
<li><a href="#sin">SIN()</a></li>
<li><a href="#sqrt">SQRT()</a></li>
<li><a href="#tan">TAN()</a></li>
</ul>
</li>
<li><a href="#%E9%A2%84%E6%B5%8B%E5%87%BD%E6%95%B0">预测函数</a>
<ul>
<li><a href="#holt_winters">HOLT_WINTERS()</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0">分析函数</a>
<ul>
<li><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></li>
<li><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></li>
<li><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></li>
<li><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></li>
<li><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></li>
</ul>
</li>
<li><a href="#other">其他</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE">示例数据</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95">函数的通用语法</a>
<ul>
<li><a href="#%E5%9C%A8SELECT%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">在<code>SELECT</code>中指定多个函数</a></li>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%AD%97%E6%AE%B5">重命名查询结果字段</a></li>
<li><a href="#%E6%94%B9%E5%8F%98%E4%B8%8D%E5%90%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">改变不含数据的时间间隔的返回值</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">函数常见问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h3>
<ul>
<li>
<h3 id="count"><a class="header" href="#count">COUNT()</a></h3>
<p>返回非空值 field values数量</p>
<h4 id="语法-1"><a class="header" href="#语法-1">语法</a></h4>
<pre><code class="language-sql">SELECT COUNT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法"><a class="header" href="#嵌套语法">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<p><code>COUNT(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT()</code>支持所有数据类型的<code>field value</code>。cnosQL支持将<a href="#distinct"><code>DISTINCT()</code></a>函数嵌套在<code>COUNT()</code>函数里。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key的field-value的数目"><a class="header" href="#计算指定field-key的field-value的数目">计算指定field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回<code>measurement``air</code>中的<code>temperature</code>的非空field value的数量。</p>
<ul>
<li>
<h4 id="计数measurement中每个field-key关联的field-value的数量"><a class="header" href="#计数measurement中每个field-key关联的field-value的数量">计数measurement中每个field key关联的field value的数量</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(*) FROM &quot;air&quot;
name: air
time                 count_pressure count_temperature count_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 3334           3334              3334
</code></pre>
<p>该查询返回与measurement<code>air</code>相关联的每个field key的非空field value的数量。<code>air</code>有3个field keys：<code>count_pressure</code> <code>count_temperature</code> <code>count_visibility</code></p>
<ul>
<li>
<h4 id="计算匹配一个正则表达式的每个field-key关联的field-value的数目"><a class="header" href="#计算匹配一个正则表达式的每个field-key关联的field-value的数目">计算匹配一个正则表达式的每个field key关联的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(/.*pre.*/) FROM &quot;air&quot;
name: air
time                 count_pressure
----                 --------------
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回measurement<code>air</code>中包含<code>pre</code>的每个field key的非空字段值的数量。</p>
<ul>
<li>
<h4 id="计数包括多个子句的field-key的field-value的数目"><a class="header" href="#计数包括多个子句的field-key的field-value的数目">计数包括多个子句的field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;  SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1ms),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                     count
----                     -----
2022-04-11T08:03:37.071Z 108
2022-04-11T08:03:37.072Z 193
2022-04-11T08:03:37.073Z 207
2022-04-11T08:03:37.074Z 209
2022-04-11T08:03:37.075Z 209
2022-04-11T08:03:37.076Z 218
2022-04-11T08:03:37.077Z 216
</code></pre>
<p>该查询返回<code>pressure</code>field key中的非空field value的数量。它涵盖<code>now()</code>之间的<code>时间段</code>，并将结果分组为1ms的时间间隔和每个tag(表示为以上代码中的<code>*</code>)。并用<code>-1</code>填充空的时间间隔，并返回7个<code>point</code>，表格返回1。</p>
</li>
<li>
<h4 id="计算一个field-key的distinct的field-value的数量"><a class="header" href="#计算一个field-key的distinct的field-value的数量">计算一个field key的distinct的field value的数量</a></h4>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
</li>
</ul>
<p>查询返回measurement为<code>air</code>field<code>为</code>pressure 的唯一field value的数量。</p>
<h4 id="count的常见问题"><a class="header" href="#count的常见问题"><code>COUNT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="count和fill"><a class="header" href="#count和fill"><code>COUNT()</code>和<code>fill()</code></a></h4>
</li>
</ul>
<p>大多数cnosQL函数对于没有数据的时间间隔返回<code>null</code>值，<code>fill(&lt;fill_option&gt;)</code>将该<code>null</code>值替换为<code>fill_option</code>。 <code>COUNT()</code>针对没有数据的时间间隔返回<code>0</code>，<code>fill(&lt;fill_option&gt;)</code>用<code>fill_option</code>替换0值。</p>
<p><em>示例</em></p>
<p>下面的代码块中的第一个查询不包括<code>fill()</code>。最后一个时间间隔没有数据，因此该时间间隔的值返回为零。第二个查询包括<code>fill(-1)</code>; 它将最后一个间隔中的零替换为<code>-1</code>。</p>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),*  LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z 0
2022-04-11T08:03:39Z 0
2022-04-11T08:03:40Z 0
2022-04-11T08:03:41Z 0
2022-04-11T08:03:42Z 0
2022-04-11T08:03:43Z 0

&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z -1
2022-04-11T08:03:39Z -1
2022-04-11T08:03:40Z -1
2022-04-11T08:03:41Z -1
2022-04-11T08:03:42Z -1
2022-04-11T08:03:43Z -1
</code></pre>
<ul>
<li>
<h3 id="distinct"><a class="header" href="#distinct"><code>DISTINCT()</code></a></h3>
<p>返回<code>field value</code>的不重复值列表。</p>
<h4 id="语法-2"><a class="header" href="#语法-2">语法</a></h4>
<pre><code class="language-sql">SELECT DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法-1"><a class="header" href="#嵌套语法-1">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<h4 id="语法描述"><a class="header" href="#语法描述">语法描述</a></h4>
<p><code>DISTINCT(field_key)</code> 返回<code>field key</code>对应的不同<code>field values</code>。</p>
<p><code>DISTINCT()</code> 支持所有数据类型的<code>field value</code>，cnosQL支持<a href="#count"><code>COUNT()</code></a>嵌套<code>DISTINCT()</code>。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<ul>
<li>
<h4 id="列出一个field-key的不同的field-value"><a class="header" href="#列出一个field-key的不同的field-value">列出一个<code>field key</code>的不同的<code>field value</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 57
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 60
</code></pre>
<p>该查询返回<code>air</code> measurement中<code>temperature</code>field 关键字中唯一<code>field values</code>的列表</p>
</li>
</ul>
<ul>
<li>
<h4 id="列出包含多个子句的field-key关联的不同值的列表"><a class="header" href="#列出包含多个子句的field-key关联的不同值的列表">列出包含多个子句的field key关联的不同值的列表</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE  time &lt;now() GROUP BY time(12m),* SLIMIT 1
name: air
tags: station=LianYunGang
time                 distinct
----                 --------
2022-04-11T08:00:00Z 58
2022-04-11T08:00:00Z 56
2022-04-11T08:00:00Z 59
2022-04-11T08:00:00Z 57
2022-04-11T08:00:00Z 62
2022-04-11T08:00:00Z 60
2022-04-11T08:00:00Z 61
</code></pre>
<p>该查询返回<code>pressure</code>field key中不同field value的列表。它涵盖now()之前的时间段，并将结果按12分钟的时间间隔和每个tag分组。查询限制（SLIMIT）返回一个series。</p>
<ul>
<li>
<h4 id="对一个字段的不同值进行计算"><a class="header" href="#对一个字段的不同值进行计算">对一个字段的不同值进行计算</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
<p>查询返回<code>air</code>这个measurement中字段<code>pressure</code>的不同值的数目。</p>
<h4 id="distinct的常见问题"><a class="header" href="#distinct的常见问题"><code>DISTINCT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="distinct-和-into-子句"><a class="header" href="#distinct-和-into-子句"><code>DISTINCT()</code> 和 <code>INTO</code> 子句</a></h4>
</li>
</ul>
<p>在<code>INTO</code>子句中使用<code>DISTINCT()</code>可能会导致CnosDB覆盖目标measurement中的<code>points</code>。<code>DISTINCT()</code>通常返回多个具有相同时间戳的结果；CnosDB假设在相同series中并具有相同时间戳的<code>point</code>是重复<code>point</code>，并简单地用目标measurement中最新的<code>point</code>覆盖重复<code>point</code>。</p>
<p>####示例</p>
<p>下面代码块中的第一个查询使用了<code>DISTINCT()</code>，并返回7个结果。请注意，每个结果都有相同的时间戳。第二个查询将<code>INTO</code>子句添加到查询中，并将查询结果写入measurement <code>distincts</code>。最后一个查询选择measurement <code>distincts</code>中所有数据。
因为原来的四个结果是重复的(它们在相同的series，有相同的时间戳)，所以最后一个查询只返回一个<code>point</code>。当系统遇到重复数据<code>point</code>，它会用最近的<code>point</code>覆盖之前的<code>point</code>。</p>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 60
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 57

&gt; SELECT DISTINCT(&quot;pressure&quot;) INTO &quot;distincts&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 7 

&gt; SELECT * FROM &quot;distincts&quot;
name: distincts
time                 distinct
----                 --------
1970-01-01T00:00:00Z 57
</code></pre>
<ul>
<li>
<h3 id="integral"><a class="header" href="#integral"><code>INTEGRAL()</code></a></h3>
<p>返回<code>field value</code>曲线下的面积，即关于<code>field value</code>的积分。</p>
<h4 id="语法-3"><a class="header" href="#语法-3">语法</a></h4>
<pre><code>SELECT INTEGRAL( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ]  ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-1"><a class="header" href="#语法描述-1">语法描述</a></h4>
<p>CnosDB计算field value曲线下的面积，并将这些结果转换为每个<code>unit</code>的总面积。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>INTEGRAL(field_key)</code>返回field key关联的值之下的面积。</p>
<p><code>INTEGRAL(/regular_expression/)</code>返回满足正则表达式的每个field key关联的值之下的面积。</p>
<p><code>INTEGRAL(*)</code>返回<code>measurement</code>中每个<code>field key</code>关联的值之下的面积。</p>
<p><code>INTEGRAL()</code>不支持<code>fill()</code>，<code>INTEGRAL()</code>支持int64和float64两个数据类型。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<p>下面的五个例子，使用数据库<a href="oceanic_station.txt"><code>oceanic_station</code>中的数据</a>：</p>
<pre><code class="language-sql">&gt;  SELECT  temperature  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                        temperature
----                        -----------
2022-04-11T08:03:37.07132Z  58
2022-04-11T08:03:37.071378Z 62
2022-04-11T08:03:37.071385Z 58
2022-04-11T08:03:37.071391Z 56
2022-04-11T08:03:37.071394Z 56
2022-04-11T08:03:37.071401Z 59
2022-04-11T08:03:37.071403Z 57
2022-04-11T08:03:37.071406Z 62
2022-04-11T08:03:37.071409Z 59
2022-04-11T08:03:37.071411Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定的field-key的值得积分"><a class="header" href="#计算指定的field-key的值得积分">计算指定的field key的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;SELECT  INTEGRAL(temperature)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10 
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 0.4677579999999999
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以秒为单位）。</p>
<ul>
<li>
<h4 id="计算指定的field-key和时间单位的值的积分"><a class="header" href="#计算指定的field-key和时间单位的值的积分">计算指定的field key和时间单位的值的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以1ms为单位）。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中每个field-key在指定时间单位的值得积分">计算measurement中每个field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(*,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_pressure  integral_temperature integral_visibility
----                 -----------------  -------------------- -------------------
1970-01-01T00:00:00Z 467.22900000000413 467.7580000000045    491.2000000000007
</code></pre>
<p>查询返回measurement<code>air</code>中存储的每个数值字段相关的字段值的曲线下面积（以1ms为单位）</p>
<ul>
<li>
<h4 id="计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分">计算measurement中匹配正则表达式的field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(/temp/,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_temperature
----                 --------------------
1970-01-01T00:00:00Z 467.7580000000045

</code></pre>
<p>查询返回field key包括单词<code>water</code>的每个数值类型的字段相关联的字段值的曲线下的区域（以分钟为单位）。</p>
<ul>
<li>
<h4 id="在含有多个子句中计算指定字段的积分"><a class="header" href="#在含有多个子句中计算指定字段的积分">在含有多个子句中计算指定字段的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now() GROUP BY time(12m) LIMIT 1
name: air
time                 integral_temperature
----                 --------------------
2022-04-11T08:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的field value曲线下的面积(以分钟为单位)，它涵盖的时间范围在now()之前，并将查询结果按12分钟的时间间隔进行分组，同时，该查询将返回的<code>point</code>个数限制为1。</p>
</li>
<li>
<h3 id="mean"><a class="header" href="#mean"><code>MEAN()</code></a></h3>
<p>返回field value的平均值。</p>
<h4 id="语法-4"><a class="header" href="#语法-4">语法</a></h4>
<pre><code>SELECT MEAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MEAN(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的field value的平均值。</p>
<p><code>MEAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值"><a class="header" href="#计算指定field-key对应的field-value的平均值">计算指定field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                   mean
----                   ----
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均值">计算measurement中每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(*) FROM &quot;air&quot; 
name: air
time                 mean_pressure     mean_temperature  mean_visibility
----                 -------------     ----------------  ---------------
1970-01-01T00:00:00Z 59.00689862027595 59.04949010197961 62.01889622075585
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均值">计算与正则表达式匹配的每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(/temp/) FROM &quot;air&quot; 
name: air
time                   mean_temperature
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822523
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均值并包含多个子句">计算指定field key对应的field value的平均值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(9.01) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 mean
----                 ----
2022-04-11T08:00:00Z 59.06864564007421
2022-04-11T08:12:00Z 9.01
2022-04-11T08:24:00Z 9.01
2022-04-11T08:36:00Z 9.01
2022-04-11T08:48:00Z 9.01
2022-04-11T09:00:00Z 9.01
2022-04-11T09:12:00Z 9.01 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value的平均值，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为7和1。</p>
</li>
<li>
<h3 id="median"><a class="header" href="#median">MEDIAN()</a></h3>
<p>返回<code>field value</code>的计算中值。</p>
<h4 id="语法-5"><a class="header" href="#语法-5">语法</a></h4>
<pre><code>SELECT MEDIAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-2"><a class="header" href="#语法描述-2">语法描述</a></h4>
<p><code>MEDIAN(field_key)</code>返回与<code>field key</code>对应的field value的中值。</p>
<p><code>MEDIAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN()</code> 支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong><code>MEDIAN()</code>近似于<code>PERCENTILE(field_key, 50)</code>，除非<code>field key</code>包含的<code>field value</code>有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</p>
</blockquote>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值"><a class="header" href="#计算指定field-key对应的field-value的中值">计算指定field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 median
----                 ------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>pressure</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的中值"><a class="header" href="#计算measurement中每个field-key对应的field-value的中值">计算measurement中每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(*) FROM &quot;air&quot;
name: air
time                 median_pressure median_temperature median_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 59              59                 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的中值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的中值">计算与正则表达式匹配的每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(/temp/) FROM &quot;air&quot;
name: air
time                 median_temperature
----                 ------------------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的中值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的中值并包含多个子句">计算指定field key对应的field value的中值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE  time&lt;now()  GROUP BY time(1m),* fill(-1) LIMIT 7 SLIMIT 3 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 median
----                 ------
2022-04-11T08:03:00Z 59
2022-04-11T08:04:00Z -1
2022-04-11T08:05:00Z -1
2022-04-11T08:06:00Z -1
2022-04-11T08:07:00Z -1
2022-04-11T08:08:00Z -1
2022-04-11T08:09:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均数，它涵盖的时间范围在now()之前，并将查询结果按1分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="mode"><a class="header" href="#mode">MODE()</a></h3>
<p>返回<code>field value</code>中出现频率最高的值。</p>
<h4 id="语法-6"><a class="header" href="#语法-6">语法</a></h4>
<pre><code>SELECT MODE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MODE(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE()</code> 支持所有数据类型的<code>field value</code>。</p>
<blockquote>
<p>**注意：**如果出现频率最高的值有两个或多个并且它们之间有关联，那么<code>MODE()</code>返回具有最早时间戳的<code>field value</code>。</p>
</blockquote>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值">计算指定field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mode
----                 ----
1970-01-01T00:00:00Z 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中某个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算measurement中每个field-key对应的field-value中出现频率最高的值">计算measurement中每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(*) FROM &quot;air&quot;
name: air
time                 mode_pressure mode_temperature mode_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 57            62               61
</code></pre>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值">计算与正则表达式匹配的每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT MODE(/temp/) FROM &quot;air&quot;
name: air
time                 mode_temperature
----                 ----------------
1970-01-01T00:00:00Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值并包含多个子句">计算指定field key对应的field value中出现频率最高的值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 mode
----                 ----
2022-04-11T08:00:00Z 59
2022-04-11T08:12:00Z 
2022-04-11T08:24:00Z 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>temperature</code>中出现频率最高的值，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="spread"><a class="header" href="#spread">SPREAD()</a></h3>
<p>返回<code>field value</code>中最大值和最小值之差。</p>
<h4 id="语法-7"><a class="header" href="#语法-7">语法</a></h4>
<pre><code class="language-sql">SELECT SPREAD( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-3"><a class="header" href="#语法描述-3">语法描述</a></h4>
<p><code>SPREAD(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD()</code>支持数据类型为int64和float64的<code>field value</code>。</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差">计算指定field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 spread
----                 ------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算measurement中每个field-key对应的field-value中最大值和最小值之差">计算measurement中每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(*) FROM &quot;air&quot;
name: air
time                 spread_pressure spread_temperature spread_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 6               6                  6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差">计算与正则表达式匹配的每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(/tem/) FROM &quot;air&quot;
name: air
time                 spread_temperature
----                 ------------------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句">计算指定field key对应的field value中最大值和最小值之差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(-1) LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 spread
----                 ------
2022-04-11T08:00:00Z 6
2022-04-11T08:12:00Z -1
2022-04-11T08:24:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value中最大值和最小值之差，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）</p>
</li>
<li>
<h3 id="stddev"><a class="header" href="#stddev">STDDEV()</a></h3>
<p>返回<code>field value</code>的标准差。</p>
<h4 id="语法-8"><a class="header" href="#语法-8">语法</a></h4>
<pre><code class="language-sql">SELECT STDDEV( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>STDDEV(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(*)</code>返回在measurement中每个field key对应的field value的标准差。</p>
<p><code>STDDEV()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差"><a class="header" href="#计算指定field-key对应的field-value的标准差">计算指定field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 stddev
----                 ------
1970-01-01T00:00:00Z 1.9933006709246002
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的标准差"><a class="header" href="#计算measurement中每个field-key对应的field-value的标准差">计算measurement中每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(*) FROM &quot;air&quot;
name: air
time                 stddev_pressure    stddev_temperature stddev_visibility
----                 ---------------    ------------------ -----------------
1970-01-01T00:00:00Z 2.0234776612813525 1.9933006709246002 1.9942769555619093
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的标准差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的标准差">计算与正则表达式匹配的每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(/temp/) FROM &quot;air&quot;
name: air
time                   stddev_temperature
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的标准差并包含多个子句">计算指定field key对应的field value的标准差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 2 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 stddev
----                 ------
2022-04-11T08:00:00Z 1.9988781365491315
2022-04-11T08:12:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为2和1，并将返回的series偏移一个（即第一个series的数据不返回）。</p>
</li>
<li>
<h3 id="sum"><a class="header" href="#sum">SUM()</a></h3>
<p>返回field value的总和。</p>
<h4 id="语法-9"><a class="header" href="#语法-9">语法</a></h4>
<pre><code>SELECT SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-4"><a class="header" href="#语法描述-4">语法描述</a></h4>
<p><code>SUM(field_key)</code>返回field key对应的field value的总和。</p>
<p><code>SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的总和。</p>
<p><code>SUM(*)</code>返回在measurement中每个field key对应的field value的总和。</p>
<p><code>SUM()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和"><a class="header" href="#计算指定field-key对应的field-value的总和">计算指定field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的总和">计算measurement中每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(*) FROM &quot;air&quot;
name: air
time                 sum_pressure sum_temperature sum_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 196729       196871          206771
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的总和">计算与正则表达式匹配的每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(/temp/) FROM &quot;air&quot;
name: air
time                 sum_temperature
----                 ---------------
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的总和并包含多个子句">计算指定field key对应的field value的总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 sum
----                 ---
2022-04-11T08:00:00Z 95514
2022-04-11T08:12:00Z 18000
2022-04-11T08:24:00Z 18000
2022-04-11T08:36:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
</li>
</ul>
<h2 id="选择函数"><a class="header" href="#选择函数">选择函数</a></h2>
<ul>
<li>
<h3 id="bottom"><a class="header" href="#bottom">BOTTOM()</a></h3>
<p>返回最小的N个field value。</p>
<h4 id="语法-10"><a class="header" href="#语法-10">语法</a></h4>
<pre><code>SELECT BOTTOM(&lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-5"><a class="header" href="#语法描述-5">语法描述</a></h4>
<p><code>BOTTOM(field_key,N)</code>返回field key对应的最小的N个值。</p>
<p><code>BOTTOM(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最小值。</p>
<p><code>BOTTOM(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最小的N个值，以及相关的tag和/或field。</p>
<p><code>BOTTOM()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最小值有两个或多个相等的值，<code>BOTTOM()</code>返回具有最早时间戳的field value。</li>
<li>当<code>BOTTOM()</code>函数与<code>INTO</code>子句一起使用时，<code>BOTTOM()</code>与其它cnosQL函数不同。请查看<code>BOTTOM()</code>的常见问题章节获得更多信息。</li>
</ul>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值"><a class="header" href="#选择指定field-key对应的最小的三个值">选择指定field key对应的最小的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom
----                 ------
2021-08-31T16:18:00Z 50
2021-08-31T17:09:00Z 50
2021-08-31T18:39:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最小的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最小值"><a class="header" href="#选择两个tag对应的field-key的最小值">选择两个tag对应的field key的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最小的四个值以及相关的tag和field">选择指定field key对应的最小的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 bottom station     pressure
----                 ------ -------     --------
2021-08-31T16:18:00Z 50     XiaoMaiDao  55
2021-08-31T17:09:00Z 50     XiaoMaiDao  63
2021-08-31T18:39:00Z 50     LianYunGang 64
2021-08-31T19:51:00Z 50     LianYunGang 62
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最小的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最小的三个值并包含多个子句">选择指定field key对应的最小的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 bottom station
----                 ------ -------
2021-09-18T00:54:00Z 69     LianYunGang
2021-09-18T00:51:00Z 65     LianYunGang
2021-09-18T00:48:00Z 68     XiaoMaiDao
2021-09-18T00:39:00Z 53     XiaoMaiDao
2021-09-18T00:36:00Z 52     LianYunGang
2021-09-18T00:33:00Z 50     LianYunGang
2021-09-18T00:06:00Z 55     LianYunGang
2021-09-18T00:03:00Z 53     XiaoMaiDao
2021-09-18T00:00:00Z 51     LianYunGang
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最小的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="bottom的常见问题"><a class="header" href="#bottom的常见问题"><code>BOTTOM()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="bottom和group-by-time子句同时使用"><a class="header" href="#bottom和group-by-time子句同时使用"><code>BOTTOM()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>BOTTOM()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>BOTTOM()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   bottom
----                   ------
                           __
2021-09-28T00:00:00Z  2.064 |
2021-09-18T00:12:00Z  2.028 | &lt;------- Smallest points for the first time interval
                           --
                           __
2021-09-18T00:24:00Z  2.041 |
2021-09-18T00:30:00Z  2.051 | &lt;------- Smallest points for the second time interval                      --
</code></pre>
<ul>
<li>
<h4 id="bottom和具有少于n个tag-value的tag-key"><a class="header" href="#bottom和具有少于n个tag-value的tag-key"><code>BOTTOM()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT BOTTOM(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最小值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<ul>
<li>
<h4 id="bottomtag和into子句"><a class="header" href="#bottomtag和into子句"><code>BOTTOM()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>BOTTOM()</code>函数除非<code>BOTTOM()</code>中包含tag key作为参数：<code>BOTTOM(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值，并且，它这些结果写入measurement <code>bottom_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>bottom_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;bottom_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;air&quot;
name: air
tagKey
------
station
</code></pre>
</li>
<li>
<h3 id="first"><a class="header" href="#first">FIRST()</a></h3>
<p>返回具有最早时间戳的field value。</p>
<h4 id="语法-11"><a class="header" href="#语法-11">语法</a></h4>
<pre><code>SELECT FIRST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-6"><a class="header" href="#语法描述-6">语法描述</a></h4>
<p><code>FIRST(field_key)</code>返回field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(*)</code>返回在measurement中每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最早时间戳的field value，以及相关的tag或field。</p>
<p><code>FIRST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value">选择指定field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 first
----                 -----
2021-08-31T16:00:00Z 78
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最早时间戳的field-value">选择measurement中每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;

name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最早时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(/temp/) FROM &quot;air&quot;

name: air
time                 first_temperature
----                 -----------------
2021-08-31T16:00:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最早时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 first station     temperature
----                 ----- -------     -----------
2021-08-31T16:00:00Z 78    LianYunGang 63
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value并包含多个子句">选择指定field key对应的具有最早时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 first
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 70
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最早时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="last"><a class="header" href="#last">LAST()</a></h3>
<p>返回具有最新时间戳的field value。</p>
<h4 id="语法-12"><a class="header" href="#语法-12">语法</a></h4>
<pre><code class="language-sql">SELECT LAST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_keys(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LAST(field_key)</code>返回field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(*)</code>返回在measurement中每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最新时间戳的field value，以及相关的tag或field。</p>
<p><code>LAST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value">选择指定field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 last
----                 ----
2021-09-30T04:00:00Z 65
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最新时间戳的field-value">选择measurement中每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(*) FROM &quot;air&quot;
name: air
time                 last_pressure last_temperature last_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 65            59               78
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最新时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(/temp/) FROM &quot;air&quot;
name: air
time                 last_temperature
----                 ----------------
2021-09-30T04:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最新时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 last station     temperature
----                 ---- -------     -----------
2021-09-30T04:00:00Z 65   LianYunGang 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value并包含多个子句">选择指定field key对应的具有最新时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 last
----                 ----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 68
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 58
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最新时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="max"><a class="header" href="#max">MAX()</a></h3>
<p>返回field value的最大值。</p>
<h4 id="语法-13"><a class="header" href="#语法-13">语法</a></h4>
<pre><code>SELECT MAX(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field__key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MAX(field_key)</code>返回field key对应的field value的最大值。</p>
<p><code>MAX(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最大值。</p>
<p><code>MAX(*)</code>返回在measurement中每个field key对应的field value的最大值。</p>
<p><code>MAX(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最大值，以及相关的tag或field。</p>
<p><code>MAX()</code> 支持数据类型为int64和float64的field value。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值"><a class="header" href="#选择指定field-key对应的field-value的最大值">选择指定field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max
----                 ---
2021-08-31T18:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最大值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最大值">选择measurement中每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最大值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最大值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最大值">选择与正则表达式匹配的每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(/pres/) FROM &quot;air&quot;
name: air
time                 max_pressure
----                 ------------
2021-08-31T17:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最大值以及相关的tag和field">选择指定field key对应的field value的最大值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 max station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最大值并包含多个子句">选择指定field key对应的field value的最大值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
2021-09-18T00:36:00Z 70
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="min"><a class="header" href="#min">MIN()</a></h3>
<p>返回field value的最小值。</p>
<h4 id="语法-14"><a class="header" href="#语法-14">语法</a></h4>
<pre><code>SELECT MIN(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MIN(field_key)</code>返回field key对应的field value的最小值。</p>
<p><code>MIN(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最小值。</p>
<p><code>MIN(*)</code>返回在measurement中每个field key对应的field value的最小值。</p>
<p><code>MIN(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最小值，以及相关的tag和/或field。</p>
<p><code>MIN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-13"><a class="header" href="#示例-13">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值"><a class="header" href="#选择指定field-key对应的field-value的最小值">选择指定field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min
----                 ---
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最小值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最小值">选择measurement中每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(*) FROM &quot;air&quot;

name: air
time                 min_pressure min_temperature min_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 50           50              50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最小值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最小值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最小值">选择与正则表达式匹配的每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(/temp/) FROM &quot;air&quot;

name: air
time                 min_temperature
----                 ---------------
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最小值以及相关的tag和field">选择指定field key对应的field value的最小值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 min station    pressure
----                 --- -------    --------
2021-08-31T16:18:00Z 50  XiaoMaiDao 55
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最小值并包含多个子句">选择指定field key对应的field value的最小值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 min
----                 ---
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="percentile"><a class="header" href="#percentile">PERCENTILE()</a></h3>
<p>返回第N个百分位数的<code>field value</code></p>
<h4 id="语法-15"><a class="header" href="#语法-15">语法</a></h4>
<pre><code>SELECT PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>PERCENTILE(field_key,N)</code>返回指定field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(*,N)</code>返回在measurement中每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的第N个百分位数的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是0到100之间的整数或浮点数。</p>
<p><code>PERCENTILE()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value">选择指定field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5) FROM &quot;air&quot;

name: air
time                 percentile
----                 ----------
2021-09-03T23:51:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择measurement中每个field-key对应的第五个百分位数的field-value">选择measurement中每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(*,5) FROM &quot;air&quot;

name: air
time                 percentile_pressure percentile_temperature percentile_visibility
----                 ------------------- ---------------------- ---------------------
1970-01-01T00:00:00Z 51                  51                     51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值的field key对应的所有field value中的百分之五。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value">选择与正则表达式匹配的每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(/visi/,5) FROM &quot;air&quot;
name: air
time                 percentile_visibility
----                 ---------------------
2021-09-29T09:54:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field">选择指定field key对应的第五个百分位数的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 percentile station    pressure
----                 ---------- -------    --------
2021-09-03T23:51:00Z 51         XiaoMaiDao 65
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第20个百分位数的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的第20个百分位数的field-value并包含多个子句">选择指定field key对应的第20个百分位数的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,20) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(24m) fill(15) LIMIT 2
name: air
time                 percentile
----                 ----------
2020-08-17T23:36:00Z 15
2020-08-18T00:00:00Z 15
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之二十，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按24分钟的时间间隔进行分组，同时，该查询用<code>15</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数限制为2。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每24分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:36:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:24:00Z</code>之间。</p>
<h4 id="percentile的常见问题"><a class="header" href="#percentile的常见问题"><code>PERCENTILE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="percentile-vs-其它cnosql函数"><a class="header" href="#percentile-vs-其它cnosql函数"><code>PERCENTILE()</code> vs 其它cnosQL函数</a></h4>
</li>
</ul>
<ul>
<li><code>PERCENTILE(&lt;field_key&gt;,100)</code>相当于<code>MAX(&lt;field_key&gt;)</code>。</li>
<li><code>PERCENTILE(&lt;field_key&gt;, 50)</code>近似于<code>MEDIAN(&lt;field_key&gt;)</code>，除非field key包含的field value有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</li>
<li><code>PERCENTILE(&lt;field_key&gt;,0)</code>不等于<code>MIN(&lt;field_key&gt;)</code>，<code>PERCENTILE(&lt;field_key&gt;,0)</code>会返回<code>null</code>。</li>
</ul>
</li>
<li>
<h3 id="sample"><a class="header" href="#sample">SAMPLE()</a></h3>
<p>返回包含N个field value的随机样本。<code>SAMPLE()</code>使用<a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a>来生成随机<code>point</code>。</p>
<h4 id="语法-16"><a class="header" href="#语法-16">语法</a></h4>
<pre><code>SELECT SAMPLE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SAMPLE(field_key,N)</code>返回指定field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(*,N)</code>返回在measurement中每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的N个随机选择的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是整数。</p>
<p><code>SAMPLE()</code>支持所有数据类型的field value。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本"><a class="header" href="#选择指定field-key对应的field-value的随机样本">选择指定field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot;
name: air
time                 sample
----                 ------
2021-09-07T02:18:00Z 77
2021-09-13T12:00:00Z 62
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的随机样本"><a class="header" href="#选择measurement中每个field-key对应的field-value的随机样本">选择measurement中每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(*,2) FROM &quot;air&quot;
name: air
time                 sample_pressure sample_temperature sample_visibility
----                 --------------- ------------------ -----------------
2021-08-31T16:18:00Z                 52                 
2021-09-03T14:33:00Z 74                                 
2021-09-12T19:39:00Z 59                                 
2021-09-17T11:33:00Z                 51                 
2021-09-20T04:09:00Z                                    50
2021-09-22T19:15:00Z                                    80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的两个随机选择的<code>point</code>。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的随机样本"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的随机样本">选择与正则表达式匹配的每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(/pres/,2) FROM &quot;air&quot;
name: air
time                 sample_pressure
----                 ---------------
2021-09-25T20:27:00Z 77
2021-09-26T20:33:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的随机样本以及相关的tag和field">选择指定field key对应的field value的随机样本以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 sample station     pressure
----                 ------ -------     --------
2021-09-09T00:03:00Z 71     LianYunGang 61
2021-09-11T01:39:00Z 53     LianYunGang 51
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应field-value的随机样本并包含多个子句"><a class="header" href="#选择指定field-key对应field-value的随机样本并包含多个子句">选择指定field key对应field value的随机样本并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,1) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                 sample
----                 ------
2021-09-18T00:09:00Z 55
2021-09-18T00:27:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的一个随机选择的<code>point</code>，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并将查询结果按18分钟的时间间隔进行分组。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="sample的常见问题"><a class="header" href="#sample的常见问题"><code>SAMPLE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="sample和group-by-time子句同时使用"><a class="header" href="#sample和group-by-time子句同时使用"><code>SAMPLE()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>SAMPLE()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数(<code>N</code>)的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>SAMPLE()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个随机选择的<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   sample
----                   ------
                           __
2021-09-18T00:09:00Z      55   |
2021-09-18T00:12:00Z      63   | &lt;------- Randomly-selected points for the first time interval
                           --
                           __
2021-09-18T00:18:00Z      79  |
2021-09-18T00:21:00Z      68  | &lt;------- Randomly-selected points for the second time interval
                           --
</code></pre>
</li>
<li>
<h3 id="top"><a class="header" href="#top">TOP()</a></h3>
<p>返回最大的N个field value</p>
<h4 id="语法-17"><a class="header" href="#语法-17">语法</a></h4>
<pre><code>SELECT TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TOP(field_key,N)</code>返回field key对应的最大的N个值。</p>
<p><code>TOP(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最大值。</p>
<p><code>TOP(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最大的N个值，以及相关的tag和/或field。</p>
<p><code>TOP()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最大值有两个或多个并且它们之间有关联，<code>TOP()</code>返回具有最早时间戳的field value。</li>
</ul>
<h4 id="示例-16"><a class="header" href="#示例-16">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值"><a class="header" href="#选择指定field-key对应的最大的三个值">选择指定field key对应的最大的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 top
----                 ---
2021-08-31T18:03:00Z 80
2021-08-31T18:18:00Z 80
2021-08-31T18:57:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最大的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最大值"><a class="header" href="#选择两个tag对应的field-key的最大值">选择两个tag对应的field key的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最大的四个值以及相关的tag和field">选择指定field key对应的最大的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 top station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
2021-08-31T18:18:00Z 80  XiaoMaiDao  53
2021-08-31T18:57:00Z 80  LianYunGang 51
2021-08-31T20:15:00Z 80  XiaoMaiDao  53
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最大的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最大的三个值并包含多个子句">选择指定field key对应的最大的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 top station
----                 --- -------
2021-09-18T00:54:00Z 79  XiaoMaiDao
2021-09-18T00:51:00Z 71  XiaoMaiDao
2021-09-18T00:48:00Z 77  LianYunGang
2021-09-18T00:30:00Z 75  LianYunGang
2021-09-18T00:27:00Z 79  LianYunGang
2021-09-18T00:24:00Z 70  LianYunGang
2021-09-18T00:18:00Z 79  LianYunGang
2021-09-18T00:09:00Z 80  XiaoMaiDao
2021-09-18T00:00:00Z 77  XiaoMaiDao
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最大的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="top的常见问题"><a class="header" href="#top的常见问题"><code>TOP()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="top和group-by-time子句同时使用"><a class="header" href="#top和group-by-time子句同时使用"><code>TOP()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>TOP()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>TOP()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)

name: air
time                   top
----                   ------
                        __
2021-09-18T00:12:00Z    63   |
2021-09-18T00:15:00Z    74   | &lt;------- Greatest points for the first time interval
                        --
                        __
2021-09-18T00:18:00Z    79   |
2021-09-18T00:27:00Z   79    | &lt;------- Greatest points for the second time interval
                        --
</code></pre>
<ul>
<li>
<h4 id="top和具有少于n个tag-value的tag-key"><a class="header" href="#top和具有少于n个tag-value的tag-key"><code>TOP()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT TOP(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最大值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<ul>
<li>
<h4 id="toptag和into子句"><a class="header" href="#toptag和into子句"><code>TOP()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数cnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>TOP()</code>函数，除非<code>TOP()</code>中包含tag key作为参数：<code>TOP(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值，并且，它这些结果写入measurement <code>top_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>top_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;top_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;top_temperatures&quot;
name: top_temperatures
tagKey
------
station
</code></pre>
</li>
</ul>
<h3 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h3>
<ul>
<li>
<h3 id="abs"><a class="header" href="#abs">ABS()</a></h3>
<p>返回field value的绝对值</p>
<h4 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h4>
<pre><code class="language-sql">SELECT ABS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ABS(field_key)</code>返回field key对应的field value的绝对值。</p>
<p><code>ABS(*)</code>返回在measurement中每个field key对应的field value的绝对值。</p>
<p><code>ABS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ABS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-17"><a class="header" href="#示例-17">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-09-24T12:00:00Z 76       LianYunGang 61          59
2021-09-24T12:00:00Z 58       XiaoMaiDao  52          77
2021-09-24T12:03:00Z 64       LianYunGang 57          72
2021-09-24T12:03:00Z 50       XiaoMaiDao  70          77
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值"><a class="header" href="#计算指定field-key对应的field-value的绝对值">计算指定field key对应的field value的绝对值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 76
2021-09-24T12:00:00Z 58
2021-09-24T12:03:00Z 64
2021-09-24T12:03:00Z 50
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值。</p>
</li>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的绝对值"><a class="header" href="#计算measurement中每个field-key对应的field-value的绝对值">计算measurement中每个field key对应的field value的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs_pressure abs_temperature abs_visibility
----                 ------------ --------------- --------------
2021-09-24T12:00:00Z 76           61              59
2021-09-24T12:00:00Z 58           52              77
2021-09-24T12:03:00Z 64           57              72
2021-09-24T12:03:00Z 50           70              77
</code></pre>
<p>该查询返回measurement <code>data</code>中每个存储数值的field key对应的field value的绝对值。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>,<code>pressure</code>和<code>visibility</code>。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的绝对值并包含多个子句">计算指定field key对应的field value的绝对值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 58
2021-09-24T12:00:00Z 76
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值，它涵盖的时间范围在<code>2020-06-24T12:00:00Z</code>和<code>2020-06-24T12:05:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-1"><a class="header" href="#高级语法-1">高级语法</a></h4>
<pre><code class="language-sql">SELECT ABS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的绝对值。</p>
<p><code>ABS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="计算平均值的绝对值"><a class="header" href="#计算平均值的绝对值">计算平均值的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 62.75
2021-09-24T12:12:00Z 64.25
2021-09-24T12:24:00Z 66
2021-09-24T12:36:00Z 64.375
2021-09-24T12:48:00Z 63.875
2021-09-24T13:00:00Z 59.5
</code></pre>
<p>该查询返回field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ABS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-24T12:00:00Z 61.75
2021-09-24T12:12:00Z 68.25
2021-09-24T12:24:00Z 66.125
2021-09-24T12:36:00Z 58
2021-09-24T12:48:00Z 68.625
2021-09-24T13:00:00Z 71
</code></pre>
<p>然后，CnosDB计算这些平均值的绝对值。</p>
</li>
<li>
<h3 id="acos"><a class="header" href="#acos">ACOS()</a></h3>
<p>返回field value的反余弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h4>
<pre><code>SELECT ACOS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ACOS(field_key)</code>返回field key对应的field value的反余弦。</p>
<p><code>ACOS(*)</code>返回在measurement中每个field key对应的field value的反余弦。</p>
<p><code>ACOS()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ACOS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ACOS()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦"><a class="header" href="#计算指定field-key对应的field-value的反余弦">计算指定field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  acos
----                  ----
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反余弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反余弦">计算measurement中每个field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 acos_pressure acos_temperature acos_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反余弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但由于这三个field key对应的field value超过余弦函数的范围，因此其反余弦值并不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反余弦并包含多个子句">计算指定field key对应的field value的反余弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 acos
----                 ----
2021-09-18T23:57:00Z 0.6435011087932843
2021-09-18T23:57:00Z 0.6599873293874983
2021-09-18T23:54:00Z 0.7669940078618667
2021-09-18T23:54:00Z 1.0003592173949745
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-2"><a class="header" href="#高级语法-2">高级语法</a></h4>
<pre><code class="language-sql">SELECT ACOS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反余弦。</p>
<p>ACOS()支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的反余弦"><a class="header" href="#计算平均值的反余弦">计算平均值的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 acos
----                 ----
2021-09-09T00:00:00Z
2021-09-12T00:00:00Z
2021-09-15T00:00:00Z
2021-09-18T00:00:00Z  、
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反余弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ACOS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反余弦。</p>
</li>
<li>
<h3 id="asin"><a class="header" href="#asin">ASIN()</a></h3>
<p>返回field value的反正弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h4>
<pre><code>SELECT ASIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ASIN(field_key)</code>返回field key对应的field value的反正弦。</p>
<p><code>ASIN(*)</code>返回在measurement中每个field key对应的field value的反正弦。</p>
<p><code>ASIN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ASIN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-19"><a class="header" href="#示例-19">示例</a></h4>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦"><a class="header" href="#计算指定field-key对应的field-value的反正弦">计算指定field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin
----                 ----
2021-09-11T00:00:00Z 0.8330703583416478
2021-09-11T00:00:00Z 0.9108089974073983
2021-09-11T00:03:00Z 0.6560605909249226
2021-09-11T00:03:00Z 0.8183219506315597
2021-09-11T00:06:00Z 0.8038023189330299
2021-09-11T00:06:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.8038023189330299
2021-09-11T00:12:00Z 0.546850950695944
2021-09-11T00:12:00Z 0.618728690672251
2021-09-11T00:15:00Z 0.8330703583416478
2021-09-11T00:15:00Z 0.8946658172342352
2021-09-11T00:18:00Z 0.7342087874533589
2021-09-11T00:18:00Z 0.8330703583416478
2021-09-11T00:21:00Z 0.7894982093461719
2021-09-11T00:21:00Z 0.5823642378687435
2021-09-11T00:24:00Z 0.7208187608700896
2021-09-11T00:24:00Z 0.7342087874533589
2021-09-11T00:27:00Z 0.8038023189330299
2021-09-11T00:27:00Z 0.7208187608700896
2021-09-11T00:30:00Z 0.6560605909249226
2021-09-11T00:30:00Z 0.570437109399922
2021-09-11T00:33:00Z 0.5823642378687435
2021-09-11T00:33:00Z 0.848062078981481
2021-09-11T00:36:00Z 0.7075844367253555
2021-09-11T00:36:00Z 0.7208187608700896
2021-09-11T00:39:00Z 0.7477626346599205
2021-09-11T00:39:00Z 0.618728690672251
2021-09-11T00:42:00Z 0.6310588407780212
2021-09-11T00:42:00Z 0.618728690672251
2021-09-11T00:45:00Z 0.7614890527476331
2021-09-11T00:45:00Z 0.7894982093461719
2021-09-11T00:48:00Z 0.7614890527476331
2021-09-11T00:48:00Z 0.6065058552130869
2021-09-11T00:51:00Z 0.5823642378687435
2021-09-11T00:51:00Z 0.8183219506315597
2021-09-11T00:54:00Z 0.7614890527476331
2021-09-11T00:54:00Z 0.6944982656265559
2021-09-11T00:57:00Z 0.8183219506315597
2021-09-11T00:57:00Z 0.546850950695944
2021-09-11T01:00:00Z 0.6310588407780212
2021-09-11T01:00:00Z 0.7477626346599205    
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正弦">计算measurement中每个field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin_pressure asin_temperature asin_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但是由于这三个field value全部大于1，因此其反正弦值不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正弦并包含多个子句">计算指定field key对应的field value的反正弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 asin
----                 ----
2021-09-18T23:57:00Z 0.9272952180016123
2021-09-18T23:57:00Z 0.9108089974073983
2021-09-18T23:54:00Z 0.8038023189330299
2021-09-18T23:54:00Z 0.570437109399922
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-3"><a class="header" href="#高级语法-3">高级语法</a></h4>
<pre><code class="language-sql">SELECT ASIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正弦。</p>
<p>ASIN()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>,
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-20"><a class="header" href="#示例-20">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正弦"><a class="header" href="#计算平均值的反正弦">计算平均值的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(MEAN(&quot;speed&quot;)) FROM &quot;wind&quot; WHERE time &gt;= '2021-09-01T00:00:00Z' AND time &lt;= '2021-09-30T00:00:00Z' GROUP BY time(1d)
name: air
time                  asin
----                  ----
2020-04-30T00:00:00Z  0.6004332535805232
2020-05-03T00:00:00Z  0.42245406218675574
2020-05-06T00:00:00Z  0.7894982093461719
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ASIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正弦。</p>
</li>
<li>
<h3 id="atan"><a class="header" href="#atan">ATAN()</a></h3>
<p>返回field value的反正切（以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h4>
<pre><code class="language-sql">SELECT ATAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN(field_key)</code>返回field key对应的field value的反正切。</p>
<p><code>ATAN(*)</code>返回在measurement中每个field key对应的field value的反正切。</p>
<p><code>ATAN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-21"><a class="header" href="#示例-21">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ATAN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切"><a class="header" href="#计算指定field-key对应的field-value的反正切">计算指定field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan
----                 ----
2021-09-11T00:00:00Z 1.5572836357815683
2021-09-11T00:00:00Z 1.5581387749608446
2021-09-11T00:03:00Z 1.5544043524868913
2021-09-11T00:03:00Z 1.5570985534220307
2021-09-11T00:06:00Z 1.5569083308639295
2021-09-11T00:06:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5569083308639295
2021-09-11T00:12:00Z 1.5515679276951893
2021-09-11T00:12:00Z 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683
2021-09-11T00:15:00Z 1.557976516321996
2021-09-11T00:18:00Z 1.5558720618048116
2021-09-11T00:18:00Z 1.5572836357815683
2021-09-11T00:21:00Z 1.5567127509720364
2021-09-11T00:21:00Z 1.5526165117219182
2021-09-11T00:24:00Z 1.5556459709201267
2021-09-11T00:24:00Z 1.5558720618048116
2021-09-11T00:27:00Z 1.5569083308639295
2021-09-11T00:27:00Z 1.5556459709201267
2021-09-11T00:30:00Z 1.5544043524868913
2021-09-11T00:30:00Z 1.5522799247268875
2021-09-11T00:33:00Z 1.5526165117219182
2021-09-11T00:33:00Z 1.557463783500751
2021-09-11T00:36:00Z 1.5554129250143014
2021-09-11T00:36:00Z 1.5556459709201267
2021-09-11T00:39:00Z 1.5560915044170451
2021-09-11T00:39:00Z 1.5535566556003668
2021-09-11T00:42:00Z 1.5538487969884915
2021-09-11T00:42:00Z 1.5535566556003668
2021-09-11T00:45:00Z 1.5563045877293966
2021-09-11T00:45:00Z 1.5567127509720364
2021-09-11T00:48:00Z 1.5563045877293966
2021-09-11T00:48:00Z 1.553254266737494
2021-09-11T00:51:00Z 1.5526165117219182
2021-09-11T00:51:00Z 1.5570985534220307
2021-09-11T00:54:00Z 1.5563045877293966
2021-09-11T00:54:00Z 1.5551725981744198
2021-09-11T00:57:00Z 1.5570985534220307
2021-09-11T00:57:00Z 1.5515679276951893
2021-09-11T01:00:00Z 1.5538487969884915
2021-09-11T01:00:00Z 1.5560915044170451
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正切"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正切">计算measurement中每个field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan_pressure      atan_temperature   atan_visibility
----                 -------------      ----------------   ---------------
2021-09-11T00:00:00Z 1.5544043524868913 1.5572836357815683 1.5526165117219182
2021-09-11T00:00:00Z 1.5576391913221408 1.5581387749608446 1.550798992821746
2021-09-11T00:03:00Z 1.5535566556003668 1.5544043524868913 1.551190995937692
2021-09-11T00:03:00Z 1.5541312030809558 1.5570985534220307 1.5581387749608446
2021-09-11T00:06:00Z 1.5549246438031066 1.5569083308639295 1.5556459709201267
2021-09-11T00:06:00Z 1.557976516321996  1.5544043524868913 1.5541312030809558
2021-09-11T00:09:00Z 1.553254266737494  1.5544043524868913 1.5560915044170451
2021-09-11T00:09:00Z 1.5556459709201267 1.5569083308639295 1.557463783500751
2021-09-11T00:12:00Z 1.5541312030809558 1.5515679276951893 1.5563045877293966
2021-09-11T00:12:00Z 1.550798992821746  1.5535566556003668 1.5565115842075
2021-09-11T00:15:00Z 1.5554129250143014 1.5572836357815683 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683 1.557976516321996  1.557976516321996
2021-09-11T00:18:00Z 1.557463783500751  1.5558720618048116 1.5526165117219182
2021-09-11T00:18:00Z 1.557810043874724  1.5572836357815683 1.551190995937692
2021-09-11T00:21:00Z 1.5544043524868913 1.5567127509720364 1.552941081655344
2021-09-11T00:21:00Z 1.5576391913221408 1.5526165117219182 1.5570985534220307
2021-09-11T00:24:00Z 1.552941081655344  1.5556459709201267 1.5541312030809558
2021-09-11T00:24:00Z 1.5570985534220307 1.5558720618048116 1.550798992821746
2021-09-11T00:27:00Z 1.550798992821746  1.5569083308639295 1.552941081655344
2021-09-11T00:27:00Z 1.5582969777755349 1.5556459709201267 1.5551725981744198
2021-09-11T00:30:00Z 1.5582969777755349 1.5544043524868913 1.5567127509720364
2021-09-11T00:30:00Z 1.5549246438031066 1.5522799247268875 1.5546686929512603
2021-09-11T00:33:00Z 1.5576391913221408 1.5526165117219182 1.5560915044170451
2021-09-11T00:33:00Z 1.5519306407732258 1.557463783500751  1.5560915044170451
2021-09-11T00:36:00Z 1.5558720618048116 1.5554129250143014 1.5519306407732258
2021-09-11T00:36:00Z 1.5560915044170451 1.5556459709201267 1.5563045877293966
2021-09-11T00:39:00Z 1.5526165117219182 1.5560915044170451 1.5567127509720364
2021-09-11T00:39:00Z 1.5563045877293966 1.5535566556003668 1.557810043874724
2021-09-11T00:42:00Z 1.5569083308639295 1.5538487969884915 1.5565115842075
2021-09-11T00:42:00Z 1.5522799247268875 1.5535566556003668 1.5549246438031066
2021-09-11T00:45:00Z 1.557810043874724  1.5563045877293966 1.5576391913221408
2021-09-11T00:45:00Z 1.5560915044170451 1.5567127509720364 1.557810043874724
2021-09-11T00:48:00Z 1.5535566556003668 1.5563045877293966 1.5551725981744198
2021-09-11T00:48:00Z 1.5546686929512603 1.553254266737494  1.5560915044170451
2021-09-11T00:51:00Z 1.5526165117219182 1.5526165117219182 1.5570985534220307
2021-09-11T00:51:00Z 1.557463783500751  1.5570985534220307 1.5572836357815683
2021-09-11T00:54:00Z 1.5563045877293966 1.5563045877293966 1.5558720618048116
2021-09-11T00:54:00Z 1.5538487969884915 1.5551725981744198 1.5544043524868913
2021-09-11T00:57:00Z 1.5565115842075    1.5570985534220307 1.5572836357815683
2021-09-11T00:57:00Z 1.5576391913221408 1.5515679276951893 1.5572836357815683
2021-09-11T01:00:00Z 1.5522799247268875 1.5538487969884915 1.5522799247268875
2021-09-11T01:00:00Z 1.557810043874724  1.5560915044170451 1.5551725981744198
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正切。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正切并包含多个子句">计算指定field key对应的field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan
----                 ----
2021-09-18T23:57:00Z 1.5582969777755349
2021-09-18T23:57:00Z 1.5581387749608446
2021-09-18T23:54:00Z 1.5569083308639295
2021-09-18T23:54:00Z 1.5522799247268875
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-4"><a class="header" href="#高级语法-4">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切。</p>
<p><code>ATAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-22"><a class="header" href="#示例-22">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切"><a class="header" href="#计算平均值的反正切">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 atan
----                 ----
2021-09-09T00:00:00Z 1.5554743016680184
2021-09-12T00:00:00Z 1.5554056912417906
2021-09-15T00:00:00Z 1.555415060964228
2021-09-18T00:00:00Z 1.555490506678637
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正切。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="atan2"><a class="header" href="#atan2">ATAN2()</a></h3>
<p>返回以弧度表示的<code>y/x</code>的反正切。</p>
<h4 id="基本语法-5"><a class="header" href="#基本语法-5">基本语法</a></h4>
<pre><code>SELECT ATAN2( [ * | &lt;field_key&gt; | num ], [ &lt;field_key&gt; | num ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN2(field_key_y, field_key_x)</code>返回field key “field_key_y”对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2(*, field_key_x)&lt;br /&gt;</code>返回在measurement中每个field key对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN2()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-23"><a class="header" href="#示例-23">示例</a></h4>
<p>下面的示例将使用如下模拟的飞行数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot;, &quot;pressure&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:15:00Z'
name: air
time                 temperature pressure
----                 ----------- --------
2021-09-06T12:03:00Z 53          78
2021-09-06T12:03:00Z 72          71
2021-09-06T12:06:00Z 69          58
2021-09-06T12:06:00Z 59          76
2021-09-06T12:09:00Z 71          55
2021-09-06T12:09:00Z 57          76
2021-09-06T12:12:00Z 53          75
2021-09-06T12:12:00Z 65          52
2021-09-06T12:15:00Z 69          67
2021-09-06T12:15:00Z 64          56
</code></pre>
<ul>
<li>
<h4 id="计算field_key_y除以field_key_x的反正切"><a class="header" href="#计算field_key_y除以field_key_x的反正切">计算field_key_y除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T13:01:00Z'
name: air
time                 atan2
----                 -----
2021-09-06T12:03:00Z 0.5968259039857009
2021-09-06T12:03:00Z 0.7923910564027816
2021-09-06T12:06:00Z 0.8717967127558954
2021-09-06T12:06:00Z 0.6601315920749263
2021-09-06T12:09:00Z 0.9117062804606886
2021-09-06T12:09:00Z 0.6435011087932844
2021-09-06T12:12:00Z 0.6151862381119739
2021-09-06T12:12:00Z 0.8960553845713439
2021-09-06T12:15:00Z 0.8001029857752997
2021-09-06T12:15:00Z 0.851966327173272
2021-09-06T12:18:00Z 0.6960841704042261
2021-09-06T12:18:00Z 0.8010218920179252
2021-09-06T12:21:00Z 0.7594299761858918
2021-09-06T12:21:00Z 0.7028792089644667
2021-09-06T12:24:00Z 0.812418612584713
2021-09-06T12:24:00Z 0.7309067071567171
2021-09-06T12:27:00Z 0.9948777271765435
2021-09-06T12:27:00Z 0.7546386373269791
2021-09-06T12:30:00Z 0.7785017210090998
2021-09-06T12:30:00Z 0.6435011087932844
2021-09-06T12:33:00Z 0.8960553845713439
2021-09-06T12:33:00Z 0.8007815651780434
2021-09-06T12:36:00Z 0.8498250028230019
2021-09-06T12:36:00Z 0.8736040677941312
2021-09-06T12:39:00Z 0.7168036599431737
2021-09-06T12:39:00Z 0.9296875579351908
2021-09-06T12:42:00Z 0.8633647972289906
2021-09-06T12:42:00Z 0.9437256642058782
2021-09-06T12:45:00Z 0.6215266244966218
2021-09-06T12:45:00Z 0.8152400480645576
2021-09-06T12:48:00Z 0.7378150601204648
2021-09-06T12:48:00Z 0.7638187798309181
2021-09-06T12:51:00Z 0.9179496956941223
2021-09-06T12:51:00Z 0.7935280655773922
2021-09-06T12:54:00Z 0.9572401812829798
2021-09-06T12:54:00Z 0.6593100683328579
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T13:00:00Z 0.8187191592756955
2021-09-06T13:00:00Z 0.8134282033572947
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切。这两个field key都在measurement <code>wind</code>中。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key除以field_key_x的反正切"><a class="header" href="#计算measurement中每个field-key除以field_key_x的反正切">计算measurement中每个field key除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(*, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:06:00Z'
name: air
time                 atan2_pressure     atan2_temperature  atan2_visibility
----                 --------------     -----------------  ----------------
2021-09-06T12:03:00Z 0.7853981633974483 0.5968259039857009 0.60554466360497
2021-09-06T12:03:00Z 0.7853981633974483 0.7923910564027816 0.7257674502662789
2021-09-06T12:06:00Z 0.7853981633974483 0.8717967127558954 0.8645972343668997
2021-09-06T12:06:00Z 0.7853981633974483 0.6601315920749263 0.6435011087932844
</code></pre>
<p>该查询返回measurement <code>wind</code>中每个存储数值的field key对应的field value除以field key <code>pressure</code>对应的field value的反正切。measurement <code>wind</code>中有两个数值类型的field：<code>temperature</code>和<code>pressure</code>。</p>
<ul>
<li>
<h4 id="计算field-value的反正切并包含多个子句"><a class="header" href="#计算field-value的反正切并包含多个子句">计算field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-16T13:01:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan2
----                 -----
2021-09-16T12:57:00Z 0.8773368222796695
2021-09-16T12:57:00Z 0.8114792046882006
2021-09-16T12:54:00Z 0.8007815651780434
2021-09-16T12:54:00Z 1.003258702010146
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-16T12:10:00Z</code>和<code>2020-05-16T12:10:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-5"><a class="header" href="#高级语法-5">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN2(&lt;function()&gt;, &lt;function()&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切(<code>ATAN2()</code>)。</p>
<p>ATAN2()支持以下嵌套函数：</p>
<ul>
<li>COUNT()</li>
<li>MEAN()</li>
<li>MEDIAN()</li>
<li>MODE()</li>
<li>SUM()</li>
<li>FIRST()</li>
<li>LAST()</li>
<li>MIN()</li>
<li>MAX()</li>
<li>PERCENTILE()</li>
</ul>
<h4 id="示例-24"><a class="header" href="#示例-24">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切-1"><a class="header" href="#计算平均值的反正切-1">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 atan2
----                 -----
2021-09-16T12:00:00Z 0.7916716068182019
2021-09-16T12:12:00Z 0.7687819020057319
2021-09-16T12:24:00Z 0.8293469014295621
2021-09-16T12:36:00Z 0.7483094274728471
2021-09-16T12:48:00Z 0.8579805385837196
2021-09-16T13:00:00Z 0.7640815957515122
2021-09-16T13:12:00Z 0.7660813391498594
2021-09-16T13:24:00Z 0.7595170787800846
2021-09-16T13:36:00Z 0.781755192263569
2021-09-16T13:48:00Z 0.8137459550765823
2021-09-16T14:00:00Z 0.7572931159369924
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value的平均值除以field key <code>pressure</code>对应的field value的平均值的反正切。平均值是按每12分钟的时间间隔计算的。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>和<code>pressure</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 mean              mean_1
----                 ----              ------
2021-09-16T12:00:00Z 66.83333333333333 66
2021-09-16T12:12:00Z 62.875            65
2021-09-16T12:24:00Z 68.25             62.5
2021-09-16T12:36:00Z 64.875            69.875
2021-09-16T12:48:00Z 71                61.375
2021-09-16T13:00:00Z 60.25             62.875
2021-09-16T13:12:00Z 66.625            69.25
2021-09-16T13:24:00Z 63.5              66.875
2021-09-16T13:36:00Z 68.375            68.875
2021-09-16T13:48:00Z 68                64.25
2021-09-16T14:00:00Z 60.5              64
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="ceil"><a class="header" href="#ceil">CEIL()</a></h3>
<p>返回大于指定值的最小整数。</p>
<h4 id="基本语法-6"><a class="header" href="#基本语法-6">基本语法</a></h4>
<pre><code>SELECT CEIL( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CEIL(field_key)</code>返回field key对应的大于field value的最小整数。</p>
<p><code>CEIL(*)</code>返回在measurement中每个field key对应的大于field value的最小整数。</p>
<p><code>CEIL()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CEIL()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-25"><a class="header" href="#示例-25">示例</a></h4>
<p>下面的示例将使用<a href="oceanic_station.txt"><code>oceanic_station</code>数据集</a>的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数">计算指定field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的大于field value的最小整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的大于field-value的最小整数"><a class="header" href="#计算measurement中每个field-key对应的大于field-value的最小整数">计算measurement中每个field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil_pressure ceil_temperature ceil_visibility
----                 ------------- ---------------- ---------------
2021-09-18T00:00:00Z 64            51               68
2021-09-18T00:03:00Z 72            60               74
2021-09-18T00:06:00Z 54            55               77
2021-09-18T00:09:00Z 66            55               55
2021-09-18T00:12:00Z 64            63               70
2021-09-18T00:15:00Z 58            74               62
2021-09-18T00:18:00Z 55            79               54
2021-09-18T00:21:00Z 64            68               58
2021-09-18T00:24:00Z 66            70               69
2021-09-18T00:27:00Z 77            79               78
2021-09-18T00:30:00Z 62            75               80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的大于field value的最小整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数并包含多个子句"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数并包含多个子句">计算指定field key对应的大于field value的最小整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ceil
----                 ----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的大于field value的最小整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-6"><a class="header" href="#高级语法-6">高级语法</a></h4>
<pre><code>SELECT CEIL(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>CEIL()</code>应用于这些结果。</p>
<p><code>CEIL()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-26"><a class="header" href="#示例-26">示例</a></h4>
<ul>
<li>
<h4 id="计算大于平均值的最小整数"><a class="header" href="#计算大于平均值的最小整数">计算大于平均值的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 56
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的大于<code>temperature</code>平均值的最小整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的大于<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CEIL()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算大于这些平均值的最小整数。</p>
</li>
<li>
<h3 id="cos"><a class="header" href="#cos">COS()</a></h3>
<p>返回field value的余弦值。</p>
<h4 id="基本语法-7"><a class="header" href="#基本语法-7">基本语法</a></h4>
<pre><code>SELECT COS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>COS(field_key)</code>返回field key对应的field value的余弦值。</p>
<p><code>COS(*)</code>返回在measurement中每个field key对应的field value的余弦值。</p>
<p><code>COS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>COS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-27"><a class="header" href="#示例-27">示例</a></h4>
<ul>
<li>
<h4 id="下面的示例将使用oceanic_station数据集的如下数据"><a class="header" href="#下面的示例将使用oceanic_station数据集的如下数据">下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值"><a class="header" href="#计算指定field-key对应的field-value的余弦值">计算指定field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.7421541968137826
2021-09-18T00:03:00Z -0.9524129804151563
2021-09-18T00:06:00Z 0.022126756261955732
2021-09-18T00:09:00Z 0.022126756261955732
2021-09-18T00:12:00Z 0.9858965815825497
2021-09-18T00:15:00Z 0.17171734183077755
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:27:00Z -0.8959709467909631
2021-09-18T00:30:00Z 0.9217512697247493
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的余弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的余弦值">计算measurement中每个field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos_pressure          cos_temperature      cos_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.39185723042955      0.7421541968137826   0.4401430224960407
2021-09-18T00:03:00Z -0.9672505882738824   -0.9524129804151563  0.17171734183077755
2021-09-18T00:06:00Z -0.8293098328631501   0.022126756261955732 -0.030975031731216456
2021-09-18T00:09:00Z -0.9996474559663501   0.022126756261955732 0.022126756261955732
2021-09-18T00:12:00Z 0.39185723042955      0.9858965815825497   0.6333192030862999
2021-09-18T00:15:00Z 0.11918013544881928   0.17171734183077755  0.6735071623235862
2021-09-18T00:18:00Z 0.022126756261955732  -0.8959709467909631  -0.8293098328631501
2021-09-18T00:21:00Z 0.39185723042955      0.4401430224960407   0.11918013544881928
2021-09-18T00:24:00Z -0.9996474559663501   0.6333192030862999   0.9933903797222716
2021-09-18T00:27:00Z -0.030975031731216456 -0.8959709467909631  -0.8578030932449878
2021-09-18T00:30:00Z 0.6735071623235862    0.9217512697247493   -0.11038724383904756
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的余弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的余弦值并包含多个子句">计算指定field key对应的field value的余弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cos
----                 ---
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:15:00Z 0.17171734183077755
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-7"><a class="header" href="#高级语法-7">高级语法</a></h4>
<pre><code>SELECT COS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的余弦值。</p>
<p><code>COS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-28"><a class="header" href="#示例-28">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的余弦值"><a class="header" href="#计算平均值的余弦值">计算平均值的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.2687822771684872
2021-09-18T00:12:00Z -0.3090227281660707
2021-09-18T00:24:00Z 0.7441351704799297
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的余弦值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>COS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的余弦值。</p>
</li>
<li>
<h3 id="cumulative_sum"><a class="header" href="#cumulative_sum">CUMULATIVE_SUM()</a></h3>
<p>返回field value的累积总和。</p>
<h4 id="基本语法-8"><a class="header" href="#基本语法-8">基本语法</a></h4>
<pre><code>SELECT CUMULATIVE_SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CUMULATIVE_SUM(field_key)</code>返回field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(*)</code>返回在measurement中每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CUMULATIVE_SUM()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-29"><a class="header" href="#示例-29">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和"><a class="header" href="#计算指定field-key对应的field-value的累积总和">计算指定field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的累积总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的累积总和">计算measurement中每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum_pressure cumulative_sum_temperature cumulative_sum_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:00:00Z 64                      51                         68
2021-09-18T00:03:00Z 136                     111                        142
2021-09-18T00:06:00Z 190                     166                        219
2021-09-18T00:09:00Z 256                     221                        274
2021-09-18T00:12:00Z 320                     284                        344
2021-09-18T00:15:00Z 378                     358                        406
2021-09-18T00:18:00Z 433                     437                        460
2021-09-18T00:21:00Z 497                     505                        518
2021-09-18T00:24:00Z 563                     575                        587
2021-09-18T00:27:00Z 640                     654                        665
2021-09-18T00:30:00Z 702                     729                        745
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的累积总和。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的累积总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的累积总和">计算与正则表达式匹配的每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(/temp/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
time                 cumulative_sum_temperature
----                 --------------------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的累积总和并包含多个子句">计算指定field key对应的field value的累积总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:24:00Z 224
2021-09-18T00:21:00Z 292
2021-09-18T00:18:00Z 371
2021-09-18T00:15:00Z 445
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-8"><a class="header" href="#高级语法-8">高级语法</a></h4>
<pre><code class="language-sql">SELECT CUMULATIVE_SUM(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的累积总和"><a class="header" href="#计算平均值的累积总和">计算平均值的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 126.25
2021-09-18T00:24:00Z 200.91666666666669
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的累积总和。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CUMULATIVE_SUM()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的累积总和。最终查询结果中的第二个<code>point</code>(<code>4.167</code>)是<code>2.09</code>和<code>2.077</code>的总和，第三个<code>point</code>(<code>6.213</code>)是<code>2.09</code>、<code>2.077</code>和<code>2.0460000000000003</code>的总和。</p>
</li>
<li>
<h3 id="derivative"><a class="header" href="#derivative">DERIVATIVE()</a></h3>
<p>返回field value之间的变化率，即导数。</p>
<h4 id="基本语法-9"><a class="header" href="#基本语法-9">基本语法</a></h4>
<pre><code>SELECT DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>DERIVATIVE(field_key)</code>返回field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-30"><a class="header" href="#示例-30">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数"><a class="header" href="#计算指定field-key对应的field-value的导数">计算指定field key对应的field value的导数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 0.05
2021-09-18T00:06:00Z -0.027777777777777776
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0.044444444444444446
2021-09-18T00:15:00Z 0.06111111111111111
2021-09-18T00:18:00Z 0.027777777777777776
2021-09-18T00:21:00Z -0.06111111111111111
2021-09-18T00:24:00Z 0.011111111111111112
2021-09-18T00:27:00Z 0.05
2021-09-18T00:30:00Z -0.022222222222222223
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率。</p>
<p>第一个结果(<code>0.05</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数并指定unit"><a class="header" href="#计算指定field-key对应的field-value的导数并指定unit">计算指定field key对应的field value的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;,6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 18
2021-09-18T00:06:00Z -10
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 16
2021-09-18T00:15:00Z 22
2021-09-18T00:18:00Z 10
2021-09-18T00:21:00Z -22
2021-09-18T00:24:00Z 4
2021-09-18T00:27:00Z 18
2021-09-18T00:30:00Z -8
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每六分钟的变化率。</p>
<p>第一个结果(<code>0.052000000000000046</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 6m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算measurement中每个field-key对应的field-value的导数并指定unit">计算measurement中每个field key对应的field value的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(*,3m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_pressure derivative_temperature derivative_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的每三分钟的变化率。measurement <code>air</code>中数值类型的field：<code>temperature</code>,<code>pressure</code>,<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit">计算与正则表达式匹配的每个field key对应的field value的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(/temp/,2m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_temperature
----                 ----------------------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z -3.3333333333333335
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 5.333333333333333
2021-09-18T00:15:00Z 7.333333333333333
2021-09-18T00:18:00Z 3.3333333333333335
2021-09-18T00:21:00Z -7.333333333333333
2021-09-18T00:24:00Z 1.3333333333333333
2021-09-18T00:27:00Z 6
2021-09-18T00:30:00Z -2.6666666666666665
</code></pre>
<p>该查询返回measurement <code>air</code>中的对应field key&quot;temperature&quot;对应的field value的每两分钟的变化率。</p>
<p>第一个结果(<code>6</code>)是原始数据中前两个field value在两分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为两分钟的变化率：</p>
<pre><code>(-3.3333333333333335 6) / (6m / 2m)
--------------            ----------
       |                      |
       |                the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的导数并包含多个子句">计算指定field key对应的field value的导数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 1 OFFSET 2
name: air
time                 derivative
----                 ----------
2021-09-18T00:21:00Z -0.011111111111111112
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<p>唯一的结果(<code>-0.011111111111111112</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
<h4 id="高级语法-9"><a class="header" href="#高级语法-9">高级语法</a></h4>
<pre><code>SELECT DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。</p>
<p><code>DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的导数"><a class="header" href="#计算平均值的导数">计算平均值的导数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -14.25
2021-09-18T00:12:00Z 15.75
2021-09-18T00:24:00Z 3.6666666666666714
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每12分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每12分钟的变化率。第一个结果(<code>55.25</code>)是原始数据中前两个field value在12分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为12分钟的变化率：</p>
<pre><code>(71 - 74.66666666666667)  / (12m / 12m)
-------------                   ----------
       |                           |
       |                     the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算平均值的导数并指定unit"><a class="header" href="#计算平均值的导数并指定unit">计算平均值的导数并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;),6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -7.125
2021-09-18T00:12:00Z 7.875
2021-09-18T00:24:00Z 1.8333333333333357
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每六分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)

name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每六分钟的变化率。第一个结果(<code>-55.25</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code class="language-sql">(71 - 74.66666666666667) / (12m / 6m)
-------------    ----------
       |                         |
       |                    the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
</li>
<li>
<h3 id="difference"><a class="header" href="#difference">DIFFERENCE()</a></h3>
<p>返回field value之间的差值。</p>
<h4 id="基本语法-10"><a class="header" href="#基本语法-10">基本语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>DIFFERENCE(field_key)</code>返回field key对应的field value的差值。</p>
<p><code>DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-31"><a class="header" href="#示例-31">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值"><a class="header" href="#计算指定field-key对应的field-value的差值">计算指定field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference
----                 ----------
2021-09-18T00:03:00Z 9
2021-09-18T00:06:00Z -5
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 8
2021-09-18T00:15:00Z 11
2021-09-18T00:18:00Z 5
2021-09-18T00:21:00Z -11
2021-09-18T00:24:00Z 2
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z -4
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的差值"><a class="header" href="#计算measurement中每个field-key对应的field-value的差值">计算measurement中每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_pressure difference_temperature difference_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value之间的差值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的差值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的差值">计算与正则表达式匹配的每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(/visi/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_visibility
----                 ----------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z -22
2021-09-18T00:12:00Z 15
2021-09-18T00:15:00Z -8
2021-09-18T00:18:00Z -8
2021-09-18T00:21:00Z 4
2021-09-18T00:24:00Z 11
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z 2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的差值并包含多个子句">计算指定field key对应的field value的差值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 2 OFFSET 2
name: air
time                 difference
----                 ----------
2021-09-18T00:21:00Z -2
2021-09-18T00:18:00Z 11
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-10"><a class="header" href="#高级语法-10">高级语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的差值。</p>
<p>DIFFERENCE()支持以下嵌套函数：
<a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-32"><a class="header" href="#示例-32">示例</a></h4>
<ul>
<li>
<h4 id="计算最大值之间的差值"><a class="header" href="#计算最大值之间的差值">计算最大值之间的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(MAX(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 difference
----                 ----------
2021-09-18T00:00:00Z -19
2021-09-18T00:12:00Z 19
2021-09-18T00:24:00Z 0
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值之间的差值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DIFFERENCE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值之间的差值。最终查询结果中的第一个<code>point</code>(<code>0.009999999999999787</code>)是<code>2.126</code>和<code>2.116</code>的差，第二个<code>point</code>(<code>-0.07499999999999973</code>)是<code>2.051</code>和<code>2.126</code>的差。</p>
</li>
<li>
<h3 id="elapsed"><a class="header" href="#elapsed">ELAPSED()</a></h3>
<p>返回field value的时间戳之间的差值。</p>
<h4 id="语法-18"><a class="header" href="#语法-18">语法</a></h4>
<pre><code>SELECT ELAPSED( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算时间戳之间的差值。参数<code>unit</code>的值是一个整数，后跟一个时间单位，它决定了返回的差值的单位。这个参数是可选的，不是必须要有的。如果没有指定<code>unit</code>的值，那么查询将返回以纳秒为单位的两个时间戳之间的差值。</p>
<p><code>ELAPSED(field_key)</code>返回field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(*)</code>返回在measurement中每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED()</code>支持所有数据类型的field value。</p>
<h4 id="示例-33"><a class="header" href="#示例-33">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔">计算指定field key对应的field value之间的时间间隔</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 180000000000
2021-09-18T00:06:00Z 180000000000
2021-09-18T00:09:00Z 180000000000
2021-09-18T00:12:00Z 180000000000
2021-09-18T00:15:00Z 180000000000
2021-09-18T00:18:00Z 180000000000
2021-09-18T00:21:00Z 180000000000
2021-09-18T00:24:00Z 180000000000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以纳秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并指定unit">计算指定field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的时间戳之间的差值(以分钟为单位)。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(/press/,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed_pressure
----                 ----------------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并包含多个子句">计算指定field key对应的field value之间的时间间隔并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1ms) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z' ORDER BY time DESC LIMIT 1 OFFSET 1
name: air
time                 elapsed
----                 -------
2021-09-18T00:18:00Z -180000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以毫秒为单位)，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:12:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移一个（即前一个<code>point</code>不返回）。</p>
<p>请注意，查询结果是负数；因为<code>ORDER BY time DESC</code>子句按递减的顺序对时间戳进行排序，所以<code>ELAPSED()</code>以相反的顺序计算时间戳的差值。</p>
<h4 id="elapsed的常见问题"><a class="header" href="#elapsed的常见问题"><code>ELAPSED()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="elapsed和大于经过时间的单位"><a class="header" href="#elapsed和大于经过时间的单位"><code>ELAPSED()</code>和大于经过时间的单位</a></h4>
</li>
</ul>
<p>I如果<code>unit</code>的值大于时间戳之间的差值，那么CnosDB将会返回<code>0</code>。</p>
<p>measurement <code>air</code>中每六分钟有一个<code>point</code>。如果查询将<code>unit</code>设置为一小时，CnosDB将会返回<code>0</code>：</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1h) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:12:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 0
2021-09-18T00:06:00Z 0
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0
</code></pre>
<ul>
<li>
<h4 id="elapsed和group-by-time子句同时使用"><a class="header" href="#elapsed和group-by-time子句同时使用"><code>ELAPSED()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p><code>ELAPSED()</code>函数支持<code>GROUP BY time()</code>子句，但是查询结果不是特别有用。目前，如果<code>ELAPSED()</code>查询包含一个嵌套的cnosQL函数和一个<code>GROUP BY time()</code>子句，那么只会返回指定<code>GROUP BY time()</code>子句中的时间间隔。</p>
<p><code>GROUP BY time()</code>子句决定了查询结果中的时间戳：每个时间戳表示时间间隔的开始时间。该行为也适用于嵌套的selector函数(例如<code>FIRST()</code>或<code>MAX()</code>)，而在其它的所有情况下，这些函数返回的是原始数据的特定时间戳。因为<code>GROUP BY time()</code>子句会覆盖原始时间戳，所以<code>ELAPSED()</code>始终返回与<code>GROUP BY time()</code>的时间间隔相同的时间戳。</p>
<p>下面代码块中的第一个查询尝试使用<code>ELAPSED()</code>和<code>GROUP BY time()</code>子句来查找最小的<code>temperature</code>的值之间经过的时间(以分钟为单位)。查询的两个时间间隔都返回了12分钟。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔的<code>temperature</code>的最小值。代码块中的第二个查询展示了这一步的结果。这一步跟同时使用<code>MIN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ELAPSED()</code>的情形一样。请注意，第二个查询返回的时间戳间隔12分钟。在原始数据中，第一个结果(<code>2.057</code>)发生在<code>2020-08-18T00:42:00Z</code>，但是<code>GROUP BY time()</code>子句覆盖了原始的时间戳。因为时间戳由<code>GROUP BY time()</code>的时间间隔(而不是原始数据)决定，所以<code>ELAPSED()</code>始终返回与GROUP BY time()的时间间隔相同的时间戳。</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(MIN(&quot;temperature&quot;),1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 elapsed
----                 -------
2021-09-08T00:36:00Z 12
2021-09-08T00:48:00Z 12

&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 min
----                 ---
2021-09-08T00:36:00Z 50
2021-09-08T00:48:00Z 73  &lt;--- Actually occurs at 2021-09-08T00:48:00Z
</code></pre>
</li>
<li>
<h3 id="exp"><a class="header" href="#exp">EXP()</a></h3>
<p>返回field value的指数。</p>
<h4 id="基本语法-11"><a class="header" href="#基本语法-11">基本语法</a></h4>
<pre><code>SELECT EXP( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>EXP(field_key)</code>返回field key对应的field value的指数。</p>
<p><code>EXP(*)</code>返回在measurement中每个field key对应的field value的指数。</p>
<p><code>EXP()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>EXP()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-34"><a class="header" href="#示例-34">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.85.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数"><a class="header" href="#计算指定field-key对应的field-value的指数">计算指定field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 1.4093490824269389e+22
2021-09-18T00:03:00Z 1.1420073898156842e+26
2021-09-18T00:06:00Z 7.694785265142018e+23
2021-09-18T00:09:00Z 7.694785265142018e+23
2021-09-18T00:12:00Z 2.29378315946961e+27
2021-09-18T00:15:00Z 1.3733829795401763e+32
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:27:00Z 2.0382810665126688e+34
2021-09-18T00:30:00Z 3.7332419967990015e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的指数"><a class="header" href="#计算measurement中每个field-key对应的field-value的指数">计算measurement中每个field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp_pressure           exp_temperature        exp_visibility
----                 ------------           ---------------        --------------
2021-09-18T00:00:00Z 6.235149080811617e+27  1.4093490824269389e+22 3.404276049931741e+29
2021-09-18T00:03:00Z 1.8586717452841279e+31 1.1420073898156842e+26 1.3733829795401763e+32
2021-09-18T00:06:00Z 2.830753303274694e+23  7.694785265142018e+23  2.7585134545231703e+33
2021-09-18T00:09:00Z 4.607186634331292e+28  7.694785265142018e+23  7.694785265142018e+23
2021-09-18T00:12:00Z 6.235149080811617e+27  2.29378315946961e+27   2.515438670919167e+30
2021-09-18T00:15:00Z 1.545538935590104e+25  1.3733829795401763e+32 8.438356668741455e+26
2021-09-18T00:18:00Z 7.694785265142018e+23  2.0382810665126688e+34 2.830753303274694e+23
2021-09-18T00:21:00Z 6.235149080811617e+27  3.404276049931741e+29  1.545538935590104e+25
2021-09-18T00:24:00Z 4.607186634331292e+28  2.515438670919167e+30  9.253781725587789e+29
2021-09-18T00:27:00Z 2.7585134545231703e+33 2.0382810665126688e+34 7.49841699699012e+33
2021-09-18T00:30:00Z 8.438356668741455e+26  3.7332419967990015e+32 5.54062238439351e+34
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的指数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的指数并包含多个子句">计算指定field key对应的field value的指数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 exp
----                 ---
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:15:00Z 1.3733829795401763e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-11"><a class="header" href="#高级语法-11">高级语法</a></h4>
<pre><code>SELECT EXP(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的指数。</p>
<p>EXP()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-35"><a class="header" href="#示例-35">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的指数"><a class="header" href="#计算平均值的指数">计算平均值的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 9.880299856396672e+23
2021-09-18T00:12:00Z 6.837671229762744e+30
2021-09-18T00:24:00Z 2.674984780655511e+32
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>EXP()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>.然后，CnosDB计算这些平均值的指数。</p>
<h3 id="floor"><a class="header" href="#floor">FLOOR()</a></h3>
<p>返回小于指定值的最大整数。</p>
<h4 id="基本语法-12"><a class="header" href="#基本语法-12">基本语法</a></h4>
<pre><code>SELECT FLOOR( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>FLOOR(field_key)</code>返回field key对应的小于field value的最大整数。</p>
<p><code>FLOOR(*)</code>返回在measurement中每个field key对应的小于field value的最大整数。</p>
<p><code>FLOOR()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>FLOOR()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-36"><a class="header" href="#示例-36">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数">计算指定field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的小于field value的最大整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的小于field-value的最大整数"><a class="header" href="#计算measurement中每个field-key对应的小于field-value的最大整数">计算measurement中每个field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor_pressure floor_temperature floor_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的小于field value的最大整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数并包含多个子句"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数并包含多个子句">计算指定field key对应的小于field value的最大整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 floor
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的小于field value的最大整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-12"><a class="header" href="#高级语法-12">高级语法</a></h4>
<pre><code>SELECT FLOOR(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>FLOOR()</code>应用于这些结果。</p>
<p><code>FLOOR()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算小于平均值的最大整数"><a class="header" href="#计算小于平均值的最大整数">计算小于平均值的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的小于<code>temperature</code>平均值的最大整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>FLOOR()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算小于这些平均值的最大整数。</p>
</li>
<li>
<h3 id="ln"><a class="header" href="#ln">LN()</a></h3>
<p>返回field value的自然对数。</p>
<h4 id="基本语法-13"><a class="header" href="#基本语法-13">基本语法</a></h4>
<pre><code>SELECT LN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LN(field_key)</code>返回field key对应的field value的自然对数。</p>
<p><code>LN(*)</code>返回在measurement中每个field key对应的field value的自然对数。</p>
<p><code>LN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-37"><a class="header" href="#示例-37">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.86.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数"><a class="header" href="#计算指定field-key对应的field-value的自然对数">计算指定field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 3.9318256327243257
2021-09-18T00:03:00Z 4.0943445622221
2021-09-18T00:06:00Z 4.007333185232471
2021-09-18T00:09:00Z 4.007333185232471
2021-09-18T00:12:00Z 4.143134726391533
2021-09-18T00:15:00Z 4.304065093204169
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:27:00Z 4.3694478524670215
2021-09-18T00:30:00Z 4.31748811353631
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的自然对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的自然对数">计算measurement中每个field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln_pressure        ln_temperature     ln_visibility
----                 -----------        --------------     -------------
2021-09-18T00:00:00Z 4.1588830833596715 3.9318256327243257 4.219507705176107
2021-09-18T00:03:00Z 4.276666119016055  4.0943445622221    4.304065093204169
2021-09-18T00:06:00Z 3.9889840465642745 4.007333185232471  4.343805421853684
2021-09-18T00:09:00Z 4.189654742026425  4.007333185232471  4.007333185232471
2021-09-18T00:12:00Z 4.1588830833596715 4.143134726391533  4.248495242049359
2021-09-18T00:15:00Z 4.060443010546419  4.304065093204169  4.127134385045092
2021-09-18T00:18:00Z 4.007333185232471  4.3694478524670215 3.9889840465642745
2021-09-18T00:21:00Z 4.1588830833596715 4.219507705176107  4.060443010546419
2021-09-18T00:24:00Z 4.189654742026425  4.248495242049359  4.23410650459726
2021-09-18T00:27:00Z 4.343805421853684  4.3694478524670215 4.356708826689592
2021-09-18T00:30:00Z 4.127134385045092  4.31748811353631   4.382026634673881
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的自然对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的自然对数并包含多个子句">计算指定field key对应的field value的自然对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ln
----                 --
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:15:00Z 4.304065093204169
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-13"><a class="header" href="#高级语法-13">高级语法</a></h4>
<pre><code>SELECT LN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个 GROUP BY time() <code>和一个嵌套的cnosQL 函数. 该查询受限以指定</code>GROUP BY time()<code>间隔计算嵌套函数的结果 </code>LN()` .</p>
<p>LN()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-38"><a class="header" href="#示例-38">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的自然对数"><a class="header" href="#计算平均值的自然对数">计算平均值的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 4.0118683403978626
2021-09-18T00:12:00Z 4.2626798770413155
2021-09-18T00:24:00Z 4.31303376318693
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的自然对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的自然对数。</p>
</li>
<li>
<h3 id="log"><a class="header" href="#log">LOG()</a></h3>
<p>返回field value的以<code>b</code>为底数的对数。</p>
<h4 id="基本语法-14"><a class="header" href="#基本语法-14">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG( [ * | &lt;field_key&gt; ], &lt;b&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG(field_key, b)</code>返回field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG(*, b)</code>返回在measurement中每个field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.87.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数">计算指定field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.836212670985748
2021-09-18T00:03:00Z 2.9534452978042594
2021-09-18T00:06:00Z 2.89067985676233
2021-09-18T00:09:00Z 2.89067985676233
2021-09-18T00:12:00Z 2.9886399617499584
2021-09-18T00:15:00Z 3.1047266828144746
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:27:00Z 3.1518903740885515
2021-09-18T00:30:00Z 3.11440934524794
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以4为底数的对数">计算measurement中每个field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log_pressure       log_temperature    log_visibility
----                 ------------       ---------------    --------------
2021-09-18T00:00:00Z 3                  2.836212670985748  3.04373142062517
2021-09-18T00:03:00Z 3.084962500721156  2.9534452978042594 3.1047266828144746
2021-09-18T00:06:00Z 2.8774437510817346 2.89067985676233   3.133393270347451
2021-09-18T00:09:00Z 3.0221970596792267 2.89067985676233   2.89067985676233
2021-09-18T00:12:00Z 3                  2.9886399617499584 3.0646415084724836
2021-09-18T00:15:00Z 2.928990497563786  3.1047266828144746 2.977098155193438
2021-09-18T00:18:00Z 2.89067985676233   3.1518903740885515 2.8774437510817346
2021-09-18T00:21:00Z 3                  3.04373142062517   2.928990497563786
2021-09-18T00:24:00Z 3.0221970596792267 3.0646415084724836 3.054262228389085
2021-09-18T00:27:00Z 3.133393270347451  3.1518903740885515 3.1427011094311244
2021-09-18T00:30:00Z 2.977098155193438  3.11440934524794   3.160964047443681
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以4为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数并包含多个子句">计算指定field key对应的field value的以4为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log
----                 ---
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:15:00Z 3.1047266828144746
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-14"><a class="header" href="#高级语法-14">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;b&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的对数。</p>
<p><code>LOG()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以4为底数的对数"><a class="header" href="#计算平均值的以4为底数的对数">计算平均值的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.8939512796957163
2021-09-18T00:12:00Z 3.074873559752341
2021-09-18T00:24:00Z 3.1111962106682243
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以4为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以4为底数的对数。</p>
</li>
<li>
<h3 id="log2"><a class="header" href="#log2">LOG2()</a></h3>
<p>返回field value的以2为底数的对数。</p>
<h4 id="基本语法-15"><a class="header" href="#基本语法-15">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG2( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG2(field_key)</code>返回field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2(*)</code>返回在measurement中每个field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG2()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.88.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数">计算指定field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.672425341971495
2021-09-18T00:03:00Z 5.906890595608519
2021-09-18T00:06:00Z 5.78135971352466
2021-09-18T00:09:00Z 5.78135971352466
2021-09-18T00:12:00Z 5.977279923499917
2021-09-18T00:15:00Z 6.20945336562895
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:27:00Z 6.303780748177103
2021-09-18T00:30:00Z 6.22881869049588
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以2为底数的对数">计算measurement中每个field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2_pressure     log2_temperature  log2_visibility
----                 -------------     ----------------  ---------------
2021-09-18T00:00:00Z 6                 5.672425341971495 6.087462841250339
2021-09-18T00:03:00Z 6.169925001442312 5.906890595608519 6.20945336562895
2021-09-18T00:06:00Z 5.754887502163468 5.78135971352466  6.266786540694901
2021-09-18T00:09:00Z 6.044394119358453 5.78135971352466  5.78135971352466
2021-09-18T00:12:00Z 6                 5.977279923499917 6.129283016944966
2021-09-18T00:15:00Z 5.857980995127572 6.20945336562895  5.954196310386875
2021-09-18T00:18:00Z 5.78135971352466  6.303780748177103 5.754887502163468
2021-09-18T00:21:00Z 6                 6.087462841250339 5.857980995127572
2021-09-18T00:24:00Z 6.044394119358453 6.129283016944966 6.108524456778169
2021-09-18T00:27:00Z 6.266786540694901 6.303780748177103 6.285402218862249
2021-09-18T00:30:00Z 5.954196310386875 6.22881869049588  6.321928094887363
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以2为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数并包含多个子句">计算指定field key对应的field value的以2为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log2
----                 ----
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:15:00Z 6.20945336562895
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-15"><a class="header" href="#高级语法-15">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG2(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以2为底数的对数。</p>
<p><code>LOG2()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以2为底数的对数"><a class="header" href="#计算平均值的以2为底数的对数">计算平均值的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.787902559391432
2021-09-18T00:12:00Z 6.149747119504682
2021-09-18T00:24:00Z 6.222392421336448
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以2为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以2为底数的对数。</p>
</li>
<li>
<h3 id="log10"><a class="header" href="#log10">LOG10()</a></h3>
<p>返回field value的以10为底数的对数。</p>
<h4 id="基本语法-16"><a class="header" href="#基本语法-16">基本语法</a></h4>
<pre><code>SELECT LOG10( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG10(field_key)</code>返回field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10(*)</code>返回在measurement中每个field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG10()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.89.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数">计算指定field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7075701760979363
2021-09-18T00:03:00Z 1.7781512503836434
2021-09-18T00:06:00Z 1.7403626894942439
2021-09-18T00:09:00Z 1.7403626894942439
2021-09-18T00:12:00Z 1.7993405494535817
2021-09-18T00:15:00Z 1.869231719730976
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:27:00Z 1.8976270912904414
2021-09-18T00:30:00Z 1.8750612633916999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以10为底数的对数">计算measurement中每个field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10_pressure     log10_temperature  log10_visibility
----                 --------------     -----------------  ----------------
2021-09-18T00:00:00Z 1.806179973983887  1.7075701760979363 1.8325089127062364
2021-09-18T00:03:00Z 1.8573324964312685 1.7781512503836434 1.869231719730976
2021-09-18T00:06:00Z 1.7323937598229686 1.7403626894942439 1.8864907251724818
2021-09-18T00:09:00Z 1.8195439355418686 1.7403626894942439 1.7403626894942439
2021-09-18T00:12:00Z 1.806179973983887  1.7993405494535817 1.845098040014257
2021-09-18T00:15:00Z 1.7634279935629371 1.869231719730976  1.792391689498254
2021-09-18T00:18:00Z 1.7403626894942439 1.8976270912904414 1.7323937598229686
2021-09-18T00:21:00Z 1.806179973983887  1.8325089127062364 1.7634279935629371
2021-09-18T00:24:00Z 1.8195439355418686 1.845098040014257  1.8388490907372554
2021-09-18T00:27:00Z 1.8864907251724818 1.8976270912904414 1.8920946026904804
2021-09-18T00:30:00Z 1.792391689498254  1.8750612633916999 1.9030899869919433
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以10为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数并包含多个子句">计算指定field key对应的field value的以10为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log10
----                 -----
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:15:00Z 1.869231719730976
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-16"><a class="header" href="#高级语法-16">高级语法</a></h4>
<pre><code>SELECT LOG10(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以10为底数的对数。</p>
<p><code>LOG10()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以10为底数的对数"><a class="header" href="#计算平均值的以10为底数的对数">计算平均值的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7423322823571483
2021-09-18T00:12:00Z 1.8512583487190752
2021-09-18T00:24:00Z 1.8731267636145004
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以10为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG10()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以10为底数的对数。</p>
</li>
<li>
<h3 id="moving_average"><a class="header" href="#moving_average">MOVING_AVERAGE()</a></h3>
<p>返回field value窗口的滚动平均值。</p>
<h4 id="基本语法-17"><a class="header" href="#基本语法-17">基本语法</a></h4>
<pre><code class="language-sql">SELECT MOVING_AVERAGE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] , &lt;N&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MOVING_AVERAGE()</code>计算包含<code>N</code>个连续field value的窗口的滚动平均值。参数<code>N</code>是一个整数，并且它是必须的。</p>
<p><code>MOVING_AVERAGE(field_key,N)</code>返回field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(*,N)</code>返回在measurement中每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>MOVING_AVERAGE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值">计算指定field key对应的field value的滚动平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average
----                 --------------
2021-09-18T00:03:00Z 55.5
2021-09-18T00:06:00Z 57.5
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 59
2021-09-18T00:15:00Z 68.5
2021-09-18T00:18:00Z 76.5
2021-09-18T00:21:00Z 73.5
2021-09-18T00:24:00Z 69
2021-09-18T00:27:00Z 74.5
2021-09-18T00:30:00Z 77
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值。第一个结果(<code>2.09</code>)是原始数据中前两个field value的平均值：(2.064 + 2.116) / 2。第二个结果(<code>2.072</code>)是原始数据中第二和第三个field value的平均值：(2.116 + 2.028) / 2。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的滚动平均值">计算measurement中每个field key对应的field value的滚动平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(*,3) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure moving_average_temperature moving_average_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:06:00Z 63.333333333333336      55.333333333333336         73
2021-09-18T00:09:00Z 64                      56.666666666666664         68.66666666666667
2021-09-18T00:12:00Z 61.333333333333336      57.666666666666664         67.33333333333333
2021-09-18T00:15:00Z 62.666666666666664      64                         62.333333333333336
2021-09-18T00:18:00Z 59                      72                         62
2021-09-18T00:21:00Z 59                      73.66666666666667          58
2021-09-18T00:24:00Z 61.666666666666664      72.33333333333333          60.333333333333336
2021-09-18T00:27:00Z 69                      72.33333333333333          68.33333333333333
2021-09-18T00:30:00Z 68.33333333333333       74.66666666666667          75.66666666666667
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的窗口大小为三个field value的滚动平均值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值">计算与正则表达式匹配的每个field key对应的field value的滚动平均值</a></h4>
</li>
</ul>
<pre><code>&gt; SELECT MOVING_AVERAGE(/press/,4) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure
----                 -----------------------
2021-09-18T00:09:00Z 64
2021-09-18T00:12:00Z 64
2021-09-18T00:15:00Z 60.5
2021-09-18T00:18:00Z 60.75
2021-09-18T00:21:00Z 60.25
2021-09-18T00:24:00Z 60.75
2021-09-18T00:27:00Z 65.5
2021-09-18T00:30:00Z 67.25
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>level</code>的field key对应的窗口大小为四个field value的滚动平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值并包含多个子句">计算指定field key对应的field value的滚动平均值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 2 OFFSET 3
name: air
time                 moving_average
----                 --------------
2021-09-18T00:18:00Z 73.5
2021-09-18T00:15:00Z 76.5
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移三个(即前三个<code>point</code>不返回）。</p>
</li>
</ul>
<h4 id="高级语法-17"><a class="header" href="#高级语法-17">高级语法</a></h4>
<pre><code>SELECT MOVING_AVERAGE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) , N ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算最大值的滚动平均值"><a class="header" href="#计算最大值的滚动平均值">计算最大值的滚动平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(MAX(&quot;temperature&quot;),2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 moving_average
----                 --------------
2021-09-18T00:00:00Z 69.5
2021-09-18T00:12:00Z 69.5
2021-09-18T00:24:00Z 79
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的最大值的窗口大小为两个值的滚动平均值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>MOVING_AVERAGE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值的窗口大小为两个值的滚动平均值。最终查询结果中的第一个<code>point</code>(<code>2.121</code>)是前两个最大值的平均值(<code>(2.116 + 2.126) / 2</code>)。</p>
<ul>
<li>
<h3 id="non_negative_derivative"><a class="header" href="#non_negative_derivative">NON_NEGATIVE_DERIVATIVE()</a></h3>
<p>返回field value之间的非负变化率。非负变化率包括正的变化率和等于0的变化率。</p>
<h4 id="基本语法-18"><a class="header" href="#基本语法-18">基本语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(field_key)</code>返回field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
<h4 id="高级语法-18"><a class="header" href="#高级语法-18">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的非负导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a>
####示例</li>
</ul>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
</li>
<li>
<h3 id="non_negative_difference"><a class="header" href="#non_negative_difference">NON_NEGATIVE_DIFFERENCE()</a></h3>
<p>返回field value之间的非负差值。非负差值包括正的差值和等于0的差值。</p>
<h4 id="基本语法-19"><a class="header" href="#基本语法-19">基本语法</a></h4>
<pre><code>SELECT NON_NEGATIVE_DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>NON_NEGATIVE_DIFFERENCE(field_key)</code>返回field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
<h4 id="高级语法-19"><a class="header" href="#高级语法-19">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的非负差值。</p>
<p>`NON_NEGATIVE_DIFFERENCE()支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
</li>
<li>
<h3 id="pow"><a class="header" href="#pow">POW()</a></h3>
<p>返回field value的<code>x</code>次方。</p>
<h4 id="基本语法-20"><a class="header" href="#基本语法-20">基本语法</a></h4>
<pre><code>SELECT POW( [ * | &lt;field_key&gt; ], &lt;x&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>POW(field_key, x)</code>返回field key对应的field value的<code>x</code>次方。</p>
<p><code>POW(*, x)</code>返回在measurement中每个field key对应的field value的<code>x</code>次方。</p>
<p><code>POW()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>POW()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.90.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方"><a class="header" href="#计算指定field-key对应的field-value的4次方">计算指定field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 6765201
2021-09-18T00:03:00Z 12960000
2021-09-18T00:06:00Z 9150625
2021-09-18T00:09:00Z 9150625
2021-09-18T00:12:00Z 15752961
2021-09-18T00:15:00Z 29986576
2021-09-18T00:18:00Z 38950081
2021-09-18T00:21:00Z 21381376
2021-09-18T00:24:00Z 24010000
2021-09-18T00:27:00Z 38950081
2021-09-18T00:30:00Z 31640625
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的4次方"><a class="header" href="#计算measurement中每个field-key对应的field-value的4次方">计算measurement中每个field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow_pressure pow_temperature pow_visibility
----                 ------------ --------------- --------------
2021-09-18T00:00:00Z 16777216     6765201         21381376
2021-09-18T00:03:00Z 26873856     12960000        29986576
2021-09-18T00:06:00Z 8503056      9150625         35153041
2021-09-18T00:09:00Z 18974736     9150625         9150625
2021-09-18T00:12:00Z 16777216     15752961        24010000
2021-09-18T00:15:00Z 11316496     29986576        14776336
2021-09-18T00:18:00Z 9150625      38950081        8503056
2021-09-18T00:21:00Z 16777216     21381376        11316496
2021-09-18T00:24:00Z 18974736     24010000        22667121
2021-09-18T00:27:00Z 35153041     38950081        37015056
2021-09-18T00:30:00Z 14776336     31640625        40960000
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的4次方。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的4次方并包含多个子句">计算指定field key对应的field value的4次方并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 pow
----                 ---
2021-09-18T00:24:00Z 24010000
2021-09-18T00:21:00Z 21381376
2021-09-18T00:18:00Z 38950081
2021-09-18T00:15:00Z 29986576
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-20"><a class="header" href="#高级语法-20">高级语法</a></h4>
<pre><code class="language-sql">SELECT POW(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;x&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的<code>x</code>次方。</p>
<p><code>POW()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的4次方"><a class="header" href="#计算平均值的4次方">计算平均值的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 9318137.81640625
2021-09-18T00:12:00Z 25411681
2021-09-18T00:24:00Z 31081863.901234582
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的4次方。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>POW()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的4次方。</p>
</li>
<li>
<h3 id="round"><a class="header" href="#round">ROUND()</a></h3>
<p>返回指定值的四舍五入后的整数。</p>
<h4 id="基本语法-21"><a class="header" href="#基本语法-21">基本语法</a></h4>
<pre><code>SELECT ROUND( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ROUND(field_key)</code>返回field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND(*)</code>返回在measurement中每个field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ROUND()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.91.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数">计算指定field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算measurement中每个field-key对应的field-value四舍五入后的整数">计算measurement中每个field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round_pressure round_temperature round_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数并包含多个子句">计算指定field key对应的field value四舍五入后的整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 round
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-21"><a class="header" href="#高级语法-21">高级语法</a></h4>
<pre><code class="language-sql">SELECT ROUND(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果四舍五入后的整数。</p>
<p><code>ROUND()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值四舍五入后的整数"><a class="header" href="#计算平均值四舍五入后的整数">计算平均值四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值四舍五入后的整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ROUND()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值四舍五入后的整数。</p>
</li>
<li>
<h3 id="sin"><a class="header" href="#sin">SIN()</a></h3>
<p>返回field value的正弦值。</p>
<h4 id="基本语法-22"><a class="header" href="#基本语法-22">基本语法</a></h4>
<pre><code class="language-sql">SELECT SIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SIN(field_key)</code>返回field key对应的field value的正弦值。</p>
<p><code>SIN(*)</code>返回在measurement中每个field key对应的field value的正弦值。</p>
<p><code>SIN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SIN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值"><a class="header" href="#计算指定field-key对应的field-value的正弦值">计算指定field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z 0.6702291758433747
2021-09-18T00:03:00Z -0.3048106211022167
2021-09-18T00:06:00Z -0.9997551733586199
2021-09-18T00:09:00Z -0.9997551733586199
2021-09-18T00:12:00Z 0.16735570030280694
2021-09-18T00:15:00Z -0.9851462604682474
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:27:00Z -0.4441126687075084
2021-09-18T00:30:00Z -0.38778163540943045
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正弦值">计算measurement中每个field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin_pressure          sin_temperature      sin_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.9200260381967907    0.6702291758433747   -0.8979276806892912
2021-09-18T00:03:00Z 0.25382336276203626   -0.3048106211022167  -0.9851462604682474
2021-09-18T00:06:00Z -0.5587890488516162   -0.9997551733586199  0.9995201585807312
2021-09-18T00:09:00Z -0.026551154023966794 -0.9997551733586199  -0.9997551733586199
2021-09-18T00:12:00Z 0.9200260381967907    0.16735570030280694  0.7738906815578891
2021-09-18T00:15:00Z 0.9928726480845371    -0.9851462604682474  -0.7391806966492229
2021-09-18T00:18:00Z -0.9997551733586199   -0.4441126687075084  -0.5587890488516162
2021-09-18T00:21:00Z 0.9200260381967907    -0.8979276806892912  0.9928726480845371
2021-09-18T00:24:00Z -0.026551154023966794 0.7738906815578891   -0.11478481378318722
2021-09-18T00:27:00Z 0.9995201585807312    -0.4441126687075084  0.5139784559875352
2021-09-18T00:30:00Z -0.7391806966492229   -0.38778163540943045 -0.9938886539233751
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正弦值并包含多个子句">计算指定field key对应的field value的正弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sin
----                 ---
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:15:00Z -0.9851462604682474
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-22"><a class="header" href="#高级语法-22">高级语法</a></h4>
<pre><code class="language-sql">SELECT SIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正弦值。</p>
<p><code>SIN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值"><a class="header" href="#计算平均值的正弦值">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z -0.9632009590319781
2021-09-18T00:12:00Z 0.9510546532543747
2021-09-18T00:24:00Z -0.6680290772524845
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正弦值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正弦值。</p>
</li>
<li>
<h3 id="sqrt"><a class="header" href="#sqrt">SQRT()</a></h3>
<p>返回field value的平方根。</p>
<h4 id="基本语法-23"><a class="header" href="#基本语法-23">基本语法</a></h4>
<pre><code>SELECT SQRT( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SQRT(field_key)</code>返回field key对应的field value的平方根。</p>
<p><code>SQRT(*)</code>返回在measurement中每个field key对应的field value的平方根。</p>
<p><code>SQRT()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SQRT()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用”oceanic_station”数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根"><a class="header" href="#计算指定field-key对应的field-value的平方根">计算指定field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.14142842854285
2021-09-18T00:03:00Z 7.745966692414834
2021-09-18T00:06:00Z 7.416198487095663
2021-09-18T00:09:00Z 7.416198487095663
2021-09-18T00:12:00Z 7.937253933193772
2021-09-18T00:15:00Z 8.602325267042627
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:27:00Z 8.888194417315589
2021-09-18T00:30:00Z 8.660254037844387
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平方根"><a class="header" href="#计算measurement中每个field-key对应的field-value的平方根">计算measurement中每个field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt_pressure      sqrt_temperature  sqrt_visibility
----                 -------------      ----------------  ---------------
2021-09-18T00:00:00Z 8                  7.14142842854285  8.246211251235321
2021-09-18T00:03:00Z 8.48528137423857   7.745966692414834 8.602325267042627
2021-09-18T00:06:00Z 7.3484692283495345 7.416198487095663 8.774964387392123
2021-09-18T00:09:00Z 8.12403840463596   7.416198487095663 7.416198487095663
2021-09-18T00:12:00Z 8                  7.937253933193772 8.366600265340756
2021-09-18T00:15:00Z 7.615773105863909  8.602325267042627 7.874007874011811
2021-09-18T00:18:00Z 7.416198487095663  8.888194417315589 7.3484692283495345
2021-09-18T00:21:00Z 8                  8.246211251235321 7.615773105863909
2021-09-18T00:24:00Z 8.12403840463596   8.366600265340756 8.306623862918075
2021-09-18T00:27:00Z 8.774964387392123  8.888194417315589 8.831760866327848
2021-09-18T00:30:00Z 7.874007874011811  8.660254037844387 8.94427190999916
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的平方根。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平方根并包含多个子句">计算指定field key对应的field value的平方根并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sqrt
----                 ----
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:15:00Z 8.602325267042627
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-23"><a class="header" href="#高级语法-23">高级语法</a></h4>
<pre><code>SELECT SQRT(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的平方根。</p>
<p><code>SQRT()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的平方根"><a class="header" href="#计算平均值的平方根">计算平均值的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.433034373659253
2021-09-18T00:12:00Z 8.426149773176359
2021-09-18T00:24:00Z 8.640987597877148
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的平方根。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SQRT()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的平方根。</p>
</li>
<li>
<h3 id="tan"><a class="header" href="#tan">TAN()</a></h3>
<p>返回field value的正切值。</p>
<h4 id="基本语法-24"><a class="header" href="#基本语法-24">基本语法</a></h4>
<pre><code>SELECT TAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TAN(field_key)</code>返回field key对应的field value的正切值。</p>
<p><code>TAN(*)</code>返回在measurement中每个field key对应的field value的正切值。</p>
<p><code>TAN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>TAN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值"><a class="header" href="#计算指定field-key对应的field-value的正切值">计算指定field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z 0.9030861493754311
2021-09-18T00:03:00Z 0.320040389379563
2021-09-18T00:06:00Z -45.18308791052113
2021-09-18T00:09:00Z -45.18308791052113
2021-09-18T00:12:00Z 0.16974975208268753
2021-09-18T00:15:00Z -5.737022539278999
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:27:00Z 0.49567753318135577
2021-09-18T00:30:00Z -0.42070095062112434
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正切值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正切值">计算measurement中每个field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan_pressure         tan_temperature      tan_visibility
----                 ------------         ---------------      --------------
2021-09-18T00:00:00Z 2.3478603091954366   0.9030861493754311   -2.040081598015946
2021-09-18T00:03:00Z -0.26241737750193517 0.320040389379563    -5.737022539278999
2021-09-18T00:06:00Z 0.6738001006480597   -45.18308791052113   -32.268575775934416
2021-09-18T00:09:00Z 0.026560517776039395 -45.18308791052113   -45.18308791052113
2021-09-18T00:12:00Z 2.3478603091954366   0.16974975208268753  1.2219599181369432
2021-09-18T00:15:00Z 8.33085685249046     -5.737022539278999   -1.0975097786622852
2021-09-18T00:18:00Z -45.18308791052113   0.49567753318135577  0.6738001006480597
2021-09-18T00:21:00Z 2.3478603091954366   -2.040081598015946   8.33085685249046
2021-09-18T00:24:00Z 0.026560517776039395 1.2219599181369432   -0.11554854579453279
2021-09-18T00:27:00Z -32.268575775934416  0.49567753318135577  -0.5991799983411151
2021-09-18T00:30:00Z -1.0975097786622852  -0.42070095062112434 9.00365494560708
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正切值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正切值并包含多个子句">计算指定field key对应的field value的正切值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 tan
----                 ---
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:15:00Z -5.737022539278999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-24"><a class="header" href="#高级语法-24">高级语法</a></h4>
<pre><code class="language-sql">SELECT TAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的cnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正切值。</p>
<p><code>TAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值-1"><a class="header" href="#计算平均值的正弦值-1">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z -3.583573177439047
2021-09-18T00:12:00Z -3.0776204031933605
2021-09-18T00:24:00Z -0.8977254452596822
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正切值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>TAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正切值。</p>
</li>
</ul>
<h3 id="预测函数"><a class="header" href="#预测函数">预测函数</a></h3>
<ul>
<li>
<h3 id="holt_winters"><a class="header" href="#holt_winters">HOLT_WINTERS()</a></h3>
<ul>
<li>
<p>使用<a href="https://www.otexts.org/fpp/7/5?spm=a2c4g.11186623.2.92.41fc3ee27HC1R6">Holt-Winters</a>的季节性方法返回N个预测的field value。</p>
<p><code>HOLT_WINTERS()</code>可用于：</p>
<ul>
<li>预测时间什么时候会超过给定的阈值</li>
<li>将预测值与实际值进行比较，检测数据中的异常</li>
</ul>
</li>
</ul>
<h4 id="语法-19"><a class="header" href="#语法-19">语法</a></h4>
<pre><code>SELECT HOLT_WINTERS[_WITH-FIT](&lt;function&gt;(&lt;field_key&gt;),&lt;N&gt;,&lt;S&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>HOLT_WINTERS(function(field_key),N,S)</code>返回field key对应的<code>N</code>个季节性调整的预测field value。</p>
<p><code>N</code>个预测值出现的时间间隔跟group by time时间间隔相同。如果您的<code>GROUP BY time()</code>时间间隔是<code>6m</code>并且<code>N</code>等于<code>3</code>，那么您将会得到3个时间间隔为6分钟的预测值。</p>
<p><code>S</code>是一个季节性模式参数，并且根据<code>GROUP BY time()</code>时间间隔限定一个季节性模式的长度。如果您的<code>GROUP BY time()</code>时间间隔是<code>2m</code>并且<code>S</code>等于<code>3</code>，那么这个季节性模式每六分钟出现一次，也就是每三个<code>point</code>。如果您不希望季节性调整您的预测值，请将<code>S</code>设置为<code>0</code>或<code>1</code>。</p>
<p><code>HOLT_WINTERS_WITH_FIT(function(field_key),N,S)</code>除了返回field key对应的<code>N</code>个季节性调整的预测field value，还返回拟合值。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>处理以相同的时间间隔出现的数据；嵌套的cnosQL函数和<code>GROUP BY time()</code>子句确保Holt-Winters函数能够对常规数据进行操作。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-39"><a class="header" href="#示例-39">示例</a></h4>
<ul>
<li>
<h4 id="预测指定field-key的field-value"><a class="header" href="#预测指定field-key的field-value">预测指定field key的field value</a></h4>
</li>
<li>
<h4 id="原始数据"><a class="header" href="#原始数据">原始数据</a></h4>
</li>
</ul>
<p>该示例重点关注<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">SELECT &quot;temperature&quot; FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00'
</code></pre>
<ul>
<li>
<h4 id="步骤一匹配原始数据的趋势"><a class="header" href="#步骤一匹配原始数据的趋势">步骤一：匹配原始数据的趋势</a></h4>
</li>
</ul>
<p>编写一个<code>GROUP BY time()</code>查询，使得它匹配原始<code>temperature</code>数据的总体趋势。这里，我们使用了<code>FIRST()</code>函数：</p>
<pre><code class="language-sql">SELECT FIRST(&quot;temperature&quot;) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' and time &gt;= '2021-09-12 12:12:00' and time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>GROUP BY time()</code>子句中，第一个参数(<code>379m</code>)匹配<code>temperature</code>数据中每个波峰和波谷之间发生的时间长度，第二个参数(<code>348m</code>)是一个偏移间隔，它通过改变CnosDB的默认<code>GROUP BY time()</code>边界来匹配原始数据的时间范围。</p>
<ul>
<li>
<h4 id="步骤二确定季节性模式"><a class="header" href="#步骤二确定季节性模式">步骤二：确定季节性模式</a></h4>
</li>
</ul>
<p>使用步骤一中查询的信息确定数据中的季节性模式。</p>
<ul>
<li>
<h4 id="步骤三应用holt_winters函数"><a class="header" href="#步骤三应用holt_winters函数">步骤三：应用<code>HOLT_WINTERS()</code>函数</a></h4>
</li>
</ul>
<p>在查询中加入Holt-Winters函数。这里，我们使用<code>HOLT_WINTERS_WITH_FIT()</code>来查看拟合值和预测值：</p>
<pre><code class="language-sql">SELECT HOLT_WINTERS_WITH_FIT(FIRST(&quot;temperature&quot;),10,4) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>HOLT_WINTERS_WITH_FIT()</code>函数中，第一个参数(<code>10</code>)请求10个预测的field value。每个预测的<code>point</code>相距<code>379m</code>，与<code>GROUP BY time()</code>子句中的第一个参数相同。<code>HOLT_WINTERS_WITH_FIT()</code>函数中的第二个参数(<code>4</code>)是我们在上一步骤中确定的季节性模式。</p>
<h4 id="holt_winters的常见问题"><a class="header" href="#holt_winters的常见问题"><code>HOLT_WINTERS()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="holt_winters和收到的point少于n个"><a class="header" href="#holt_winters和收到的point少于n个"><code>HOLT_WINTERS()</code>和收到的<code>point</code>少于”N”个</a></h4>
</li>
</ul>
<p>在某些情况下，用户可能会收到比参数<code>N</code>请求的更少的预测<code>point</code>。当数学计算不稳定和不能预测更多<code>point</code>时，这种情况就会发生。这意味着该数据集不适合使用<code>HOLT_WINTERS()</code>，或者，季节性调整参数是无效的并且是算法混乱。</p>
</li>
</ul>
<h3 id="分析函数"><a class="header" href="#分析函数">分析函数</a></h3>
<p>下面技术分析的函数将广泛使用的算法应用在您的数据中。虽然这些函数主要应用在金融和投资领域，但是它们也适用于其它行业和用例。</p>
<p><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></p>
<p><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></p>
<p><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></p>
<p><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></p>
<p><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></p>
<ul>
<li>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>除了field key，技术分析函数还接受以下参数：</p>
<p><code>PERIOD</code></p>
<p><strong>必需，整数，min=1</strong></p>
<p>算法的样本大小。这基本上是对算法的输出有显著影响的历史样本的数量。例如，<code>2</code>表示当前的<code>point</code>和前一个<code>point</code>。算法使用指数衰减率来决定历史<code>point</code>的权重，通常称为<code>alpha(α)</code>。参数<code>PERIOD</code>控制衰减率。</p>
<blockquote>
<p>请注意，历史<code>point</code>仍然可以产生影响。</p>
</blockquote>
<h4 id="hold_period"><a class="header" href="#hold_period">HOLD_PERIOD</a></h4>
<p><strong>整数，min=-1</strong></p>
<p>算法需要多少个样本才会开始发送结果。默认值<code>-1</code>表示该参数的值基于算法、<code>PERIOD</code>和<code>WARMUP_TYPE</code>，但是这是一个可以使算法发送有意义的结果的值。</p>
<p><strong>默认的Hold Periods：</strong></p>
<p>对于大多数提供的技术分析，<code>HOLD_PERIOD</code>的默认值由您使用的技术分析算法和<code>WARMUP_TYPE</code>决定。</p>
</li>
</ul>
<table><thead><tr><th>算法 \ Warmup Type</th><th>simple</th><th>exponential</th><th style="text-align: center">none</th></tr></thead><tbody>
<tr><td><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE</a></td><td>PERIOD - 1</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 2</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 3</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE</a></td><td>( PERIOD - 1 ) * 3 + 1</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center">PERIOD - 1</td></tr>
</tbody></table>
<p><em><strong>Kaufman算法默认的Hold Periods：</strong></em></p>
<table><thead><tr><th>算法</th><th>默认的Hold Period</th></tr></thead><tbody>
<tr><td><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></td><td>PERIOD</td></tr>
<tr><td><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></td><td>PERIOD</td></tr>
</tbody></table>
<h4 id="warmup_type"><a class="header" href="#warmup_type">WARMUP_TYPE</a></h4>
<p><strong>默认=”exponential”</strong></p>
<p>这个参数控制算法如何为第一个<code>PERIOD</code>样本初始化自身，它本质上是具有不完整样本集的持续时间。</p>
<p><code>simple</code>
第一个<code>PERIOD</code>样本的简单移动平均值(simple moving average，SMA)。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.106.41fc3ee27HC1R6">ta-lib</a>使用的方法。</p>
<p><code>exponential</code>
具有缩放alpha(α)的指数移动平均值(exponential moving average，EMA)。基本上是这样使用EMA：<code>PERIOD=1</code>用于第一个点，<code>PERIOD=2</code>用于第二个点，以此类推，直至算法已经消耗了<code>PERIOD</code>个<code>point</code>。由于算法一开始就使用了EMA，当使用此方法并且没有指定<code>HOLD_PERIOD</code>的值或<code>HOLD_PERIOD</code>的值为<code>-1</code>时，算法可能会在比<code>simple</code>小得多的样本大小的情况下开始发送<code>point</code>。</p>
<p><code>none</code>
算法不执行任何的平滑操作。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.107.41fc3ee27HC1R6">ta-lib</a>使用的方法。当使用此方法并且没有指定<code>HOLD_PERIOD</code>时，<code>HOLD_PERIOD</code>的默认值是<code>PERIOD - 1</code>。</p>
<blockquote>
<p>类型<code>none</code>仅适用于<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数。</p>
</blockquote>
<ul>
<li>
<h3 id="chande_momentum_oscillator"><a class="header" href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></h3>
<p>Chande Momentum Oscillator (CMO)是由Tushar Chande开发的一个技术动量指标。通过计算所有最近较高<code>point</code>的总和与所有最近较低<code>point</code>的总和的差值，然后将结果除以给定时间范围内的所有数据变动的总和来创建CMO指标。将结果乘以100可以得到一个从-100到+100的范围。
<sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo" target="\_blank">Source</a></p>
<h4 id="基本语法-25"><a class="header" href="#基本语法-25">基本语法</a></h4>
<pre><code>CHANDE_MOMENTUM_OSCILLATOR([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;, [warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup-type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 2)</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 10, 9, 'none')</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>none</code>。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用CMO算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(/regular_expression/, 2)</code>返回使用CMO算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(*, 2)</code>返回使用CMO算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="exponential_moving_average"><a class="header" href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>指数移动平均值 (Exponential Moving Average，EMA)类似于简单移动平均值，不同的是，指数移动平均值对最新数据给予更多的权重，它也被称为”指数加权移动平均值”。与简单移动平均值相比，这种类型的移动平均值对最近数据的变化反应更快。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/e/ema.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-26"><a class="header" href="#基本语法-26">基本语法</a></h4>
<pre><code>EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用参数:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用EMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用EMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用EMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="double_exponential_moving_average"><a class="header" href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>双重指数移动平均值 (Double Exponential Moving Average，DEMA)通过增加最近数据的权重，尝试消除与移动平均值相关的固有滞后。该名字似乎表明这是通过双重指数平滑来实现的，然而事实并非如此，它表示的是将EMA的值翻倍。为了使它与实际数据保持一致，也为了消除滞后，从之前两倍EMA的值中把”EMA of EMA”的值减去，公式为：DEMA = 2 * EMA - EMA(EMA)。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Double_exponential_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-27"><a class="header" href="#基本语法-27">基本语法</a></h4>
<pre><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用DEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用DEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用DEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="kaufmans_efficiency_ratio"><a class="header" href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></h3>
<p>Kaufman效率比 (Kaufman’s Efficiency Ration)，或简称为效率比 (Efficiency Ratio，ER)，它的计算方法是：将一段时间内的数据变化除以实现该变化所发生的数据变动的绝对值的总和。得出的比率在0和1之间，比率越高，表示市场越有效率或越有趋势。</p>
<p>ER跟Chande Momentum Oscillator (CMO)非常类似。不同的是，CMO将市场方向考虑在内，但是如果您将CMO的绝对值除以100，就可以得到ER。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://etfhq.com/blog/2011/02/07/kaufmans-efficiency-ratio/" target="\_blank">Source</a></p>
<h4 id="基本语法-28"><a class="header" href="#基本语法-28">基本语法</a></h4>
<pre><code class="language-sql">KAUFMANS_EFFICIENCY_RATIO([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 2)</code>返回使用效率指数(Efficiency Index)算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 10, 10)</code>返回使用效率指数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用效率指数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_EFFICIENCY_RATIO()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_EFFICIENCY_RATIO(/regular_expression/, 2)</code>返回使用效率指数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(*, 2)</code>返回使用效率指数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="kaufmans_adaptive_moving_average"><a class="header" href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></h3>
<p>Kaufman自适应移动平均值 (Kaufman’s Adaptive Moving Average，KAMA)，是一个用于计算样本噪音或波动率的移动平均值。当数据波动相对较小并且噪音较低时，KAMA会密切关注<code>point</code>。当数据波动较大时，KAMA会进行调整，平滑噪音。该趋势跟踪指标可用于识别总体趋势、时间转折点和过滤价格变动。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:kaufman_s_adaptive_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-29"><a class="header" href="#基本语法-29">基本语法</a></h4>
<pre><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong>
<a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 2)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 10, 10)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用KAMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用KAMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(*, 2)</code>返回使用KAMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_moving_average"><a class="header" href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>三重指数移动平均值 (Triple Exponential Moving Average，TEMA)，旨在过滤常规移动平均值的波动。该名字似乎表明这是通过三重指数平滑来实现的，然而事实并非如此，它实际上是包含指数移动平均值、双重指数移动平均值和三重指数移动平均值的复合函数。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/t/triple-exponential-moving-average.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-30"><a class="header" href="#基本语法-30">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用TEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用TEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用TEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_derivative"><a class="header" href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></h3>
<p>三重指数导数指标 (Triple Exponential Derivative Indicator)，通常称为”TRIX”，是一种用于识别超卖和超买市场的振荡器，也可用作动量指标。TRIX计算一段时间内输入数据的对数的三重指数移动平均值。从当前的值中减去之前的值，这可以防止指标考虑比规定期间短的周期。</p>
<p>跟很多振荡器一样，TRIX围绕着零线震荡。当它用作振荡器时，正数表示炒买超买市场，而负数表示超卖市场。当它用作动量指标时，正数表示动量在增加，而负数表示动量在减少。很多分析师认为，当TRIX超过零线时，它会给出买入信号，当低于零线时，它会给出卖出信号。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/articles/technical/02/092402.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-31"><a class="header" href="#基本语法-31">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_DERIVATIVE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 2)</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 10, 10, 'exponential')</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用三重指数导数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(/regular_expression/, 2)</code>返回使用三重指数导数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(*, 2)</code>返回使用三重指数导数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="relative_strength_index"><a class="header" href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></h3>
<p>相对强弱指数 (Relative Strength Index，RSI)是一个动量指标，用于比较在指定时间段内最近数据增大和减小的幅度，以便measurement数据变动的速度和变化。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/r/rsi.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-32"><a class="header" href="#基本语法-32">基本语法</a></h4>
<pre><code>RELATIVE_STRENGTH_INDEX([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 2)</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 10, 10, 'exponential')</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>RELATIVE_STRENGTH_INDEX(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用RSI算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>RELATIVE_STRENGTH_INDEX()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>RELATIVE_STRENGTH_INDEX(/regular_expression/, 2)</code>返回使用RSI算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(*, 2)</code>返回使用RSI算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<h4 id="示例数据"><a class="header" href="#示例数据">示例数据</a></h4>
<p>本文档使用的数据可在<a href="oceanic_station.txt">示例数据</a>中下载。</p>
<h4 id="函数的通用语法"><a class="header" href="#函数的通用语法">函数的通用语法</a></h4>
<ul>
<li>
<h4 id="在select中指定多个函数"><a class="header" href="#在select中指定多个函数">在<code>SELECT</code>中指定多个函数</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;(),&lt;function&gt;() FROM_clause [...]
</code></pre>
<p>使用逗号(<code>,</code>)将<code>SELECT</code>语句中的多个函数分开。该语法适用于除<code>TOP()</code>和<code>BOTTOM()</code>之外的所有cnosQL函数。<code>SELECT</code>子句不支持<code>TOP()</code>或<code>BOTTOM()</code>和其它函数同时使用。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的平均值和平均数"><a class="header" href="#在一个查询中计算field-value的平均值和平均数">在一个查询中计算field value的平均值和平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;),MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mean              median
----                 ----              ------
1970-01-01T00:00:00Z 64.94933267424616 65
</code></pre>
<p>该查询返回<code>temperature</code>的平均值和平均数。</p>
<ul>
<li>
<h4 id="在一个查询中计算两个field的mode"><a class="header" href="#在一个查询中计算两个field的mode">在一个查询中计算两个field的mode</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;),MODE(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 mode mode_1
----                 ---- ------
1970-01-01T00:00:00Z 53
</code></pre>
<p>该查询返回<code>temperature</code>中出现频率最高的field value和<code>pressure</code>中出现频率最高的field value。<code>temperature</code>对应的值在列<code>mode</code>中，<code>pressure</code>对应的值在列<code>mode_1</code>中。因为系统不能返回多个具有相同名字的列，所以它将第二个列<code>mode</code>重命名为<code>mode_1</code>。</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的最小值和最大值"><a class="header" href="#在一个查询中计算field-value的最小值和最大值">在一个查询中计算field value的最小值和最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;), MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min max
----                 --- ---
1970-01-01T00:00:00Z 50  80
</code></pre>
<p>该查询返回<code>temperature</code>的最小值和最大值。</p>
<p>请注意，该查询返回<code>1970-01-01T00:00:00Z</code>作为时间戳，这是CnosDB的空时间戳。<code>MIN()</code>和<code>MAX()</code>是selector函数；当selector函数是<code>SELECT</code>子句中的唯一函数时，它返回一个特定的时间戳。因为<code>MIN()</code>和<code>MAX()</code>返回两个不同的时间戳（见下面的例子），所以系统会用空时间戳覆盖这些时间戳。</p>
<pre><code class="language-sql">&gt;  SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  min
----                  ---
2021-08-31T16:18:00Z  50    &lt;--- Timestamp 1

&gt;  SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2021-08-31T18:03:00Z  80    &lt;--- Timestamp 2
</code></pre>
<h4 id="重命名查询结果字段"><a class="header" href="#重命名查询结果字段">重命名查询结果字段</a></h4>
<ul>
<li>
<h4 id="语法-20"><a class="header" href="#语法-20">语法</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;() AS &lt;field_key&gt; [...]
</code></pre>
<p>默认情况下，函数返回的结果在与函数名称匹配的field key下面。使用<code>AS</code>子句可以指定输出的field key的名字。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="指定输出的field-key"><a class="header" href="#指定输出的field-key">指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) AS &quot;dream_name&quot; FROM &quot;air&quot;
name: air
time                  dream_name
----                  ----------
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<p>该查询返回<code>temperature</code>的平均值，并将输出的field key重命名为<code>dream_name</code>。如果没有<code>AS</code>子句，那么查询会返回<code>mean</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  mean
----                  ----
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<ul>
<li>
<h4 id="为多个函数指定输出的field-key"><a class="header" href="#为多个函数指定输出的field-key">为多个函数指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) AS &quot;med_wat&quot;,MODE(&quot;temperature&quot;) AS &quot;mode_wat&quot; FROM &quot;air&quot;
name: air
time                 med_wat mode_wat
----                 ------- --------
1970-01-01T00:00:00Z 65      53
</code></pre>
<p>该查询返回<code>temperature</code>的平均数和<code>temperature</code>中出现频率最高的field value，并将输出的field key分别重命名为<code>med_wat</code>和<code>mode_wat</code>。如果没有<code>AS</code>子句，那么查询会返回<code>median</code>和<code>mode</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;),MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 median mode
----                 ------ ----
1970-01-01T00:00:00Z 65     53
</code></pre>
<h4 id="改变不含数据的时间间隔的返回值"><a class="header" href="#改变不含数据的时间间隔的返回值">改变不含数据的时间间隔的返回值</a></h4>
<p>默认情况下，包含cnosQL函数和<code>GROUP BY time()</code>子句的查询对不包含数据的时间间隔返回空值。在<code>GROUP BY</code>子句后面加上<code>fill()</code>可以更改这个值。关于<code>fill()</code>的详细讨论，请查看数据探索。</p>
<h4 id="函数的常见问题"><a class="header" href="#函数的常见问题">函数的常见问题</a></h4>
<p>以下部分描述了所有函数、聚合函数和选择函数的常见混淆来源，有关单个功能的常见问题，请参见以下特定文档：</p>
<ul>
<li><a href="#common-issues-with-distinct">DISTINCT()</a></li>
<li><a href="#common-issues-with-bottom">BOTTOM()</a></li>
<li><a href="#common-issues-with-percentile">PERCENTILE()</a></li>
<li><a href="#common-issues-with-sample">SAMPLE()</a></li>
<li><a href="#common-issues-with-top">TOP()</a></li>
<li><a href="#common-issues-with-elapsed">ELAPSED()</a></li>
<li><a href="#common-issues-with-holt-winters">HOLT_WINTERS()</a></li>
</ul>
<h4 id="所有函数"><a class="header" href="#所有函数">所有函数</a></h4>
<ul>
<li>
<h4 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h4>
</li>
</ul>
<p>某些cnosQL 函数支持 <a href="/cnosdb/v1.8/query_language/explore-data/#select-clause"><code>SELECT</code> clause</a>中嵌套:</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a> with <a href="#distinct"><code>DISTINCT()</code></a></li>
<li><a href="#cumulative-sum"><code>CUMULATIVE_SUM()</code></a></li>
<li><a href="#derivative"><code>DERIVATIVE()</code></a></li>
<li><a href="#difference"><code>DIFFERENCE()</code></a></li>
<li><a href="#elapsed"><code>ELAPSED()</code></a></li>
<li><a href="#moving-average"><code>MOVING_AVERAGE()</code></a></li>
<li><a href="#non-negative-derivative"><code>NON_NEGATIVE_DERIVATIVE()</code></a></li>
<li><a href="#holt-winters"><code>HOLT_WINTERS()</code></a> and <a href="#holt-winters"><code>HOLT_WINTERS_WITH_FIT()</code></a></li>
</ul>
<ul>
<li>
<h4 id="查询在now之后的时间范围"><a class="header" href="#查询在now之后的时间范围">查询在now()之后的时间范围</a></h4>
</li>
</ul>
<p>大多数<code>SELECT</code>语句的默认时间范围在<code>1677-09-21 00:12:43.145224194</code> UTC和<code>2262-04-11T23:47:16.854775806Z</code> UTC之间。对于包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询，默认的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。</p>
<p>如果要查询时间戳发生在<code>now()</code>之后的数据，那么包含cnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询必须在<code>WHERE</code>子句中提供一个时间上限。请查看常见问题。</p>
<h4 id="聚合函数-1"><a class="header" href="#聚合函数-1">聚合函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳"><a class="header" href="#理解返回的时间戳">理解返回的时间戳</a></h4>
</li>
</ul>
<p>子句中具有 <a href="#aggregations">聚合函数</a> 且 <code>WHERE</code>没有时间范围的查询讲返回 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间戳.
CnosDB 使用 epoch 0 作为等效的空时间戳.
带有聚合函数的查询，如果 <code>WHERE</code> 子句中包含时间范围，将返回时间下限作为时间戳.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用聚合函数并且没有指定时间范围"><a class="header" href="#使用聚合函数并且没有指定时间范围">使用聚合函数并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 1839495
</code></pre>
<p>该查询将CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为时间戳返回。<code>SUM()</code>将多个<code>point</code>聚合，没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围"><a class="header" href="#使用聚合函数并且指定时间范围">使用聚合函数并且指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 134766
</code></pre>
<p>该查询将时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为时间戳返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围和使用group-by-time子句"><a class="header" href="#使用聚合函数并且指定时间范围和使用group-by-time子句">使用聚合函数并且指定时间范围和使用GROUP BY time()子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:28:00Z' GROUP BY time(12m)
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 490
2021-09-28T00:12:00Z 524
2021-09-28T00:24:00Z 263
</code></pre>
<p>该查询将每个<code>GROUP BY time()</code>间隔的时间下界作为时间戳返回。</p>
<ul>
<li>
<h4 id="将聚合函数和不聚合的数据混合使用"><a class="header" href="#将聚合函数和不聚合的数据混合使用">将聚合函数和不聚合的数据混合使用</a></h4>
</li>
</ul>
<p>聚合函数不支持在<code>SELECT</code>语句中指定不使用聚合函数的单独的field key或tag key。聚合函数返回一个计算结果，对于没有被聚合的field或tag，没有明显的单个值可以返回。当<code>SELECT</code>语句同时包含聚合函数和单独的field key或tag key时，会返回错误：</p>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;),&quot;station&quot; FROM &quot;air&quot;
ERR: mixing aggregate and non-aggregate queries is not supported
</code></pre>
<ul>
<li>
<h4 id="得到略有不同的结果"><a class="header" href="#得到略有不同的结果">得到略有不同的结果</a></h4>
</li>
</ul>
<p>对于某些聚合函数，在相同的<code>point</code>（数据类型为float64)上执行相同的函数，可能会产生稍微不同的结果。在应用聚合函数之间，CnosDB不会将<code>point</code>进行排序；该行为可能会导致查询结果中出现小小的差异。</p>
<h4 id="selector函数"><a class="header" href="#selector函数">Selector函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳-1"><a class="header" href="#理解返回的时间戳-1">理解返回的时间戳</a></h4>
</li>
</ul>
<p>selector函数返回的时间戳依赖查询中函数的数量和查询中的其它子句：</p>
<p>带有单个选择器函数，单个 field key 参数和无 <code>GROUP BY time()</code> 的查询返回原始数据中出现的point时间戳.
具有单个 selector 函数, 多个 <code>field key</code> 参数的查询, <code>GROUP BY time()</code> 返回原始数据中出现的point 时间戳，或与空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>)等价的CnosDB.</p>
<p><code>WHERE</code>子句中有多个函数且没有时间范围的查询将返回相当于空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>).
在 <code>WHERE</code>子句中包含多个函数和时间范围的查询将时间下限作为时间戳返回</p>
<p>带有 selector 函数和  <code>GROUP BY time()</code> 子句的查询返回每个 <code>GROUP BY time()</code>间隔的时间下限.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用单个selector函数和单个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和单个field-key并且没有指定时间范围">使用单个selector函数和单个field key，并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964

&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 max
----                 ---
2021-09-28T01:57:00Z 80
</code></pre>
<p>该查询返回原始数据中具有<code>最大</code>值的<code>point</code>的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数和多个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和多个field-key并且没有指定时间范围">使用单个selector函数和多个field key，并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;
name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71

&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80

</code></pre>
<p>第一个查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>FIRST(*)</code>返回两个时间戳（对应measurement <code>air</code>中的每个field key），所以系统使用空时间戳覆盖这两个时间戳。</p>
<p>第二个查询返回原始数据中具有最大值的<code>point</code>的时间戳。因为<code>MAX(*)</code>只返回一个时间戳(measurement <code>air</code>中只有一个数值类型的field)，所以系统不会覆盖原始时间戳。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且没有指定时间范围"><a class="header" href="#使用多个selector函数并且没有指定时间范围">使用多个selector函数，并且没有指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max min
----                 --- ---
1970-01-01T00:00:00Z 80  50 
</code></pre>
<p>该查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>MAX()</code>和<code>MIN()</code>函数返回不同的时间戳，所以系统没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且指定时间范围"><a class="header" href="#使用多个selector函数并且指定时间范围">使用多个selector函数，并且指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
  name: air
  time                 max min
  ----                 --- ---
  2021-09-28T00:00:00Z 80  50
</code></pre>
<p>该查询返回时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为查询结果中的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数并且指定时间范围"><a class="header" href="#使用单个selector函数并且指定时间范围">使用单个selector函数，并且指定时间范围</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:18:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 80
2021-09-18T00:12:00Z 797
</code></pre>
<p>该查询返回每个<code>GROUP BY time()</code>间隔的时间下限作为查询结果中的时间戳。</p>
</li>
</ul>
<h2 id="cnosql-数学运算符"><a class="header" href="#cnosql-数学运算符">CnosQL 数学运算符</a></h2>
<ul>
<li>
<h3 id="数学运算符"><a class="header" href="#数学运算符"><a href="#%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97%E7%AC%A6">数学运算符</a></a></h3>
<ul>
<li>
<h4 id="加法"><a class="header" href="#加法"><a href="#%E5%8A%A0%E6%B3%95">加法</a></a></h4>
</li>
<li>
<h4 id="减法"><a class="header" href="#减法"><a href="#%E5%87%8F%E6%B3%95">减法</a></a></h4>
</li>
<li>
<h4 id="乘法"><a class="header" href="#乘法"><a href="#%E4%B9%98%E6%B3%95">乘法</a></a></h4>
</li>
<li>
<h4 id="除法"><a class="header" href="#除法"><a href="#%E9%99%A4%E6%B3%95">除法</a></a></h4>
</li>
<li>
<h4 id="模运算"><a class="header" href="#模运算"><a href="#%E6%A8%A1%E8%BF%90%E7%AE%97">模运算</a></a></h4>
</li>
<li>
<h4 id="位与运算"><a class="header" href="#位与运算"><a href="#%E4%BD%8D%E4%B8%8E%E8%BF%90%E7%AE%97">位与运算</a></a></h4>
</li>
<li>
<h4 id="位或运算"><a class="header" href="#位或运算"><a href="#%E4%BD%8D%E6%88%96%E8%BF%90%E7%AE%97">位或运算</a></a></h4>
</li>
<li>
<h4 id="位异运算"><a class="header" href="#位异运算"><a href="#%E4%BD%8D%E5%BC%82%E8%BF%90%E7%AE%97">位异运算</a></a></h4>
</li>
<li>
<h4 id="常见问题"><a class="header" href="#常见问题"><a href="#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">常见问题</a></a></h4>
</li>
</ul>
</li>
<li>
<h3 id="不支持的运算符"><a class="header" href="#不支持的运算符"><a href="#%E4%B8%8D%E6%94%AF%E6%8C%81%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6">不支持的运算符</a></a></h3>
</li>
<li>
<h3 id="数学运算符-1"><a class="header" href="#数学运算符-1">数学运算符</a></h3>
<ul>
<li>
<h4 id="加法-1"><a class="header" href="#加法-1">加法</a></h4>
</li>
</ul>
<p>常量的加法</p>
<pre><code>SELECT &quot;temperature&quot; + 5 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; + 5 &gt; 10
</code></pre>
<p>两字段的加法</p>
<pre><code>SELECT &quot;temperature&quot; + &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; + &quot;visibility&quot; &gt; 10
</code></pre>
<ul>
<li>
<h4 id="减法-1"><a class="header" href="#减法-1">减法</a></h4>
</li>
</ul>
<p>常量的减法</p>
<pre><code>SELECT &quot;temperature&quot; - 2 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - 2 &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; - &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - &quot;visibility&quot; &gt; 10
</code></pre>
<ul>
<li>
<h4 id="乘法-1"><a class="header" href="#乘法-1">乘法</a></h4>
</li>
</ul>
<p>常量的乘法</p>
<pre><code>SELECT &quot;temperature&quot; * 2 FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; - 2 &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; * &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; * &quot;visibility&quot; &gt; 10
</code></pre>
<p>乘法和其他操作符并用</p>
<pre><code>SELECT 10 * (&quot;temperature&quot; + &quot;visibility&quot; + &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 * (&quot;temperature&quot; + &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 * (&quot;temperature&quot; - &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
</code></pre>
<ul>
<li>
<h4 id="除法-1"><a class="header" href="#除法-1">除法</a></h4>
</li>
</ul>
<p>常量的除法</p>
<pre><code>SELECT 10 / &quot;temperature&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE 10 / &quot;temperature&quot; &gt; 12
</code></pre>
<p>两字段的减法</p>
<pre><code>SELECT &quot;temperature&quot; / &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; / &quot;visibility&quot; &gt; 10
</code></pre>
<p>乘法和其他操作符并用</p>
<pre><code>SELECT 10 / (&quot;temperature&quot; + &quot;visibility&quot; + &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 / (&quot;temperature&quot; + &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
SELECT 10 / (&quot;temperature&quot; - &quot;visibility&quot; - &quot;pressure&quot;) FROM &quot;air&quot;
</code></pre>
<ul>
<li>
<h4 id="模运算-1"><a class="header" href="#模运算-1">模运算</a></h4>
</li>
</ul>
<p>常量的模运算</p>
<pre><code>SELECT 10 % &quot;temperature&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE 10 % &quot;temperature&quot; = 0
</code></pre>
<p>两字段的模运算</p>
<pre><code>SELECT &quot;temperature&quot; % &quot;visibility&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; % &quot;visibility&quot; = 0
</code></pre>
<ul>
<li>
<h4 id="按位与运算"><a class="header" href="#按位与运算">按位与运算</a></h4>
</li>
</ul>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; &amp; 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; &amp; &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; &amp; 15 &gt; 0
SELECT &quot;temperature&quot; &amp; &quot;pressure&quot; FROM &quot;air&quot;
SELECT (&quot;temperature&quot; ^ true) &amp; &quot;pressure&quot; FROM &quot;air&quot;
</code></pre>
<ul>
<li>
<h4 id="按位或运算"><a class="header" href="#按位或运算">按位或运算</a></h4>
</li>
</ul>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; | 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; | &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; | 12 = 12
</code></pre>
<ul>
<li>
<h4 id="按位异运算"><a class="header" href="#按位异运算">按位异运算</a></h4>
</li>
</ul>
<p>您可以对任何整数或布尔值使用此操作符，无论它们是字段还是常量。它不适用于浮点或字符串数据类型，并且不能混合整数和布尔值使用。</p>
<pre><code>SELECT &quot;temperature&quot; ^ 255 FROM &quot;air&quot;
SELECT &quot;temperature&quot; ^ &quot;pressure&quot; FROM &quot;air&quot;
SELECT * FROM &quot;air&quot; WHERE &quot;temperature&quot; ^ 12 = 12
</code></pre>
<ul>
<li>
<h4 id="常见问题-1"><a class="header" href="#常见问题-1">常见问题</a></h4>
<ul>
<li>
<h4 id="带有通配符和正则表达式的数学操作符"><a class="header" href="#带有通配符和正则表达式的数学操作符">带有通配符和正则表达式的数学操作符</a></h4>
</li>
</ul>
<p>CnosDB不支持在SELECT子句中组合数学操作与通配符(*)或正则表达式。以下查询无效，系统返回错误:
对通配符执行数学运算。</p>
<pre><code>&gt; SELECT * + 2 FROM &quot;air&quot;
ERR: unsupported expression with wildcard: * + 2
</code></pre>
<p>对函数中的通配符执行数学运算。</p>
<pre><code>&gt; SELECT COUNT(*) / 2 FROM &quot;nope&quot;
ERR: unsupported expression with wildcard: count(*) / 2
</code></pre>
<p>对正则表达式执行数学运算。</p>
<pre><code>&gt; SELECT /A/ + 2 FROM &quot;air&quot;
ERR: error parsing query: found +, expected FROM at line 1, char 12
</code></pre>
<p>对函数中的正则表达式执行数学运算。</p>
<pre><code>&gt; SELECT COUNT(/A/) + 2 FROM &quot;nope&quot;
ERR: unsupported expression with regex field: count(/A/) + 2
</code></pre>
<ul>
<li>
<h4 id="函数的数学运算符"><a class="header" href="#函数的数学运算符">函数的数学运算符</a></h4>
</li>
</ul>
<p>目前不支持在函数调用中使用数学运算符。注意，CnosDB只允许SELECT子句中的函数。
可行操作：</p>
<pre><code>SELECT 10 * mean(&quot;value&quot;) FROM &quot;cpu&quot;
</code></pre>
<p>不可行操作：</p>
<pre><code>SELECT mean(10 * &quot;value&quot;) FROM &quot;cpu&quot;
</code></pre>
</li>
</ul>
</li>
<li>
<h3 id="不支持的运算符-1"><a class="header" href="#不支持的运算符-1">不支持的运算符</a></h3>
<ul>
<li>
<h4 id="比较运算"><a class="header" href="#比较运算">比较运算</a></h4>
</li>
</ul>
<p>所有的比较运算符都不支持。例如：<code>=</code>,<code>!=</code>,<code>&lt;</code>,<code>&gt;</code>,<code>&lt;=</code>,<code>&gt;=</code>,<code>&lt;&gt;</code>。在SELECT语句中均不可以使用。</p>
<ul>
<li>
<h4 id="逻辑运算符"><a class="header" href="#逻辑运算符">逻辑运算符</a></h4>
</li>
</ul>
<p>使用逻辑运算符，如：<code>!|</code>, <code>NAND</code>,<code>XOR</code>,<code>NOR</code>；都会导致解析错误。</p>
<p>此外，在查询的<code>SELECT</code>子句中使用<code>AND</code>和<code>OR</code>不会表现为数学运算符，只会产生空结果，因为它们在CnosQL中已经被定义。但是，您可以对布尔数据应用位操作符<code>&amp;</code>、<code>|</code>和<code>^</code>。</p>
<ul>
<li>
<h4 id="位非运算"><a class="header" href="#位非运算">位非运算</a></h4>
</li>
</ul>
<p>没有位非运算符，因为您期望的结果取决于您的位域的宽度。CnosQL不知道您的位域有多宽，因此无法实现合适的位非运算。</p>
<p>您可以通过使用<code>^</code>(位异或)操作符和代表字宽的全1的二进制数字来实现位非操作:</p>
<pre><code>8-bit 数据：

SELECT &quot;temperature&quot; ^ 255 FROM &quot;air&quot;

16-bit 数据:

SELECT &quot;temperature&quot; ^ 65535 FROM &quot;air&quot;

32-bit 数据:

SELECT &quot;temperature&quot; ^ 4294967295 FROM &quot;air&quot;
</code></pre>
</li>
</ul>
<h2 id="cnosql参考"><a class="header" href="#cnosql参考">CnosQL参考</a></h2>
<ul>
<li>
<h3 id="介绍"><a class="header" href="#介绍">介绍</a></h3>
<p>CnosQL的定义和详细信息</p>
<ul>
<li>
<h4 id="符号"><a class="header" href="#符号"><a href="#%E7%AC%A6%E5%8F%B7">符号</a></a></h4>
</li>
<li>
<h4 id="查询表示"><a class="header" href="#查询表示"><a href="#%E6%9F%A5%E8%AF%A2%E8%A1%A8%E7%A4%BA">查询表示</a></a></h4>
</li>
<li>
<h4 id="字母和数字"><a class="header" href="#字母和数字"><a href="#%E5%AD%97%E6%AF%8D%E5%92%8C%E6%95%B0%E5%AD%97">字母和数字</a></a></h4>
</li>
<li>
<h4 id="标识符"><a class="header" href="#标识符"><a href="#%E6%A0%87%E8%AF%86%E7%AC%A6">标识符</a></a></h4>
</li>
<li>
<h4 id="关键字"><a class="header" href="#关键字"><a href="#%E5%85%B3%E9%94%AE%E5%AD%97">关键字</a></a></h4>
</li>
<li>
<h4 id="文字"><a class="header" href="#文字"><a href="#%E6%96%87%E5%AD%97">文字</a></a></h4>
</li>
<li>
<h4 id="查询"><a class="header" href="#查询"><a href="#%E6%9F%A5%E8%AF%A2">查询</a></a></h4>
</li>
<li>
<h4 id="语句"><a class="header" href="#语句"><a href="#%E8%AF%AD%E5%8F%A5">语句</a></a></h4>
</li>
<li>
<h4 id="条款"><a class="header" href="#条款"><a href="#%E6%9D%A1%E6%AC%BE">条款</a></a></h4>
</li>
<li>
<h4 id="表达式"><a class="header" href="#表达式"><a href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F">表达式</a></a></h4>
</li>
<li>
<h4 id="其他"><a class="header" href="#其他"><a href="#%E5%85%B6%E4%BB%96">其他</a></a></h4>
</li>
<li>
<h4 id="查询引擎内部"><a class="header" href="#查询引擎内部"><a href="#%E6%9F%A5%E8%AF%A2%E5%BC%95%E6%93%8E%E5%86%85%E9%83%A8">查询引擎内部</a></a></h4>
</li>
</ul>
<p>要了解更多关于CnosQL的信息，请浏览以下内容：</p>
<ul>
<li>
<h4 id="使用cnosql探索数据"><a class="header" href="#使用cnosql探索数据"><a href="#%E4%BD%BF%E7%94%A8cnosql%E6%8E%A2%E7%B4%A2%E6%95%B0%E6%8D%AE">使用CnosQL探索数据</a></a></h4>
</li>
<li>
<h4 id="使用cnosql探索您的模式"><a class="header" href="#使用cnosql探索您的模式"><a href="#">使用CnosQL探索您的模式</a></a></h4>
</li>
<li>
<h4 id="数据库管理-1"><a class="header" href="#数据库管理-1"><a href="#">数据库管理</a></a></h4>
</li>
</ul>
</li>
<li>
<h3 id="符号-1"><a class="header" href="#符号-1">符号</a></h3>
<p>使用Extended Backus-Naur Form(&quot; EBNF &quot;)指定语法。EBNF与Go编程语言规范中使用的符号相同。并非巧合的是，CnosDB是用Go编写的。</p>
<pre><code>Production  = production_name &quot;=&quot; [ Expression ] &quot;.&quot; .
Expression  = Alternative { &quot;|&quot; Alternative } .
Alternative = Term { Term } .
Term        = production_name | token [ &quot;…&quot; token ] | Group | Option | Repetition .
Group       = &quot;(&quot; Expression &quot;)&quot; .
Option      = &quot;[&quot; Expression &quot;]&quot; .
Repetition  = &quot;{&quot; Expression &quot;}&quot; .
</code></pre>
<p>按优先级递增的顺序表示操作符:</p>
<pre><code>|   alternation
()  grouping
[]  option (0 or 1 times)
{}  repetition (0 to n times)
</code></pre>
</li>
<li>
<h3 id="查询表示-1"><a class="header" href="#查询表示-1">查询表示</a></h3>
<ul>
<li>
<h4 id="字符"><a class="header" href="#字符">字符</a></h4>
</li>
</ul>
<p>CnosQL是使用UTF-8编码的Unicode文本。</p>
<pre><code>newline             = /* the Unicode code point U+000A */ .
unicode_char        = /* an arbitrary Unicode code point except newline */ .
</code></pre>
</li>
<li>
<h3 id="字母和数字-1"><a class="header" href="#字母和数字-1">字母和数字</a></h3>
<p>字母是ASCII字符的集合，加上下划线_ (U+005F)也被认为是字母。只支持十进制数字。</p>
<pre><code>letter              = ascii_letter | &quot;_&quot; .
ascii_letter        = &quot;A&quot; … &quot;Z&quot; | &quot;a&quot; … &quot;z&quot; .
digit               = &quot;0&quot; … &quot;9&quot; .
</code></pre>
</li>
<li>
<h3 id="标识符-1"><a class="header" href="#标识符-1">标识符</a></h3>
<p>标识符包括数据库名、保留策略名、用户名、度量名、标记键以及字段键。</p>
<p>标识符使用规则如下；</p>
<ul>
<li>双引号标识符可以包含除新行以外的任何unicode字符。</li>
<li>双引号标识符可以包括转义的<code>&quot;</code>字符。例如；<code>\&quot;</code> 。</li>
<li>双引号标识符中可以包括CnosQL的关键字。</li>
<li>未加引号的标识符必须以大写或小写ASCII字符或者&quot;_&quot;开头。</li>
<li>未加引号的标识符只能包括ASCII字母、十进制数字或者&quot;_&quot;。</li>
</ul>
<pre><code>identifier          = unquoted_identifier | quoted_identifier .
unquoted_identifier = ( letter ) { letter | digit } .
quoted_identifier   = `&quot;` unicode_char { unicode_char } `&quot;` .
</code></pre>
<p>例如：</p>
<pre><code>air
_air_temperature
&quot;1h&quot;
&quot;anything really&quot;
&quot;1_Crazy-1337.identifier&gt;NAME👍&quot;
</code></pre>
</li>
<li>
<h3 id="关键字-1"><a class="header" href="#关键字-1">关键字</a></h3>
<pre><code>ALL           ALTER         ANY           AS            ASC           BEGIN
BY            CREATE        CONTINUOUS    DATABASE      DATABASES     DEFAULT
DELETE        DESC          DESTINATIONS  DIAGNOSTICS   DISTINCT      DROP
DURATION      END           EVERY         EXPLAIN       FIELD         FOR
FROM          GRANT         GRANTS        GROUP         GROUPS        IN
INF           INSERT        INTO          KEY           KEYS          KILL
LIMIT         SHOW          MEASUREMENT   MEASUREMENTS  NAME          OFFSET
ON            ORDER         PASSWORD      POLICY        POLICIES      PRIVILEGES
QUERIES       QUERY         READ          REPLICATION   RESAMPLE      RETENTION
REVOKE        SELECT        SERIES        SET           SHARD         SHARDS
SLIMIT        SOFFSET       STATS         SUBSCRIPTION  SUBSCRIPTIONS TAG
TO            USER          USERS         VALUES        WHERE         WITH
WRITE
</code></pre>
<p>如果使用了CnosQL的关键字作为标识符，则需要在每次查询中对该标识符加双引号。</p>
<p>关键字<code>time</code>是一种特殊情况。<code>time</code>可以是连续查询名称、数据库名称、测量名称、保留策略名称、订阅名称和用户名称。在这些情况下，查询中的<code>time</code>不需要双引号。<code>time</code>不能是字段键或标签键；CnosQL拒绝将<code>time</code>作为字段键或标记键的写入，并返回错误。</p>
</li>
<li>
<h3 id="文字-1"><a class="header" href="#文字-1">文字</a></h3>
<ul>
<li>
<h4 id="整数"><a class="header" href="#整数">整数</a></h4>
</li>
</ul>
<p>CnosQL目前只支持十进制数字，并不支持其他进制数字。</p>
<pre><code>int_lit             = ( &quot;1&quot; … &quot;9&quot; ) { digit } .
</code></pre>
<ul>
<li>
<h4 id="浮点数"><a class="header" href="#浮点数">浮点数</a></h4>
</li>
</ul>
<p>CnosQL目前只支持浮点数，并不支持指数。</p>
<pre><code>float_lit           = int_lit &quot;.&quot; int_lit .
</code></pre>
<ul>
<li>
<h4 id="字符串"><a class="header" href="#字符串">字符串</a></h4>
</li>
</ul>
<p>字符串必须和单引号搭配使用。如果加上转义字符，那么字符串中可以包含单引号。</p>
<pre><code>string_lit          = `'` { unicode_char } `'` .
</code></pre>
<ul>
<li>
<h4 id="持续时间"><a class="header" href="#持续时间">持续时间</a></h4>
</li>
</ul>
<p>持续时间的字面值指定时间长度。整数字面值紧跟着(没有空格)下面列出的持续时间单位被称为持续时间字面值。可以使用混合单元指定持续时间。</p>
<pre><code>duration_lit        = int_lit duration_unit .
duration_unit       = &quot;ns&quot; | &quot;u&quot; | &quot;µ&quot; | &quot;ms&quot; | &quot;s&quot; | &quot;m&quot; | &quot;h&quot; | &quot;d&quot; | &quot;w&quot; .
</code></pre>
<ul>
<li>
<h4 id="日期和时间"><a class="header" href="#日期和时间">日期和时间</a></h4>
</li>
</ul>
<p>与本文档的其余部分一样，EBNF中没有指定日期和时间文本格式。它是使用Go的日期/时间解析格式指定的，它是按照CnosQL要求的格式编写的引用日期。</p>
<p>参考日期时间为:January 2nd, 2006 at 3:04:05 PM</p>
<pre><code>time_lit            = &quot;2006-01-02 15:04:05.999999&quot; | &quot;2006-01-02&quot; .
</code></pre>
<ul>
<li>
<h4 id="布尔值"><a class="header" href="#布尔值">布尔值</a></h4>
</li>
</ul>
<pre><code>bool_lit            = TRUE | FALSE .
</code></pre>
<ul>
<li>
<h4 id="正则表达式"><a class="header" href="#正则表达式">正则表达式</a></h4>
</li>
</ul>
<pre><code>regex_lit           = &quot;/&quot; { unicode_char } &quot;/&quot; .
</code></pre>
</li>
<li>
<h3 id="查询-1"><a class="header" href="#查询-1">查询</a></h3>
<p>查询由一个或多个以分号分隔的语句组成。</p>
<pre><code>query               = statement { &quot;;&quot; statement } .

statement           = alter_retention_policy_stmt |
                      create_continuous_query_stmt |
                      create_database_stmt |
                      create_retention_policy_stmt |
                      create_subscription_stmt |
                      create_user_stmt |
                      delete_stmt |
                      drop_continuous_query_stmt |
                      drop_database_stmt |
                      drop_measurement_stmt |
                      drop_retention_policy_stmt |
                      drop_series_stmt |
                      drop_shard_stmt |
                      drop_subscription_stmt |
                      drop_user_stmt |
                      explain_stmt |
                      explain_analyze_stmt |
                      grant_stmt |
                      kill_query_statement |
                      revoke_stmt |
                      select_stmt |
                      show_continuous_queries_stmt |
                      show_databases_stmt |
                      show_diagnostics_stmt |
                      show_field_key_cardinality_stmt |
                      show_field_keys_stmt |
                      show_grants_stmt |
                      show_measurement_cardinality_stmt |
                      show_measurement_exact_cardinality_stmt |
                      show_measurements_stmt |
                      show_queries_stmt |
                      show_retention_policies_stmt |
                      show_series_cardinality_stmt |
                      show_series_exact_cardinality_stmt |
                      show_series_stmt |
                      show_shard_groups_stmt |
                      show_shards_stmt |
                      show_stats_stmt |
                      show_subscriptions_stmt |
                      show_tag_key_cardinality_stmt |
                      show_tag_key_exact_cardinality_stmt |
                      show_tag_keys_stmt |
                      show_tag_values_stmt |
                      show_tag_values_cardinality_stmt |
                      show_users_stmt .
</code></pre>
</li>
<li>
<h3 id="语句-1"><a class="header" href="#语句-1">语句</a></h3>
<ul>
<li>
<h4 id="改变保留策略"><a class="header" href="#改变保留策略">改变保留策略</a></h4>
</li>
</ul>
<pre><code>alter_retention_policy_stmt  = &quot;ALTER RETENTION POLICY&quot; policy_name on_clause
                               retention_policy_option
                               [ retention_policy_option ]
                               [ retention_policy_option ]
                               [ retention_policy_option ] .
</code></pre>
<ul>
<li>
<h4 id="创建连续查询"><a class="header" href="#创建连续查询">创建连续查询</a></h4>
</li>
</ul>
<pre><code>create_continuous_query_stmt = &quot;CREATE CONTINUOUS QUERY&quot; query_name on_clause
[ &quot;RESAMPLE&quot; resample_opts ]
&quot;BEGIN&quot; select_stmt &quot;END&quot; .

query_name                   = identifier .

resample_opts                = (every_stmt for_stmt | every_stmt | for_stmt) .
every_stmt                   = &quot;EVERY&quot; duration_lit
for_stmt                     = &quot;FOR&quot; duration_lit
</code></pre>
<ul>
<li>
<h4 id="创建数据库-1"><a class="header" href="#创建数据库-1">创建数据库</a></h4>
</li>
</ul>
<pre><code>create_database_stmt = &quot;CREATE DATABASE&quot; db_name
                       [ WITH
                           [ retention_policy_duration ]
                           [ retention_policy_replication ]
                           [ retention_policy_shard_group_duration ]
                           [ retention_policy_name ]
                        ] .
</code></pre>
<ul>
<li>
<h4 id="创建保留策略-1"><a class="header" href="#创建保留策略-1">创建保留策略</a></h4>
</li>
</ul>
<pre><code>create_retention_policy_stmt = &quot;CREATE RETENTION POLICY&quot; policy_name on_clause
                               retention_policy_duration
                               retention_policy_replication
                               [ retention_policy_shard_group_duration ]
                               [ &quot;DEFAULT&quot; ] .
</code></pre>
<ul>
<li>
<h4 id="创建用户"><a class="header" href="#创建用户">创建用户</a></h4>
</li>
</ul>
<pre><code>create_user_stmt = &quot;CREATE USER&quot; user_name &quot;WITH PASSWORD&quot; password
                   [ &quot;WITH ALL PRIVILEGES&quot; ] .
</code></pre>
<ul>
<li>
<h4 id="删除"><a class="header" href="#删除">删除</a></h4>
</li>
</ul>
<pre><code>e_stmt = &quot;DELETE&quot; ( from_clause | where_clause | from_clause where_clause ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃连续查询"><a class="header" href="#抛弃连续查询">抛弃连续查询</a></h4>
</li>
</ul>
<pre><code>drop_continuous_query_stmt = &quot;DROP CONTINUOUS QUERY&quot; query_name on_clause .
</code></pre>
<ul>
<li>
<h4 id="抛弃数据库"><a class="header" href="#抛弃数据库">抛弃数据库</a></h4>
</li>
</ul>
<pre><code>drop_database_stmt = &quot;DROP DATABASE&quot; db_name .
</code></pre>
<ul>
<li>
<h4 id="抛弃度量"><a class="header" href="#抛弃度量">抛弃度量</a></h4>
</li>
</ul>
<pre><code>drop_measurement_stmt = &quot;DROP MEASUREMENT&quot; measurement .
</code></pre>
<ul>
<li>
<h4 id="抛弃保留策略"><a class="header" href="#抛弃保留策略">抛弃保留策略</a></h4>
</li>
</ul>
<pre><code>drop_retention_policy_stmt = &quot;DROP RETENTION POLICY&quot; policy_name on_clause .
</code></pre>
<ul>
<li>
<h4 id="抛弃序列"><a class="header" href="#抛弃序列">抛弃序列</a></h4>
</li>
</ul>
<pre><code>drop_series_stmt = &quot;DROP SERIES&quot; ( from_clause | where_clause | from_clause where_clause ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃分片"><a class="header" href="#抛弃分片">抛弃分片</a></h4>
</li>
</ul>
<pre><code>drop_shard_stmt = &quot;DROP SHARD&quot; ( shard_id ) .
</code></pre>
<ul>
<li>
<h4 id="抛弃用户"><a class="header" href="#抛弃用户">抛弃用户</a></h4>
</li>
</ul>
<pre><code>drop_user_stmt = &quot;DROP USER&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="explain"><a class="header" href="#explain">EXPLAIN</a></h4>
</li>
</ul>
<pre><code>explain_stmt = &quot;EXPLAIN&quot; select_stmt .
</code></pre>
<ul>
<li>
<h4 id="explain-analyze"><a class="header" href="#explain-analyze">EXPLAIN ANALYZE</a></h4>
</li>
</ul>
<p>例如</p>
<pre><code>&gt; explain analyze select mean(temperature) from air where time &gt;= '2018-02-22T00:00:00Z' and time &lt; '2018-02-22T12:00:00Z'
EXPLAIN ANALYZE
----    -----------
 .
 └── select
   ├── execution_time: 279.292µs
   ├── planning_time: 952.75µs
   ├── total_time: 1.232042ms
   └── build_cursor
    ├── labels
     │   └── statement: SELECT mean(temperature) FROM data.autogen.air
     └── iterator_scanner
      └── labels
       └── expr: mean(temperature)
</code></pre>
<p>execution_time: 执行查询所花费的时间，包括读取时间序列数据、在数据流经迭代器时执行操作，以及从迭代器中提取已处理的数据。执行时间不包括将输出序列化为JSON或其他格式所花费的时间。
planning_time: 显示计划查询所花费的时间量。在CnosDB中规划查询需要许多步骤。根据查询的复杂性，与执行查询相比，计划可能需要更多的工作并消耗更多的CPU和内存资源。例如，执行查询所需的系列键的数量会影响计划查询的速度和所需的内存。
create_iterator: 表示本地CnosDB实例所做的工作──一组复杂的嵌套迭代器组合在一起，以产生最终的查询输出。
cursor type：EXPLAIN ANALYZE区分3种游标类型。虽然游标类型具有相同的数据结构和相同的CPU和I/O成本，但每种游标类型的构造原因不同，并在最终输出中分开。
block types：EXPLAIN ANALYZE分离存储块类型，并报告被解码的块的总数和它们在磁盘上的大小(以字节为单位)。</p>
<ul>
<li>
<h4 id="授权"><a class="header" href="#授权">授权</a></h4>
</li>
</ul>
<pre><code>grant_stmt = &quot;GRANT&quot; privilege [ on_clause ] to_clause .
</code></pre>
<ul>
<li>
<h4 id="关闭查询"><a class="header" href="#关闭查询">关闭查询</a></h4>
</li>
</ul>
<pre><code>kill_query_statement = &quot;KILL QUERY&quot; query_id .
</code></pre>
<ul>
<li>
<h4 id="撤销"><a class="header" href="#撤销">撤销</a></h4>
</li>
</ul>
<pre><code>revoke_stmt = &quot;REVOKE&quot; privilege [ on_clause ] &quot;FROM&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="选择"><a class="header" href="#选择">选择</a></h4>
</li>
</ul>
<pre><code>select_stmt = &quot;SELECT&quot; fields [ into_clause ] from_clause [ where_clause ]
         [ group_by_clause ] [ order_by_clause ] [ limit_clause ]
         [ offset_clause ] [ slimit_clause ] [ soffset_clause ] [ timezone_clause ] .
</code></pre>
<ul>
<li>
<h4 id="展示基数"><a class="header" href="#展示基数">展示基数</a></h4>
</li>
</ul>
<p>指用于精确估计或计数测量值、序列、标记键、标记键值和字段键的基数的一组命令。SHOW CARDINALITY命令有两种变体:估计的和精确的。估计值使用草图计算，是所有基数大小的安全默认值。准确的值是直接从TSM(时间结构合并树)数据中计算的，但是对于高基数的数据来说，运行这些值是非常昂贵的。除非必要，使用估计的品种。仅当在数据库上启用了时间序列索引(TSI)时，才支持按时间过滤。</p>
<ul>
<li>
<h4 id="show-continuous-queries"><a class="header" href="#show-continuous-queries">SHOW CONTINUOUS QUERIES</a></h4>
</li>
</ul>
<pre><code>show_continuous_queries_stmt = &quot;SHOW CONTINUOUS QUERIES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-databases"><a class="header" href="#show-databases">SHOW DATABASES</a></h4>
</li>
</ul>
<pre><code>show_databases_stmt = &quot;SHOW DATABASES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-diagnostics"><a class="header" href="#show-diagnostics">SHOW DIAGNOSTICS</a></h4>
</li>
</ul>
<p>示节点信息，如构建信息、正常运行时间、主机名、服务器配置、内存使用和运行时诊断。</p>
<pre><code>show_diagnostics_stmt = &quot;SHOW DIAGNOSTICS&quot;
</code></pre>
<ul>
<li>
<h4 id="show-field-key-cardinality"><a class="header" href="#show-field-key-cardinality">SHOW FIELD KEY CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_field_key_cardinality_stmt = &quot;SHOW FIELD KEY CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

show_field_key_exact_cardinality_stmt = &quot;SHOW FIELD KEY EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]
</code></pre>
<ul>
<li>
<h4 id="show-field-keys"><a class="header" href="#show-field-keys">SHOW FIELD KEYS</a></h4>
</li>
</ul>
<pre><code>show_field_keys_stmt = &quot;SHOW FIELD KEYS&quot; [on_clause] [ from_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-grants"><a class="header" href="#show-grants">SHOW GRANTS</a></h4>
</li>
</ul>
<pre><code>show_grants_stmt = &quot;SHOW GRANTS FOR&quot; user_name .
</code></pre>
<ul>
<li>
<h4 id="show-measurements"><a class="header" href="#show-measurements">SHOW MEASUREMENTS</a></h4>
</li>
</ul>
<pre><code>show_measurements_stmt = &quot;SHOW MEASUREMENTS&quot; [on_clause] [ with_measurement_clause ] [ where_clause ] [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-queries"><a class="header" href="#show-queries">SHOW QUERIES</a></h4>
</li>
</ul>
<pre><code>show_queries_stmt = &quot;SHOW QUERIES&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-retention-policies"><a class="header" href="#show-retention-policies">SHOW RETENTION POLICIES</a></h4>
</li>
</ul>
<pre><code>show_retention_policies_stmt = &quot;SHOW RETENTION POLICIES&quot; [on_clause] .
</code></pre>
<ul>
<li>
<h4 id="show-series"><a class="header" href="#show-series">SHOW SERIES</a></h4>
</li>
</ul>
<pre><code>show_series_stmt = &quot;SHOW SERIES&quot; [on_clause] [ from_clause ] [ where_clause ] [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-series-cardinality"><a class="header" href="#show-series-cardinality">SHOW SERIES CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_series_cardinality_stmt = &quot;SHOW SERIES CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

show_series_exact_cardinality_stmt = &quot;SHOW SERIES EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ]

</code></pre>
<ul>
<li>
<h4 id="show-shard-groups"><a class="header" href="#show-shard-groups">SHOW SHARD GROUPS</a></h4>
</li>
</ul>
<pre><code>show_shard_groups_stmt = &quot;SHOW SHARD GROUPS&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-shards"><a class="header" href="#show-shards">SHOW SHARDS</a></h4>
</li>
</ul>
<pre><code>show_shards_stmt = &quot;SHOW SHARDS&quot; .
</code></pre>
<ul>
<li>
<h4 id="show-stats"><a class="header" href="#show-stats">SHOW STATS</a></h4>
</li>
</ul>
<pre><code>show_stats_stmt = &quot;SHOW STATS [ FOR '&lt;component&gt;' | 'indexes' ]&quot;
</code></pre>
<ul>
<li>
<h4 id="show-tag-keys"><a class="header" href="#show-tag-keys">SHOW TAG KEYS</a></h4>
</li>
</ul>
<pre><code>show_tag_keys_stmt = &quot;SHOW TAG KEYS&quot; [on_clause] [ from_clause ] [ where_clause ]
                [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-tag-values"><a class="header" href="#show-tag-values">SHOW TAG VALUES</a></h4>
</li>
</ul>
<pre><code>show_tag_values_stmt = &quot;SHOW TAG VALUES&quot; [on_clause] [ from_clause ] with_tag_clause [ where_clause ]
                  [ limit_clause ] [ offset_clause ] .
</code></pre>
<ul>
<li>
<h4 id="show-tag-values-cardinality"><a class="header" href="#show-tag-values-cardinality">SHOW TAG VALUES CARDINALITY</a></h4>
</li>
</ul>
<pre><code>show_tag_values_cardinality_stmt = &quot;SHOW TAG VALUES CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ] with_key_clause

show_tag_values_exact_cardinality_stmt = &quot;SHOW TAG VALUES EXACT CARDINALITY&quot; [ on_clause ] [ from_clause ] [ where_clause ] [ group_by_clause ] [ limit_clause ] [ offset_clause ] with_key_clause
</code></pre>
<ul>
<li>
<h4 id="show-users"><a class="header" href="#show-users">SHOW USERS</a></h4>
</li>
</ul>
<pre><code>show_users_stmt = &quot;SHOW USERS&quot; .
</code></pre>
</li>
<li>
<h3 id="条款-1"><a class="header" href="#条款-1">条款</a></h3>
<pre><code>from_clause     = &quot;FROM&quot; measurements .

group_by_clause = &quot;GROUP BY&quot; dimensions fill(fill_option).

into_clause     = &quot;INTO&quot; ( measurement | back_ref ).

limit_clause    = &quot;LIMIT&quot; int_lit .

offset_clause   = &quot;OFFSET&quot; int_lit .

slimit_clause   = &quot;SLIMIT&quot; int_lit .

soffset_clause  = &quot;SOFFSET&quot; int_lit .

timezone_clause = tz(string_lit) .

on_clause       = &quot;ON&quot; db_name .

order_by_clause = &quot;ORDER BY&quot; sort_fields .

to_clause       = &quot;TO&quot; user_name .

where_clause    = &quot;WHERE&quot; expr .

with_measurement_clause = &quot;WITH MEASUREMENT&quot; ( &quot;=&quot; measurement | &quot;=~&quot; regex_lit ) .

with_tag_clause = &quot;WITH KEY&quot; ( &quot;=&quot; tag_key | &quot;!=&quot; tag_key | &quot;=~&quot; regex_lit | &quot;IN (&quot; tag_keys &quot;)&quot;  ) .
</code></pre>
</li>
<li>
<h3 id="表达式-1"><a class="header" href="#表达式-1">表达式</a></h3>
<pre><code>binary_op        = &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&amp;&quot; | &quot;|&quot; | &quot;^&quot; | &quot;AND&quot; |
                &quot;OR&quot; | &quot;=&quot; | &quot;!=&quot; | &quot;&lt;&gt;&quot; | &quot;&lt;&quot; | &quot;&lt;=&quot; | &quot;&gt;&quot; | &quot;&gt;=&quot; .

expr             = unary_expr { binary_op unary_expr } .

unary_expr       = &quot;(&quot; expr &quot;)&quot; | var_ref | time_lit | string_lit | int_lit |
float_lit | bool_lit | duration_lit | regex_lit .
</code></pre>
</li>
<li>
<h3 id="其他-1"><a class="header" href="#其他-1">其他</a></h3>
<pre><code>alias            = &quot;AS&quot; identifier .

back_ref         = ( policy_name &quot;.:MEASUREMENT&quot; ) |
( db_name &quot;.&quot; [ policy_name ] &quot;.:MEASUREMENT&quot; ) .

db_name          = identifier .

dimension        = expr .

dimensions       = dimension { &quot;,&quot; dimension } .

field_key        = identifier .

field            = expr [ alias ] .

fields           = field { &quot;,&quot; field } .

fill_option      = &quot;null&quot; | &quot;none&quot; | &quot;previous&quot; | int_lit | float_lit | &quot;linear&quot; .

host             = string_lit .

measurement      = measurement_name |
( policy_name &quot;.&quot; measurement_name ) |
( db_name &quot;.&quot; [ policy_name ] &quot;.&quot; measurement_name ) .

measurements     = measurement { &quot;,&quot; measurement } .

measurement_name = identifier | regex_lit .

password         = string_lit .

policy_name      = identifier .

privilege        = &quot;ALL&quot; [ &quot;PRIVILEGES&quot; ] | &quot;READ&quot; | &quot;WRITE&quot; .

query_id         = int_lit .

query_name       = identifier .

retention_policy = identifier .

retention_policy_option      = retention_policy_duration |
retention_policy_replication |
retention_policy_shard_group_duration |
&quot;DEFAULT&quot; .

retention_policy_duration    = &quot;DURATION&quot; duration_lit .

retention_policy_replication = &quot;REPLICATION&quot; int_lit .

retention_policy_shard_group_duration = &quot;SHARD DURATION&quot; duration_lit .

retention_policy_name = &quot;NAME&quot; identifier .

series_id        = int_lit .

shard_id         = int_lit .

sort_field       = field_key [ ASC | DESC ] .

sort_fields      = sort_field { &quot;,&quot; sort_field } .

subscription_name = identifier .

tag_key          = identifier .

tag_keys         = tag_key { &quot;,&quot; tag_key } .

user_name        = identifier .

var_ref          = measurement .
</code></pre>
</li>
<li>
<h3 id="查询引擎内部-1"><a class="header" href="#查询引擎内部-1">查询引擎内部</a></h3>
<p>查询的生命周期是这样的；</p>
<ul>
<li>
<p>对CnosQL查询字符串进行标记，然后将其解析为抽象语法树(AST)。这是查询本身的代码表示。</p>
</li>
<li>
<p>AST被传递给<code>QueryExecutor</code>, <code>QueryExecutor</code>将查询定向到适当的处理程序。例如，与元数据相关的查询由元服务执行，<code>SELECT</code>语句由分片自己执行。</p>
</li>
<li>
<p>然后，查询引擎确定与<code>SELECT</code>语句的时间范围匹配的分片。从这些分片中，为语句中的每个字段创建迭代器。</p>
</li>
<li>
<p>迭代器被传递给发射器，发射器耗尽迭代器并连接结果点。发射器的工作是将简单的时间/值点转换为返回给客户端的更复杂的结果对象。</p>
</li>
<li>
<h4 id="理解迭代器"><a class="header" href="#理解迭代器">理解迭代器</a></h4>
<p>迭代器是查询引擎的核心。它们为在一组点上循环提供了一个简单的接口。例如，这是一个浮点数的迭代器:</p>
<pre><code>type FloatIterator interface {
    Next() *FloatPoint
}
</code></pre>
<p>这些迭代器是通过<code>IteratorCreator</code>接口创建的:</p>
<pre><code>type IteratorCreator interface {
    CreateIterator(opt *IteratorOptions) (Iterator, error)
}
</code></pre>
<p><code>IteratorOptions</code>提供了关于字段选择、时间范围和维度的参数，迭代器创建者在规划迭代器时可以使用这些参数。<code>IteratorCreator</code>接口用于许多级别，如<code>Shards</code>、<code>Shard</code>和<code>Engine</code>。这允许在适当的时候执行优化，例如返回预先计算的<code>COUNT()</code>。
迭代器不仅仅是从存储器中读取原始数据。迭代器可以进行组合，以便围绕输入迭代器提供额外的功能。例如，<code>DistinctIterator</code>可以为输入迭代器计算每个时间窗口的不同值。或者，<code>FillIterator</code>可以生成输入迭代器所缺少的额外点。
这种组合也很适合聚合。例如，像这样的语句:</p>
<pre><code>SELECT MEAN(temperature) FROM cpu GROUP BY time(10m)
</code></pre>
<p>本例中，MEAN(temperature)是一个从底层分片包装迭代器的<code>MeanIterator</code>。但是，如果我们可以添加一个额外的迭代器来确定平均值的导数:</p>
<pre><code>SELECT DERIVATIVE(MEAN(temperature), 20m) FROM cpu GROUP BY time(10m)
</code></pre>
</li>
<li>
<h4 id="理解游标"><a class="header" href="#理解游标">理解游标</a></h4>
<p>游标通过元组(时间、值)中的分片标识单个序列(测量值、标签集和字段)的数据。游标遍历以日志结构的合并树形式存储的数据，并跨级别处理重复数据删除、删除数据的tombstone和合并缓存(Write Ahead Log)。游标按时间升序或降序对(时间，值)元组进行排序。</p>
</li>
<li>
<h4 id="理解辅助字段"><a class="header" href="#理解辅助字段">理解辅助字段</a></h4>
<p>因为CnosQL允许用户使用FIRST()、LAST()、MIN()和MAX()等选择器函数，所以引擎必须提供一种方法，在选择点的同时返回相关数据。</p>
</li>
<li>
<h4 id="内置的迭代器"><a class="header" href="#内置的迭代器">内置的迭代器</a></h4>
<p>有许多内置迭代器可以让我们构建查询:</p>
<ul>
<li>排序合并迭代器——该迭代器将一个或多个迭代器合并成一个相同类型的新迭代器。该迭代器保证在开始下一个窗口之前输出窗口内的所有点，但不提供窗口内的排序保证。这允许快速访问聚合查询，而聚合查询不需要更强的排序保证。</li>
<li>限制迭代器——该迭代器限制每个名称/标签组的点数。这是<code>LIMIT &amp; OFFSET</code>语法的实现。</li>
<li>填充迭代器——如果输入迭代器缺少额外的点，这个迭代器会注入额外的点。它可以提供空点、带有前一个值的点或带有特定值的点。</li>
<li>缓冲迭代器——该迭代器提供了将一个点“未读”回缓冲区的能力，以便下次可以再次读取它。这被广泛用于为窗口提供前瞻。</li>
<li>Reduce迭代器——该迭代器为窗口中的每个点调用一个Reduce函数。当窗口完成时，输出该窗口的所有点。这用于简单的聚合函数，如COUNT()。</li>
<li>Reduce Slice迭代器——该迭代器首先收集窗口的所有点，然后将它们一次性全部传递给Reduce函数。迭代器返回结果。这用于聚合函数，如DERIVATIVE()。</li>
<li>Transform迭代器——该迭代器为输入迭代器中的每个点调用Transform函数。它用于执行二进制表达式。</li>
<li>重复数据删除迭代器——此迭代器只输出唯一的点。它是资源密集型的，所以它只用于像元查询语句这样的小查询。</li>
</ul>
</li>
<li>
<h4 id="调用迭代器"><a class="header" href="#调用迭代器">调用迭代器</a></h4>
<p>CnosQL中的函数调用在两个级别上实现。为了提高效率，可以将一些调用封装在多个层上。例如，一个<code>COUNT()</code>可以在分片层执行，然后多个<code>counterator</code>可以与另一个<code>counterator</code>包装，以计算所有分片的计数。这些迭代器可以使用<code>NewCallIterator()</code>创建。有些迭代器更复杂，或者需要在更高的级别上实现。例如，在执行计算之前，<code>DERIVATIVE()</code>需要首先检索窗口的所有点。这个迭代器是由引擎本身创建的，较低级别的迭代器不会被要求创建。</p>
</li>
</ul>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../content/cnosdb/latest/management.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next" href="../../../content/cnosdb/latest/protocol.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../content/cnosdb/latest/management.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next" href="../../../content/cnosdb/latest/protocol.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
