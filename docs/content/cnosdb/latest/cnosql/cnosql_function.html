<!DOCTYPE HTML>
<html lang="zh-CN" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>函数 - CnosDB</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../../../../favicon.svg">
        <link rel="shortcut icon" href="../../../../favicon.png">
        <link rel="stylesheet" href="../../../../css/variables.css">
        <link rel="stylesheet" href="../../../../css/general.css">
        <link rel="stylesheet" href="../../../../css/chrome.css">
        <link rel="stylesheet" href="../../../../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../../../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../../../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../../../../highlight.css">
        <link rel="stylesheet" href="../../../../tomorrow-night.css">
        <link rel="stylesheet" href="../../../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../../../../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/about.html"><strong aria-hidden="true">1.</strong> 关于CnosDB</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/introduction/index.html"><strong aria-hidden="true">2.</strong> 快速上手</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/introduction/install.html"><strong aria-hidden="true">2.1.</strong> 下载与安装</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/introduction/cnosdb-cli.html"><strong aria-hidden="true">2.2.</strong> 命令行终端</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/introduction/quick-start.html"><strong aria-hidden="true">2.3.</strong> 快速开始</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/protocol/index.html"><strong aria-hidden="true">3.</strong> 应用编程接口</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/protocol/line_protocol.html"><strong aria-hidden="true">3.1.</strong> CnosDB Line Protocol</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/protocol/write_api.html"><strong aria-hidden="true">3.2.</strong> CnosDB Write API</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/protocol/query_api.html"><strong aria-hidden="true">3.3.</strong> CnosDB Query API</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/protocol/prometheus.html"><strong aria-hidden="true">3.4.</strong> Prometheus</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/protocol/goland.html"><strong aria-hidden="true">3.5.</strong> Golang</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/managerment/index.html"><strong aria-hidden="true">4.</strong> 运维管理</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/managerment/export_import.html"><strong aria-hidden="true">4.1.</strong> 导入和导出</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/managerment/backup_restore.html"><strong aria-hidden="true">4.2.</strong> 备份和还原</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/managerment/configuration.html"><strong aria-hidden="true">4.3.</strong> CnosDB配置</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/sandboxmanagement.html"><strong aria-hidden="true">4.4.</strong> 集群管理</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosdb_tools/index.html"><strong aria-hidden="true">4.5.</strong> 运维工具介绍</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosdb_tools/cnosdb.html"><strong aria-hidden="true">4.5.1.</strong> cnosdb</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosdb_tools/cnosdb-cli.html"><strong aria-hidden="true">4.5.2.</strong> cnosdb-cli</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosdb_tools/cnosdb-inspect.html"><strong aria-hidden="true">4.5.3.</strong> cnosdb-inspect</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/index.html"><strong aria-hidden="true">5.</strong> 语法参考手册</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/cnosql_sample.html"><strong aria-hidden="true">5.1.</strong> 示例数据</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/cnosql_syntax.html"><strong aria-hidden="true">5.2.</strong> 数据查询</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/cnosql_management.html"><strong aria-hidden="true">5.3.</strong> 数据库管理和模式查询</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/cnosql_function.html" class="active"><strong aria-hidden="true">5.4.</strong> 函数</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/continuous_queries.html"><strong aria-hidden="true">5.5.</strong> 连续查询</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/math_operators.html"><strong aria-hidden="true">5.6.</strong> 数学运算符</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/cnosql/cnosql_spect.html"><strong aria-hidden="true">5.7.</strong> 语法约定</a></li></ol></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/other/index.html"><strong aria-hidden="true">6.</strong> 其他</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/other/version_manager.html"><strong aria-hidden="true">6.1.</strong> 发行版本说明</a></li><li class="chapter-item expanded "><a href="../../../../content/cnosdb/latest/other/tsdb-comparisions.html"><strong aria-hidden="true">6.2.</strong> CnosDB性能比较</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CnosDB</h1>

                    <div class="right-buttons">
                        <a href="../../../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h2 id="cnosql函数"><a class="header" href="#cnosql函数">CnosQL函数</a></h2>
<ul>
<li>
<h3 id="目录"><a class="header" href="#目录">目录</a></h3>
<ul>
<li><a href="#%E8%81%9A%E5%90%88%E5%87%BD%E6%95%B0">聚合函数</a>
<ul>
<li><a href="#count">COUNT()</a></li>
<li><a href="#distinct">DISTINCT()</a></li>
<li><a href="#integral">INTEGRAL()</a></li>
<li><a href="#mean">MEAN()</a></li>
<li><a href="#median">MEDIAN()</a></li>
<li><a href="#mode">MODE()</a></li>
<li><a href="#spread">SPREAD()</a></li>
<li><a href="#stddev">STDDEV()</a></li>
<li><a href="#sum">SUM()</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E5%87%BD%E6%95%B0">选择函数</a>
<ul>
<li><a href="#bottom">BOTTOM()</a></li>
<li><a href="#first">FIRST()</a></li>
<li><a href="#last">LAST()</a></li>
<li><a href="#max">MAX()</a></li>
<li><a href="#min">MIN()</a></li>
<li><a href="#percentile">PERCENTILE()</a></li>
<li><a href="#sample">SAMPLE()</a></li>
<li><a href="#top">TOP()</a></li>
</ul>
</li>
<li><a href="#%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0">转换函数</a>
<ul>
<li><a href="#abs">ABS()</a></li>
<li><a href="#acos">ACOS()</a></li>
<li><a href="#asin">ASIN()</a></li>
<li><a href="#atan">ATAN()</a></li>
<li><a href="#atan2">ATAN2()</a></li>
<li><a href="#ceil">CEIL()</a></li>
<li><a href="#cos">COS()</a></li>
<li><a href="#cumulative-sum">CUMULATIVE_SUM()</a></li>
<li><a href="#derivative">DERIVATIVE()</a></li>
<li><a href="#difference">DIFFERENCE()</a></li>
<li><a href="#elapsed">ELAPSED()</a></li>
<li><a href="#exp">EXP()</a></li>
<li><a href="#floor">FLOOR()</a></li>
<li><a href="#histogram">HISTOGRAM()</a></li>
<li><a href="#ln">LN()</a></li>
<li><a href="#log">LOG()</a></li>
<li><a href="#log2">LOG2()</a></li>
<li><a href="#log10">LOG10()</a></li>
<li><a href="#moving-average">MOVING_AVERAGE()</a></li>
<li><a href="#non-negative-derivative">NON_NEGATIVE_DERIVATIVE()</a></li>
<li><a href="#non-negative-difference">NON_NEGATIVE_DIFFERENCE()</a></li>
<li><a href="#pow">POW()</a></li>
<li><a href="#round">ROUND()</a></li>
<li><a href="#sin">SIN()</a></li>
<li><a href="#sqrt">SQRT()</a></li>
<li><a href="#tan">TAN()</a></li>
</ul>
</li>
<li><a href="#%E9%A2%84%E6%B5%8B%E5%87%BD%E6%95%B0">预测函数</a>
<ul>
<li><a href="#holt_winters">HOLT_WINTERS()</a></li>
</ul>
</li>
<li><a href="#%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0">分析函数</a>
<ul>
<li><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></li>
<li><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></li>
<li><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></li>
<li><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></li>
<li><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></li>
<li><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></li>
</ul>
</li>
<li><a href="#other">其他</a>
<ul>
<li><a href="#%E7%A4%BA%E4%BE%8B%E6%95%B0%E6%8D%AE">示例数据</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E9%80%9A%E7%94%A8%E8%AF%AD%E6%B3%95">函数的通用语法</a>
<ul>
<li><a href="#%E5%9C%A8SELECT%E4%B8%AD%E6%8C%87%E5%AE%9A%E5%A4%9A%E4%B8%AA%E5%87%BD%E6%95%B0">在<code>SELECT</code>中指定多个函数</a></li>
<li><a href="#%E9%87%8D%E5%91%BD%E5%90%8D%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%AD%97%E6%AE%B5">重命名查询结果字段</a></li>
<li><a href="#%E6%94%B9%E5%8F%98%E4%B8%8D%E5%90%AB%E6%95%B0%E6%8D%AE%E7%9A%84%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC">改变不含数据的时间间隔的返回值</a></li>
</ul>
</li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98">函数常见问题</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="聚合函数"><a class="header" href="#聚合函数">聚合函数</a></h3>
<ul>
<li>
<h3 id="count"><a class="header" href="#count">COUNT()</a></h3>
<p>返回非空值 field values数量</p>
<h4 id="语法"><a class="header" href="#语法">语法</a></h4>
<pre><code class="language-sql">SELECT COUNT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法"><a class="header" href="#嵌套语法">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<p><code>COUNT(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的个数。</p>
<p><code>COUNT()</code>支持所有数据类型的<code>field value</code>。CnosQL支持将<a href="#distinct"><code>DISTINCT()</code></a>函数嵌套在<code>COUNT()</code>函数里。</p>
<h4 id="示例"><a class="header" href="#示例">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key的field-value的数目"><a class="header" href="#计算指定field-key的field-value的数目">计算指定field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回measurement<code>air</code>中的<code>temperature</code>的非空field value的数量。</p>
<ul>
<li>
<h4 id="计数measurement中每个field-key关联的field-value的数量"><a class="header" href="#计数measurement中每个field-key关联的field-value的数量">计数measurement中每个field key关联的field value的数量</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(*) FROM &quot;air&quot;
name: air
time                 count_pressure count_temperature count_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 3334           3334              3334
</code></pre>
<p>该查询返回与measurement<code>air</code>相关联的每个field key的非空field value的数量。<code>air</code>有3个field keys：<code>count_pressure</code> <code>count_temperature</code> <code>count_visibility</code></p>
<ul>
<li>
<h4 id="计算匹配一个正则表达式的每个field-key关联的field-value的数目"><a class="header" href="#计算匹配一个正则表达式的每个field-key关联的field-value的数目">计算匹配一个正则表达式的每个field key关联的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COUNT(/.*pre.*/) FROM &quot;air&quot;
name: air
time                 count_pressure
----                 --------------
1970-01-01T00:00:00Z 3334
</code></pre>
<p>该查询返回measurement<code>air</code>中包含<code>pre</code>的每个field key的非空字段值的数量。</p>
<ul>
<li>
<h4 id="计数包括多个子句的field-key的field-value的数目"><a class="header" href="#计数包括多个子句的field-key的field-value的数目">计数包括多个子句的field key的field value的数目</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;  SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1ms),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                     count
----                     -----
2022-04-11T08:03:37.071Z 108
2022-04-11T08:03:37.072Z 193
2022-04-11T08:03:37.073Z 207
2022-04-11T08:03:37.074Z 209
2022-04-11T08:03:37.075Z 209
2022-04-11T08:03:37.076Z 218
2022-04-11T08:03:37.077Z 216
</code></pre>
<p>该查询返回<code>pressure</code>field key中的非空field value的数量。它涵盖<code>now()</code>之间的<code>时间段</code>，并将结果分组为1ms的时间间隔和每个tag(表示为以上代码中的<code>*</code>)。并用<code>-1</code>填充空的时间间隔，并返回7个<code>point</code>，表格返回1。</p>
<ul>
<li>
<h4 id="计算一个field-key的distinct的field-value的数量"><a class="header" href="#计算一个field-key的distinct的field-value的数量">计算一个field key的distinct的field value的数量</a></h4>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
</li>
</ul>
<p>该查询返回measurement为<code>air</code>field为<code>pressure</code> 的唯一field value的数量。</p>
</li>
</ul>
<h4 id="count的常见问题"><a class="header" href="#count的常见问题"><code>COUNT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="count和fill"><a class="header" href="#count和fill"><code>COUNT()</code>和<code>fill()</code></a></h4>
</li>
</ul>
<p>大多数CnosQL函数对于没有数据的时间间隔返回<code>null</code>值，<code>fill(&lt;fill_option&gt;)</code>将该<code>null</code>值替换为<code>fill_option</code>。 <code>COUNT()</code>针对没有数据的时间间隔返回<code>0</code>，<code>fill(&lt;fill_option&gt;)</code>用<code>fill_option</code>替换0值。</p>
<p><em>示例</em></p>
<p>下面的代码块中的第一个查询不包括<code>fill()</code>。最后一个时间间隔没有数据，因此该时间间隔的值返回为零。第二个查询包括<code>fill(-1)</code>; 它将最后一个间隔中的零替换为<code>-1</code>。</p>
<pre><code class="language-sql">&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),*  LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z 0
2022-04-11T08:03:39Z 0
2022-04-11T08:03:40Z 0
2022-04-11T08:03:41Z 0
2022-04-11T08:03:42Z 0
2022-04-11T08:03:43Z 0

&gt; SELECT COUNT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &lt; now()  GROUP BY time(1s),* fill(-1) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 count
----                 -----
2022-04-11T08:03:37Z 1617
2022-04-11T08:03:38Z -1
2022-04-11T08:03:39Z -1
2022-04-11T08:03:40Z -1
2022-04-11T08:03:41Z -1
2022-04-11T08:03:42Z -1
2022-04-11T08:03:43Z -1
</code></pre>
<ul>
<li>
<h3 id="distinct"><a class="header" href="#distinct"><code>DISTINCT()</code></a></h3>
<p>返回<code>field value</code>的不重复值列表。</p>
<h4 id="语法-1"><a class="header" href="#语法-1">语法</a></h4>
<pre><code class="language-sql">SELECT DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="嵌套语法-1"><a class="header" href="#嵌套语法-1">嵌套语法</a></h4>
<pre><code class="language-sql">SELECT COUNT(DISTINCT( [ &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [...]
</code></pre>
<h4 id="语法描述"><a class="header" href="#语法描述">语法描述</a></h4>
<p><code>DISTINCT(field_key)</code> 返回<code>field key</code>对应的不同<code>field values</code>。</p>
<p><code>DISTINCT()</code> 支持所有数据类型的<code>field value</code>，CnosQL支持<a href="#count"><code>COUNT()</code></a>嵌套<code>DISTINCT()</code>。</p>
<h4 id="示例-1"><a class="header" href="#示例-1">示例</a></h4>
<ul>
<li>
<h4 id="列出一个field-key的不同的field-value"><a class="header" href="#列出一个field-key的不同的field-value">列出一个<code>field key</code>的不同的<code>field value</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 57
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 60
</code></pre>
<p>该查询返回<code>air</code> measurement中<code>temperature</code>field 关键字中唯一<code>field values</code>的列表</p>
</li>
</ul>
<ul>
<li>
<h4 id="列出包含多个子句的field-key关联的不同值的列表"><a class="header" href="#列出包含多个子句的field-key关联的不同值的列表">列出包含多个子句的field key关联的不同值的列表</a></h4>
<pre><code class="language-sql">&gt;SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot; WHERE  time &lt;now() GROUP BY time(12m),* SLIMIT 1
name: air
tags: station=LianYunGang
time                 distinct
----                 --------
2022-04-11T08:00:00Z 58
2022-04-11T08:00:00Z 56
2022-04-11T08:00:00Z 59
2022-04-11T08:00:00Z 57
2022-04-11T08:00:00Z 62
2022-04-11T08:00:00Z 60
2022-04-11T08:00:00Z 61
</code></pre>
</li>
</ul>
<p>该查询返回<code>pressure</code>field key中不同field value的列表。它涵盖now()之前的时间段，并将结果按12分钟的时间间隔和每个tag分组。查询限制（SLIMIT）返回一个series。</p>
<ul>
<li>
<h4 id="对一个字段的不同值进行计算"><a class="header" href="#对一个字段的不同值进行计算">对一个字段的不同值进行计算</a></h4>
<pre><code class="language-sql">&gt; SELECT COUNT(DISTINCT(&quot;pressure&quot;)) FROM &quot;air&quot;
name: air
time                 count
----                 -----
1970-01-01T00:00:00Z 7
</code></pre>
</li>
</ul>
<p>查询返回<code>air</code>这个measurement中字段<code>pressure</code>的不同值的数目。</p>
<h4 id="distinct的常见问题"><a class="header" href="#distinct的常见问题"><code>DISTINCT()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="distinct-和-into-子句"><a class="header" href="#distinct-和-into-子句"><code>DISTINCT()</code> 和 <code>INTO</code> 子句</a></h4>
</li>
</ul>
<p>在<code>INTO</code>子句中使用<code>DISTINCT()</code>可能会导致CnosDB覆盖目标measurement中的<code>points</code>。<code>DISTINCT()</code>通常返回多个具有相同时间戳的结果；CnosDB假设在相同series中并具有相同时间戳的<code>point</code>是重复<code>point</code>，并简单地用目标measurement中最新的<code>point</code>覆盖重复<code>point</code>。</p>
<p>####示例</p>
<p>下面代码块中的第一个查询使用了<code>DISTINCT()</code>，并返回7个结果。请注意，每个结果都有相同的时间戳。第二个查询将<code>INTO</code>子句添加到查询中，并将查询结果写入measurement <code>distincts</code>。最后一个查询选择measurement <code>distincts</code>中所有数据。
因为原来的四个结果是重复的(它们在相同的series，有相同的时间戳)，所以最后一个查询只返回一个<code>point</code>。当系统遇到重复数据<code>point</code>，它会用最近的<code>point</code>覆盖之前的<code>point</code>。</p>
<pre><code class="language-sql">&gt; SELECT DISTINCT(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 distinct
----                 --------
1970-01-01T00:00:00Z 56
1970-01-01T00:00:00Z 59
1970-01-01T00:00:00Z 62
1970-01-01T00:00:00Z 58
1970-01-01T00:00:00Z 60
1970-01-01T00:00:00Z 61
1970-01-01T00:00:00Z 57

&gt; SELECT DISTINCT(&quot;pressure&quot;) INTO &quot;distincts&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 7 

&gt; SELECT * FROM &quot;distincts&quot;
name: distincts
time                 distinct
----                 --------
1970-01-01T00:00:00Z 57
</code></pre>
<ul>
<li>
<h3 id="integral"><a class="header" href="#integral"><code>INTEGRAL()</code></a></h3>
<p>返回<code>field value</code>曲线下的面积，即关于<code>field value</code>的积分。</p>
<h4 id="语法-2"><a class="header" href="#语法-2">语法</a></h4>
<pre><code>SELECT INTEGRAL( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ]  ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-1"><a class="header" href="#语法描述-1">语法描述</a></h4>
<p>CnosDB计算field value曲线下的面积，并将这些结果转换为每个<code>unit</code>的总面积。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>INTEGRAL(field_key)</code>返回field key关联的值之下的面积。</p>
<p><code>INTEGRAL(/regular_expression/)</code>返回满足正则表达式的每个field key关联的值之下的面积。</p>
<p><code>INTEGRAL(*)</code>返回<code>measurement</code>中每个<code>field key</code>关联的值之下的面积。</p>
<p><code>INTEGRAL()</code>不支持<code>fill()</code>，<code>INTEGRAL()</code>支持int64和float64两个数据类型。</p>
<h4 id="示例-2"><a class="header" href="#示例-2">示例</a></h4>
<p>下面的五个例子，使用数据库<a href="oceanic_station.txt"><code>oceanic_station</code>中的数据</a>：</p>
<pre><code class="language-sql">&gt;  SELECT  temperature  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                        temperature
----                        -----------
2022-04-11T08:03:37.07132Z  58
2022-04-11T08:03:37.071378Z 62
2022-04-11T08:03:37.071385Z 58
2022-04-11T08:03:37.071391Z 56
2022-04-11T08:03:37.071394Z 56
2022-04-11T08:03:37.071401Z 59
2022-04-11T08:03:37.071403Z 57
2022-04-11T08:03:37.071406Z 62
2022-04-11T08:03:37.071409Z 59
2022-04-11T08:03:37.071411Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定的field-key的值得积分"><a class="header" href="#计算指定的field-key的值得积分">计算指定的field key的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt;SELECT  INTEGRAL(temperature)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10 
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 0.4677579999999999
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以秒为单位）。</p>
<ul>
<li>
<h4 id="计算指定的field-key和时间单位的值的积分"><a class="header" href="#计算指定的field-key和时间单位的值的积分">计算指定的field key和时间单位的值的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' limit 10
name: air
time                 integral
----                 --------
1970-01-01T00:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>air</code>中的字段<code>temperature</code>的曲线下的面积（以1ms为单位）。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中每个field-key在指定时间单位的值得积分">计算measurement中每个field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(*,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_pressure  integral_temperature integral_visibility
----                 -----------------  -------------------- -------------------
1970-01-01T00:00:00Z 467.22900000000413 467.7580000000045    491.2000000000007
</code></pre>
<p>查询返回measurement<code>air</code>中存储的每个数值字段相关的字段值的曲线下面积（以1ms为单位）</p>
<ul>
<li>
<h4 id="计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分"><a class="header" href="#计算measurement中匹配正则表达式的field-key在指定时间单位的值得积分">计算measurement中匹配正则表达式的field key在指定时间单位的值得积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(/temp/,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now()
name: air
time                 integral_temperature
----                 --------------------
1970-01-01T00:00:00Z 467.7580000000045

</code></pre>
<p>查询返回field key包括单词<code>water</code>的每个数值类型的字段相关联的字段值的曲线下的区域（以分钟为单位）。</p>
<ul>
<li>
<h4 id="在含有多个子句中计算指定字段的积分"><a class="header" href="#在含有多个子句中计算指定字段的积分">在含有多个子句中计算指定字段的积分</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT  INTEGRAL(temperature,1ms)  FROM &quot;air&quot; WHERE &quot;station&quot; = 'XiaoMaiDao' and time&lt;now() GROUP BY time(12m) LIMIT 1
name: air
time                 integral_temperature
----                 --------------------
2022-04-11T08:00:00Z 467.7580000000045
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的field value曲线下的面积(以分钟为单位)，它涵盖的时间范围在now()之前，并将查询结果按12分钟的时间间隔进行分组，同时，该查询将返回的<code>point</code>个数限制为1。</p>
</li>
<li>
<h3 id="mean"><a class="header" href="#mean"><code>MEAN()</code></a></h3>
<p>返回field value的平均值。</p>
<h4 id="语法-3"><a class="header" href="#语法-3">语法</a></h4>
<pre><code>SELECT MEAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MEAN(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的field value的平均值。</p>
<p><code>MEAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的平均值。</p>
<p><code>MEAN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-3"><a class="header" href="#示例-3">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值"><a class="header" href="#计算指定field-key对应的field-value的平均值">计算指定field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                   mean
----                   ----
1970-01-01T00:00:00Z   4.442107025822522
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的平均值">计算measurement中每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(*) FROM &quot;air&quot; 
name: air
time                 mean_pressure     mean_temperature  mean_visibility
----                 -------------     ----------------  ---------------
1970-01-01T00:00:00Z 59.00689862027595 59.04949010197961 62.01889622075585
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的平均值">计算与正则表达式匹配的每个field key对应的field value的平均值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(/temp/) FROM &quot;air&quot; 
name: air
time                   mean_temperature
----                   ----------------
1970-01-01T00:00:00Z   4.442107025822523
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>的平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平均值并包含多个子句">计算指定field key对应的field value的平均值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(9.01) LIMIT 7 SLIMIT 1
name: air
tags: station=LianYunGang
time                 mean
----                 ----
2022-04-11T08:00:00Z 59.06864564007421
2022-04-11T08:12:00Z 9.01
2022-04-11T08:24:00Z 9.01
2022-04-11T08:36:00Z 9.01
2022-04-11T08:48:00Z 9.01
2022-04-11T09:00:00Z 9.01
2022-04-11T09:12:00Z 9.01 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value的平均值，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为7和1。</p>
</li>
<li>
<h3 id="median"><a class="header" href="#median">MEDIAN()</a></h3>
<p>返回<code>field value</code>的计算中值。</p>
<h4 id="语法-4"><a class="header" href="#语法-4">语法</a></h4>
<pre><code>SELECT MEDIAN( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-2"><a class="header" href="#语法描述-2">语法描述</a></h4>
<p><code>MEDIAN(field_key)</code>返回与<code>field key</code>对应的field value的中值。</p>
<p><code>MEDIAN(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>的中值。</p>
<p><code>MEDIAN()</code> 支持数据类型为int64和float64的field value。</p>
<blockquote>
<p><strong>注意：</strong><code>MEDIAN()</code>近似于<code>PERCENTILE(field_key, 50)</code>，除非<code>field key</code>包含的<code>field value</code>有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</p>
</blockquote>
<h4 id="示例-4"><a class="header" href="#示例-4">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值"><a class="header" href="#计算指定field-key对应的field-value的中值">计算指定field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 median
----                 ------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>pressure</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的中值"><a class="header" href="#计算measurement中每个field-key对应的field-value的中值">计算measurement中每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(*) FROM &quot;air&quot;
name: air
time                 median_pressure median_temperature median_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 59              59                 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>的中值。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的中值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的中值">计算与正则表达式匹配的每个field key对应的field value的中值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(/temp/) FROM &quot;air&quot;
name: air
time                 median_temperature
----                 ------------------
1970-01-01T00:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的中值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的中值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的中值并包含多个子句">计算指定field key对应的field value的中值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE  time&lt;now()  GROUP BY time(1m),* fill(-1) LIMIT 7 SLIMIT 3 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 median
----                 ------
2022-04-11T08:03:00Z 59
2022-04-11T08:04:00Z -1
2022-04-11T08:05:00Z -1
2022-04-11T08:06:00Z -1
2022-04-11T08:07:00Z -1
2022-04-11T08:08:00Z -1
2022-04-11T08:09:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>的平均数，它涵盖的时间范围在now()之前，并将查询结果按1分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="mode"><a class="header" href="#mode">MODE()</a></h3>
<p>返回<code>field value</code>中出现频率最高的值。</p>
<h4 id="语法-5"><a class="header" href="#语法-5">语法</a></h4>
<pre><code>SELECT MODE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MODE(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<p><code>MODE()</code> 支持所有数据类型的<code>field value</code>。</p>
<blockquote>
<p>**注意：**如果出现频率最高的值有两个或多个并且它们之间有关联，那么<code>MODE()</code>返回具有最早时间戳的<code>field value</code>。</p>
</blockquote>
<h4 id="示例-5"><a class="header" href="#示例-5">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值">计算指定field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mode
----                 ----
1970-01-01T00:00:00Z 62
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中某个<code>field key</code>对应的<code>field value</code>中出现频率最高的值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算measurement中每个field-key对应的field-value中出现频率最高的值">计算measurement中每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(*) FROM &quot;air&quot;
name: air
time                 mode_pressure mode_temperature mode_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 57            62               61
</code></pre>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中出现频率最高的值">计算与正则表达式匹配的每个field key对应的field value中出现频率最高的值</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT MODE(/temp/) FROM &quot;air&quot;
name: air
time                 mode_temperature
----                 ----------------
1970-01-01T00:00:00Z 62
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中出现频率最高的值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中出现频率最高的值并包含多个子句">计算指定field key对应的field value中出现频率最高的值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 mode
----                 ----
2022-04-11T08:00:00Z 59
2022-04-11T08:12:00Z 
2022-04-11T08:24:00Z 
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>temperature</code>中出现频率最高的值，并将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）。</p>
</li>
<li>
<h3 id="spread"><a class="header" href="#spread">SPREAD()</a></h3>
<p>返回<code>field value</code>中最大值和最小值之差。</p>
<h4 id="语法-6"><a class="header" href="#语法-6">语法</a></h4>
<pre><code class="language-sql">SELECT SPREAD( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-3"><a class="header" href="#语法描述-3">语法描述</a></h4>
<p><code>SPREAD(field_key)</code>返回<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD(*)</code>返回在<code>measurement</code>中每个<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<p><code>SPREAD()</code>支持数据类型为int64和float64的<code>field value</code>。</p>
<h4 id="示例-6"><a class="header" href="#示例-6">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差">计算指定field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 spread
----                 ------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中<code>field key</code> <code>temperature</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算measurement中每个field-key对应的field-value中最大值和最小值之差">计算measurement中每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(*) FROM &quot;air&quot;
name: air
time                 spread_pressure spread_temperature spread_visibility
----                 --------------- ------------------ -----------------
1970-01-01T00:00:00Z 6               6                  6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value中最大值和最小值之差">计算与正则表达式匹配的每个field key对应的field value中最大值和最小值之差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(/tem/) FROM &quot;air&quot;
name: air
time                 spread_temperature
----                 ------------------
1970-01-01T00:00:00Z 6
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中每个存储数值并包含单词<code>water</code>的<code>field key</code>对应的<code>field value</code>中最大值和最小值之差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value中最大值和最小值之差并包含多个子句">计算指定field key对应的field value中最大值和最小值之差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SPREAD(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(-1) LIMIT 3 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 spread
----                 ------
2022-04-11T08:00:00Z 6
2022-04-11T08:12:00Z -1
2022-04-11T08:24:00Z -1
</code></pre>
<p>该查询返回<code>measurement</code> <code>air</code>中field key <code>temperature</code>对应的field value中最大值和最小值之差，将查询结果按12分钟的时间间隔和每个<code>tag</code>进行分组，同时，该查询用<code>-1</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和<code>series</code>个数分别限制为3和1，并将返回的<code>series</code>偏移一个（即第一个<code>series</code>的数据不返回）</p>
</li>
<li>
<h3 id="stddev"><a class="header" href="#stddev">STDDEV()</a></h3>
<p>返回<code>field value</code>的标准差。</p>
<h4 id="语法-7"><a class="header" href="#语法-7">语法</a></h4>
<pre><code class="language-sql">SELECT STDDEV( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>STDDEV(field_key)</code>返回<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(/regular_expression/)</code>返回与正则表达式匹配的每个<code>field key</code>对应的<code>field value</code>的标准差。</p>
<p><code>STDDEV(*)</code>返回在measurement中每个field key对应的field value的标准差。</p>
<p><code>STDDEV()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-7"><a class="header" href="#示例-7">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差"><a class="header" href="#计算指定field-key对应的field-value的标准差">计算指定field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 stddev
----                 ------
1970-01-01T00:00:00Z 1.9933006709246002
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的标准差"><a class="header" href="#计算measurement中每个field-key对应的field-value的标准差">计算measurement中每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(*) FROM &quot;air&quot;
name: air
time                 stddev_pressure    stddev_temperature stddev_visibility
----                 ---------------    ------------------ -----------------
1970-01-01T00:00:00Z 2.0234776612813525 1.9933006709246002 1.9942769555619093
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的标准差"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的标准差">计算与正则表达式匹配的每个field key对应的field value的标准差</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT STDDEV(/temp/) FROM &quot;air&quot;
name: air
time                   stddev_temperature
----                   ------------------
1970-01-01T00:00:00Z   2.279144584196141
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的标准差。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的标准差并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的标准差并包含多个子句">计算指定field key对应的field value的标准差并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">SELECT STDDEV(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 2 SLIMIT 1 SOFFSET 1
name: air
tags: station=XiaoMaiDao
time                 stddev
----                 ------
2022-04-11T08:00:00Z 1.9988781365491315
2022-04-11T08:12:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的标准差，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，将返回的<code>point</code>个数和series个数分别限制为2和1，并将返回的series偏移一个（即第一个series的数据不返回）。</p>
</li>
<li>
<h3 id="sum"><a class="header" href="#sum">SUM()</a></h3>
<p>返回field value的总和。</p>
<h4 id="语法-8"><a class="header" href="#语法-8">语法</a></h4>
<pre><code>SELECT SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-4"><a class="header" href="#语法描述-4">语法描述</a></h4>
<p><code>SUM(field_key)</code>返回field key对应的field value的总和。</p>
<p><code>SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的总和。</p>
<p><code>SUM(*)</code>返回在measurement中每个field key对应的field value的总和。</p>
<p><code>SUM()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-8"><a class="header" href="#示例-8">示例</a></h4>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和"><a class="header" href="#计算指定field-key对应的field-value的总和">计算指定field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的总和">计算measurement中每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(*) FROM &quot;air&quot;
name: air
time                 sum_pressure sum_temperature sum_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 196729       196871          206771
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的总和">计算与正则表达式匹配的每个field key对应的field value的总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(/temp/) FROM &quot;air&quot;
name: air
time                 sum_temperature
----                 ---------------
1970-01-01T00:00:00Z 196871
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的总和并包含多个子句">计算指定field key对应的field value的总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &lt;now() GROUP BY time(12m),* fill(18000) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 sum
----                 ---
2022-04-11T08:00:00Z 95514
2022-04-11T08:12:00Z 18000
2022-04-11T08:24:00Z 18000
2022-04-11T08:36:00Z 18000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的总和，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>18000</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
</li>
</ul>
<h2 id="选择函数"><a class="header" href="#选择函数">选择函数</a></h2>
<ul>
<li>
<h3 id="bottom"><a class="header" href="#bottom">BOTTOM()</a></h3>
<p>返回最小的N个field value。</p>
<h4 id="语法-9"><a class="header" href="#语法-9">语法</a></h4>
<pre><code>SELECT BOTTOM(&lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-5"><a class="header" href="#语法描述-5">语法描述</a></h4>
<p><code>BOTTOM(field_key,N)</code>返回field key对应的最小的N个值。</p>
<p><code>BOTTOM(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最小值。</p>
<p><code>BOTTOM(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最小的N个值，以及相关的tag和/或field。</p>
<p><code>BOTTOM()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最小值有两个或多个相等的值，<code>BOTTOM()</code>返回具有最早时间戳的field value。</li>
<li>当<code>BOTTOM()</code>函数与<code>INTO</code>子句一起使用时，<code>BOTTOM()</code>与其它CnosQL函数不同。请查看<code>BOTTOM()</code>的常见问题章节获得更多信息。</li>
</ul>
<h4 id="示例-9"><a class="header" href="#示例-9">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值"><a class="header" href="#选择指定field-key对应的最小的三个值">选择指定field key对应的最小的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom
----                 ------
2021-08-31T16:18:00Z 50
2021-08-31T17:09:00Z 50
2021-08-31T18:39:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最小的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最小值"><a class="header" href="#选择两个tag对应的field-key的最小值">选择两个tag对应的field key的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最小的四个值以及相关的tag和field">选择指定field key对应的最小的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 bottom station     pressure
----                 ------ -------     --------
2021-08-31T16:18:00Z 50     XiaoMaiDao  55
2021-08-31T17:09:00Z 50     XiaoMaiDao  63
2021-08-31T18:39:00Z 50     LianYunGang 64
2021-08-31T19:51:00Z 50     LianYunGang 62
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最小的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最小的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最小的三个值并包含多个子句">选择指定field key对应的最小的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 bottom station
----                 ------ -------
2021-09-18T00:54:00Z 69     LianYunGang
2021-09-18T00:51:00Z 65     LianYunGang
2021-09-18T00:48:00Z 68     XiaoMaiDao
2021-09-18T00:39:00Z 53     XiaoMaiDao
2021-09-18T00:36:00Z 52     LianYunGang
2021-09-18T00:33:00Z 50     LianYunGang
2021-09-18T00:06:00Z 55     LianYunGang
2021-09-18T00:03:00Z 53     XiaoMaiDao
2021-09-18T00:00:00Z 51     LianYunGang
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最小的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="bottom的常见问题"><a class="header" href="#bottom的常见问题"><code>BOTTOM()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="bottom和group-by-time子句同时使用"><a class="header" href="#bottom和group-by-time子句同时使用"><code>BOTTOM()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>BOTTOM()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>BOTTOM()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   bottom
----                   ------
                           __
2021-09-28T00:00:00Z  2.064 |
2021-09-18T00:12:00Z  2.028 | &lt;------- Smallest points for the first time interval
                           --
                           __
2021-09-18T00:24:00Z  2.041 |
2021-09-18T00:30:00Z  2.051 | &lt;------- Smallest points for the second time interval                      --
</code></pre>
<ul>
<li>
<h4 id="bottom和具有少于n个tag-value的tag-key"><a class="header" href="#bottom和具有少于n个tag-value的tag-key"><code>BOTTOM()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT BOTTOM(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最小值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 bottom station
----                 ------ -------
2021-08-31T16:18:00Z 50     XiaoMaiDao
2021-08-31T18:39:00Z 50     LianYunGang
</code></pre>
<ul>
<li>
<h4 id="bottomtag和into子句"><a class="header" href="#bottomtag和into子句"><code>BOTTOM()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数CnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>BOTTOM()</code>函数除非<code>BOTTOM()</code>中包含tag key作为参数：<code>BOTTOM(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最小值，并且，它这些结果写入measurement <code>bottom_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>bottom_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT BOTTOM(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;bottom_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;air&quot;
name: air
tagKey
------
station
</code></pre>
</li>
<li>
<h3 id="first"><a class="header" href="#first">FIRST()</a></h3>
<p>返回具有最早时间戳的field value。</p>
<h4 id="语法-10"><a class="header" href="#语法-10">语法</a></h4>
<pre><code>SELECT FIRST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<h4 id="语法描述-6"><a class="header" href="#语法描述-6">语法描述</a></h4>
<p><code>FIRST(field_key)</code>返回field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(*)</code>返回在measurement中每个field key对应的具有最早时间戳的field value。</p>
<p><code>FIRST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最早时间戳的field value，以及相关的tag或field。</p>
<p><code>FIRST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-10"><a class="header" href="#示例-10">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value">选择指定field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 first
----                 -----
2021-08-31T16:00:00Z 78
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最早时间戳的field-value">选择measurement中每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;

name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最早时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最早时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最早时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(/temp/) FROM &quot;air&quot;

name: air
time                 first_temperature
----                 -----------------
2021-08-31T16:00:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最早时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最早时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 first station     temperature
----                 ----- -------     -----------
2021-08-31T16:00:00Z 78    LianYunGang 63
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最早时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最早时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最早时间戳的field-value并包含多个子句">选择指定field key对应的具有最早时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FIRST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 first
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 70
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最早时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="last"><a class="header" href="#last">LAST()</a></h3>
<p>返回具有最新时间戳的field value。</p>
<h4 id="语法-11"><a class="header" href="#语法-11">语法</a></h4>
<pre><code class="language-sql">SELECT LAST(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_keys(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LAST(field_key)</code>返回field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(*)</code>返回在measurement中每个field key对应的具有最新时间戳的field value。</p>
<p><code>LAST(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的具有最新时间戳的field value，以及相关的tag或field。</p>
<p><code>LAST()</code>支持所有数据类型的field value。</p>
<h4 id="示例-11"><a class="header" href="#示例-11">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value">选择指定field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 last
----                 ----
2021-09-30T04:00:00Z 65
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择measurement中每个field-key对应的具有最新时间戳的field-value">选择measurement中每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(*) FROM &quot;air&quot;
name: air
time                 last_pressure last_temperature last_visibility
----                 ------------- ---------------- ---------------
1970-01-01T00:00:00Z 65            59               78
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的具有最新时间戳的field value。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的具有最新时间戳的field-value">选择与正则表达式匹配的每个field key对应的具有最新时间戳的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(/temp/) FROM &quot;air&quot;
name: air
time                 last_temperature
----                 ----------------
2021-09-30T04:00:00Z 59
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的具有最新时间戳的field value。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value以及相关的tag和field">选择指定field key对应的具有最新时间戳的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;pressure&quot;),&quot;station&quot;,&quot;temperature&quot; FROM &quot;air&quot;
name: air
time                 last station     temperature
----                 ---- -------     -----------
2021-09-30T04:00:00Z 65   LianYunGang 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>pressure</code>对应的具有最新时间戳的field value，以及相关的tag key <code>station</code>和field key <code>temperature</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的具有最新时间戳的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的具有最新时间戳的field-value并包含多个子句">选择指定field key对应的具有最新时间戳的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LAST(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 last
----                 ----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 68
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 58
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的具有最新时间戳的field value，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="max"><a class="header" href="#max">MAX()</a></h3>
<p>返回field value的最大值。</p>
<h4 id="语法-12"><a class="header" href="#语法-12">语法</a></h4>
<pre><code>SELECT MAX(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field__key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MAX(field_key)</code>返回field key对应的field value的最大值。</p>
<p><code>MAX(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最大值。</p>
<p><code>MAX(*)</code>返回在measurement中每个field key对应的field value的最大值。</p>
<p><code>MAX(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最大值，以及相关的tag或field。</p>
<p><code>MAX()</code> 支持数据类型为int64和float64的field value。</p>
<h4 id="示例-12"><a class="header" href="#示例-12">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值"><a class="header" href="#选择指定field-key对应的field-value的最大值">选择指定field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max
----                 ---
2021-08-31T18:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最大值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最大值">选择measurement中每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最大值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最大值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最大值">选择与正则表达式匹配的每个field key对应的field value的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(/pres/) FROM &quot;air&quot;
name: air
time                 max_pressure
----                 ------------
2021-08-31T17:03:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最大值以及相关的tag和field">选择指定field key对应的field value的最大值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 max station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最大值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最大值并包含多个子句">选择指定field key对应的field value的最大值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
2021-09-18T00:36:00Z 70
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最大值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="min"><a class="header" href="#min">MIN()</a></h3>
<p>返回field value的最小值。</p>
<h4 id="语法-13"><a class="header" href="#语法-13">语法</a></h4>
<pre><code>SELECT MIN(&lt;field_key&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MIN(field_key)</code>返回field key对应的field value的最小值。</p>
<p><code>MIN(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的最小值。</p>
<p><code>MIN(*)</code>返回在measurement中每个field key对应的field value的最小值。</p>
<p><code>MIN(field_key),tag_key(s),field_key(s)</code>返回括号中的field key对应的field value的最小值，以及相关的tag和/或field。</p>
<p><code>MIN()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-13"><a class="header" href="#示例-13">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值"><a class="header" href="#选择指定field-key对应的field-value的最小值">选择指定field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min
----                 ---
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的最小值"><a class="header" href="#选择measurement中每个field-key对应的field-value的最小值">选择measurement中每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(*) FROM &quot;air&quot;

name: air
time                 min_pressure min_temperature min_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 50           50              50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的最小值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的最小值"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的最小值">选择与正则表达式匹配的每个field key对应的field value的最小值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(/temp/) FROM &quot;air&quot;

name: air
time                 min_temperature
----                 ---------------
2021-08-31T16:18:00Z 50
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的最小值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的最小值以及相关的tag和field">选择指定field key对应的field value的最小值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 min station    pressure
----                 --- -------    --------
2021-08-31T16:18:00Z 50  XiaoMaiDao 55
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的最小值并包含多个子句"><a class="header" href="#选择指定field-key对应的field-value的最小值并包含多个子句">选择指定field key对应的field value的最小值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(12m),* fill(9.01) LIMIT 4 SLIMIT 1
name: air
tags: station=LianYunGang
time                 min
----                 ---
2021-09-18T00:00:00Z 51
2021-09-18T00:12:00Z 63
2021-09-18T00:24:00Z 50
2021-09-18T00:36:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的最小值，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按12分钟的时间间隔和每个tag进行分组，同时，该查询用<code>9.01</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数和series个数分别限制为4和1。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每12分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:48:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2020-08-18T00:24:00Z</code>和<code>2020-08-18T00:36:00Z</code>之间。</p>
</li>
<li>
<h3 id="percentile"><a class="header" href="#percentile">PERCENTILE()</a></h3>
<p>返回第N个百分位数的<code>field value</code></p>
<h4 id="语法-14"><a class="header" href="#语法-14">语法</a></h4>
<pre><code>SELECT PERCENTILE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>PERCENTILE(field_key,N)</code>返回指定field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(*,N)</code>返回在measurement中每个field key对应的第N个百分位数的field value。</p>
<p><code>PERCENTILE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的第N个百分位数的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是0到100之间的整数或浮点数。</p>
<p><code>PERCENTILE()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-14"><a class="header" href="#示例-14">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value">选择指定field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5) FROM &quot;air&quot;

name: air
time                 percentile
----                 ----------
2021-09-03T23:51:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择measurement中每个field-key对应的第五个百分位数的field-value">选择measurement中每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(*,5) FROM &quot;air&quot;

name: air
time                 percentile_pressure percentile_temperature percentile_visibility
----                 ------------------- ---------------------- ---------------------
1970-01-01T00:00:00Z 51                  51                     51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值的field key对应的所有field value中的百分之五。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的第五个百分位数的field-value">选择与正则表达式匹配的每个field key对应的第五个百分位数的field value</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(/visi/,5) FROM &quot;air&quot;
name: air
time                 percentile_visibility
----                 ---------------------
2021-09-29T09:54:00Z 51
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的所有field value中的百分之五。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field"><a class="header" href="#选择指定field-key对应的第五个百分位数的field-value以及相关的tag和field">选择指定field key对应的第五个百分位数的field value以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,5),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 percentile station    pressure
----                 ---------- -------    --------
2021-09-03T23:51:00Z 51         XiaoMaiDao 65
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之五，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的第20个百分位数的field-value并包含多个子句"><a class="header" href="#选择指定field-key对应的第20个百分位数的field-value并包含多个子句">选择指定field key对应的第20个百分位数的field value并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT PERCENTILE(&quot;temperature&quot;,20) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:54:00Z' GROUP BY time(24m) fill(15) LIMIT 2
name: air
time                 percentile
----                 ----------
2020-08-17T23:36:00Z 15
2020-08-18T00:00:00Z 15
</code></pre>
<p>该查询返回的field value大于measurement <code>air</code>中field key <code>temperature</code>对应的所有field value中的百分之二十，它涵盖的时间范围在<code>2020-08-17T23:48:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间，并将查询结果按24分钟的时间间隔进行分组，同时，该查询用<code>15</code>填充没有数据的时间间隔，并将返回的<code>point</code>个数限制为2。</p>
<p>请注意，<code>GROUP BY time()</code>子句会覆盖<code>point</code>的原始时间戳。查询结果中的时间戳表示每24分钟时间间隔的开始时间，其中，第一个<code>point</code>涵盖的时间间隔在<code>2020-08-17T23:36:00Z</code>和<code>2021-09-28T00:00:00Z</code>之间，最后一个<code>point</code>涵盖的时间间隔在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:24:00Z</code>之间。</p>
<h4 id="percentile的常见问题"><a class="header" href="#percentile的常见问题"><code>PERCENTILE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="percentile-vs-其它cnosql函数"><a class="header" href="#percentile-vs-其它cnosql函数"><code>PERCENTILE()</code> vs 其它CnosQL函数</a></h4>
</li>
</ul>
<ul>
<li><code>PERCENTILE(&lt;field_key&gt;,100)</code>相当于<code>MAX(&lt;field_key&gt;)</code>。</li>
<li><code>PERCENTILE(&lt;field_key&gt;, 50)</code>近似于<code>MEDIAN(&lt;field_key&gt;)</code>，除非field key包含的field value有偶数个，那么这时候<code>MEDIAN()</code>将返回两个中间值的平均数。</li>
<li><code>PERCENTILE(&lt;field_key&gt;,0)</code>不等于<code>MIN(&lt;field_key&gt;)</code>，<code>PERCENTILE(&lt;field_key&gt;,0)</code>会返回<code>null</code>。</li>
</ul>
</li>
<li>
<h3 id="sample"><a class="header" href="#sample">SAMPLE()</a></h3>
<p>返回包含N个field value的随机样本。<code>SAMPLE()</code>使用<a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a>来生成随机<code>point</code>。</p>
<h4 id="语法-15"><a class="header" href="#语法-15">语法</a></h4>
<pre><code>SELECT SAMPLE(&lt;field_key&gt;, &lt;N&gt;)[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SAMPLE(field_key,N)</code>返回指定field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(*,N)</code>返回在measurement中每个field key对应的N个随机选择的field value。</p>
<p><code>SAMPLE(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的N个随机选择的field value，以及相关的tag和/或field。</p>
<p><code>N</code>必须是整数。</p>
<p><code>SAMPLE()</code>支持所有数据类型的field value。</p>
<h4 id="示例-15"><a class="header" href="#示例-15">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本"><a class="header" href="#选择指定field-key对应的field-value的随机样本">选择指定field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot;
name: air
time                 sample
----                 ------
2021-09-07T02:18:00Z 77
2021-09-13T12:00:00Z 62
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择measurement中每个field-key对应的field-value的随机样本"><a class="header" href="#选择measurement中每个field-key对应的field-value的随机样本">选择measurement中每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(*,2) FROM &quot;air&quot;
name: air
time                 sample_pressure sample_temperature sample_visibility
----                 --------------- ------------------ -----------------
2021-08-31T16:18:00Z                 52                 
2021-09-03T14:33:00Z 74                                 
2021-09-12T19:39:00Z 59                                 
2021-09-17T11:33:00Z                 51                 
2021-09-20T04:09:00Z                                    50
2021-09-22T19:15:00Z                                    80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的两个随机选择的<code>point</code>。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="选择与正则表达式匹配的每个field-key对应的field-value的随机样本"><a class="header" href="#选择与正则表达式匹配的每个field-key对应的field-value的随机样本">选择与正则表达式匹配的每个field key对应的field value的随机样本</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(/pres/,2) FROM &quot;air&quot;
name: air
time                 sample_pressure
----                 ---------------
2021-09-25T20:27:00Z 77
2021-09-26T20:33:00Z 52
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的两个随机选择的<code>point</code>。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的field-value的随机样本以及相关的tag和field"><a class="header" href="#选择指定field-key对应的field-value的随机样本以及相关的tag和field">选择指定field key对应的field value的随机样本以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 sample station     pressure
----                 ------ -------     --------
2021-09-09T00:03:00Z 71     LianYunGang 61
2021-09-11T01:39:00Z 53     LianYunGang 51
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的两个随机选择的<code>point</code>，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应field-value的随机样本并包含多个子句"><a class="header" href="#选择指定field-key对应field-value的随机样本并包含多个子句">选择指定field key对应field value的随机样本并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,1) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                 sample
----                 ------
2021-09-18T00:09:00Z 55
2021-09-18T00:27:00Z 79
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的一个随机选择的<code>point</code>，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并将查询结果按18分钟的时间间隔进行分组。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="sample的常见问题"><a class="header" href="#sample的常见问题"><code>SAMPLE()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="sample和group-by-time子句同时使用"><a class="header" href="#sample和group-by-time子句同时使用"><code>SAMPLE()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>SAMPLE()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数(<code>N</code>)的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>SAMPLE()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个随机选择的<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT SAMPLE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)
name: air
time                   sample
----                   ------
                           __
2021-09-18T00:09:00Z      55   |
2021-09-18T00:12:00Z      63   | &lt;------- Randomly-selected points for the first time interval
                           --
                           __
2021-09-18T00:18:00Z      79  |
2021-09-18T00:21:00Z      68  | &lt;------- Randomly-selected points for the second time interval
                           --
</code></pre>
</li>
<li>
<h3 id="top"><a class="header" href="#top">TOP()</a></h3>
<p>返回最大的N个field value</p>
<h4 id="语法-16"><a class="header" href="#语法-16">语法</a></h4>
<pre><code>SELECT TOP( &lt;field_key&gt;[,&lt;tag_key(s)&gt;],&lt;N&gt; )[,&lt;tag_key(s)&gt;|&lt;field_key(s)&gt;] [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TOP(field_key,N)</code>返回field key对应的最大的N个值。</p>
<p><code>TOP(field_key,tag_key(s),N)</code>返回tag key的N个tag value对应的field key的最大值。</p>
<p><code>TOP(field_key,N),tag_key(s),field_key(s)</code>返回括号中的field key对应的最大的N个值，以及相关的tag和/或field。</p>
<p><code>TOP()</code>支持数据类型为int64和float64的field value。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果最大值有两个或多个并且它们之间有关联，<code>TOP()</code>返回具有最早时间戳的field value。</li>
</ul>
<h4 id="示例-16"><a class="header" href="#示例-16">示例</a></h4>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值"><a class="header" href="#选择指定field-key对应的最大的三个值">选择指定field key对应的最大的三个值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3) FROM &quot;air&quot;
name: air
time                 top
----                 ---
2021-08-31T18:03:00Z 80
2021-08-31T18:18:00Z 80
2021-08-31T18:57:00Z 80
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的最大的三个值。</p>
<ul>
<li>
<h4 id="选择两个tag对应的field-key的最大值"><a class="header" href="#选择两个tag对应的field-key的最大值">选择两个tag对应的field key的最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<p>该查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的四个值以及相关的tag和field"><a class="header" href="#选择指定field-key对应的最大的四个值以及相关的tag和field">选择指定field key对应的最大的四个值以及相关的tag和field</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,4),&quot;station&quot;,&quot;pressure&quot; FROM &quot;air&quot;
name: air
time                 top station     pressure
----                 --- -------     --------
2021-08-31T18:03:00Z 80  LianYunGang 74
2021-08-31T18:18:00Z 80  XiaoMaiDao  53
2021-08-31T18:57:00Z 80  LianYunGang 51
2021-08-31T20:15:00Z 80  XiaoMaiDao  53
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的最大的四个值，以及相关的tag key <code>station</code>和field key <code>pressure</code>的值。</p>
<ul>
<li>
<h4 id="选择指定field-key对应的最大的三个值并包含多个子句"><a class="header" href="#选择指定field-key对应的最大的三个值并包含多个子句">选择指定field key对应的最大的三个值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,3),&quot;station&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:54:00Z' GROUP BY time(24m) ORDER BY time DESC
name: air
time                 top station
----                 --- -------
2021-09-18T00:54:00Z 79  XiaoMaiDao
2021-09-18T00:51:00Z 71  XiaoMaiDao
2021-09-18T00:48:00Z 77  LianYunGang
2021-09-18T00:30:00Z 75  LianYunGang
2021-09-18T00:27:00Z 79  LianYunGang
2021-09-18T00:24:00Z 70  LianYunGang
2021-09-18T00:18:00Z 79  LianYunGang
2021-09-18T00:09:00Z 80  XiaoMaiDao
2021-09-18T00:00:00Z 77  XiaoMaiDao
</code></pre>
<p>该查询返回在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:54:00Z</code>之间的每个24分钟间隔内，field key <code>temperature</code>对应的最大的三个值，并且以递减的时间戳顺序返回结果。</p>
<p>请注意，<code>GROUP BY time()</code>子句不会覆盖<code>point</code>的原始时间戳。请查看下面章节获得更详细的说明。</p>
<h4 id="top的常见问题"><a class="header" href="#top的常见问题"><code>TOP()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="top和group-by-time子句同时使用"><a class="header" href="#top和group-by-time子句同时使用"><code>TOP()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p>对于同时带有<code>TOP()</code>和<code>GROUP BY time()</code>子句的查询，将返回每个<code>GROUP BY time()</code>时间间隔的指定个数的<code>point</code>。对于大多数<code>GROUP BY time()</code>查询，返回的时间戳表示<code>GROUP BY time()</code>时间间隔的开始时间，但是，带有<code>TOP()</code>函数的<code>GROUP BY time()</code>查询则不一样，它们保留原始<code>point</code>的时间戳。</p>
<p>以下查询返回每18分钟<code>GROUP BY time()</code>间隔对应的两个<code>point</code>。请注意，返回的时间戳是<code>point</code>的原始时间戳；它们不会被强制要求必须匹配<code>GROUP BY time()</code>间隔的开始时间。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(18m)

name: air
time                   top
----                   ------
                        __
2021-09-18T00:12:00Z    63   |
2021-09-18T00:15:00Z    74   | &lt;------- Greatest points for the first time interval
                        --
                        __
2021-09-18T00:18:00Z    79   |
2021-09-18T00:27:00Z   79    | &lt;------- Greatest points for the second time interval
                        --
</code></pre>
<ul>
<li>
<h4 id="top和具有少于n个tag-value的tag-key"><a class="header" href="#top和具有少于n个tag-value的tag-key"><code>TOP()</code>和具有少于N个tag value的tag key</a></h4>
</li>
</ul>
<p>使用语法<code>SELECT TOP(&lt;field_key&gt;,&lt;tag_key&gt;,&lt;N&gt;)</code>的查询可以返回比预期少的<code>point</code>。如果tag key有<code>X</code>个tag value，但是查询指定的是<code>N</code>个tag value，如果<code>X</code>小于<code>N</code>，那么查询将返回<code>X</code>个<code>point</code>。</p>
<p>以下查询请求的是tag key <code>station</code>的三个tag value对于的<code>temperature</code>的最大值。因为tag key <code>station</code>只有两个tag value(<code>LianYunGang</code>和<code>XiaoMaiDao</code>)，所以该查询返回两个<code>point</code>而不是三个。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,3) FROM &quot;air&quot;
name: air
time                 top station
----                 --- -------
2021-08-31T18:03:00Z 80  LianYunGang
2021-08-31T18:18:00Z 80  XiaoMaiDao
</code></pre>
<ul>
<li>
<h4 id="toptag和into子句"><a class="header" href="#toptag和into子句"><code>TOP()</code>、tag和<code>INTO</code>子句</a></h4>
</li>
</ul>
<p>当使用<code>INTO</code>子句但没有使用<code>GROUP BY tag</code>子句时，大多数CnosQL函数将原始数据中的tag转换为新写入数据中的field。这种行为同样适用于<code>TOP()</code>函数，除非<code>TOP()</code>中包含tag key作为参数：<code>TOP(field_key,tag_key(s),N)</code>。在这些情况下，系统会将指定的tag保留为新写入数据中的tag。</p>
<p>下面代码块中的第一个查询返回tag key <code>station</code>的两个tag value对应的field key <code>temperature</code>的最大值，并且，它这些结果写入measurement <code>top_temperatures</code>中。第二个查询展示了CnosDB将tag <code>station</code>保留为measurement <code>top_temperatures</code>中的tag。</p>
<pre><code class="language-sql">&gt; SELECT TOP(&quot;temperature&quot;,&quot;station&quot;,2) INTO &quot;top_temperatures&quot; FROM &quot;air&quot;
name: result
time                 written
----                 -------
1970-01-01T00:00:00Z 2

&gt; SHOW TAG KEYS FROM &quot;top_temperatures&quot;
name: top_temperatures
tagKey
------
station
</code></pre>
</li>
</ul>
<h3 id="转换函数"><a class="header" href="#转换函数">转换函数</a></h3>
<ul>
<li>
<h3 id="abs"><a class="header" href="#abs">ABS()</a></h3>
<p>返回field value的绝对值</p>
<h4 id="基本语法"><a class="header" href="#基本语法">基本语法</a></h4>
<pre><code class="language-sql">SELECT ABS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ABS(field_key)</code>返回field key对应的field value的绝对值。</p>
<p><code>ABS(*)</code>返回在measurement中每个field key对应的field value的绝对值。</p>
<p><code>ABS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ABS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-17"><a class="header" href="#示例-17">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT * FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 pressure station     temperature visibility
----                 -------- -------     ----------- ----------
2021-09-24T12:00:00Z 76       LianYunGang 61          59
2021-09-24T12:00:00Z 58       XiaoMaiDao  52          77
2021-09-24T12:03:00Z 64       LianYunGang 57          72
2021-09-24T12:03:00Z 50       XiaoMaiDao  70          77
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值"><a class="header" href="#计算指定field-key对应的field-value的绝对值">计算指定field key对应的field value的绝对值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 76
2021-09-24T12:00:00Z 58
2021-09-24T12:03:00Z 64
2021-09-24T12:03:00Z 50
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值。</p>
</li>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的绝对值"><a class="header" href="#计算measurement中每个field-key对应的field-value的绝对值">计算measurement中每个field key对应的field value的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z'
name: air
time                 abs_pressure abs_temperature abs_visibility
----                 ------------ --------------- --------------
2021-09-24T12:00:00Z 76           61              59
2021-09-24T12:00:00Z 58           52              77
2021-09-24T12:03:00Z 64           57              72
2021-09-24T12:03:00Z 50           70              77
</code></pre>
<p>该查询返回measurement <code>data</code>中每个存储数值的field key对应的field value的绝对值。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>,<code>pressure</code>和<code>visibility</code>。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的绝对值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的绝对值并包含多个子句">计算指定field key对应的field value的绝对值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T12:05:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 58
2021-09-24T12:00:00Z 76
</code></pre>
<p>该查询返回measurement <code>data</code>中field key <code>a</code>对应的field value的绝对值，它涵盖的时间范围在<code>2020-06-24T12:00:00Z</code>和<code>2020-06-24T12:05:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法"><a class="header" href="#高级语法">高级语法</a></h4>
<pre><code class="language-sql">SELECT ABS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的绝对值。</p>
<p><code>ABS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="计算平均值的绝对值"><a class="header" href="#计算平均值的绝对值">计算平均值的绝对值</a></h4>
<pre><code class="language-sql">&gt; SELECT ABS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 abs
----                 ---
2021-09-24T12:00:00Z 62.75
2021-09-24T12:12:00Z 64.25
2021-09-24T12:24:00Z 66
2021-09-24T12:36:00Z 64.375
2021-09-24T12:48:00Z 63.875
2021-09-24T13:00:00Z 59.5
</code></pre>
<p>该查询返回field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>a</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ABS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-24T12:00:00Z' AND time &lt;= '2021-09-24T13:00:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-24T12:00:00Z 61.75
2021-09-24T12:12:00Z 68.25
2021-09-24T12:24:00Z 66.125
2021-09-24T12:36:00Z 58
2021-09-24T12:48:00Z 68.625
2021-09-24T13:00:00Z 71
</code></pre>
<p>然后，CnosDB计算这些平均值的绝对值。</p>
</li>
<li>
<h3 id="acos"><a class="header" href="#acos">ACOS()</a></h3>
<p>返回field value的反余弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-1"><a class="header" href="#基本语法-1">基本语法</a></h4>
<pre><code>SELECT ACOS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ACOS(field_key)</code>返回field key对应的field value的反余弦。</p>
<p><code>ACOS(*)</code>返回在measurement中每个field key对应的field value的反余弦。</p>
<p><code>ACOS()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ACOS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-18"><a class="header" href="#示例-18">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ACOS()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  capacity
----                  --------
2020-05-01T00:00:00Z  0.83
2020-05-02T00:00:00Z  0.3
2020-05-03T00:00:00Z  0.84
2020-05-04T00:00:00Z  0.22
2020-05-05T00:00:00Z  0.17
2020-05-06T00:00:00Z  0.77
2020-05-07T00:00:00Z  0.64
2020-05-08T00:00:00Z  0.72
2020-05-09T00:00:00Z  0.16
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦"><a class="header" href="#计算指定field-key对应的field-value的反余弦">计算指定field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z'
name: air
time                  acos
----                  ----
2020-05-01T00:00:00Z  0.591688642426544
2020-05-02T00:00:00Z  1.266103672779499
2020-05-03T00:00:00Z  0.5735131044230969
2020-05-04T00:00:00Z  1.3489818562981022
2020-05-05T00:00:00Z  1.399966657665792
2020-05-06T00:00:00Z  0.6919551751263169
2020-05-07T00:00:00Z  0.8762980611683406
2020-05-08T00:00:00Z  0.7669940078618667
2020-05-09T00:00:00Z  1.410105673842986
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反余弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反余弦">计算measurement中每个field key对应的field value的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 acos_pressure acos_temperature acos_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反余弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但由于这三个field key对应的field value超过余弦函数的范围，因此其反余弦值并不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反余弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反余弦并包含多个子句">计算指定field key对应的field value的反余弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 acos
----                 ----
2021-09-18T23:57:00Z 0.6435011087932843
2021-09-18T23:57:00Z 0.6599873293874983
2021-09-18T23:54:00Z 0.7669940078618667
2021-09-18T23:54:00Z 1.0003592173949745
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反余弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-1"><a class="header" href="#高级语法-1">高级语法</a></h4>
<pre><code class="language-sql">SELECT ACOS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反余弦。</p>
<p>ACOS()支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的反余弦"><a class="header" href="#计算平均值的反余弦">计算平均值的反余弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ACOS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 acos
----                 ----
2021-09-09T00:00:00Z
2021-09-12T00:00:00Z
2021-09-15T00:00:00Z
2021-09-18T00:00:00Z  、
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反余弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ACOS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反余弦。</p>
</li>
<li>
<h3 id="asin"><a class="header" href="#asin">ASIN()</a></h3>
<p>返回field value的反正弦(以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-2"><a class="header" href="#基本语法-2">基本语法</a></h4>
<pre><code>SELECT ASIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ASIN(field_key)</code>返回field key对应的field value的反正弦。</p>
<p><code>ASIN(*)</code>返回在measurement中每个field key对应的field value的反正弦。</p>
<p><code>ASIN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ASIN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-19"><a class="header" href="#示例-19">示例</a></h4>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦"><a class="header" href="#计算指定field-key对应的field-value的反正弦">计算指定field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin
----                 ----
2021-09-11T00:00:00Z 0.8330703583416478
2021-09-11T00:00:00Z 0.9108089974073983
2021-09-11T00:03:00Z 0.6560605909249226
2021-09-11T00:03:00Z 0.8183219506315597
2021-09-11T00:06:00Z 0.8038023189330299
2021-09-11T00:06:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.6560605909249226
2021-09-11T00:09:00Z 0.8038023189330299
2021-09-11T00:12:00Z 0.546850950695944
2021-09-11T00:12:00Z 0.618728690672251
2021-09-11T00:15:00Z 0.8330703583416478
2021-09-11T00:15:00Z 0.8946658172342352
2021-09-11T00:18:00Z 0.7342087874533589
2021-09-11T00:18:00Z 0.8330703583416478
2021-09-11T00:21:00Z 0.7894982093461719
2021-09-11T00:21:00Z 0.5823642378687435
2021-09-11T00:24:00Z 0.7208187608700896
2021-09-11T00:24:00Z 0.7342087874533589
2021-09-11T00:27:00Z 0.8038023189330299
2021-09-11T00:27:00Z 0.7208187608700896
2021-09-11T00:30:00Z 0.6560605909249226
2021-09-11T00:30:00Z 0.570437109399922
2021-09-11T00:33:00Z 0.5823642378687435
2021-09-11T00:33:00Z 0.848062078981481
2021-09-11T00:36:00Z 0.7075844367253555
2021-09-11T00:36:00Z 0.7208187608700896
2021-09-11T00:39:00Z 0.7477626346599205
2021-09-11T00:39:00Z 0.618728690672251
2021-09-11T00:42:00Z 0.6310588407780212
2021-09-11T00:42:00Z 0.618728690672251
2021-09-11T00:45:00Z 0.7614890527476331
2021-09-11T00:45:00Z 0.7894982093461719
2021-09-11T00:48:00Z 0.7614890527476331
2021-09-11T00:48:00Z 0.6065058552130869
2021-09-11T00:51:00Z 0.5823642378687435
2021-09-11T00:51:00Z 0.8183219506315597
2021-09-11T00:54:00Z 0.7614890527476331
2021-09-11T00:54:00Z 0.6944982656265559
2021-09-11T00:57:00Z 0.8183219506315597
2021-09-11T00:57:00Z 0.546850950695944
2021-09-11T01:00:00Z 0.6310588407780212
2021-09-11T01:00:00Z 0.7477626346599205    
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正弦"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正弦">计算measurement中每个field key对应的field value的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 asin_pressure asin_temperature asin_visibility
----                 ------------- ---------------- ---------------
2021-09-11T00:00:00Z                                
2021-09-11T00:00:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:03:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:06:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:09:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:12:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:15:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:18:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:21:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:24:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:27:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:30:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:33:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:36:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:39:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:42:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:45:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:48:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:51:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:54:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T00:57:00Z                                
2021-09-11T01:00:00Z                                
2021-09-11T01:00:00Z
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正弦。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。但是由于这三个field value全部大于1，因此其反正弦值不存在。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正弦并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正弦并包含多个子句">计算指定field key对应的field value的反正弦并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(temperature/100) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 asin
----                 ----
2021-09-18T23:57:00Z 0.9272952180016123
2021-09-18T23:57:00Z 0.9108089974073983
2021-09-18T23:54:00Z 0.8038023189330299
2021-09-18T23:54:00Z 0.570437109399922
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正弦，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-2"><a class="header" href="#高级语法-2">高级语法</a></h4>
<pre><code class="language-sql">SELECT ASIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正弦。</p>
<p>ASIN()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>,
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-20"><a class="header" href="#示例-20">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正弦"><a class="header" href="#计算平均值的反正弦">计算平均值的反正弦</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ASIN(MEAN(&quot;speed&quot;)) FROM &quot;wind&quot; WHERE time &gt;= '2021-09-01T00:00:00Z' AND time &lt;= '2021-09-30T00:00:00Z' GROUP BY time(1d)
name: air
time                  asin
----                  ----
2020-04-30T00:00:00Z  0.6004332535805232
2020-05-03T00:00:00Z  0.42245406218675574
2020-05-06T00:00:00Z  0.7894982093461719
2020-05-09T00:00:00Z  0.1606906529519106
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正弦。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ASIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正弦。</p>
</li>
<li>
<h3 id="atan"><a class="header" href="#atan">ATAN()</a></h3>
<p>返回field value的反正切（以弧度表示)。field value必须在-1和1之间。</p>
<h4 id="基本语法-3"><a class="header" href="#基本语法-3">基本语法</a></h4>
<pre><code class="language-sql">SELECT ATAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN(field_key)</code>返回field key对应的field value的反正切。</p>
<p><code>ATAN(*)</code>返回在measurement中每个field key对应的field value的反正切。</p>
<p><code>ATAN()</code>支持数据类型为int64和float64的field value，并且field value必须在-1和1之间。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-21"><a class="header" href="#示例-21">示例</a></h4>
<p>下面的示例将使用如下模拟的公园占有率(相对于总空间)的数据。需要注意的重要事项是，所有的field value都在<code>ATAN()</code>函数的可计算范围里(-1到1)：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 temperature
----                 -----------
2021-09-11T00:00:00Z 74
2021-09-11T00:00:00Z 79
2021-09-11T00:03:00Z 61
2021-09-11T00:03:00Z 73
2021-09-11T00:06:00Z 72
2021-09-11T00:06:00Z 61
2021-09-11T00:09:00Z 61
2021-09-11T00:09:00Z 72
2021-09-11T00:12:00Z 52
2021-09-11T00:12:00Z 58
2021-09-11T00:15:00Z 74
2021-09-11T00:15:00Z 78
2021-09-11T00:18:00Z 67
2021-09-11T00:18:00Z 74
2021-09-11T00:21:00Z 71
2021-09-11T00:21:00Z 55
2021-09-11T00:24:00Z 66
2021-09-11T00:24:00Z 67
2021-09-11T00:27:00Z 72
2021-09-11T00:27:00Z 66
2021-09-11T00:30:00Z 61
2021-09-11T00:30:00Z 54
2021-09-11T00:33:00Z 55
2021-09-11T00:33:00Z 75
2021-09-11T00:36:00Z 65
2021-09-11T00:36:00Z 66
2021-09-11T00:39:00Z 68
2021-09-11T00:39:00Z 58
2021-09-11T00:42:00Z 59
2021-09-11T00:42:00Z 58
2021-09-11T00:45:00Z 69
2021-09-11T00:45:00Z 71
2021-09-11T00:48:00Z 69
2021-09-11T00:48:00Z 57
2021-09-11T00:51:00Z 55
2021-09-11T00:51:00Z 73
2021-09-11T00:54:00Z 69
2021-09-11T00:54:00Z 64
2021-09-11T00:57:00Z 73
2021-09-11T00:57:00Z 52
2021-09-11T01:00:00Z 59
2021-09-11T01:00:00Z 68
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切"><a class="header" href="#计算指定field-key对应的field-value的反正切">计算指定field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan
----                 ----
2021-09-11T00:00:00Z 1.5572836357815683
2021-09-11T00:00:00Z 1.5581387749608446
2021-09-11T00:03:00Z 1.5544043524868913
2021-09-11T00:03:00Z 1.5570985534220307
2021-09-11T00:06:00Z 1.5569083308639295
2021-09-11T00:06:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5544043524868913
2021-09-11T00:09:00Z 1.5569083308639295
2021-09-11T00:12:00Z 1.5515679276951893
2021-09-11T00:12:00Z 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683
2021-09-11T00:15:00Z 1.557976516321996
2021-09-11T00:18:00Z 1.5558720618048116
2021-09-11T00:18:00Z 1.5572836357815683
2021-09-11T00:21:00Z 1.5567127509720364
2021-09-11T00:21:00Z 1.5526165117219182
2021-09-11T00:24:00Z 1.5556459709201267
2021-09-11T00:24:00Z 1.5558720618048116
2021-09-11T00:27:00Z 1.5569083308639295
2021-09-11T00:27:00Z 1.5556459709201267
2021-09-11T00:30:00Z 1.5544043524868913
2021-09-11T00:30:00Z 1.5522799247268875
2021-09-11T00:33:00Z 1.5526165117219182
2021-09-11T00:33:00Z 1.557463783500751
2021-09-11T00:36:00Z 1.5554129250143014
2021-09-11T00:36:00Z 1.5556459709201267
2021-09-11T00:39:00Z 1.5560915044170451
2021-09-11T00:39:00Z 1.5535566556003668
2021-09-11T00:42:00Z 1.5538487969884915
2021-09-11T00:42:00Z 1.5535566556003668
2021-09-11T00:45:00Z 1.5563045877293966
2021-09-11T00:45:00Z 1.5567127509720364
2021-09-11T00:48:00Z 1.5563045877293966
2021-09-11T00:48:00Z 1.553254266737494
2021-09-11T00:51:00Z 1.5526165117219182
2021-09-11T00:51:00Z 1.5570985534220307
2021-09-11T00:54:00Z 1.5563045877293966
2021-09-11T00:54:00Z 1.5551725981744198
2021-09-11T00:57:00Z 1.5570985534220307
2021-09-11T00:57:00Z 1.5515679276951893
2021-09-11T01:00:00Z 1.5538487969884915
2021-09-11T01:00:00Z 1.5560915044170451
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的反正切"><a class="header" href="#计算measurement中每个field-key对应的field-value的反正切">计算measurement中每个field key对应的field value的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-11T01:00:00Z'
name: air
time                 atan_pressure      atan_temperature   atan_visibility
----                 -------------      ----------------   ---------------
2021-09-11T00:00:00Z 1.5544043524868913 1.5572836357815683 1.5526165117219182
2021-09-11T00:00:00Z 1.5576391913221408 1.5581387749608446 1.550798992821746
2021-09-11T00:03:00Z 1.5535566556003668 1.5544043524868913 1.551190995937692
2021-09-11T00:03:00Z 1.5541312030809558 1.5570985534220307 1.5581387749608446
2021-09-11T00:06:00Z 1.5549246438031066 1.5569083308639295 1.5556459709201267
2021-09-11T00:06:00Z 1.557976516321996  1.5544043524868913 1.5541312030809558
2021-09-11T00:09:00Z 1.553254266737494  1.5544043524868913 1.5560915044170451
2021-09-11T00:09:00Z 1.5556459709201267 1.5569083308639295 1.557463783500751
2021-09-11T00:12:00Z 1.5541312030809558 1.5515679276951893 1.5563045877293966
2021-09-11T00:12:00Z 1.550798992821746  1.5535566556003668 1.5565115842075
2021-09-11T00:15:00Z 1.5554129250143014 1.5572836357815683 1.5535566556003668
2021-09-11T00:15:00Z 1.5572836357815683 1.557976516321996  1.557976516321996
2021-09-11T00:18:00Z 1.557463783500751  1.5558720618048116 1.5526165117219182
2021-09-11T00:18:00Z 1.557810043874724  1.5572836357815683 1.551190995937692
2021-09-11T00:21:00Z 1.5544043524868913 1.5567127509720364 1.552941081655344
2021-09-11T00:21:00Z 1.5576391913221408 1.5526165117219182 1.5570985534220307
2021-09-11T00:24:00Z 1.552941081655344  1.5556459709201267 1.5541312030809558
2021-09-11T00:24:00Z 1.5570985534220307 1.5558720618048116 1.550798992821746
2021-09-11T00:27:00Z 1.550798992821746  1.5569083308639295 1.552941081655344
2021-09-11T00:27:00Z 1.5582969777755349 1.5556459709201267 1.5551725981744198
2021-09-11T00:30:00Z 1.5582969777755349 1.5544043524868913 1.5567127509720364
2021-09-11T00:30:00Z 1.5549246438031066 1.5522799247268875 1.5546686929512603
2021-09-11T00:33:00Z 1.5576391913221408 1.5526165117219182 1.5560915044170451
2021-09-11T00:33:00Z 1.5519306407732258 1.557463783500751  1.5560915044170451
2021-09-11T00:36:00Z 1.5558720618048116 1.5554129250143014 1.5519306407732258
2021-09-11T00:36:00Z 1.5560915044170451 1.5556459709201267 1.5563045877293966
2021-09-11T00:39:00Z 1.5526165117219182 1.5560915044170451 1.5567127509720364
2021-09-11T00:39:00Z 1.5563045877293966 1.5535566556003668 1.557810043874724
2021-09-11T00:42:00Z 1.5569083308639295 1.5538487969884915 1.5565115842075
2021-09-11T00:42:00Z 1.5522799247268875 1.5535566556003668 1.5549246438031066
2021-09-11T00:45:00Z 1.557810043874724  1.5563045877293966 1.5576391913221408
2021-09-11T00:45:00Z 1.5560915044170451 1.5567127509720364 1.557810043874724
2021-09-11T00:48:00Z 1.5535566556003668 1.5563045877293966 1.5551725981744198
2021-09-11T00:48:00Z 1.5546686929512603 1.553254266737494  1.5560915044170451
2021-09-11T00:51:00Z 1.5526165117219182 1.5526165117219182 1.5570985534220307
2021-09-11T00:51:00Z 1.557463783500751  1.5570985534220307 1.5572836357815683
2021-09-11T00:54:00Z 1.5563045877293966 1.5563045877293966 1.5558720618048116
2021-09-11T00:54:00Z 1.5538487969884915 1.5551725981744198 1.5544043524868913
2021-09-11T00:57:00Z 1.5565115842075    1.5570985534220307 1.5572836357815683
2021-09-11T00:57:00Z 1.5576391913221408 1.5515679276951893 1.5572836357815683
2021-09-11T01:00:00Z 1.5522799247268875 1.5538487969884915 1.5522799247268875
2021-09-11T01:00:00Z 1.557810043874724  1.5560915044170451 1.5551725981744198
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的反正切。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的反正切并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的反正切并包含多个子句">计算指定field key对应的field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan
----                 ----
2021-09-18T23:57:00Z 1.5582969777755349
2021-09-18T23:57:00Z 1.5581387749608446
2021-09-18T23:54:00Z 1.5569083308639295
2021-09-18T23:54:00Z 1.5522799247268875
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-01T00:00:00Z</code>和<code>2020-05-09T00:00:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-3"><a class="header" href="#高级语法-3">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切。</p>
<p><code>ATAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-22"><a class="header" href="#示例-22">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切"><a class="header" href="#计算平均值的反正切">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 atan
----                 ----
2021-09-09T00:00:00Z 1.5554743016680184
2021-09-12T00:00:00Z 1.5554056912417906
2021-09-15T00:00:00Z 1.555415060964228
2021-09-18T00:00:00Z 1.555490506678637
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值的反正切。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每三天的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-11T00:00:00Z' AND time &lt;= '2021-09-19T00:00:00Z' GROUP BY time(3d)
name: air
time                 mean
----                 ----
2021-09-09T00:00:00Z 65.26041666666667
2021-09-12T00:00:00Z 64.96944444444445
2021-09-15T00:00:00Z 65.00902777777777
2021-09-18T00:00:00Z 65.32952182952182
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="atan2"><a class="header" href="#atan2">ATAN2()</a></h3>
<p>返回以弧度表示的<code>y/x</code>的反正切。</p>
<h4 id="基本语法-4"><a class="header" href="#基本语法-4">基本语法</a></h4>
<pre><code>SELECT ATAN2( [ * | &lt;field_key&gt; | num ], [ &lt;field_key&gt; | num ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ATAN2(field_key_y, field_key_x)</code>返回field key “field_key_y”对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2(*, field_key_x)&lt;br /&gt;</code>返回在measurement中每个field key对应的field value除以field key “field_key_x”对应的field value的反正切。</p>
<p><code>ATAN2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ATAN2()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-23"><a class="header" href="#示例-23">示例</a></h4>
<p>下面的示例将使用如下模拟的飞行数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot;, &quot;pressure&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:15:00Z'
name: air
time                 temperature pressure
----                 ----------- --------
2021-09-06T12:03:00Z 53          78
2021-09-06T12:03:00Z 72          71
2021-09-06T12:06:00Z 69          58
2021-09-06T12:06:00Z 59          76
2021-09-06T12:09:00Z 71          55
2021-09-06T12:09:00Z 57          76
2021-09-06T12:12:00Z 53          75
2021-09-06T12:12:00Z 65          52
2021-09-06T12:15:00Z 69          67
2021-09-06T12:15:00Z 64          56
</code></pre>
<ul>
<li>
<h4 id="计算field_key_y除以field_key_x的反正切"><a class="header" href="#计算field_key_y除以field_key_x的反正切">计算field_key_y除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T13:01:00Z'
name: air
time                 atan2
----                 -----
2021-09-06T12:03:00Z 0.5968259039857009
2021-09-06T12:03:00Z 0.7923910564027816
2021-09-06T12:06:00Z 0.8717967127558954
2021-09-06T12:06:00Z 0.6601315920749263
2021-09-06T12:09:00Z 0.9117062804606886
2021-09-06T12:09:00Z 0.6435011087932844
2021-09-06T12:12:00Z 0.6151862381119739
2021-09-06T12:12:00Z 0.8960553845713439
2021-09-06T12:15:00Z 0.8001029857752997
2021-09-06T12:15:00Z 0.851966327173272
2021-09-06T12:18:00Z 0.6960841704042261
2021-09-06T12:18:00Z 0.8010218920179252
2021-09-06T12:21:00Z 0.7594299761858918
2021-09-06T12:21:00Z 0.7028792089644667
2021-09-06T12:24:00Z 0.812418612584713
2021-09-06T12:24:00Z 0.7309067071567171
2021-09-06T12:27:00Z 0.9948777271765435
2021-09-06T12:27:00Z 0.7546386373269791
2021-09-06T12:30:00Z 0.7785017210090998
2021-09-06T12:30:00Z 0.6435011087932844
2021-09-06T12:33:00Z 0.8960553845713439
2021-09-06T12:33:00Z 0.8007815651780434
2021-09-06T12:36:00Z 0.8498250028230019
2021-09-06T12:36:00Z 0.8736040677941312
2021-09-06T12:39:00Z 0.7168036599431737
2021-09-06T12:39:00Z 0.9296875579351908
2021-09-06T12:42:00Z 0.8633647972289906
2021-09-06T12:42:00Z 0.9437256642058782
2021-09-06T12:45:00Z 0.6215266244966218
2021-09-06T12:45:00Z 0.8152400480645576
2021-09-06T12:48:00Z 0.7378150601204648
2021-09-06T12:48:00Z 0.7638187798309181
2021-09-06T12:51:00Z 0.9179496956941223
2021-09-06T12:51:00Z 0.7935280655773922
2021-09-06T12:54:00Z 0.9572401812829798
2021-09-06T12:54:00Z 0.6593100683328579
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T12:57:00Z 0.8674056089236339
2021-09-06T13:00:00Z 0.8187191592756955
2021-09-06T13:00:00Z 0.8134282033572947
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切。这两个field key都在measurement <code>wind</code>中。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key除以field_key_x的反正切"><a class="header" href="#计算measurement中每个field-key除以field_key_x的反正切">计算measurement中每个field key除以field_key_x的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(*, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-06T12:06:00Z'
name: air
time                 atan2_pressure     atan2_temperature  atan2_visibility
----                 --------------     -----------------  ----------------
2021-09-06T12:03:00Z 0.7853981633974483 0.5968259039857009 0.60554466360497
2021-09-06T12:03:00Z 0.7853981633974483 0.7923910564027816 0.7257674502662789
2021-09-06T12:06:00Z 0.7853981633974483 0.8717967127558954 0.8645972343668997
2021-09-06T12:06:00Z 0.7853981633974483 0.6601315920749263 0.6435011087932844
</code></pre>
<p>该查询返回measurement <code>wind</code>中每个存储数值的field key对应的field value除以field key <code>pressure</code>对应的field value的反正切。measurement <code>wind</code>中有两个数值类型的field：<code>temperature</code>和<code>pressure</code>。</p>
<ul>
<li>
<h4 id="计算field-value的反正切并包含多个子句"><a class="header" href="#计算field-value的反正切并包含多个子句">计算field value的反正切并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(&quot;temperature&quot;, &quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-06T12:01:00Z' AND time &lt;= '2021-09-16T13:01:00Z' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 atan2
----                 -----
2021-09-16T12:57:00Z 0.8773368222796695
2021-09-16T12:57:00Z 0.8114792046882006
2021-09-16T12:54:00Z 0.8007815651780434
2021-09-16T12:54:00Z 1.003258702010146
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value除以field key <code>pressure</code>对应的field value的反正切，它涵盖的时间范围在<code>2020-05-16T12:10:00Z</code>和<code>2020-05-16T12:10:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-4"><a class="header" href="#高级语法-4">高级语法</a></h4>
<pre><code class="language-sql">SELECT ATAN2(&lt;function()&gt;, &lt;function()&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的反正切(<code>ATAN2()</code>)。</p>
<p>ATAN2()支持以下嵌套函数：</p>
<ul>
<li>COUNT()</li>
<li>MEAN()</li>
<li>MEDIAN()</li>
<li>MODE()</li>
<li>SUM()</li>
<li>FIRST()</li>
<li>LAST()</li>
<li>MIN()</li>
<li>MAX()</li>
<li>PERCENTILE()</li>
</ul>
<h4 id="示例-24"><a class="header" href="#示例-24">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的反正切-1"><a class="header" href="#计算平均值的反正切-1">计算平均值的反正切</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ATAN2(MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 atan2
----                 -----
2021-09-16T12:00:00Z 0.7916716068182019
2021-09-16T12:12:00Z 0.7687819020057319
2021-09-16T12:24:00Z 0.8293469014295621
2021-09-16T12:36:00Z 0.7483094274728471
2021-09-16T12:48:00Z 0.8579805385837196
2021-09-16T13:00:00Z 0.7640815957515122
2021-09-16T13:12:00Z 0.7660813391498594
2021-09-16T13:24:00Z 0.7595170787800846
2021-09-16T13:36:00Z 0.781755192263569
2021-09-16T13:48:00Z 0.8137459550765823
2021-09-16T14:00:00Z 0.7572931159369924
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的field value的平均值除以field key <code>pressure</code>对应的field value的平均值的反正切。平均值是按每12分钟的时间间隔计算的。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>和<code>pressure</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ATAN2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;), MEAN(&quot;pressure&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-16T12:01:00Z' AND time &lt;= '2021-09-16T14:02:00Z' GROUP BY time(12m)
name: air
time                 mean              mean_1
----                 ----              ------
2021-09-16T12:00:00Z 66.83333333333333 66
2021-09-16T12:12:00Z 62.875            65
2021-09-16T12:24:00Z 68.25             62.5
2021-09-16T12:36:00Z 64.875            69.875
2021-09-16T12:48:00Z 71                61.375
2021-09-16T13:00:00Z 60.25             62.875
2021-09-16T13:12:00Z 66.625            69.25
2021-09-16T13:24:00Z 63.5              66.875
2021-09-16T13:36:00Z 68.375            68.875
2021-09-16T13:48:00Z 68                64.25
2021-09-16T14:00:00Z 60.5              64
</code></pre>
<p>然后，CnosDB计算这些平均值的反正切。</p>
</li>
<li>
<h3 id="ceil"><a class="header" href="#ceil">CEIL()</a></h3>
<p>返回大于指定值的最小整数。</p>
<h4 id="基本语法-5"><a class="header" href="#基本语法-5">基本语法</a></h4>
<pre><code>SELECT CEIL( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CEIL(field_key)</code>返回field key对应的大于field value的最小整数。</p>
<p><code>CEIL(*)</code>返回在measurement中每个field key对应的大于field value的最小整数。</p>
<p><code>CEIL()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CEIL()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-25"><a class="header" href="#示例-25">示例</a></h4>
<p>下面的示例将使用<a href="oceanic_station.txt"><code>oceanic_station</code>数据集</a>的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数">计算指定field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的大于field value的最小整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的大于field-value的最小整数"><a class="header" href="#计算measurement中每个field-key对应的大于field-value的最小整数">计算measurement中每个field key对应的大于field value的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ceil_pressure ceil_temperature ceil_visibility
----                 ------------- ---------------- ---------------
2021-09-18T00:00:00Z 64            51               68
2021-09-18T00:03:00Z 72            60               74
2021-09-18T00:06:00Z 54            55               77
2021-09-18T00:09:00Z 66            55               55
2021-09-18T00:12:00Z 64            63               70
2021-09-18T00:15:00Z 58            74               62
2021-09-18T00:18:00Z 55            79               54
2021-09-18T00:21:00Z 64            68               58
2021-09-18T00:24:00Z 66            70               69
2021-09-18T00:27:00Z 77            79               78
2021-09-18T00:30:00Z 62            75               80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的大于field value的最小整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的大于field-value的最小整数并包含多个子句"><a class="header" href="#计算指定field-key对应的大于field-value的最小整数并包含多个子句">计算指定field key对应的大于field value的最小整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ceil
----                 ----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的大于field value的最小整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-5"><a class="header" href="#高级语法-5">高级语法</a></h4>
<pre><code>SELECT CEIL(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>CEIL()</code>应用于这些结果。</p>
<p><code>CEIL()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-26"><a class="header" href="#示例-26">示例</a></h4>
<ul>
<li>
<h4 id="计算大于平均值的最小整数"><a class="header" href="#计算大于平均值的最小整数">计算大于平均值的最小整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CEIL(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ceil
----                 ----
2021-09-18T00:00:00Z 56
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的大于<code>temperature</code>平均值的最小整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的大于<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CEIL()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算大于这些平均值的最小整数。</p>
</li>
<li>
<h3 id="cos"><a class="header" href="#cos">COS()</a></h3>
<p>返回field value的余弦值。</p>
<h4 id="基本语法-6"><a class="header" href="#基本语法-6">基本语法</a></h4>
<pre><code>SELECT COS( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>COS(field_key)</code>返回field key对应的field value的余弦值。</p>
<p><code>COS(*)</code>返回在measurement中每个field key对应的field value的余弦值。</p>
<p><code>COS()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>COS()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-27"><a class="header" href="#示例-27">示例</a></h4>
<ul>
<li>
<h4 id="下面的示例将使用oceanic_station数据集的如下数据"><a class="header" href="#下面的示例将使用oceanic_station数据集的如下数据">下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值"><a class="header" href="#计算指定field-key对应的field-value的余弦值">计算指定field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.7421541968137826
2021-09-18T00:03:00Z -0.9524129804151563
2021-09-18T00:06:00Z 0.022126756261955732
2021-09-18T00:09:00Z 0.022126756261955732
2021-09-18T00:12:00Z 0.9858965815825497
2021-09-18T00:15:00Z 0.17171734183077755
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:27:00Z -0.8959709467909631
2021-09-18T00:30:00Z 0.9217512697247493
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的余弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的余弦值">计算measurement中每个field key对应的field value的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cos_pressure          cos_temperature      cos_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.39185723042955      0.7421541968137826   0.4401430224960407
2021-09-18T00:03:00Z -0.9672505882738824   -0.9524129804151563  0.17171734183077755
2021-09-18T00:06:00Z -0.8293098328631501   0.022126756261955732 -0.030975031731216456
2021-09-18T00:09:00Z -0.9996474559663501   0.022126756261955732 0.022126756261955732
2021-09-18T00:12:00Z 0.39185723042955      0.9858965815825497   0.6333192030862999
2021-09-18T00:15:00Z 0.11918013544881928   0.17171734183077755  0.6735071623235862
2021-09-18T00:18:00Z 0.022126756261955732  -0.8959709467909631  -0.8293098328631501
2021-09-18T00:21:00Z 0.39185723042955      0.4401430224960407   0.11918013544881928
2021-09-18T00:24:00Z -0.9996474559663501   0.6333192030862999   0.9933903797222716
2021-09-18T00:27:00Z -0.030975031731216456 -0.8959709467909631  -0.8578030932449878
2021-09-18T00:30:00Z 0.6735071623235862    0.9217512697247493   -0.11038724383904756
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的余弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的余弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的余弦值并包含多个子句">计算指定field key对应的field value的余弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cos
----                 ---
2021-09-18T00:24:00Z 0.6333192030862999
2021-09-18T00:21:00Z 0.4401430224960407
2021-09-18T00:18:00Z -0.8959709467909631
2021-09-18T00:15:00Z 0.17171734183077755
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的余弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-6"><a class="header" href="#高级语法-6">高级语法</a></h4>
<pre><code>SELECT COS(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的余弦值。</p>
<p><code>COS()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<h4 id="示例-28"><a class="header" href="#示例-28">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的余弦值"><a class="header" href="#计算平均值的余弦值">计算平均值的余弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT COS(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cos
----                 ---
2021-09-18T00:00:00Z 0.2687822771684872
2021-09-18T00:12:00Z -0.3090227281660707
2021-09-18T00:24:00Z 0.7441351704799297
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的余弦值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>COS()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的余弦值。</p>
</li>
<li>
<h3 id="cumulative_sum"><a class="header" href="#cumulative_sum">CUMULATIVE_SUM()</a></h3>
<p>返回field value的累积总和。</p>
<h4 id="基本语法-7"><a class="header" href="#基本语法-7">基本语法</a></h4>
<pre><code>SELECT CUMULATIVE_SUM( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>CUMULATIVE_SUM(field_key)</code>返回field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM(*)</code>返回在measurement中每个field key对应的field value的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>CUMULATIVE_SUM()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-29"><a class="header" href="#示例-29">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和"><a class="header" href="#计算指定field-key对应的field-value的累积总和">计算指定field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的累积总和"><a class="header" href="#计算measurement中每个field-key对应的field-value的累积总和">计算measurement中每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 cumulative_sum_pressure cumulative_sum_temperature cumulative_sum_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:00:00Z 64                      51                         68
2021-09-18T00:03:00Z 136                     111                        142
2021-09-18T00:06:00Z 190                     166                        219
2021-09-18T00:09:00Z 256                     221                        274
2021-09-18T00:12:00Z 320                     284                        344
2021-09-18T00:15:00Z 378                     358                        406
2021-09-18T00:18:00Z 433                     437                        460
2021-09-18T00:21:00Z 497                     505                        518
2021-09-18T00:24:00Z 563                     575                        587
2021-09-18T00:27:00Z 640                     654                        665
2021-09-18T00:30:00Z 702                     729                        745
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的累积总和。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的累积总和"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的累积总和">计算与正则表达式匹配的每个field key对应的field value的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(/temp/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
time                 cumulative_sum_temperature
----                 --------------------------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 111
2021-09-18T00:06:00Z 166
2021-09-18T00:09:00Z 221
2021-09-18T00:12:00Z 284
2021-09-18T00:15:00Z 358
2021-09-18T00:18:00Z 437
2021-09-18T00:21:00Z 505
2021-09-18T00:24:00Z 575
2021-09-18T00:27:00Z 654
2021-09-18T00:30:00Z 729
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value的累积总和。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的累积总和并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的累积总和并包含多个子句">计算指定field key对应的field value的累积总和并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:24:00Z 224
2021-09-18T00:21:00Z 292
2021-09-18T00:18:00Z 371
2021-09-18T00:15:00Z 445
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的累积总和，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-7"><a class="header" href="#高级语法-7">高级语法</a></h4>
<pre><code class="language-sql">SELECT CUMULATIVE_SUM(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的累积总和。</p>
<p><code>CUMULATIVE_SUM()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的累积总和"><a class="header" href="#计算平均值的累积总和">计算平均值的累积总和</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT CUMULATIVE_SUM(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 cumulative_sum
----                 --------------
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 126.25
2021-09-18T00:24:00Z 200.91666666666669
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的累积总和。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>CUMULATIVE_SUM()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的累积总和。最终查询结果中的第二个<code>point</code>(<code>4.167</code>)是<code>2.09</code>和<code>2.077</code>的总和，第三个<code>point</code>(<code>6.213</code>)是<code>2.09</code>、<code>2.077</code>和<code>2.0460000000000003</code>的总和。</p>
</li>
<li>
<h3 id="derivative"><a class="header" href="#derivative">DERIVATIVE()</a></h3>
<p>返回field value之间的变化率，即导数。</p>
<h4 id="基本语法-8"><a class="header" href="#基本语法-8">基本语法</a></h4>
<pre><code>SELECT DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。</p>
<p><code>DERIVATIVE(field_key)</code>返回field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的变化率。</p>
<p><code>DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-30"><a class="header" href="#示例-30">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数"><a class="header" href="#计算指定field-key对应的field-value的导数">计算指定field key对应的field value的导数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 0.05
2021-09-18T00:06:00Z -0.027777777777777776
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0.044444444444444446
2021-09-18T00:15:00Z 0.06111111111111111
2021-09-18T00:18:00Z 0.027777777777777776
2021-09-18T00:21:00Z -0.06111111111111111
2021-09-18T00:24:00Z 0.011111111111111112
2021-09-18T00:27:00Z 0.05
2021-09-18T00:30:00Z -0.022222222222222223
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率。</p>
<p>第一个结果(<code>0.05</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的导数并指定unit"><a class="header" href="#计算指定field-key对应的field-value的导数并指定unit">计算指定field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;,6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative
----                 ----------
2021-09-18T00:03:00Z 18
2021-09-18T00:06:00Z -10
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 16
2021-09-18T00:15:00Z 22
2021-09-18T00:18:00Z 10
2021-09-18T00:21:00Z -22
2021-09-18T00:24:00Z 4
2021-09-18T00:27:00Z 18
2021-09-18T00:30:00Z -8
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每六分钟的变化率。</p>
<p>第一个结果(<code>0.052000000000000046</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code>(2.116 - 2.064) / (6m / 6m)
--------------    ----------
       |              |
       |          the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算measurement中每个field-key对应的field-value的导数并指定unit">计算measurement中每个field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(*,3m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_pressure derivative_temperature derivative_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的每三分钟的变化率。measurement <code>air</code>中数值类型的field：<code>temperature</code>,<code>pressure</code>,<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的导数并指定unit">计算与正则表达式匹配的每个field key对应的field value的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(/temp/,2m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 derivative_temperature
----                 ----------------------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z -3.3333333333333335
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 5.333333333333333
2021-09-18T00:15:00Z 7.333333333333333
2021-09-18T00:18:00Z 3.3333333333333335
2021-09-18T00:21:00Z -7.333333333333333
2021-09-18T00:24:00Z 1.3333333333333333
2021-09-18T00:27:00Z 6
2021-09-18T00:30:00Z -2.6666666666666665
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中的对应field key&quot;temperature&quot;对应的field value的每两分钟的变化率。</p>
<p>第一个结果(<code>6</code>)是原始数据中前两个field value在两分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为两分钟的变化率：</p>
<pre><code>(-3.3333333333333335 6) / (6m / 2m)
--------------            ----------
       |                      |
       |                the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的导数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的导数并包含多个子句">计算指定field key对应的field value的导数并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 1 OFFSET 2
name: air
time                 derivative
----                 ----------
2021-09-18T00:21:00Z -0.011111111111111112
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的每秒变化率，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<p>唯一的结果(<code>-0.011111111111111112</code>)是原始数据中前两个field value在一秒内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为一秒的变化率。</p>
<h4 id="高级语法-8"><a class="header" href="#高级语法-8">高级语法</a></h4>
<pre><code>SELECT DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。</p>
<p><code>DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的导数"><a class="header" href="#计算平均值的导数">计算平均值的导数</a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -14.25
2021-09-18T00:12:00Z 15.75
2021-09-18T00:24:00Z 3.6666666666666714
</code></pre>
</li>
</ul>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每12分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每12分钟的变化率。第一个结果(<code>55.25</code>)是原始数据中前两个field value在12分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为12分钟的变化率：</p>
<pre><code>(71 - 74.66666666666667)  / (12m / 12m)
-------------                   ----------
       |                           |
       |                     the difference between the field values' timestamps / the default unit
second field value - first field value
</code></pre>
<ul>
<li>
<h4 id="计算平均值的导数并指定unit"><a class="header" href="#计算平均值的导数并指定unit">计算平均值的导数并指定<code>unit</code></a></h4>
<pre><code class="language-sql">&gt; SELECT DERIVATIVE(MEAN(&quot;temperature&quot;),6m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 derivative
----                 ----------
2021-09-18T00:00:00Z -7.125
2021-09-18T00:12:00Z 7.875
2021-09-18T00:24:00Z 1.8333333333333357
</code></pre>
</li>
</ul>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值的每六分钟变化率。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DERIVATIVE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)

name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的每六分钟的变化率。第一个结果(<code>-55.25</code>)是原始数据中前两个field value在六分钟内的变化率。CnosDB计算两个field value之间的差值，并将该值标准化为六分钟的变化率：</p>
<pre><code class="language-sql">(71 - 74.66666666666667) / (12m / 6m)
-------------    ----------
       |                         |
       |                    the difference between the field values' timestamps / the specified unit
second field value - first field value
</code></pre>
<ul>
<li>
<h3 id="difference"><a class="header" href="#difference">DIFFERENCE()</a></h3>
<p>返回field value之间的差值。</p>
<h4 id="基本语法-9"><a class="header" href="#基本语法-9">基本语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>DIFFERENCE(field_key)</code>返回field key对应的field value的差值。</p>
<p><code>DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的差值。</p>
<p><code>DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-31"><a class="header" href="#示例-31">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值"><a class="header" href="#计算指定field-key对应的field-value的差值">计算指定field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference
----                 ----------
2021-09-18T00:03:00Z 9
2021-09-18T00:06:00Z -5
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 8
2021-09-18T00:15:00Z 11
2021-09-18T00:18:00Z 5
2021-09-18T00:21:00Z -11
2021-09-18T00:24:00Z 2
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z -4
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的差值"><a class="header" href="#计算measurement中每个field-key对应的field-value的差值">计算measurement中每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_pressure difference_temperature difference_visibility
----                 ------------------- ---------------------- ---------------------
2021-09-18T00:03:00Z 8                   9                      6
2021-09-18T00:06:00Z -18                 -5                     3
2021-09-18T00:09:00Z 12                  0                      -22
2021-09-18T00:12:00Z -2                  8                      15
2021-09-18T00:15:00Z -6                  11                     -8
2021-09-18T00:18:00Z -3                  5                      -8
2021-09-18T00:21:00Z 9                   -11                    4
2021-09-18T00:24:00Z 2                   2                      11
2021-09-18T00:27:00Z 11                  9                      9
2021-09-18T00:30:00Z -15                 -4                     2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value之间的差值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的差值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的差值">计算与正则表达式匹配的每个field key对应的field value的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(/visi/) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 difference_visibility
----                 ----------
2021-09-18T00:03:00Z 6
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z -22
2021-09-18T00:12:00Z 15
2021-09-18T00:15:00Z -8
2021-09-18T00:18:00Z -8
2021-09-18T00:21:00Z 4
2021-09-18T00:24:00Z 11
2021-09-18T00:27:00Z 9
2021-09-18T00:30:00Z 2
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>water</code>的field key对应的field value之间的差值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的差值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的差值并包含多个子句">计算指定field key对应的field value的差值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 2 OFFSET 2
name: air
time                 difference
----                 ----------
2021-09-18T00:21:00Z -2
2021-09-18T00:18:00Z 11
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value之间的差值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移两个（即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-9"><a class="header" href="#高级语法-9">高级语法</a></h4>
<pre><code class="language-sql">SELECT DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的差值。</p>
<p>DIFFERENCE()支持以下嵌套函数：
<a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-32"><a class="header" href="#示例-32">示例</a></h4>
<ul>
<li>
<h4 id="计算最大值之间的差值"><a class="header" href="#计算最大值之间的差值">计算最大值之间的差值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT DIFFERENCE(MAX(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 difference
----                 ----------
2021-09-18T00:00:00Z -19
2021-09-18T00:12:00Z 19
2021-09-18T00:24:00Z 0
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值之间的差值。</p>
<p>为了得到这些结果，CnosDB首先计算field key <code>temperature</code>对应的每12分钟的时间间隔的field value的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>DIFFERENCE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值之间的差值。最终查询结果中的第一个<code>point</code>(<code>0.009999999999999787</code>)是<code>2.126</code>和<code>2.116</code>的差，第二个<code>point</code>(<code>-0.07499999999999973</code>)是<code>2.051</code>和<code>2.126</code>的差。</p>
</li>
<li>
<h3 id="elapsed"><a class="header" href="#elapsed">ELAPSED()</a></h3>
<p>返回field value的时间戳之间的差值。</p>
<h4 id="语法-17"><a class="header" href="#语法-17">语法</a></h4>
<pre><code>SELECT ELAPSED( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算时间戳之间的差值。参数<code>unit</code>的值是一个整数，后跟一个时间单位，它决定了返回的差值的单位。这个参数是可选的，不是必须要有的。如果没有指定<code>unit</code>的值，那么查询将返回以纳秒为单位的两个时间戳之间的差值。</p>
<p><code>ELAPSED(field_key)</code>返回field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED(*)</code>返回在measurement中每个field key对应的时间戳之间的差值。</p>
<p><code>ELAPSED()</code>支持所有数据类型的field value。</p>
<h4 id="示例-33"><a class="header" href="#示例-33">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔">计算指定field key对应的field value之间的时间间隔</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 180000000000
2021-09-18T00:06:00Z 180000000000
2021-09-18T00:09:00Z 180000000000
2021-09-18T00:12:00Z 180000000000
2021-09-18T00:15:00Z 180000000000
2021-09-18T00:18:00Z 180000000000
2021-09-18T00:21:00Z 180000000000
2021-09-18T00:24:00Z 180000000000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以纳秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并指定unit">计算指定field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个field key对应的时间戳之间的差值(以分钟为单位)。measurement <code>air</code>中有两个field key：<code>pressure</code>和<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value之间的时间间隔并指定unit">计算与正则表达式匹配的每个field key对应的field value之间的时间间隔并指定<code>unit</code></a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(/press/,1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z'
name: air
time                 elapsed_pressure
----                 ----------------
2021-09-18T00:03:00Z 3
2021-09-18T00:06:00Z 3
2021-09-18T00:09:00Z 3
2021-09-18T00:12:00Z 3
2021-09-18T00:15:00Z 3
2021-09-18T00:18:00Z 3
2021-09-18T00:21:00Z 3
2021-09-18T00:24:00Z 3
</code></pre>
<p>该查询返回measurement <code>air</code>中每个包含单词<code>level</code>的field key对应的时间戳之间的差值(以秒为单位)。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value之间的时间间隔并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value之间的时间间隔并包含多个子句">计算指定field key对应的field value之间的时间间隔并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1ms) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:24:00Z' ORDER BY time DESC LIMIT 1 OFFSET 1
name: air
time                 elapsed
----                 -------
2021-09-18T00:18:00Z -180000
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的时间戳之间的差值(以毫秒为单位)，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2020-08-18T00:12:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为1，并将返回的<code>point</code>偏移一个（即前一个<code>point</code>不返回）。</p>
<p>请注意，查询结果是负数；因为<code>ORDER BY time DESC</code>子句按递减的顺序对时间戳进行排序，所以<code>ELAPSED()</code>以相反的顺序计算时间戳的差值。</p>
<h4 id="elapsed的常见问题"><a class="header" href="#elapsed的常见问题"><code>ELAPSED()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="elapsed和大于经过时间的单位"><a class="header" href="#elapsed和大于经过时间的单位"><code>ELAPSED()</code>和大于经过时间的单位</a></h4>
</li>
</ul>
<p>I如果<code>unit</code>的值大于时间戳之间的差值，那么CnosDB将会返回<code>0</code>。</p>
<p>measurement <code>air</code>中每六分钟有一个<code>point</code>。如果查询将<code>unit</code>设置为一小时，CnosDB将会返回<code>0</code>：</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(&quot;temperature&quot;,1h) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:12:00Z'
name: air
time                 elapsed
----                 -------
2021-09-18T00:03:00Z 0
2021-09-18T00:06:00Z 0
2021-09-18T00:09:00Z 0
2021-09-18T00:12:00Z 0
</code></pre>
<ul>
<li>
<h4 id="elapsed和group-by-time子句同时使用"><a class="header" href="#elapsed和group-by-time子句同时使用"><code>ELAPSED()</code>和<code>GROUP BY time()</code>子句同时使用</a></h4>
</li>
</ul>
<p><code>ELAPSED()</code>函数支持<code>GROUP BY time()</code>子句，但是查询结果不是特别有用。目前，如果<code>ELAPSED()</code>查询包含一个嵌套的CnosQL函数和一个<code>GROUP BY time()</code>子句，那么只会返回指定<code>GROUP BY time()</code>子句中的时间间隔。</p>
<p><code>GROUP BY time()</code>子句决定了查询结果中的时间戳：每个时间戳表示时间间隔的开始时间。该行为也适用于嵌套的selector函数(例如<code>FIRST()</code>或<code>MAX()</code>)，而在其它的所有情况下，这些函数返回的是原始数据的特定时间戳。因为<code>GROUP BY time()</code>子句会覆盖原始时间戳，所以<code>ELAPSED()</code>始终返回与<code>GROUP BY time()</code>的时间间隔相同的时间戳。</p>
<p>下面代码块中的第一个查询尝试使用<code>ELAPSED()</code>和<code>GROUP BY time()</code>子句来查找最小的<code>temperature</code>的值之间经过的时间(以分钟为单位)。查询的两个时间间隔都返回了12分钟。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔的<code>temperature</code>的最小值。代码块中的第二个查询展示了这一步的结果。这一步跟同时使用<code>MIN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ELAPSED()</code>的情形一样。请注意，第二个查询返回的时间戳间隔12分钟。在原始数据中，第一个结果(<code>2.057</code>)发生在<code>2020-08-18T00:42:00Z</code>，但是<code>GROUP BY time()</code>子句覆盖了原始的时间戳。因为时间戳由<code>GROUP BY time()</code>的时间间隔(而不是原始数据)决定，所以<code>ELAPSED()</code>始终返回与GROUP BY time()的时间间隔相同的时间戳。</p>
<pre><code class="language-sql">&gt; SELECT ELAPSED(MIN(&quot;temperature&quot;),1m) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 elapsed
----                 -------
2021-09-08T00:36:00Z 12
2021-09-08T00:48:00Z 12

&gt; SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-08T00:36:00Z' AND time &lt;= '2021-09-08T00:54:00Z' GROUP BY time(12m)
name: air
time                 min
----                 ---
2021-09-08T00:36:00Z 50
2021-09-08T00:48:00Z 73  &lt;--- Actually occurs at 2021-09-08T00:48:00Z
</code></pre>
</li>
<li>
<h3 id="exp"><a class="header" href="#exp">EXP()</a></h3>
<p>返回field value的指数。</p>
<h4 id="基本语法-10"><a class="header" href="#基本语法-10">基本语法</a></h4>
<pre><code>SELECT EXP( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>EXP(field_key)</code>返回field key对应的field value的指数。</p>
<p><code>EXP(*)</code>返回在measurement中每个field key对应的field value的指数。</p>
<p><code>EXP()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>EXP()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-34"><a class="header" href="#示例-34">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.85.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数"><a class="header" href="#计算指定field-key对应的field-value的指数">计算指定field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 1.4093490824269389e+22
2021-09-18T00:03:00Z 1.1420073898156842e+26
2021-09-18T00:06:00Z 7.694785265142018e+23
2021-09-18T00:09:00Z 7.694785265142018e+23
2021-09-18T00:12:00Z 2.29378315946961e+27
2021-09-18T00:15:00Z 1.3733829795401763e+32
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:27:00Z 2.0382810665126688e+34
2021-09-18T00:30:00Z 3.7332419967990015e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的指数"><a class="header" href="#计算measurement中每个field-key对应的field-value的指数">计算measurement中每个field key对应的field value的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 exp_pressure           exp_temperature        exp_visibility
----                 ------------           ---------------        --------------
2021-09-18T00:00:00Z 6.235149080811617e+27  1.4093490824269389e+22 3.404276049931741e+29
2021-09-18T00:03:00Z 1.8586717452841279e+31 1.1420073898156842e+26 1.3733829795401763e+32
2021-09-18T00:06:00Z 2.830753303274694e+23  7.694785265142018e+23  2.7585134545231703e+33
2021-09-18T00:09:00Z 4.607186634331292e+28  7.694785265142018e+23  7.694785265142018e+23
2021-09-18T00:12:00Z 6.235149080811617e+27  2.29378315946961e+27   2.515438670919167e+30
2021-09-18T00:15:00Z 1.545538935590104e+25  1.3733829795401763e+32 8.438356668741455e+26
2021-09-18T00:18:00Z 7.694785265142018e+23  2.0382810665126688e+34 2.830753303274694e+23
2021-09-18T00:21:00Z 6.235149080811617e+27  3.404276049931741e+29  1.545538935590104e+25
2021-09-18T00:24:00Z 4.607186634331292e+28  2.515438670919167e+30  9.253781725587789e+29
2021-09-18T00:27:00Z 2.7585134545231703e+33 2.0382810665126688e+34 7.49841699699012e+33
2021-09-18T00:30:00Z 8.438356668741455e+26  3.7332419967990015e+32 5.54062238439351e+34
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的指数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的指数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的指数并包含多个子句">计算指定field key对应的field value的指数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 exp
----                 ---
2021-09-18T00:24:00Z 2.515438670919167e+30
2021-09-18T00:21:00Z 3.404276049931741e+29
2021-09-18T00:18:00Z 2.0382810665126688e+34
2021-09-18T00:15:00Z 1.3733829795401763e+32
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的指数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-10"><a class="header" href="#高级语法-10">高级语法</a></h4>
<pre><code>SELECT EXP(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的指数。</p>
<p>EXP()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
<h4 id="示例-35"><a class="header" href="#示例-35">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的指数"><a class="header" href="#计算平均值的指数">计算平均值的指数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT EXP(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 exp
----                 ---
2021-09-18T00:00:00Z 9.880299856396672e+23
2021-09-18T00:12:00Z 6.837671229762744e+30
2021-09-18T00:24:00Z 2.674984780655511e+32
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的绝对值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>EXP()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>.然后，CnosDB计算这些平均值的指数。</p>
<h3 id="floor"><a class="header" href="#floor">FLOOR()</a></h3>
<p>返回小于指定值的最大整数。</p>
<h4 id="基本语法-11"><a class="header" href="#基本语法-11">基本语法</a></h4>
<pre><code>SELECT FLOOR( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>FLOOR(field_key)</code>返回field key对应的小于field value的最大整数。</p>
<p><code>FLOOR(*)</code>返回在measurement中每个field key对应的小于field value的最大整数。</p>
<p><code>FLOOR()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>FLOOR()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-36"><a class="header" href="#示例-36">示例</a></h4>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数">计算指定field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的小于field value的最大整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的小于field-value的最大整数"><a class="header" href="#计算measurement中每个field-key对应的小于field-value的最大整数">计算measurement中每个field key对应的小于field value的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 floor_pressure floor_temperature floor_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的小于field value的最大整数。measurement <code>air</code>只有一个数值类型的field：<code>temperature</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的小于field-value的最大整数并包含多个子句"><a class="header" href="#计算指定field-key对应的小于field-value的最大整数并包含多个子句">计算指定field key对应的小于field value的最大整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 floor
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回field key <code>temperature</code>对应的小于field value的最大整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回)。</p>
<h4 id="高级语法-11"><a class="header" href="#高级语法-11">高级语法</a></h4>
<pre><code>SELECT FLOOR(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后将<code>FLOOR()</code>应用于这些结果。</p>
<p><code>FLOOR()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算小于平均值的最大整数"><a class="header" href="#计算小于平均值的最大整数">计算小于平均值的最大整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT FLOOR(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 floor
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的小于<code>temperature</code>平均值的最大整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>FLOOR()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算小于这些平均值的最大整数。</p>
</li>
<li>
<h3 id="ln"><a class="header" href="#ln">LN()</a></h3>
<p>返回field value的自然对数。</p>
<h4 id="基本语法-12"><a class="header" href="#基本语法-12">基本语法</a></h4>
<pre><code>SELECT LN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LN(field_key)</code>返回field key对应的field value的自然对数。</p>
<p><code>LN(*)</code>返回在measurement中每个field key对应的field value的自然对数。</p>
<p><code>LN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LN()</code>和<code>GROUP BY time()</code>子句。</p>
<h4 id="示例-37"><a class="header" href="#示例-37">示例</a></h4>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.86.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数"><a class="header" href="#计算指定field-key对应的field-value的自然对数">计算指定field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 3.9318256327243257
2021-09-18T00:03:00Z 4.0943445622221
2021-09-18T00:06:00Z 4.007333185232471
2021-09-18T00:09:00Z 4.007333185232471
2021-09-18T00:12:00Z 4.143134726391533
2021-09-18T00:15:00Z 4.304065093204169
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:27:00Z 4.3694478524670215
2021-09-18T00:30:00Z 4.31748811353631
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的自然对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的自然对数">计算measurement中每个field key对应的field value的自然对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 ln_pressure        ln_temperature     ln_visibility
----                 -----------        --------------     -------------
2021-09-18T00:00:00Z 4.1588830833596715 3.9318256327243257 4.219507705176107
2021-09-18T00:03:00Z 4.276666119016055  4.0943445622221    4.304065093204169
2021-09-18T00:06:00Z 3.9889840465642745 4.007333185232471  4.343805421853684
2021-09-18T00:09:00Z 4.189654742026425  4.007333185232471  4.007333185232471
2021-09-18T00:12:00Z 4.1588830833596715 4.143134726391533  4.248495242049359
2021-09-18T00:15:00Z 4.060443010546419  4.304065093204169  4.127134385045092
2021-09-18T00:18:00Z 4.007333185232471  4.3694478524670215 3.9889840465642745
2021-09-18T00:21:00Z 4.1588830833596715 4.219507705176107  4.060443010546419
2021-09-18T00:24:00Z 4.189654742026425  4.248495242049359  4.23410650459726
2021-09-18T00:27:00Z 4.343805421853684  4.3694478524670215 4.356708826689592
2021-09-18T00:30:00Z 4.127134385045092  4.31748811353631   4.382026634673881
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的自然对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的自然对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的自然对数并包含多个子句">计算指定field key对应的field value的自然对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 ln
----                 --
2021-09-18T00:24:00Z 4.248495242049359
2021-09-18T00:21:00Z 4.219507705176107
2021-09-18T00:18:00Z 4.3694478524670215
2021-09-18T00:15:00Z 4.304065093204169
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的自然对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-12"><a class="header" href="#高级语法-12">高级语法</a></h4>
<pre><code>SELECT LN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个 GROUP BY time() <code>和一个嵌套的CnosQL 函数. 该查询受限以指定</code>GROUP BY time()<code>间隔计算嵌套函数的结果 </code>LN()` .</p>
<p>LN()支持以下嵌套函数：</p>
<p><a href="#count"><code>COUNT()</code></a>,
<a href="#mean"><code>MEAN()</code></a>,
<a href="#median"><code>MEDIAN()</code></a>,
<a href="#mode"><code>MODE()</code></a>,
<a href="#sum"><code>SUM()</code></a>,
<a href="#first"><code>FIRST()</code></a>,
<a href="#last"><code>LAST()</code></a>,
<a href="#min"><code>MIN()</code></a>,
<a href="#max"><code>MAX()</code></a>, and
<a href="#percentile"><code>PERCENTILE()</code></a>.</p>
</li>
</ul>
<h4 id="示例-38"><a class="header" href="#示例-38">示例</a></h4>
<ul>
<li>
<h4 id="计算平均值的自然对数"><a class="header" href="#计算平均值的自然对数">计算平均值的自然对数</a></h4>
<pre><code class="language-sql">&gt; SELECT LN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 ln
----                 --
2021-09-18T00:00:00Z 4.0118683403978626
2021-09-18T00:12:00Z 4.2626798770413155
2021-09-18T00:24:00Z 4.31303376318693
</code></pre>
</li>
</ul>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的自然对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的自然对数。</p>
<ul>
<li>
<h3 id="log"><a class="header" href="#log">LOG()</a></h3>
<p>返回field value的以<code>b</code>为底数的对数。</p>
<h4 id="基本语法-13"><a class="header" href="#基本语法-13">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG( [ * | &lt;field_key&gt; ], &lt;b&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG(field_key, b)</code>返回field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG(*, b)</code>返回在measurement中每个field key对应的field value的以<code>b</code>为底数的对数。</p>
<p><code>LOG()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.87.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数">计算指定field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.836212670985748
2021-09-18T00:03:00Z 2.9534452978042594
2021-09-18T00:06:00Z 2.89067985676233
2021-09-18T00:09:00Z 2.89067985676233
2021-09-18T00:12:00Z 2.9886399617499584
2021-09-18T00:15:00Z 3.1047266828144746
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:27:00Z 3.1518903740885515
2021-09-18T00:30:00Z 3.11440934524794
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以4为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以4为底数的对数">计算measurement中每个field key对应的field value的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log_pressure       log_temperature    log_visibility
----                 ------------       ---------------    --------------
2021-09-18T00:00:00Z 3                  2.836212670985748  3.04373142062517
2021-09-18T00:03:00Z 3.084962500721156  2.9534452978042594 3.1047266828144746
2021-09-18T00:06:00Z 2.8774437510817346 2.89067985676233   3.133393270347451
2021-09-18T00:09:00Z 3.0221970596792267 2.89067985676233   2.89067985676233
2021-09-18T00:12:00Z 3                  2.9886399617499584 3.0646415084724836
2021-09-18T00:15:00Z 2.928990497563786  3.1047266828144746 2.977098155193438
2021-09-18T00:18:00Z 2.89067985676233   3.1518903740885515 2.8774437510817346
2021-09-18T00:21:00Z 3                  3.04373142062517   2.928990497563786
2021-09-18T00:24:00Z 3.0221970596792267 3.0646415084724836 3.054262228389085
2021-09-18T00:27:00Z 3.133393270347451  3.1518903740885515 3.1427011094311244
2021-09-18T00:30:00Z 2.977098155193438  3.11440934524794   3.160964047443681
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以4为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以4为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以4为底数的对数并包含多个子句">计算指定field key对应的field value的以4为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log
----                 ---
2021-09-18T00:24:00Z 3.0646415084724836
2021-09-18T00:21:00Z 3.04373142062517
2021-09-18T00:18:00Z 3.1518903740885515
2021-09-18T00:15:00Z 3.1047266828144746
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以4为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-13"><a class="header" href="#高级语法-13">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;b&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的对数。</p>
<p><code>LOG()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以4为底数的对数"><a class="header" href="#计算平均值的以4为底数的对数">计算平均值的以4为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log
----                 ---
2021-09-18T00:00:00Z 2.8939512796957163
2021-09-18T00:12:00Z 3.074873559752341
2021-09-18T00:24:00Z 3.1111962106682243
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以4为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以4为底数的对数。</p>
</li>
<li>
<h3 id="log2"><a class="header" href="#log2">LOG2()</a></h3>
<p>返回field value的以2为底数的对数。</p>
<h4 id="基本语法-14"><a class="header" href="#基本语法-14">基本语法</a></h4>
<pre><code class="language-sql">SELECT LOG2( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG2(field_key)</code>返回field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2(*)</code>返回在measurement中每个field key对应的field value的以2为底数的对数。</p>
<p><code>LOG2()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG2()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.88.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数">计算指定field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.672425341971495
2021-09-18T00:03:00Z 5.906890595608519
2021-09-18T00:06:00Z 5.78135971352466
2021-09-18T00:09:00Z 5.78135971352466
2021-09-18T00:12:00Z 5.977279923499917
2021-09-18T00:15:00Z 6.20945336562895
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:27:00Z 6.303780748177103
2021-09-18T00:30:00Z 6.22881869049588
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以2为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以2为底数的对数">计算measurement中每个field key对应的field value的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log2_pressure     log2_temperature  log2_visibility
----                 -------------     ----------------  ---------------
2021-09-18T00:00:00Z 6                 5.672425341971495 6.087462841250339
2021-09-18T00:03:00Z 6.169925001442312 5.906890595608519 6.20945336562895
2021-09-18T00:06:00Z 5.754887502163468 5.78135971352466  6.266786540694901
2021-09-18T00:09:00Z 6.044394119358453 5.78135971352466  5.78135971352466
2021-09-18T00:12:00Z 6                 5.977279923499917 6.129283016944966
2021-09-18T00:15:00Z 5.857980995127572 6.20945336562895  5.954196310386875
2021-09-18T00:18:00Z 5.78135971352466  6.303780748177103 5.754887502163468
2021-09-18T00:21:00Z 6                 6.087462841250339 5.857980995127572
2021-09-18T00:24:00Z 6.044394119358453 6.129283016944966 6.108524456778169
2021-09-18T00:27:00Z 6.266786540694901 6.303780748177103 6.285402218862249
2021-09-18T00:30:00Z 5.954196310386875 6.22881869049588  6.321928094887363
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以2为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以2为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以2为底数的对数并包含多个子句">计算指定field key对应的field value的以2为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log2
----                 ----
2021-09-18T00:24:00Z 6.129283016944966
2021-09-18T00:21:00Z 6.087462841250339
2021-09-18T00:18:00Z 6.303780748177103
2021-09-18T00:15:00Z 6.20945336562895
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以2为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-14"><a class="header" href="#高级语法-14">高级语法</a></h4>
<pre><code class="language-sql">SELECT LOG2(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以2为底数的对数。</p>
<p><code>LOG2()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以2为底数的对数"><a class="header" href="#计算平均值的以2为底数的对数">计算平均值的以2为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG2(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log2
----                 ----
2021-09-18T00:00:00Z 5.787902559391432
2021-09-18T00:12:00Z 6.149747119504682
2021-09-18T00:24:00Z 6.222392421336448
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以2为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG2()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以2为底数的对数。</p>
</li>
<li>
<h3 id="log10"><a class="header" href="#log10">LOG10()</a></h3>
<p>返回field value的以10为底数的对数。</p>
<h4 id="基本语法-15"><a class="header" href="#基本语法-15">基本语法</a></h4>
<pre><code>SELECT LOG10( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>LOG10(field_key)</code>返回field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10(*)</code>返回在measurement中每个field key对应的field value的以10为底数的对数。</p>
<p><code>LOG10()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>LOG10()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.89.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数">计算指定field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7075701760979363
2021-09-18T00:03:00Z 1.7781512503836434
2021-09-18T00:06:00Z 1.7403626894942439
2021-09-18T00:09:00Z 1.7403626894942439
2021-09-18T00:12:00Z 1.7993405494535817
2021-09-18T00:15:00Z 1.869231719730976
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:27:00Z 1.8976270912904414
2021-09-18T00:30:00Z 1.8750612633916999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的以10为底数的对数"><a class="header" href="#计算measurement中每个field-key对应的field-value的以10为底数的对数">计算measurement中每个field key对应的field value的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 log10_pressure     log10_temperature  log10_visibility
----                 --------------     -----------------  ----------------
2021-09-18T00:00:00Z 1.806179973983887  1.7075701760979363 1.8325089127062364
2021-09-18T00:03:00Z 1.8573324964312685 1.7781512503836434 1.869231719730976
2021-09-18T00:06:00Z 1.7323937598229686 1.7403626894942439 1.8864907251724818
2021-09-18T00:09:00Z 1.8195439355418686 1.7403626894942439 1.7403626894942439
2021-09-18T00:12:00Z 1.806179973983887  1.7993405494535817 1.845098040014257
2021-09-18T00:15:00Z 1.7634279935629371 1.869231719730976  1.792391689498254
2021-09-18T00:18:00Z 1.7403626894942439 1.8976270912904414 1.7323937598229686
2021-09-18T00:21:00Z 1.806179973983887  1.8325089127062364 1.7634279935629371
2021-09-18T00:24:00Z 1.8195439355418686 1.845098040014257  1.8388490907372554
2021-09-18T00:27:00Z 1.8864907251724818 1.8976270912904414 1.8920946026904804
2021-09-18T00:30:00Z 1.792391689498254  1.8750612633916999 1.9030899869919433
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的以10为底数的对数。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的以10为底数的对数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的以10为底数的对数并包含多个子句">计算指定field key对应的field value的以10为底数的对数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 log10
----                 -----
2021-09-18T00:24:00Z 1.845098040014257
2021-09-18T00:21:00Z 1.8325089127062364
2021-09-18T00:18:00Z 1.8976270912904414
2021-09-18T00:15:00Z 1.869231719730976
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的以10为底数的对数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-15"><a class="header" href="#高级语法-15">高级语法</a></h4>
<pre><code>SELECT LOG10(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的以10为底数的对数。</p>
<p><code>LOG10()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的以10为底数的对数"><a class="header" href="#计算平均值的以10为底数的对数">计算平均值的以10为底数的对数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT LOG10(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 log10
----                 -----
2021-09-18T00:00:00Z 1.7423322823571483
2021-09-18T00:12:00Z 1.8512583487190752
2021-09-18T00:24:00Z 1.8731267636145004
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的以10为底数的对数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>LOG10()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的以10为底数的对数。</p>
</li>
<li>
<h3 id="moving_average"><a class="header" href="#moving_average">MOVING_AVERAGE()</a></h3>
<p>返回field value窗口的滚动平均值。</p>
<h4 id="基本语法-16"><a class="header" href="#基本语法-16">基本语法</a></h4>
<pre><code class="language-sql">SELECT MOVING_AVERAGE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] , &lt;N&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>MOVING_AVERAGE()</code>计算包含<code>N</code>个连续field value的窗口的滚动平均值。参数<code>N</code>是一个整数，并且它是必须的。</p>
<p><code>MOVING_AVERAGE(field_key,N)</code>返回field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(/regular_expression/,N)</code>返回与正则表达式匹配的每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE(*,N)</code>返回在measurement中每个field key对应的N个field value的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>MOVING_AVERAGE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
</li>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值">计算指定field key对应的field value的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average
----                 --------------
2021-09-18T00:03:00Z 55.5
2021-09-18T00:06:00Z 57.5
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 59
2021-09-18T00:15:00Z 68.5
2021-09-18T00:18:00Z 76.5
2021-09-18T00:21:00Z 73.5
2021-09-18T00:24:00Z 69
2021-09-18T00:27:00Z 74.5
2021-09-18T00:30:00Z 77
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值。第一个结果(<code>2.09</code>)是原始数据中前两个field value的平均值：(2.064 + 2.116) / 2。第二个结果(<code>2.072</code>)是原始数据中第二和第三个field value的平均值：(2.116 + 2.028) / 2。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算measurement中每个field-key对应的field-value的滚动平均值">计算measurement中每个field key对应的field value的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(*,3) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure moving_average_temperature moving_average_visibility
----                 ----------------------- -------------------------- -------------------------
2021-09-18T00:06:00Z 63.333333333333336      55.333333333333336         73
2021-09-18T00:09:00Z 64                      56.666666666666664         68.66666666666667
2021-09-18T00:12:00Z 61.333333333333336      57.666666666666664         67.33333333333333
2021-09-18T00:15:00Z 62.666666666666664      64                         62.333333333333336
2021-09-18T00:18:00Z 59                      72                         62
2021-09-18T00:21:00Z 59                      73.66666666666667          58
2021-09-18T00:24:00Z 61.666666666666664      72.33333333333333          60.333333333333336
2021-09-18T00:27:00Z 69                      72.33333333333333          68.33333333333333
2021-09-18T00:30:00Z 68.33333333333333       74.66666666666667          75.66666666666667
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的窗口大小为三个field value的滚动平均值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值"><a class="header" href="#计算与正则表达式匹配的每个field-key对应的field-value的滚动平均值">计算与正则表达式匹配的每个field key对应的field value的滚动平均值</a></h4>
<pre><code>&gt; SELECT MOVING_AVERAGE(/press/,4) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z'
name: air
time                 moving_average_pressure
----                 -----------------------
2021-09-18T00:09:00Z 64
2021-09-18T00:12:00Z 64
2021-09-18T00:15:00Z 60.5
2021-09-18T00:18:00Z 60.75
2021-09-18T00:21:00Z 60.25
2021-09-18T00:24:00Z 60.75
2021-09-18T00:27:00Z 65.5
2021-09-18T00:30:00Z 67.25
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中每个存储数值并包含单词<code>level</code>的field key对应的窗口大小为四个field value的滚动平均值。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的滚动平均值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的滚动平均值并包含多个子句">计算指定field key对应的field value的滚动平均值并包含多个子句</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(&quot;temperature&quot;,2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' ORDER BY time DESC LIMIT 2 OFFSET 3
name: air
time                 moving_average
----                 --------------
2021-09-18T00:18:00Z 73.5
2021-09-18T00:15:00Z 76.5
</code></pre>
</li>
</ul>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的窗口大小为两个field value的滚动平均值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为2，并将返回的<code>point</code>偏移三个(即前三个<code>point</code>不返回）。</p>
<h4 id="高级语法-16"><a class="header" href="#高级语法-16">高级语法</a></h4>
<pre><code>SELECT MOVING_AVERAGE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) , N ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的滚动平均值。</p>
<p><code>MOVING_AVERAGE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算最大值的滚动平均值"><a class="header" href="#计算最大值的滚动平均值">计算最大值的滚动平均值</a></h4>
<pre><code class="language-sql">&gt; SELECT MOVING_AVERAGE(MAX(&quot;temperature&quot;),2) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 moving_average
----                 --------------
2021-09-18T00:00:00Z 69.5
2021-09-18T00:12:00Z 69.5
2021-09-18T00:24:00Z 79
</code></pre>
</li>
</ul>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的最大值的窗口大小为两个值的滚动平均值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的最大值。这一步跟同时使用<code>MAX()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>MOVING_AVERAGE()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE &quot;station&quot; = 'LianYunGang' AND time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 60
2021-09-18T00:12:00Z 79
2021-09-18T00:24:00Z 79
</code></pre>
<p>然后，CnosDB计算这些最大值的窗口大小为两个值的滚动平均值。最终查询结果中的第一个<code>point</code>(<code>2.121</code>)是前两个最大值的平均值(<code>(2.116 + 2.126) / 2</code>)。</p>
<ul>
<li>
<h3 id="non_negative_derivative"><a class="header" href="#non_negative_derivative">NON_NEGATIVE_DERIVATIVE()</a></h3>
<p>返回field value之间的非负变化率。非负变化率包括正的变化率和等于0的变化率。</p>
<h4 id="基本语法-17"><a class="header" href="#基本语法-17">基本语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>CnosDB计算field value之间的差值，并将这些结果转换为每个<code>unit</code>的变化率。参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为一秒(<code>1s</code>)。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(field_key)</code>返回field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE(*)</code>返回在measurement中每个field key对应的field value的非负变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DERIVATIVE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
<h4 id="高级语法-17"><a class="header" href="#高级语法-17">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DERIVATIVE(&lt;function&gt; ([ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ]) [ , &lt;unit&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的非负导数。</p>
<p>参数<code>unit</code>的值是一个整数，后跟一个时间单位。这个参数是可选的，不是必须要有的。如果查询没有指定<code>unit</code>的值，那么<code>unit</code>默认为<code>GROUP BY time()</code>的时间间隔。请注意，这里<code>unit</code>的默认值跟基本语法中<code>unit</code>的默认值不一样。<code>NON_NEGATIVE_DERIVATIVE()</code>只返回正的变化率和等于0的变化率。</p>
<p><code>NON_NEGATIVE_DERIVATIVE()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a>
####示例</li>
</ul>
<p>请查看<code>DERIVATIVE()</code>文档中的示例，<code>NON_NEGATIVE_DERIVATIVE()</code>跟<code>DERIVATIVE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DERIVATIVE()</code>只返回查询结果中正的变化率和等于0的变化率。</p>
</li>
<li>
<h3 id="non_negative_difference"><a class="header" href="#non_negative_difference">NON_NEGATIVE_DIFFERENCE()</a></h3>
<p>返回field value之间的非负差值。非负差值包括正的差值和等于0的差值。</p>
<h4 id="基本语法-18"><a class="header" href="#基本语法-18">基本语法</a></h4>
<pre><code>SELECT NON_NEGATIVE_DIFFERENCE( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>NON_NEGATIVE_DIFFERENCE(field_key)</code>返回field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(/regular_expression/)</code>返回与正则表达式匹配的每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE(*)</code>返回在measurement中每个field key对应的field value的非负差值。</p>
<p><code>NON_NEGATIVE_DIFFERENCE()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>NON_NEGATIVE_DIFFERENCE()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
<h4 id="高级语法-18"><a class="header" href="#高级语法-18">高级语法</a></h4>
<pre><code class="language-sql">SELECT NON_NEGATIVE_DIFFERENCE(&lt;function&gt;( [ * | &lt;field_key&gt; | /&lt;regular_expression&gt;/ ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果之间的非负差值。</p>
<p>`NON_NEGATIVE_DIFFERENCE()支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<p>请查看<code>DIFFERENCE()</code>文档中的示例，<code>NON_NEGATIVE_DIFFERENCE()</code>跟<code>DIFFERENCE()</code>的运行方式相同，但是<code>NON_NEGATIVE_DIFFERENCE()</code>只返回查询结果中正的差值和等于0的差值。</p>
</li>
<li>
<h3 id="pow"><a class="header" href="#pow">POW()</a></h3>
<p>返回field value的<code>x</code>次方。</p>
<h4 id="基本语法-19"><a class="header" href="#基本语法-19">基本语法</a></h4>
<pre><code>SELECT POW( [ * | &lt;field_key&gt; ], &lt;x&gt; ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>POW(field_key, x)</code>返回field key对应的field value的<code>x</code>次方。</p>
<p><code>POW(*, x)</code>返回在measurement中每个field key对应的field value的<code>x</code>次方。</p>
<p><code>POW()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>POW()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.90.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方"><a class="header" href="#计算指定field-key对应的field-value的4次方">计算指定field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 6765201
2021-09-18T00:03:00Z 12960000
2021-09-18T00:06:00Z 9150625
2021-09-18T00:09:00Z 9150625
2021-09-18T00:12:00Z 15752961
2021-09-18T00:15:00Z 29986576
2021-09-18T00:18:00Z 38950081
2021-09-18T00:21:00Z 21381376
2021-09-18T00:24:00Z 24010000
2021-09-18T00:27:00Z 38950081
2021-09-18T00:30:00Z 31640625
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的4次方"><a class="header" href="#计算measurement中每个field-key对应的field-value的4次方">计算measurement中每个field key对应的field value的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(*, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 pow_pressure pow_temperature pow_visibility
----                 ------------ --------------- --------------
2021-09-18T00:00:00Z 16777216     6765201         21381376
2021-09-18T00:03:00Z 26873856     12960000        29986576
2021-09-18T00:06:00Z 8503056      9150625         35153041
2021-09-18T00:09:00Z 18974736     9150625         9150625
2021-09-18T00:12:00Z 16777216     15752961        24010000
2021-09-18T00:15:00Z 11316496     29986576        14776336
2021-09-18T00:18:00Z 9150625      38950081        8503056
2021-09-18T00:21:00Z 16777216     21381376        11316496
2021-09-18T00:24:00Z 18974736     24010000        22667121
2021-09-18T00:27:00Z 35153041     38950081        37015056
2021-09-18T00:30:00Z 14776336     31640625        40960000
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的4次方。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的4次方并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的4次方并包含多个子句">计算指定field key对应的field value的4次方并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(&quot;temperature&quot;, 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 pow
----                 ---
2021-09-18T00:24:00Z 24010000
2021-09-18T00:21:00Z 21381376
2021-09-18T00:18:00Z 38950081
2021-09-18T00:15:00Z 29986576
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的4次方，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-19"><a class="header" href="#高级语法-19">高级语法</a></h4>
<pre><code class="language-sql">SELECT POW(&lt;function&gt;( [ * | &lt;field_key&gt; ] ), &lt;x&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的<code>x</code>次方。</p>
<p><code>POW()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的4次方"><a class="header" href="#计算平均值的4次方">计算平均值的4次方</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT POW(MEAN(&quot;temperature&quot;), 4) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 pow
----                 ---
2021-09-18T00:00:00Z 9318137.81640625
2021-09-18T00:12:00Z 25411681
2021-09-18T00:24:00Z 31081863.901234582
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的4次方。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>POW()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的4次方。</p>
</li>
<li>
<h3 id="round"><a class="header" href="#round">ROUND()</a></h3>
<p>返回指定值的四舍五入后的整数。</p>
<h4 id="基本语法-20"><a class="header" href="#基本语法-20">基本语法</a></h4>
<pre><code>SELECT ROUND( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>ROUND(field_key)</code>返回field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND(*)</code>返回在measurement中每个field key对应的field value四舍五入后的整数。</p>
<p><code>ROUND()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>ROUND()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<a href="https://gist.github.com/sanderson/8f8aec94a60b2c31a61f44a37737bfea?spm=a2c4g.11186623.2.91.41fc3ee27HC1R6">示例数据</a>中的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数">计算指定field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value四舍五入后的整数"><a class="header" href="#计算measurement中每个field-key对应的field-value四舍五入后的整数">计算measurement中每个field key对应的field value四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 round_pressure round_temperature round_visibility
----                 -------------- ----------------- ----------------
2021-09-18T00:00:00Z 64             51                68
2021-09-18T00:03:00Z 72             60                74
2021-09-18T00:06:00Z 54             55                77
2021-09-18T00:09:00Z 66             55                55
2021-09-18T00:12:00Z 64             63                70
2021-09-18T00:15:00Z 58             74                62
2021-09-18T00:18:00Z 55             79                54
2021-09-18T00:21:00Z 64             68                58
2021-09-18T00:24:00Z 66             70                69
2021-09-18T00:27:00Z 77             79                78
2021-09-18T00:30:00Z 62             75                80
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value四舍五入后的整数并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value四舍五入后的整数并包含多个子句">计算指定field key对应的field value四舍五入后的整数并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 round
----                 -----
2021-09-18T00:24:00Z 70
2021-09-18T00:21:00Z 68
2021-09-18T00:18:00Z 79
2021-09-18T00:15:00Z 74
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value四舍五入后的整数，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-20"><a class="header" href="#高级语法-20">高级语法</a></h4>
<pre><code class="language-sql">SELECT ROUND(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果四舍五入后的整数。</p>
<p><code>ROUND()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值四舍五入后的整数"><a class="header" href="#计算平均值四舍五入后的整数">计算平均值四舍五入后的整数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT ROUND(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 round
----                 -----
2021-09-18T00:00:00Z 55
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 75
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值四舍五入后的整数。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>ROUND()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值四舍五入后的整数。</p>
</li>
<li>
<h3 id="sin"><a class="header" href="#sin">SIN()</a></h3>
<p>返回field value的正弦值。</p>
<h4 id="基本语法-21"><a class="header" href="#基本语法-21">基本语法</a></h4>
<pre><code class="language-sql">SELECT SIN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SIN(field_key)</code>返回field key对应的field value的正弦值。</p>
<p><code>SIN(*)</code>返回在measurement中每个field key对应的field value的正弦值。</p>
<p><code>SIN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SIN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值"><a class="header" href="#计算指定field-key对应的field-value的正弦值">计算指定field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z 0.6702291758433747
2021-09-18T00:03:00Z -0.3048106211022167
2021-09-18T00:06:00Z -0.9997551733586199
2021-09-18T00:09:00Z -0.9997551733586199
2021-09-18T00:12:00Z 0.16735570030280694
2021-09-18T00:15:00Z -0.9851462604682474
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:27:00Z -0.4441126687075084
2021-09-18T00:30:00Z -0.38778163540943045
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正弦值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正弦值">计算measurement中每个field key对应的field value的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sin_pressure          sin_temperature      sin_visibility
----                 ------------          ---------------      --------------
2021-09-18T00:00:00Z 0.9200260381967907    0.6702291758433747   -0.8979276806892912
2021-09-18T00:03:00Z 0.25382336276203626   -0.3048106211022167  -0.9851462604682474
2021-09-18T00:06:00Z -0.5587890488516162   -0.9997551733586199  0.9995201585807312
2021-09-18T00:09:00Z -0.026551154023966794 -0.9997551733586199  -0.9997551733586199
2021-09-18T00:12:00Z 0.9200260381967907    0.16735570030280694  0.7738906815578891
2021-09-18T00:15:00Z 0.9928726480845371    -0.9851462604682474  -0.7391806966492229
2021-09-18T00:18:00Z -0.9997551733586199   -0.4441126687075084  -0.5587890488516162
2021-09-18T00:21:00Z 0.9200260381967907    -0.8979276806892912  0.9928726480845371
2021-09-18T00:24:00Z -0.026551154023966794 0.7738906815578891   -0.11478481378318722
2021-09-18T00:27:00Z 0.9995201585807312    -0.4441126687075084  0.5139784559875352
2021-09-18T00:30:00Z -0.7391806966492229   -0.38778163540943045 -0.9938886539233751
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正弦值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正弦值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正弦值并包含多个子句">计算指定field key对应的field value的正弦值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sin
----                 ---
2021-09-18T00:24:00Z 0.7738906815578891
2021-09-18T00:21:00Z -0.8979276806892912
2021-09-18T00:18:00Z -0.4441126687075084
2021-09-18T00:15:00Z -0.9851462604682474
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正弦值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-21"><a class="header" href="#高级语法-21">高级语法</a></h4>
<pre><code class="language-sql">SELECT SIN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正弦值。</p>
<p><code>SIN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值"><a class="header" href="#计算平均值的正弦值">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SIN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sin
----                 ---
2021-09-18T00:00:00Z -0.9632009590319781
2021-09-18T00:12:00Z 0.9510546532543747
2021-09-18T00:24:00Z -0.6680290772524845
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正弦值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SIN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正弦值。</p>
</li>
<li>
<h3 id="sqrt"><a class="header" href="#sqrt">SQRT()</a></h3>
<p>返回field value的平方根。</p>
<h4 id="基本语法-22"><a class="header" href="#基本语法-22">基本语法</a></h4>
<pre><code>SELECT SQRT( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>SQRT(field_key)</code>返回field key对应的field value的平方根。</p>
<p><code>SQRT(*)</code>返回在measurement中每个field key对应的field value的平方根。</p>
<p><code>SQRT()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>SQRT()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用”oceanic_station”数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根"><a class="header" href="#计算指定field-key对应的field-value的平方根">计算指定field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.14142842854285
2021-09-18T00:03:00Z 7.745966692414834
2021-09-18T00:06:00Z 7.416198487095663
2021-09-18T00:09:00Z 7.416198487095663
2021-09-18T00:12:00Z 7.937253933193772
2021-09-18T00:15:00Z 8.602325267042627
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:27:00Z 8.888194417315589
2021-09-18T00:30:00Z 8.660254037844387
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的平方根"><a class="header" href="#计算measurement中每个field-key对应的field-value的平方根">计算measurement中每个field key对应的field value的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 sqrt_pressure      sqrt_temperature  sqrt_visibility
----                 -------------      ----------------  ---------------
2021-09-18T00:00:00Z 8                  7.14142842854285  8.246211251235321
2021-09-18T00:03:00Z 8.48528137423857   7.745966692414834 8.602325267042627
2021-09-18T00:06:00Z 7.3484692283495345 7.416198487095663 8.774964387392123
2021-09-18T00:09:00Z 8.12403840463596   7.416198487095663 7.416198487095663
2021-09-18T00:12:00Z 8                  7.937253933193772 8.366600265340756
2021-09-18T00:15:00Z 7.615773105863909  8.602325267042627 7.874007874011811
2021-09-18T00:18:00Z 7.416198487095663  8.888194417315589 7.3484692283495345
2021-09-18T00:21:00Z 8                  8.246211251235321 7.615773105863909
2021-09-18T00:24:00Z 8.12403840463596   8.366600265340756 8.306623862918075
2021-09-18T00:27:00Z 8.774964387392123  8.888194417315589 8.831760866327848
2021-09-18T00:30:00Z 7.874007874011811  8.660254037844387 8.94427190999916
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的平方根。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的平方根并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的平方根并包含多个子句">计算指定field key对应的field value的平方根并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 sqrt
----                 ----
2021-09-18T00:24:00Z 8.366600265340756
2021-09-18T00:21:00Z 8.246211251235321
2021-09-18T00:18:00Z 8.888194417315589
2021-09-18T00:15:00Z 8.602325267042627
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的平方根，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-22"><a class="header" href="#高级语法-22">高级语法</a></h4>
<pre><code>SELECT SQRT(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的平方根。</p>
<p><code>SQRT()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的平方根"><a class="header" href="#计算平均值的平方根">计算平均值的平方根</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT SQRT(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 sqrt
----                 ----
2021-09-18T00:00:00Z 7.433034373659253
2021-09-18T00:12:00Z 8.426149773176359
2021-09-18T00:24:00Z 8.640987597877148
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的平方根。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>SQRT()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的平方根。</p>
</li>
<li>
<h3 id="tan"><a class="header" href="#tan">TAN()</a></h3>
<p>返回field value的正切值。</p>
<h4 id="基本语法-23"><a class="header" href="#基本语法-23">基本语法</a></h4>
<pre><code>SELECT TAN( [ * | &lt;field_key&gt; ] ) [INTO_clause] FROM_clause [WHERE_clause] [GROUP_BY_clause] [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>TAN(field_key)</code>返回field key对应的field value的正切值。</p>
<p><code>TAN(*)</code>返回在measurement中每个field key对应的field value的正切值。</p>
<p><code>TAN()</code>支持数据类型为int64和float64的field value。</p>
<p>基本语法支持group by tags的<code>GROUP BY</code>子句，但是不支持group by time。请查看高级语法章节了解如何使用<code>TAN()</code>和<code>GROUP BY time()</code>子句。</p>
<p>####示例</p>
<p>下面的示例将使用<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">&gt; SELECT &quot;temperature&quot; FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 temperature
----                 -----------
2021-09-18T00:00:00Z 51
2021-09-18T00:03:00Z 60
2021-09-18T00:06:00Z 55
2021-09-18T00:09:00Z 55
2021-09-18T00:12:00Z 63
2021-09-18T00:15:00Z 74
2021-09-18T00:18:00Z 79
2021-09-18T00:21:00Z 68
2021-09-18T00:24:00Z 70
2021-09-18T00:27:00Z 79
2021-09-18T00:30:00Z 75
</code></pre>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值"><a class="header" href="#计算指定field-key对应的field-value的正切值">计算指定field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z 0.9030861493754311
2021-09-18T00:03:00Z 0.320040389379563
2021-09-18T00:06:00Z -45.18308791052113
2021-09-18T00:09:00Z -45.18308791052113
2021-09-18T00:12:00Z 0.16974975208268753
2021-09-18T00:15:00Z -5.737022539278999
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:27:00Z 0.49567753318135577
2021-09-18T00:30:00Z -0.42070095062112434
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值。</p>
<ul>
<li>
<h4 id="计算measurement中每个field-key对应的field-value的正切值"><a class="header" href="#计算measurement中每个field-key对应的field-value的正切值">计算measurement中每个field key对应的field value的正切值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(*) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang'
name: air
time                 tan_pressure         tan_temperature      tan_visibility
----                 ------------         ---------------      --------------
2021-09-18T00:00:00Z 2.3478603091954366   0.9030861493754311   -2.040081598015946
2021-09-18T00:03:00Z -0.26241737750193517 0.320040389379563    -5.737022539278999
2021-09-18T00:06:00Z 0.6738001006480597   -45.18308791052113   -32.268575775934416
2021-09-18T00:09:00Z 0.026560517776039395 -45.18308791052113   -45.18308791052113
2021-09-18T00:12:00Z 2.3478603091954366   0.16974975208268753  1.2219599181369432
2021-09-18T00:15:00Z 8.33085685249046     -5.737022539278999   -1.0975097786622852
2021-09-18T00:18:00Z -45.18308791052113   0.49567753318135577  0.6738001006480597
2021-09-18T00:21:00Z 2.3478603091954366   -2.040081598015946   8.33085685249046
2021-09-18T00:24:00Z 0.026560517776039395 1.2219599181369432   -0.11554854579453279
2021-09-18T00:27:00Z -32.268575775934416  0.49567753318135577  -0.5991799983411151
2021-09-18T00:30:00Z -1.0975097786622852  -0.42070095062112434 9.00365494560708
</code></pre>
<p>该查询返回measurement <code>air</code>中每个存储数值的field key对应的field value的正切值。。measurement <code>air</code>中有三个数值类型的field：<code>temperature</code>、<code>pressure</code>以及<code>visibility</code>。</p>
<ul>
<li>
<h4 id="计算指定field-key对应的field-value的正切值并包含多个子句"><a class="header" href="#计算指定field-key对应的field-value的正切值并包含多个子句">计算指定field key对应的field value的正切值并包含多个子句</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' ORDER BY time DESC LIMIT 4 OFFSET 2
name: air
time                 tan
----                 ---
2021-09-18T00:24:00Z 1.2219599181369432
2021-09-18T00:21:00Z -2.040081598015946
2021-09-18T00:18:00Z 0.49567753318135577
2021-09-18T00:15:00Z -5.737022539278999
</code></pre>
<p>该查询返回measurement <code>air</code>中field key <code>temperature</code>对应的field value的正切值，它涵盖的时间范围在<code>2021-09-28T00:00:00Z</code>和<code>2021-09-18T00:30:00Z</code>之间，并且以递减的时间戳顺序返回结果，同时，该查询将返回的<code>point</code>个数限制为4，并将返回的<code>point</code>偏移两个(即前两个<code>point</code>不返回）。</p>
<h4 id="高级语法-23"><a class="header" href="#高级语法-23">高级语法</a></h4>
<pre><code class="language-sql">SELECT TAN(&lt;function&gt;( [ * | &lt;field_key&gt; ] )) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p>高级语法需要一个<code>GROUP BY time()</code>子句和一个嵌套的CnosQL函数。查询首先计算在指定的<code>GROUP BY time()</code>间隔内嵌套函数的结果，然后计算这些结果的正切值。</p>
<p><code>TAN()</code>支持以下嵌套函数：</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a></li>
<li><a href="#mean"><code>MEAN()</code></a></li>
<li><a href="#median"><code>MEDIAN()</code></a></li>
<li><a href="#mode"><code>MODE()</code></a></li>
<li><a href="#sum"><code>SUM()</code></a></li>
<li><a href="#first"><code>FIRST()</code></a></li>
<li><a href="#last"><code>LAST()</code></a></li>
<li><a href="#min"><code>MIN()</code></a></li>
<li><a href="#max"><code>MAX()</code></a></li>
<li><a href="#percentile"><code>PERCENTILE()</code></a></li>
</ul>
<p>####示例</p>
<ul>
<li>
<h4 id="计算平均值的正弦值-1"><a class="header" href="#计算平均值的正弦值-1">计算平均值的正弦值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT TAN(MEAN(&quot;temperature&quot;)) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 tan
----                 ---
2021-09-18T00:00:00Z -3.583573177439047
2021-09-18T00:12:00Z -3.0776204031933605
2021-09-18T00:24:00Z -0.8977254452596822
</code></pre>
<p>该查询返回每12分钟的时间间隔对应的<code>temperature</code>的平均值的正切值。</p>
<p>为了得到这些结果，CnosDB首先计算每12分钟的时间间隔对应的<code>temperature</code>的平均值。这一步跟同时使用<code>MEAN()</code>函数和<code>GROUP BY time()</code>子句、但不使用<code>TAN()</code>的情形一样：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:30:00Z' AND &quot;station&quot; = 'LianYunGang' GROUP BY time(12m)
name: air
time                 mean
----                 ----
2021-09-18T00:00:00Z 55.25
2021-09-18T00:12:00Z 71
2021-09-18T00:24:00Z 74.66666666666667
</code></pre>
<p>然后，CnosDB计算这些平均值的正切值。</p>
</li>
</ul>
<h3 id="预测函数"><a class="header" href="#预测函数">预测函数</a></h3>
<ul>
<li>
<h3 id="holt_winters"><a class="header" href="#holt_winters">HOLT_WINTERS()</a></h3>
<ul>
<li>
<p>使用<a href="https://www.otexts.org/fpp/7/5?spm=a2c4g.11186623.2.92.41fc3ee27HC1R6">Holt-Winters</a>的季节性方法返回N个预测的field value。</p>
<p><code>HOLT_WINTERS()</code>可用于：</p>
<ul>
<li>预测时间什么时候会超过给定的阈值</li>
<li>将预测值与实际值进行比较，检测数据中的异常</li>
</ul>
</li>
</ul>
<h4 id="语法-18"><a class="header" href="#语法-18">语法</a></h4>
<pre><code>SELECT HOLT_WINTERS[_WITH-FIT](&lt;function&gt;(&lt;field_key&gt;),&lt;N&gt;,&lt;S&gt;) [INTO_clause] FROM_clause [WHERE_clause] GROUP_BY_clause [ORDER_BY_clause] [LIMIT_clause] [OFFSET_clause] [SLIMIT_clause] [SOFFSET_clause]
</code></pre>
<p><code>HOLT_WINTERS(function(field_key),N,S)</code>返回field key对应的<code>N</code>个季节性调整的预测field value。</p>
<p><code>N</code>个预测值出现的时间间隔跟group by time时间间隔相同。如果您的<code>GROUP BY time()</code>时间间隔是<code>6m</code>并且<code>N</code>等于<code>3</code>，那么您将会得到3个时间间隔为6分钟的预测值。</p>
<p><code>S</code>是一个季节性模式参数，并且根据<code>GROUP BY time()</code>时间间隔限定一个季节性模式的长度。如果您的<code>GROUP BY time()</code>时间间隔是<code>2m</code>并且<code>S</code>等于<code>3</code>，那么这个季节性模式每六分钟出现一次，也就是每三个<code>point</code>。如果您不希望季节性调整您的预测值，请将<code>S</code>设置为<code>0</code>或<code>1</code>。</p>
<p><code>HOLT_WINTERS_WITH_FIT(function(field_key),N,S)</code>除了返回field key对应的<code>N</code>个季节性调整的预测field value，还返回拟合值。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>处理以相同的时间间隔出现的数据；嵌套的CnosQL函数和<code>GROUP BY time()</code>子句确保Holt-Winters函数能够对常规数据进行操作。</p>
<p><code>HOLT_WINTERS()</code>和<code>HOLT_WINTERS_WITH_FIT()</code>支持数据类型为int64和float64的field value。</p>
<h4 id="示例-39"><a class="header" href="#示例-39">示例</a></h4>
<ul>
<li>
<h4 id="预测指定field-key的field-value"><a class="header" href="#预测指定field-key的field-value">预测指定field key的field value</a></h4>
</li>
<li>
<h4 id="原始数据"><a class="header" href="#原始数据">原始数据</a></h4>
</li>
</ul>
<p>该示例重点关注<code>oceanic_station</code>数据集的如下数据：</p>
<pre><code class="language-sql">SELECT &quot;temperature&quot; FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00'
</code></pre>
<ul>
<li>
<h4 id="步骤一匹配原始数据的趋势"><a class="header" href="#步骤一匹配原始数据的趋势">步骤一：匹配原始数据的趋势</a></h4>
</li>
</ul>
<p>编写一个<code>GROUP BY time()</code>查询，使得它匹配原始<code>temperature</code>数据的总体趋势。这里，我们使用了<code>FIRST()</code>函数：</p>
<pre><code class="language-sql">SELECT FIRST(&quot;temperature&quot;) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' and time &gt;= '2021-09-12 12:12:00' and time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>GROUP BY time()</code>子句中，第一个参数(<code>379m</code>)匹配<code>temperature</code>数据中每个波峰和波谷之间发生的时间长度，第二个参数(<code>348m</code>)是一个偏移间隔，它通过改变CnosDB的默认<code>GROUP BY time()</code>边界来匹配原始数据的时间范围。</p>
<ul>
<li>
<h4 id="步骤二确定季节性模式"><a class="header" href="#步骤二确定季节性模式">步骤二：确定季节性模式</a></h4>
</li>
</ul>
<p>使用步骤一中查询的信息确定数据中的季节性模式。</p>
<ul>
<li>
<h4 id="步骤三应用holt_winters函数"><a class="header" href="#步骤三应用holt_winters函数">步骤三：应用<code>HOLT_WINTERS()</code>函数</a></h4>
</li>
</ul>
<p>在查询中加入Holt-Winters函数。这里，我们使用<code>HOLT_WINTERS_WITH_FIT()</code>来查看拟合值和预测值：</p>
<pre><code class="language-sql">SELECT HOLT_WINTERS_WITH_FIT(FIRST(&quot;temperature&quot;),10,4) FROM &quot;oceanic_station&quot;.&quot;autogen&quot;.&quot;air&quot; WHERE &quot;station&quot;='LianYunGang' AND time &gt;= '2021-09-12 12:12:00' AND time &lt;= '2021-09-28 04:00:00' GROUP BY time(379m,348m)
</code></pre>
<p>在<code>HOLT_WINTERS_WITH_FIT()</code>函数中，第一个参数(<code>10</code>)请求10个预测的field value。每个预测的<code>point</code>相距<code>379m</code>，与<code>GROUP BY time()</code>子句中的第一个参数相同。<code>HOLT_WINTERS_WITH_FIT()</code>函数中的第二个参数(<code>4</code>)是我们在上一步骤中确定的季节性模式。</p>
<h4 id="holt_winters的常见问题"><a class="header" href="#holt_winters的常见问题"><code>HOLT_WINTERS()</code>的常见问题</a></h4>
<ul>
<li>
<h4 id="holt_winters和收到的point少于n个"><a class="header" href="#holt_winters和收到的point少于n个"><code>HOLT_WINTERS()</code>和收到的<code>point</code>少于”N”个</a></h4>
</li>
</ul>
<p>在某些情况下，用户可能会收到比参数<code>N</code>请求的更少的预测<code>point</code>。当数学计算不稳定和不能预测更多<code>point</code>时，这种情况就会发生。这意味着该数据集不适合使用<code>HOLT_WINTERS()</code>，或者，季节性调整参数是无效的并且是算法混乱。</p>
</li>
</ul>
<h3 id="分析函数"><a class="header" href="#分析函数">分析函数</a></h3>
<p>下面技术分析的函数将广泛使用的算法应用在您的数据中。虽然这些函数主要应用在金融和投资领域，但是它们也适用于其它行业和用例。</p>
<p><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></p>
<p><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></p>
<p><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></p>
<p><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></p>
<p><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></p>
<p><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></p>
<ul>
<li>
<h3 id="参数"><a class="header" href="#参数">参数</a></h3>
<p>除了field key，技术分析函数还接受以下参数：</p>
<p><code>PERIOD</code></p>
<p><strong>必需，整数，min=1</strong></p>
<p>算法的样本大小。这基本上是对算法的输出有显著影响的历史样本的数量。例如，<code>2</code>表示当前的<code>point</code>和前一个<code>point</code>。算法使用指数衰减率来决定历史<code>point</code>的权重，通常称为<code>alpha(α)</code>。参数<code>PERIOD</code>控制衰减率。</p>
<blockquote>
<p>请注意，历史<code>point</code>仍然可以产生影响。</p>
</blockquote>
<h4 id="hold_period"><a class="header" href="#hold_period">HOLD_PERIOD</a></h4>
<p><strong>整数，min=-1</strong></p>
<p>算法需要多少个样本才会开始发送结果。默认值<code>-1</code>表示该参数的值基于算法、<code>PERIOD</code>和<code>WARMUP_TYPE</code>，但是这是一个可以使算法发送有意义的结果的值。</p>
<p><strong>默认的Hold Periods：</strong></p>
<p>对于大多数提供的技术分析，<code>HOLD_PERIOD</code>的默认值由您使用的技术分析算法和<code>WARMUP_TYPE</code>决定。</p>
</li>
</ul>
<table><thead><tr><th>算法 \ Warmup Type</th><th>simple</th><th>exponential</th><th style="text-align: center">none</th></tr></thead><tbody>
<tr><td><a href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE</a></td><td>PERIOD - 1</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 2</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE</a></td><td>( PERIOD - 1 ) * 3</td><td>PERIOD - 1</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE</a></td><td>( PERIOD - 1 ) * 3 + 1</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#relative_strength_index">RELATIVE_STRENGTH_INDEX</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center"><span style="opacity:.35">n/a</span></td></tr>
<tr><td><a href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR</a></td><td>PERIOD</td><td>PERIOD</td><td style="text-align: center">PERIOD - 1</td></tr>
</tbody></table>
<p><em><strong>Kaufman算法默认的Hold Periods：</strong></em></p>
<table><thead><tr><th>算法</th><th>默认的Hold Period</th></tr></thead><tbody>
<tr><td><a href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></td><td>PERIOD</td></tr>
<tr><td><a href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></td><td>PERIOD</td></tr>
</tbody></table>
<h4 id="warmup_type"><a class="header" href="#warmup_type">WARMUP_TYPE</a></h4>
<p><strong>默认=”exponential”</strong></p>
<p>这个参数控制算法如何为第一个<code>PERIOD</code>样本初始化自身，它本质上是具有不完整样本集的持续时间。</p>
<p><code>simple</code>
第一个<code>PERIOD</code>样本的简单移动平均值(simple moving average，SMA)。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.106.41fc3ee27HC1R6">ta-lib</a>使用的方法。</p>
<p><code>exponential</code>
具有缩放alpha(α)的指数移动平均值(exponential moving average，EMA)。基本上是这样使用EMA：<code>PERIOD=1</code>用于第一个点，<code>PERIOD=2</code>用于第二个点，以此类推，直至算法已经消耗了<code>PERIOD</code>个<code>point</code>。由于算法一开始就使用了EMA，当使用此方法并且没有指定<code>HOLD_PERIOD</code>的值或<code>HOLD_PERIOD</code>的值为<code>-1</code>时，算法可能会在比<code>simple</code>小得多的样本大小的情况下开始发送<code>point</code>。</p>
<p><code>none</code>
算法不执行任何的平滑操作。这是<a href="https://www.ta-lib.org/?spm=a2c4g.11186623.2.107.41fc3ee27HC1R6">ta-lib</a>使用的方法。当使用此方法并且没有指定<code>HOLD_PERIOD</code>时，<code>HOLD_PERIOD</code>的默认值是<code>PERIOD - 1</code>。</p>
<blockquote>
<p>类型<code>none</code>仅适用于<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数。</p>
</blockquote>
<ul>
<li>
<h3 id="chande_momentum_oscillator"><a class="header" href="#chande_momentum_oscillator">CHANDE_MOMENTUM_OSCILLATOR()</a></h3>
<p>Chande Momentum Oscillator (CMO)是由Tushar Chande开发的一个技术动量指标。通过计算所有最近较高<code>point</code>的总和与所有最近较低<code>point</code>的总和的差值，然后将结果除以给定时间范围内的所有数据变动的总和来创建CMO指标。将结果乘以100可以得到一个从-100到+100的范围。
<sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.fidelity.com/learning-center/trading-investing/technical-analysis/technical-indicator-guide/cmo" target="\_blank">Source</a></p>
<h4 id="基本语法-24"><a class="header" href="#基本语法-24">基本语法</a></h4>
<pre><code>CHANDE_MOMENTUM_OSCILLATOR([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;, [warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup-type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 2)</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(field_key, 10, 9, 'none')</code>返回使用CMO算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>none</code>。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用CMO算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>CHANDE_MOMENTUM_OSCILLATOR()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(/regular_expression/, 2)</code>返回使用CMO算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR(*, 2)</code>返回使用CMO算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>CHANDE_MOMENTUM_OSCILLATOR()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="exponential_moving_average"><a class="header" href="#exponential_moving_average">EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>指数移动平均值 (Exponential Moving Average，EMA)类似于简单移动平均值，不同的是，指数移动平均值对最新数据给予更多的权重，它也被称为”指数加权移动平均值”。与简单移动平均值相比，这种类型的移动平均值对最近数据的变化反应更快。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/e/ema.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-25"><a class="header" href="#基本语法-25">基本语法</a></h4>
<pre><code>EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用参数:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用EMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用EMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用EMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用EMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>EXPONENTIAL_MOVING_AVERAGE()</code> 支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="double_exponential_moving_average"><a class="header" href="#double_exponential_moving_average">DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>双重指数移动平均值 (Double Exponential Moving Average，DEMA)通过增加最近数据的权重，尝试消除与移动平均值相关的固有滞后。该名字似乎表明这是通过双重指数平滑来实现的，然而事实并非如此，它表示的是将EMA的值翻倍。为了使它与实际数据保持一致，也为了消除滞后，从之前两倍EMA的值中把”EMA of EMA”的值减去，公式为：DEMA = 2 * EMA - EMA(EMA)。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://en.wikipedia.org/wiki/Double_exponential_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-26"><a class="header" href="#基本语法-26">基本语法</a></h4>
<pre><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用DEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用DEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用DEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用DEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>DOUBLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="kaufmans_efficiency_ratio"><a class="header" href="#kaufmans_efficiency_ratio">KAUFMANS_EFFICIENCY_RATIO()</a></h3>
<p>Kaufman效率比 (Kaufman’s Efficiency Ration)，或简称为效率比 (Efficiency Ratio，ER)，它的计算方法是：将一段时间内的数据变化除以实现该变化所发生的数据变动的绝对值的总和。得出的比率在0和1之间，比率越高，表示市场越有效率或越有趋势。</p>
</li>
</ul>
<p>ER跟Chande Momentum Oscillator (CMO)非常类似。不同的是，CMO将市场方向考虑在内，但是如果您将CMO的绝对值除以100，就可以得到ER。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://etfhq.com/blog/2011/02/07/kaufmans-efficiency-ratio/" target="\_blank">Source</a></p>
<h4 id="基本语法-27"><a class="header" href="#基本语法-27">基本语法</a></h4>
<pre><code class="language-sql">KAUFMANS_EFFICIENCY_RATIO([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 2)</code>返回使用效率指数(Efficiency Index)算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(field_key, 10, 10)</code>返回使用效率指数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用效率指数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_EFFICIENCY_RATIO()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_EFFICIENCY_RATIO(/regular_expression/, 2)</code>返回使用效率指数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO(*, 2)</code>返回使用效率指数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_EFFICIENCY_RATIO()</code>支持数据类型为int64和float64的field value。</p>
<ul>
<li>
<h3 id="kaufmans_adaptive_moving_average"><a class="header" href="#kaufmans_adaptive_moving_average">KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</a></h3>
<p>Kaufman自适应移动平均值 (Kaufman’s Adaptive Moving Average，KAMA)，是一个用于计算样本噪音或波动率的移动平均值。当数据波动相对较小并且噪音较低时，KAMA会密切关注<code>point</code>。当数据波动较大时，KAMA会进行调整，平滑噪音。该趋势跟踪指标可用于识别总体趋势、时间转折点和过滤价格变动。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="http://stockcharts.com/school/doku.php?id=chart_school:technical_indicators:kaufman_s_adaptive_moving_average" target="\_blank">Source</a></p>
<h4 id="基本语法-28"><a class="header" href="#基本语法-28">基本语法</a></h4>
<pre><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period&gt;])
</code></pre>
<p><strong>可用的参数：</strong>
<a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 2)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(field_key, 10, 10)</code>返回使用KAMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用KAMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用KAMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE(*, 2)</code>返回使用KAMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period。</p>
<p><code>KAUFMANS_ADAPTIVE_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_moving_average"><a class="header" href="#triple_exponential_moving_average">TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</a></h3>
<p>三重指数移动平均值 (Triple Exponential Moving Average，TEMA)，旨在过滤常规移动平均值的波动。该名字似乎表明这是通过三重指数平滑来实现的，然而事实并非如此，它实际上是包含指数移动平均值、双重指数移动平均值和三重指数移动平均值的复合函数。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/t/triple-exponential-moving-average.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-29"><a class="header" href="#基本语法-29">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 2)</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(field_key, 10, 9, 'exponential')</code>返回使用TEMA算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为9，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用TEMA算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(/regular_expression/, 2)</code>返回使用TEMA算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE(*, 2)</code>返回使用TEMA算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_MOVING_AVERAGE()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="triple_exponential_derivative"><a class="header" href="#triple_exponential_derivative">TRIPLE_EXPONENTIAL_DERIVATIVE()</a></h3>
<p>三重指数导数指标 (Triple Exponential Derivative Indicator)，通常称为”TRIX”，是一种用于识别超卖和超买市场的振荡器，也可用作动量指标。TRIX计算一段时间内输入数据的对数的三重指数移动平均值。从当前的值中减去之前的值，这可以防止指标考虑比规定期间短的周期。</p>
</li>
</ul>
<p>跟很多振荡器一样，TRIX围绕着零线震荡。当它用作振荡器时，正数表示炒买超买市场，而负数表示超卖市场。当它用作动量指标时，正数表示动量在增加，而负数表示动量在减少。很多分析师认为，当TRIX超过零线时，它会给出买入信号，当低于零线时，它会给出卖出信号。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/articles/technical/02/092402.asp " target="\_blank">Source</a></p>
<h4 id="基本语法-30"><a class="header" href="#基本语法-30">基本语法</a></h4>
<pre><code>TRIPLE_EXPONENTIAL_DERIVATIVE([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>可用的参数：</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 2)</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(field_key, 10, 10, 'exponential')</code>返回使用三重指数导数算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用三重指数导数算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(/regular_expression/, 2)</code>返回使用三重指数导数算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE(*, 2)</code>返回使用三重指数导数算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>TRIPLE_EXPONENTIAL_DERIVATIVE()</code>支持数据类型为int64和float64的field value。</p>
<ul>
<li>
<h3 id="relative_strength_index"><a class="header" href="#relative_strength_index">RELATIVE_STRENGTH_INDEX()</a></h3>
<p>相对强弱指数 (Relative Strength Index，RSI)是一个动量指标，用于比较在指定时间段内最近数据增大和减小的幅度，以便measurement数据变动的速度和变化。</p>
<p><sup style="line-height:0; font-size:.7rem; font-style:italic; font-weight:normal;"><a href="https://www.investopedia.com/terms/r/rsi.asp" target="\_blank">Source</a></p>
<h4 id="基本语法-31"><a class="header" href="#基本语法-31">基本语法</a></h4>
<pre><code>RELATIVE_STRENGTH_INDEX([ * | &lt;field_key&gt; | /regular_expression/ ], &lt;period&gt;[, &lt;hold_period)[, &lt;warmup_type]])
</code></pre>
<p><strong>Available Arguments:</strong></p>
<p><a href="#period">period</a>
<a href="#warmup_type">hold_period</a> （可选项）
<a href="#warmup_type">warmup_type</a> （可选项）</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 2)</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(field_key, 10, 10, 'exponential')</code>返回使用RSI算法处理field key对应的field value后的结果，该算法中，period设为10，hold period设为10，warmup type设为<code>exponential</code>。</p>
<p><code>RELATIVE_STRENGTH_INDEX(MEAN(&lt;field_key&gt;), 2) ... GROUP BY time(1d)</code>返回使用RSI算法处理field key对应的field value平均值后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<blockquote>
<p>**注意：**当使用<code>GROUP BY</code>子句将数据进行聚合时，您必须在<code>RELATIVE_STRENGTH_INDEX()</code>函数中调用聚合函数。</p>
</blockquote>
<p><code>RELATIVE_STRENGTH_INDEX(/regular_expression/, 2)</code>返回使用RSI算法处理与正则表达式匹配的每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX(*, 2)</code>返回使用RSI算法处理measurement中每个field key对应的field value后的结果，该算法中，period设为2，使用默认的hold period和warmup type。</p>
<p><code>RELATIVE_STRENGTH_INDEX()</code>支持数据类型为int64和float64的field value。</p>
</li>
<li>
<h3 id="其它"><a class="header" href="#其它">其它</a></h3>
<h4 id="示例数据"><a class="header" href="#示例数据">示例数据</a></h4>
<p>本文档使用的数据可在<a href="oceanic_station.txt">示例数据</a>中下载。</p>
<h4 id="函数的通用语法"><a class="header" href="#函数的通用语法">函数的通用语法</a></h4>
<ul>
<li>
<h4 id="在select中指定多个函数"><a class="header" href="#在select中指定多个函数">在<code>SELECT</code>中指定多个函数</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;(),&lt;function&gt;() FROM_clause [...]
</code></pre>
<p>使用逗号(<code>,</code>)将<code>SELECT</code>语句中的多个函数分开。该语法适用于除<code>TOP()</code>和<code>BOTTOM()</code>之外的所有CnosQL函数。<code>SELECT</code>子句不支持<code>TOP()</code>或<code>BOTTOM()</code>和其它函数同时使用。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的平均值和平均数"><a class="header" href="#在一个查询中计算field-value的平均值和平均数">在一个查询中计算field value的平均值和平均数</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;),MEDIAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 mean              median
----                 ----              ------
1970-01-01T00:00:00Z 64.94933267424616 65
</code></pre>
<p>该查询返回<code>temperature</code>的平均值和平均数。</p>
<ul>
<li>
<h4 id="在一个查询中计算两个field的mode"><a class="header" href="#在一个查询中计算两个field的mode">在一个查询中计算两个field的mode</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MODE(&quot;temperature&quot;),MODE(&quot;pressure&quot;) FROM &quot;air&quot;
name: air
time                 mode mode_1
----                 ---- ------
1970-01-01T00:00:00Z 53
</code></pre>
<p>该查询返回<code>temperature</code>中出现频率最高的field value和<code>pressure</code>中出现频率最高的field value。<code>temperature</code>对应的值在列<code>mode</code>中，<code>pressure</code>对应的值在列<code>mode_1</code>中。因为系统不能返回多个具有相同名字的列，所以它将第二个列<code>mode</code>重命名为<code>mode_1</code>。</p>
<ul>
<li>
<h4 id="在一个查询中计算field-value的最小值和最大值"><a class="header" href="#在一个查询中计算field-value的最小值和最大值">在一个查询中计算field value的最小值和最大值</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MIN(&quot;temperature&quot;), MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 min max
----                 --- ---
1970-01-01T00:00:00Z 50  80
</code></pre>
<p>该查询返回<code>temperature</code>的最小值和最大值。</p>
<p>请注意，该查询返回<code>1970-01-01T00:00:00Z</code>作为时间戳，这是CnosDB的空时间戳。<code>MIN()</code>和<code>MAX()</code>是selector函数；当selector函数是<code>SELECT</code>子句中的唯一函数时，它返回一个特定的时间戳。因为<code>MIN()</code>和<code>MAX()</code>返回两个不同的时间戳（见下面的例子），所以系统会用空时间戳覆盖这些时间戳。</p>
<pre><code class="language-sql">&gt;  SELECT MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  min
----                  ---
2021-08-31T16:18:00Z  50    &lt;--- Timestamp 1

&gt;  SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2021-08-31T18:03:00Z  80    &lt;--- Timestamp 2
</code></pre>
<h4 id="重命名查询结果字段"><a class="header" href="#重命名查询结果字段">重命名查询结果字段</a></h4>
<ul>
<li>
<h4 id="语法-19"><a class="header" href="#语法-19">语法</a></h4>
</li>
</ul>
<pre><code>SELECT &lt;function&gt;() AS &lt;field_key&gt; [...]
</code></pre>
<p>默认情况下，函数返回的结果在与函数名称匹配的field key下面。使用<code>AS</code>子句可以指定输出的field key的名字。</p>
<p>####示例</p>
<ul>
<li>
<h4 id="指定输出的field-key"><a class="header" href="#指定输出的field-key">指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) AS &quot;dream_name&quot; FROM &quot;air&quot;
name: air
time                  dream_name
----                  ----------
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<p>该查询返回<code>temperature</code>的平均值，并将输出的field key重命名为<code>dream_name</code>。如果没有<code>AS</code>子句，那么查询会返回<code>mean</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEAN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  mean
----                  ----
1970-01-01T00:00:00Z 64.94933267424616
</code></pre>
<ul>
<li>
<h4 id="为多个函数指定输出的field-key"><a class="header" href="#为多个函数指定输出的field-key">为多个函数指定输出的field key</a></h4>
</li>
</ul>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;) AS &quot;med_wat&quot;,MODE(&quot;temperature&quot;) AS &quot;mode_wat&quot; FROM &quot;air&quot;
name: air
time                 med_wat mode_wat
----                 ------- --------
1970-01-01T00:00:00Z 65      53
</code></pre>
<p>该查询返回<code>temperature</code>的平均数和<code>temperature</code>中出现频率最高的field value，并将输出的field key分别重命名为<code>med_wat</code>和<code>mode_wat</code>。如果没有<code>AS</code>子句，那么查询会返回<code>median</code>和<code>mode</code>作为输出的field key：</p>
<pre><code class="language-sql">&gt; SELECT MEDIAN(&quot;temperature&quot;),MODE(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 median mode
----                 ------ ----
1970-01-01T00:00:00Z 65     53
</code></pre>
<h4 id="改变不含数据的时间间隔的返回值"><a class="header" href="#改变不含数据的时间间隔的返回值">改变不含数据的时间间隔的返回值</a></h4>
<p>默认情况下，包含CnosQL函数和<code>GROUP BY time()</code>子句的查询对不包含数据的时间间隔返回空值。在<code>GROUP BY</code>子句后面加上<code>fill()</code>可以更改这个值。关于<code>fill()</code>的详细讨论，请查看数据探索。</p>
<h4 id="函数的常见问题"><a class="header" href="#函数的常见问题">函数的常见问题</a></h4>
<p>以下部分描述了所有函数、聚合函数和选择函数的常见混淆来源，有关单个功能的常见问题，请参见以下特定文档：</p>
<ul>
<li><a href="#common-issues-with-distinct">DISTINCT()</a></li>
<li><a href="#common-issues-with-bottom">BOTTOM()</a></li>
<li><a href="#common-issues-with-percentile">PERCENTILE()</a></li>
<li><a href="#common-issues-with-sample">SAMPLE()</a></li>
<li><a href="#common-issues-with-top">TOP()</a></li>
<li><a href="#common-issues-with-elapsed">ELAPSED()</a></li>
<li><a href="#common-issues-with-holt-winters">HOLT_WINTERS()</a></li>
</ul>
<h4 id="所有函数"><a class="header" href="#所有函数">所有函数</a></h4>
<ul>
<li>
<h4 id="嵌套函数"><a class="header" href="#嵌套函数">嵌套函数</a></h4>
</li>
</ul>
</li>
</ul>
<p>某些CnosQL 函数支持 <a href="/cnosdb/v1.8/query_language/explore-data/#select-clause"><code>SELECT</code> clause</a>中嵌套:</p>
<ul>
<li><a href="#count"><code>COUNT()</code></a> with <a href="#distinct"><code>DISTINCT()</code></a></li>
<li><a href="#cumulative-sum"><code>CUMULATIVE_SUM()</code></a></li>
<li><a href="#derivative"><code>DERIVATIVE()</code></a></li>
<li><a href="#difference"><code>DIFFERENCE()</code></a></li>
<li><a href="#elapsed"><code>ELAPSED()</code></a></li>
<li><a href="#moving-average"><code>MOVING_AVERAGE()</code></a></li>
<li><a href="#non-negative-derivative"><code>NON_NEGATIVE_DERIVATIVE()</code></a></li>
<li><a href="#holt-winters"><code>HOLT_WINTERS()</code></a> and <a href="#holt-winters"><code>HOLT_WINTERS_WITH_FIT()</code></a></li>
</ul>
<ul>
<li>
<h4 id="查询在now之后的时间范围"><a class="header" href="#查询在now之后的时间范围">查询在now()之后的时间范围</a></h4>
</li>
</ul>
<p>大多数<code>SELECT</code>语句的默认时间范围在<code>1677-09-21 00:12:43.145224194</code> UTC和<code>2262-04-11T23:47:16.854775806Z</code> UTC之间。对于包含CnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询，默认的时间范围在<code>1677-09-21 00:12:43.145224194</code>和<code>now()</code>之间。</p>
<p>如果要查询时间戳发生在<code>now()</code>之后的数据，那么包含CnosQL函数和<code>GROUP BY time()</code>子句的<code>SELECT</code>查询必须在<code>WHERE</code>子句中提供一个时间上限。请查看常见问题。</p>
<h4 id="聚合函数-1"><a class="header" href="#聚合函数-1">聚合函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳"><a class="header" href="#理解返回的时间戳">理解返回的时间戳</a></h4>
</li>
</ul>
<p>子句中具有 <a href="#aggregations">聚合函数</a> 且 <code>WHERE</code>没有时间范围的查询讲返回 epoch 0 (<code>1970-01-01T00:00:00Z</code>) 作为时间戳.
CnosDB 使用 epoch 0 作为等效的空时间戳.
带有聚合函数的查询，如果 <code>WHERE</code> 子句中包含时间范围，将返回时间下限作为时间戳.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用聚合函数并且没有指定时间范围"><a class="header" href="#使用聚合函数并且没有指定时间范围">使用聚合函数并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 sum
----                 ---
1970-01-01T00:00:00Z 1839495
</code></pre>
</li>
</ul>
<p>该查询将CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为时间戳返回。<code>SUM()</code>将多个<code>point</code>聚合，没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围"><a class="header" href="#使用聚合函数并且指定时间范围">使用聚合函数并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 134766
</code></pre>
</li>
</ul>
<p>该查询将时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为时间戳返回。</p>
<ul>
<li>
<h4 id="使用聚合函数并且指定时间范围和使用group-by-time子句"><a class="header" href="#使用聚合函数并且指定时间范围和使用group-by-time子句">使用聚合函数并且指定时间范围和使用GROUP BY time()子句</a></h4>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-28T00:28:00Z' GROUP BY time(12m)
name: air
time                 sum
----                 ---
2021-09-28T00:00:00Z 490
2021-09-28T00:12:00Z 524
2021-09-28T00:24:00Z 263
</code></pre>
</li>
</ul>
<p>该查询将每个<code>GROUP BY time()</code>间隔的时间下界作为时间戳返回。</p>
<ul>
<li>
<h4 id="将聚合函数和不聚合的数据混合使用"><a class="header" href="#将聚合函数和不聚合的数据混合使用">将聚合函数和不聚合的数据混合使用</a></h4>
</li>
</ul>
<p>聚合函数不支持在<code>SELECT</code>语句中指定不使用聚合函数的单独的field key或tag key。聚合函数返回一个计算结果，对于没有被聚合的field或tag，没有明显的单个值可以返回。当<code>SELECT</code>语句同时包含聚合函数和单独的field key或tag key时，会返回错误：</p>
<pre><code class="language-sql">&gt; SELECT SUM(&quot;temperature&quot;),&quot;station&quot; FROM &quot;air&quot;
ERR: mixing aggregate and non-aggregate queries is not supported
</code></pre>
<ul>
<li>
<h4 id="得到略有不同的结果"><a class="header" href="#得到略有不同的结果">得到略有不同的结果</a></h4>
</li>
</ul>
<p>对于某些聚合函数，在相同的<code>point</code>（数据类型为float64)上执行相同的函数，可能会产生稍微不同的结果。在应用聚合函数之间，CnosDB不会将<code>point</code>进行排序；该行为可能会导致查询结果中出现小小的差异。</p>
<h4 id="selector函数"><a class="header" href="#selector函数">Selector函数</a></h4>
<ul>
<li>
<h4 id="理解返回的时间戳-1"><a class="header" href="#理解返回的时间戳-1">理解返回的时间戳</a></h4>
</li>
</ul>
<p>selector函数返回的时间戳依赖查询中函数的数量和查询中的其它子句：</p>
<p>带有单个选择器函数，单个 field key 参数和无 <code>GROUP BY time()</code> 的查询返回原始数据中出现的point时间戳.
具有单个 selector 函数, 多个 <code>field key</code> 参数的查询, <code>GROUP BY time()</code> 返回原始数据中出现的point 时间戳，或与空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>)等价的CnosDB.</p>
<p><code>WHERE</code>子句中有多个函数且没有时间范围的查询将返回相当于空时间戳 (epoch 0: <code>1970-01-01T00:00:00Z</code>).
在 <code>WHERE</code>子句中包含多个函数和时间范围的查询将时间下限作为时间戳返回</p>
<p>带有 selector 函数和  <code>GROUP BY time()</code> 子句的查询返回每个 <code>GROUP BY time()</code>间隔的时间下限.</p>
<p>####示例</p>
<ul>
<li>
<h4 id="使用单个selector函数和单个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和单个field-key并且没有指定时间范围">使用单个selector函数和单个field key，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                  max
----                  ---
2020-08-29T07:24:00Z  9.964

&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
name: air
time                 max
----                 ---
2021-09-28T01:57:00Z 80
</code></pre>
</li>
</ul>
<p>该查询返回原始数据中具有<code>最大</code>值的<code>point</code>的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数和多个field-key并且没有指定时间范围"><a class="header" href="#使用单个selector函数和多个field-key并且没有指定时间范围">使用单个selector函数和多个field key，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT FIRST(*) FROM &quot;air&quot;
name: air
time                 first_pressure first_temperature first_visibility
----                 -------------- ----------------- ----------------
1970-01-01T00:00:00Z 78             79                71

&gt; SELECT MAX(*) FROM &quot;air&quot;
name: air
time                 max_pressure max_temperature max_visibility
----                 ------------ --------------- --------------
1970-01-01T00:00:00Z 80           80              80

</code></pre>
</li>
</ul>
<p>第一个查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>FIRST(*)</code>返回两个时间戳（对应measurement <code>air</code>中的每个field key），所以系统使用空时间戳覆盖这两个时间戳。</p>
<p>第二个查询返回原始数据中具有最大值的<code>point</code>的时间戳。因为<code>MAX(*)</code>只返回一个时间戳(measurement <code>air</code>中只有一个数值类型的field)，所以系统不会覆盖原始时间戳。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且没有指定时间范围"><a class="header" href="#使用多个selector函数并且没有指定时间范围">使用多个selector函数，并且没有指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot;
name: air
time                 max min
----                 --- ---
1970-01-01T00:00:00Z 80  50 
</code></pre>
</li>
</ul>
<p>该查询返回CnosDB的空时间戳(epoch 0: <code>1970-01-01T00:00:00Z</code>)作为查询结果中的时间戳。因为<code>MAX()</code>和<code>MIN()</code>函数返回不同的时间戳，所以系统没有单个时间戳可以返回。</p>
<ul>
<li>
<h4 id="使用多个selector函数并且指定时间范围"><a class="header" href="#使用多个selector函数并且指定时间范围">使用多个selector函数，并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;),MIN(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z'
  name: air
  time                 max min
  ----                 --- ---
  2021-09-28T00:00:00Z 80  50
</code></pre>
</li>
</ul>
<p>该查询返回时间范围的下界(<code>WHERE time &gt;= '2021-09-18T00:00:00Z'</code>)作为查询结果中的时间戳。</p>
<ul>
<li>
<h4 id="使用单个selector函数并且指定时间范围"><a class="header" href="#使用单个selector函数并且指定时间范围">使用单个selector函数，并且指定时间范围</a></h4>
<pre><code class="language-sql">&gt; SELECT MAX(&quot;temperature&quot;) FROM &quot;air&quot; WHERE time &gt;= '2021-09-18T00:00:00Z' AND time &lt;= '2021-09-18T00:18:00Z' GROUP BY time(12m)
name: air
time                 max
----                 ---
2021-09-18T00:00:00Z 80
2021-09-18T00:12:00Z 797
</code></pre>
</li>
</ul>
<p>该查询返回每个<code>GROUP BY time()</code>间隔的时间下限作为查询结果中的时间戳。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../../../content/cnosdb/latest/cnosql/cnosql_management.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../../../../content/cnosdb/latest/cnosql/continuous_queries.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../../../content/cnosdb/latest/cnosql/cnosql_management.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../../../../content/cnosdb/latest/cnosql/continuous_queries.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../../../../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../../../../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
