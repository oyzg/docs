## TSM架构设计

### 设计架构

每个CnosDB用例都是唯一的，您的模式反映了这种唯一性。通常，为查询而设计的模式可以实现更简单、更高效的查询。对于大多数用例，我们推荐以下设计架构:

- 在何处存储数据(标签或字段)
- 避免过多的series
- 使用推荐的命名约定
- 分片时长管理

#### 在何处存储数据(标签或字段)

- 将常用查询和分组元数据存储在标签中。
- 如果每个数据点包含不同的值，则将数据存储在字段中。
- 将数字值存储为fields(tag values只支持字符串值)。

#### 避免过多的series

按tags查询比按fields查询性能更好。但是，当创建过多的索引时，写和读都可能开始变慢。

每一组索引数据元素形成一个series key。包含高度可变信息(如唯一id、哈希值和随机字符串)的标记将导致大量的series，也称为高series基数。对于许多数据库工作负载来说，高series基数是高内存使用量的主要驱动因素。因此，为了减少内存消耗，可以考虑将高基数值存储在field values中，而不是存储在tag keys或field keys中。

#### 使用推荐的命名约定

- 避免在tag和field keys中保留关键字
- 如果每个数据点包含不同的值，则将数据存储在field中。
- 将数字值存储为fields(tag values只支持字符串值)。

### TSM 树

时间结构合并树(TSM)引擎解决了获得最大吞吐量、压缩和原始时间序列数据查询速度的问题。在TSI之前，倒排索引是一种内存中的数据结构，是在基于TSM中的数据启动数据库时构建的。这意味着对于每个度量、标记键值对和字段名，内存中都有一个查询表来将这些元数据位映射到底层的时间序列。对于具有大量临时序列的用户，内存利用率随着新的时间序列的创建而不断增加。而且，启动时间增加了，因为所有的数据都必须在启动时加载到堆上。

### TSM 相关概念

CnosDB存储引擎看起来非常类似于LSM树。它有一个预写日志和一组只读数据文件，这些文件在概念上类似于LSM树中的sstable。TSM文件包含排序、压缩的系列数据。

CnosDB将为每个时间块创建一个分片（即shard）。例如，如果您有一个无限持续时间的保留策略，那么将为每7天的时间块创建分片。每个分片都映射到底层存储引擎数据库。每个数据库都有自己的WAL和TSM文件。

### 存储引擎

存储引擎将多个组件捆绑在一起，提供存储和查询系列数据的外部接口。它由多个组件组成，每个组件都扮演一个特定的角色:

- `内存索引`- 内存索引是跨分片的共享索引，提供对`measurement`、`tags`和`series`的快速访问。索引由引擎使用，但并不特定于存储引擎本身。

- `WAL` - `WAL`是一种写入优化的存储格式，它允许写入是持久的，但不容易查询。对`WAL`的写入附加到固定大小的段。

- `缓存` - 缓存是存储在`WAL`中的数据的内存表示。它在运行时被查询并与存储在`TSM`文件中的数据合并。

- `TSM 文件` - `TSM`文件以列格式存储压缩的系列数据。

- `FileStore`- `FileStore`调解对磁盘上所有`TSM`文件的访问。它确保在替换现有文件以及删除不再使用的`TSM`文件时自动安装`TSM`文件。

- `Compactor` - `Compactor`负责将优化程度较低的`Cache`和`TSM`数据转换为读取优化程度更高的格式。它通过压缩系列、删除已删除的数据、优化索引以及将较小的文件组合成较大的文件来实现这一点。

- `Compaction Planner` - `Compaction Planner`确定哪些`TSM`文件已准备好进行压缩，并确保多个并发压缩不会相互干扰。

- `Compression`- `Compression`由各种编码器和解码器处理特定数据类型。一些编码器是相当静态的，并且总是以相同的方式编码相同的类型；其他人根据数据的形状切换压缩策略。

- `Writers/Readers` - 每种文件类型（`WAL`段、`TSM`文件、`tombstones`等）都有用于处理格式的`Writers`和`Readers`。

### 预写日志 WAL

WAL被组织成一组类似于`_000001.wal`的文件。文件编号是单调递增的，称为WAL段。当一个段的大小达到10MB时，它被关闭并打开一个新的段。每个WAL段存储多个压缩的写和删除块。

当写入时，新的点被序列化，使用Snappy压缩，并写入WAL文件。在成功返回之前，文件被fsync并将数据添加到内存索引中。这意味着需要将点批处理在一起以实现高吞吐量性能。(对于许多用例来说，最佳批量大小似乎是每批5000 - 10000个点。)

WAL中的每个表项都遵循`TLV标准`，一个字节代表表项的类型(写或删除)，一个4字节的`uint32`压缩块的长度，然后是压缩块。

### 缓存

缓存是当前存储在WAL中的所有数据点的内存副本。这些点由key组织，key是measurement、tag set和field。每个field保存为自己的时间顺序范围。缓存数据在内存中没有被压缩。

对存储引擎的查询将把来自缓存的数据与来自TSM文件的数据合并。在查询处理时，对从缓存中获取的数据的副本执行查询。这样，在查询运行时输入的写操作不会影响结果。

发送到缓存的删除操作将清除给定key或给定key的特定时间范围。

缓存为快照行为提供了一些控制。最重要的控制是内存限制。有一个下界，即`cache-snapshot-memory-size`，超过这个下界将触发对TSM文件的快照，并删除相应的WAL段。还有一个上限，`cache-max-memory-size`，超过这个上限会导致缓存拒绝新的写操作。这些配置对于防止内存不足的情况以及对客户机施加反压力非常有用，因为写入数据的速度比实例持久化数据的速度要快。每次写操作时都会检查内存阈值。

其他快照控制是基于时间的。空闲阈值`cache -snapshot-write-cold-duration`在制定时间间隔内没有收到写请求时，强制缓存快照TSM文件。

通过重新读取磁盘上的WAL文件，在重新启动时重新创建内存缓存。


### TSM 文件

TSM文件是内存映射的只读文件的集合。这些文件的结构看起来非常类似于LevelDB或其他LSM树变体中的SSTable。

TSM文件由四部分组成：header, blocks, index, footer.

#### Header

```
+--------+------------------------------------+-------------+--------------+
| Header |               Blocks               |    Index    |    Footer    |
|5 bytes |              N bytes               |   N bytes   |   4 bytes    |
+--------+------------------------------------+-------------+--------------+
```
`Header`用于标识文件类型和版本号。
```
  +-------------------+
  |      Header       |
  +-------------------+
  |  Magic  │ Version |
  | 4 bytes │ 1 byte  |
  +-------------------+
```

#### Blocks

`Blocks` 是成对的 CRC32 校验和和数据的序列。block数据对文件是不透明的。CRC32 用于block级错误检测。block的长度存储在索引中。

```
  +--------------------------------------------------------------------+
  │                           Blocks                                   │
  +---------------------+-----------------------+----------------------+
  |       Block 1       |        Block 2        |       Block N        |
  +---------------------+-----------------------+----------------------+
  |   CRC    |  Data    |    CRC    |   Data    |   CRC    |   Data    |
  | 4 bytes  | N bytes  |  4 bytes  | N bytes   | 4 bytes  |  N bytes  |
  +---------------------+-----------------------+----------------------+
```

#### Index

block之后是文件中block的Index。Index由一系列Index条目组成，这些条目按字典顺序按key排序，然后按时间排序。key包括measurement name、tag set和one field。每个点的多个字段在 TSM 文件中创建多个Index条目。每个Index条目以key长度和key开头，然后是block类型（float、int、bool、string）和key后面的block Index条目数。每个block Index条目由block的最小和最大时间、block所在文件的偏移量和block的大小组成。TSM 文件中包含密钥的每个block都有一个block Index条目。

Index结构可以提供对所有block的有效访问以及确定与访问给定key相关的成本的能力。给定一个key和timestamp，我们可以确定一个文件是否包含该时间戳的块。我们还可以确定该block所在的位置以及必须读取多少数据才能检索该block。知道block的大小，我们可以有效地配置我们的 IO 语句。
```
  +-----------------------------------------------------------------------------+
  │                                   Index                                     │
  +-----------------------------------------------------------------------------+
  │ Key Len │   Key   │ Type │ Count │Min Time │Max Time │ Offset │  Size  │....│
  │ 2 bytes │ N bytes │1 byte│2 bytes│ 8 bytes │ 8 bytes │8 bytes │4 bytes │    │
  +-----------------------------------------------------------------------------+
```

#### Footer

最后一部分是存储索引开始的偏移量的页脚。
```
  +---------+
  │ Footer  │
  +---------+
  │Index Ofs│
  │ 8 bytes │
  +---------+
```

### 压缩

压缩是将以写优化格式存储的数据迁移到读优化格式的循环过程。当写一个shard时，有几个压缩阶段:

1.快照 —— 必须将Cache和WAL中的值转换为TSM文件，以释放WAL段所使用的内存和磁盘空间。这些压缩是基于缓存内存和时间阈值进行的。

2.级别压缩 —— 级别压缩(级别1-4)发生在TSM文件生成时。TSM文件从快照文件压缩到一级文件。多个1级文件被压缩以生成2级文件。这个过程继续进行，直到文件达到TSM文件的最大大小4级(完全压缩)。除非需要运行删除、索引优化压缩或完全压缩，否则不会进一步压缩它们。较低级别的压缩使用的策略避免了cpu密集型活动，如解压缩和组合块。更高级别(因此更少频率)的压缩将重新组合块，以完全压缩它们，并增加压缩比。

3.索引优化 —— 当许多4级TSM文件累积时，内部索引将变得更大，访问成本也更高。索引优化压缩在一组新的TSM文件中分割序列和索引，将给定序列的所有点排序到一个TSM文件中。在进行索引优化之前，每个TSM文件包含大多数或所有系列的点，因此每个文件包含相同的系列索引。在索引优化之后，每个TSM文件包含来自最小序列的点，并且文件之间的序列重叠很少。因此，每个TSM文件都有一个较小的惟一系列索引，而不是完整系列列表的副本。此外，来自特定系列的所有点在TSM文件中是连续的，而不是分布在多个TSM文件中。

4.完全压缩(4级压缩) —— 当碎片长时间处于冷状态，或者碎片上发生删除时，就会发生完全压缩。完全压缩生成一组最优的TSM文件，并包括来自级别和索引优化压缩的所有优化。一旦碎片被完全压缩，除非存储了新的写或删除操作，否则不会在其上运行其他压缩操作。

每个块都被压缩，以减少查询时的存储空间和磁盘IO。一个块包含给定序列和字段的时间戳和值。每个块有一个字节头，后面是压缩时间戳和压缩值。

```
  +--------------------------------------------------+
  | Type  |  Len  |   Timestamps    |      Values    |
  |1 Byte | VByte |     N Bytes     |    N Bytes     │
  +--------------------------------------------------+
```

根据数据类型及其形状，使用编码对时间戳和值进行压缩和单独存储。独立存储它们允许对所有时间戳使用时间戳编码，同时允许对不同的字段类型使用不同的编码。例如，有些点可以使用游程编码，而其他点则不能。

每个值类型还包含一个1字节的头，指示剩余字节的压缩类型。四个高位存储压缩类型，四个低位在需要时由编码器使用。

#### 时间戳

时间戳编码是自适应的，并基于所编码的时间戳的结构。它结合使用增量编码、缩放和使用simple8b游程编码的压缩，并在需要时退回到无压缩。

时间戳的分辨率是可变的，但可以是纳秒级的粒度，需要8个字节来存储未压缩的数据。在编码期间，值首先进行增量编码。第一个值是起始时间戳，随后的值是与前一个值的差值。这通常将值转换成更小的整数，更容易压缩。许多时间戳也是单调增加的，并落在时间的偶数边界上，例如每10秒。当时间戳具有这种结构时，它们的最大公约数也是10的倍数。这可以将非常大的整数delta转换为更小的整数delta，从而更好地压缩。

使用这些调整后的值，如果所有增量相同，则使用游程编码存储时间范围。如果不能进行游程编码，并且所有值都小于(1«60)- 1(在纳秒分辨率下~36.5年)，则使用simple8b编码对时间戳进行编码。Simple8b编码是一种64位字对齐整数编码，它将多个整数打包成一个64位字。如果任何值超过了最大值，增量将不压缩地存储，每个块使用8个字节。未来的编码可能使用补丁方案，如PFOR，以更有效地处理异常值。

#### 浮点数

浮点是使用`Facebook Gorilla paper`的实现进行编码的。将XORS连续的值编码在一起，当这些值很接近时产生一个小结果。然后使用控制位存储增量，以指示异或值中有多少前导和尾零。我们的实现删除了论文中描述的时间戳编码，只对浮点值进行编码。

#### 整数

整数编码根据未压缩数据中的值范围使用两种不同的策略。编码后的值首先使用ZigZag编码。它使正整数和负整数在一个正整数范围内交叉。

如果所有ZigZag编码的值都小于(1«60)- 1，则使用simple8b编码对它们进行压缩。如果任何值大于最大值，那么所有的值都被不压缩地存储在块中。如果所有值都相同，则使用游程编码。对于经常是常量的值，这种方法非常有效。

#### 布尔值

布尔值使用简单的位打包策略进行编码，每个布尔值使用1位。编码的布尔值的数量使用可变字节编码存储在块的开头。

#### 字符串

字符串使用`Snappy`压缩进行编码。每个字符串都是连续打包的，它们被压缩为一个更大的块。

### 写

写操作被添加到当前的WAL段，同时也被添加到缓存中。每个WAL段都有一个最大尺寸。当前文件写满时，写入滚动到新文件。缓存也是有大小限制的；当缓存太满时，会进行snapshot和WAL压缩。如果写速率在一段持续时间内超过WAL压缩速率，那么缓存可能会变得太满，在这种情况下，新的写操作将会失败，直到snapshot进程赶上。

当WAL段被填满并关闭时，Compactor会snapshot缓存并将数据写入一个新的TSM文件。当成功写入TSM文件并进行fsync时，文件存储就会加载并引用它。

### 更新

更新(为一个已经存在的点写一个新的值)与正常写操作一样发生。因为缓存的值会覆盖现有的值，所以新的写操作优先。如果写入将覆盖以前的TSM文件中的一个点，那么这些点将在查询运行时合并，新的写入优先。

### 删除

删除是通过向WAL写入一个删除条目来进行的，该条目用于测量或序列，然后更新Cache和FileStore。Cache将收回所有相关条目。FileStore为每个包含相关数据的TSM文件写一个tombstone文件。这些tombstone文件在启动时用于忽略块以及在压缩期间用于删除已删除的条目。

对部分删除的系列的查询在查询时进行处理，直到压缩从TSM文件中完全删除数据。

### 查询

当存储引擎执行查询时，它本质上是对与特定series key和field相关的给定时间的搜索。首先，我们对数据文件进行搜索，以找到包含与查询匹配的时间范围以及包含匹配序列的文件。

选中数据文件后，接下来需要找到series key索引条目在文件中的位置。我们对每个TSM索引执行二进制搜索，以找到其索引块的位置。

在通常情况下，多个TSM文件之间的块不会重叠，我们可以线性搜索索引条目，以找到要读取的起始块。如果有重叠的时间块，则对索引项进行排序，以确保较新的写操作优先，并且在查询执行期间可以按顺序处理这些块。

当遍历索引项时，块顺序地从块部分读取。块被解压缩，我们寻找特定的点。
